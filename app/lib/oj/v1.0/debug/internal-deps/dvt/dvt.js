define([], function() {
  // Internal use only.  All APIs and functionality are subject to change at any time.
  
  // Create DvtObj so that it will be able to export the classes as needed.
  this.DvtObj = function() {};
  this.DvtObj['owner'] = window;
  
  // Copyright (c) 2008, 2013, Oracle and/or its affiliates. 
// All rights reserved. 

/**
 * Base object for HTML toolkit derivative objects.
 * @class The base object for HTML toolkit derivative objects.
 * @constructor  
 */
var DvtObj = this.DvtObj;
if (!DvtObj) {
  DvtObj = function() {};
  
  // Assign the window to the owner field of DvtObj if a window is present.  This allows the code
  // in createSubclass to expose the class names on the window, which is needed when loading the
  // script inside of a function body.
  if(typeof(window) != "undefined")
    DvtObj[DvtObj._OWNER_KEY] = window;
}

DvtObj._GET_FUNCTION_NAME_REGEXP = /function\s+([\S^]+)\s*\(/;

/**
 * @const
 * @private
 */
DvtObj._OWNER_KEY = "owner";

DvtObj.prototype = {};
DvtObj.prototype.constructor = DvtObj;

/**
 *  Provides inheritance by subclassing a class from a given base class.
 *  @param  {class} extendingClass  The class to be extended from the base class.
 *  @param  {class} baseClass  The base class
 *  @param  {string} typeName The type of the extending class
 */
DvtObj.createSubclass = function (extendingClass, baseClass, typeName) {
  if (extendingClass === undefined || extendingClass === null) {
    return;
  }
  
  // Expose the classes on the owner, which will usually be the window object.
  if (DvtObj[DvtObj._OWNER_KEY])
    DvtObj[DvtObj._OWNER_KEY][typeName] = extendingClass;
  
  if (baseClass === undefined) {
    // assume Object
    baseClass = Object;
  }

  if (extendingClass == baseClass) {
    return;
  }

  // use a temporary constructor to get our superclass as our prototype
  // without out having to initialize the superclass
  var tempConstructor = DvtObj._tempSubclassConstructor;

  tempConstructor.prototype = baseClass.prototype;
  extendingClass.prototype = new tempConstructor();

  extendingClass.prototype.constructor = extendingClass;
  extendingClass.superclass = baseClass.prototype;
  
  if(typeName)
    extendingClass._typeName = typeName;
} ;

/**  @private  */
DvtObj._tempSubclassConstructor = function () {};

DvtObj.getTypeName = function (clazz) {
  var typeName = clazz._typeName;
  if (typeName == null) {
    var constructorText = clazz.toString();
    var matches = DvtObj._GET_FUNCTION_NAME_REGEXP.exec(constructorText);

    typeName = matches[1];

    clazz._typeName = typeName;
  }

  return typeName;
}

DvtObj.prototype.getTypeName = function () {
  return DvtObj.getTypeName(this.constructor);
}


/*-------------------------------------------------------------------*/
/*   clone()                                                         */
/*-------------------------------------------------------------------*/
/**
  *  Returns a copy of this object.  Abstract method, subclasses
  *   must implement.
  *  @type DvtObj
  */
DvtObj.prototype.clone = function()
{
   return null ;
};

/*-------------------------------------------------------------------*/
/*   mergeProps()                                                    */
/*-------------------------------------------------------------------*/
/**
  *   Merge properties in the current object into the supplied object.
  *   Abstract method, subclasses must implement. Used internally by clone().
  *   @param {DvtObj}
  *   @private
  */
DvtObj.prototype.mergeProps = function(obj)
{
} ;

DvtObj._flashToolkit = false ;     // Flash needs a slightly different version
                                   // because the "string version" is not valid for Flash
                                   // this is set only by ActionScript.
/*
 * Creates a callback function
 * 
 * @param {object} thisPtr the object that should be "this" when the function is called
 * @param {function} func the function to create the callback for
 * 
 * @return {function} the callback function
 */
DvtObj.createCallback = function(thisPtr, func) {
  if (DvtObj._flashToolkit) {
    var f = function() {
      return func.apply(thisPtr,arguments) ;
    };
    return f;
  }
  else {
    // create a function that sets up "this" and delegates all of the parameters
    // to the passed in function
    var proxyFunction ;
    try {
          proxyFunction = new Function(
            "var f=arguments.callee; return f._func.apply(f._owner, arguments);");

          // attach ourselves as "this" to the created function
          proxyFunction['_owner'] = thisPtr;

          // attach function to delegate to
          proxyFunction['_func'] = func;
    } catch(e) {} ;

    return proxyFunction;
  }
};

//FIX BUG 17075260: 
/**
 * Define a constant value such that the advanced closure compiler will not simply do an inline replace of the
 * value everywhere it's referenced.  The compiled code should then contain abbreviated references to the constant
 * instead of the literal value, which should help decrease overall code size.  
 * @param {object} constValue value to define for the constant
 * @return {object}
 */
DvtObj.defineConstant = function(constValue) {
  return constValue;
};
// Copyright (c) 2008, 2013, Oracle and/or its affiliates. 
// All rights reserved. 
/*-------------------------------------------------------------------------*/
/*   DvtArrayUtils         Miscellaneous array utility functions           */
/*-------------------------------------------------------------------------*/
/**
  *  @class  DvtArrayUtils  A static class providing miscellaneous array utility
  *  functions.
  */
var  DvtArrayUtils = new Object();

DvtObj.createSubclass(DvtArrayUtils, DvtObj, "DvtArrayUtils");

//  Factor scaling operation types for toFloat()

/**
  * Factor operation for DvtArrayUtils.toFloat() - no scaling of converted float.
  * @final
  */
DvtArrayUtils.NONE = 0 ;
/**
  * Factor operation for DvtArrayUtils.toFloat() - add factor to converted float.
  * @final
  */
DvtArrayUtils.ADD  = 1 ;
/**
  * Factor operation for DvtArrayUtils.toFloat() - subtract factor from converted float.
  * @final
  */
DvtArrayUtils.SUB  = 2 ;
/**
  * Factor operation for DvtArrayUtils.toFloat() - divide converted float by factor.
  * @final
  */
DvtArrayUtils.DIV  = 3 ;
/**
  * Factor operation for DvtArrayUtils.toFloat() - multiply converted float by factor.
  * @final
  */
DvtArrayUtils.MULT = 4 ;
/**
  *  Factor operation for DvtArrayUtils.toFloat() - set converted float to mod(factor).
  * @final
  */
DvtArrayUtils.MOD  = 5 ;



DvtArrayUtils.argsToArray = function(args)
{
  if (args)
  {
    var array = new Array(args.length);
    if (args.length > 0)
    {
      for (var i = 0; i < args.length; i++)
      {
        array[i] = args[i];
      }
    }
    return array;
  }
  return args;
};


/*--------------------------------------------------------------------*/
/*  isArray()          Cross-browser array detection                  */
/*--------------------------------------------------------------------*/
/**
  *   Test if the specified object is an instance of Array (cross-browser safe).
  * @base DvtArrayUtils
  *   @param {Object}  obj
  *   @type Boolean
  *   @returns true if the object is an Array.
  */
DvtArrayUtils.isArray = function(obj)
{
   // check for undefined explicitly because the second clauses will blow up in Rhino
   return typeof obj != "undefined" && Object.prototype.toString.apply(obj)  === '[object Array]' ;
} ;



/*--------------------------------------------------------------------*/
/*  toFloat()                                                         */
/*--------------------------------------------------------------------*/
/**
  *  Converts an array from string values to floats.  If optional 'factor'
  *  argument is supplied, the array values are scaled by this factor using
  *  the factorType  operator. e.g. <p><code>
  *  &nbsp; &nbsp; &nbsp;  DvtArrayUtils.toFloat(ar, 0.01, DvtArrayUtils.MULT) ;<p></code>
  *  converts an array of percentage value strings to an array of floats converted
  *  to dcimal percentages (between zero and 1).
  *  @param {Array} ar
  *  @param {number} factor
  *  @param {number} factorType
  *  @type {Array}
  *  @returns the Array that was supplied as the first argument.
  */
DvtArrayUtils.toFloat = function(ar, factor, factorType)
{
   if (! DvtArrayUtils.isArray(ar)) {
     return ar ;
   }

   if (! factor) {
     factorType = DvtArrayUtils.NONE ;
   }

   factorType = (factorType === null || isNaN(factorType)) ? DvtArrayUtils.NONE : factorType;

   if (factorType !== DvtArrayUtils.NONE) {
     if ((typeof factor) !== 'number') {
       factor = parseFloat(factor) ;
     } 
     if (isNaN(factor)) {
       factorType = DvtArrayUtils.NONE ;
     }
   }

   var len = ar.length ;
   var i ;

   if (factorType === DvtArrayUtils.NONE) {
     for (i = 0; i < len; i++) {
        ar[i] = parseFloat(ar[i]) ;
     }
   }
   else {
     for (i = 0; i < len; i++)  {
        var  v = parseFloat(ar[i]) ;

         switch (factorType) {
            case  DvtArrayUtils.MULT : v *= factor ;
                                       break ;
            case  DvtArrayUtils.ADD :  v += factor ;
                                       break ;
            case  DvtArrayUtils.SUB :  v -= factor ;
                                       break ;
            case  DvtArrayUtils.DIV :  v /= factor ;
                                       break ;
            case  DvtArrayUtils.MOD :  v %= factor ;
                                       break ;
         }
         ar[i] = v ;
     }

   }

   return ar ;
} ;



/*--------------------------------------------------------------------*/
/*   copy()       Performs a shallow copy of the array. (Much faster  */
/*                than Array.concat().                                */
/*--------------------------------------------------------------------*/
/**
  *  Create a shallow copy of the supplied array.
  *  @param {Array} ar The array to be copied.
  *  @type Array
  *  @returns A shallow copy of the supplied array.
  */
DvtArrayUtils.copy = function(ar)
{
   var arRet ;

   if (ar) {
     arRet = [] ; 
     var len = ar.length ;

     for (var i = 0; i < len; i++)  {
       arRet.push(ar[i]) ;
     }
   }
   return arRet ;
} ;


/**
  *  Returns the index of the first occurrence of an item in an array.  
  *  @param {Array} array  The array to be searched.
  *  @param {Object} item  The item to be found.
  *  @type number
  */
DvtArrayUtils.getIndex = function(array, item)
{
  if (array) {
    for (var i = 0; i < array.length; i++) {
      if (array[i] === item) {
        return i;
      }
    }
  }
  return -1;
};

/**
  *  Returns the index of the last occurrence of an item in an array.  
  *  @param {Array} array  The array to be searched.
  *  @param {Object} item  The item to be found.
  *  @type number
  */
DvtArrayUtils.getLastIndex = function(array, item)
{
  for (var i = array.length - 1; i >= 0; i--)  {
    if (array[i] === item) {
      return i;
    }
  }
  return -1;
};


/*--------------------------------------------------------------------*/
/*   getMinIndex(), getMaxIndex()                                     */
/*--------------------------------------------------------------------*/
/**
  *  Returns the index to the array entry containg the minimum value.
  *  Array entries with undefined or null values are ignored.
  *  @param {Array} ar the array to be searched.
  *  @type number
  *  @returns The index of the array entry containing the minimum value.
  *           If the array length is zero, or all entries are undefined
  *           or null, a value of -1 is returned.
  */
DvtArrayUtils.getMinIndex = function(ar)
{
  var nRet   = -1 ;
  var len    = ar.length; 
  var minVal = Number.MAX_VALUE ;
  var val ;
  
  for (var i = 0; i < len; i++) {
     val = ar[i] ;

     if (val && (typeof val === 'number') && (val < minVal)) {
       minVal = val ;
       nRet   = i ;
     }
  }

  return nRet ;
};


/**
  *  Returns the index to the array entry containg the maximum value.
  *  Array entries with undefined or null values are ignored.
  *  @param {Array} ar the array to be searched.
  *  @type number
  *  @returns The index of the array entry containing the maximum value.
  *           If the array length is zero, or all entries are undefined
  *           or null, a value of -1 is returned.
  */
DvtArrayUtils.getMaxIndex = function(ar)
{
  var nRet   = -1 ;
  var len    = ar.length; 
  var maxVal = Number.MIN_VALUE ;
  var val ;
  
  for (var i = 0; i < len; i++) {
     val = ar[i] ;

     if (val && (typeof val === 'number') && (val > maxVal)) {
       maxVal = val ;
       nRet   = i ;
     }
  }

  return nRet ;
};

/**
 * Returns true if the two arrays have the same contents.
 * @param {array} a
 * @param {array} b
 */
DvtArrayUtils.equals = function(a, b) {
  if(!a && b)
    return false;
  else if(a && !b)
    return false;
  else if(!a && !b)
    return true;
  else // a && b
  {
    if(a.length != b.length)
      return false;
    
    // Compare the individual items
    for(var i=0; i<=a.length; i++) {
      if(a[i] !== b[i])
        return false;
    }
    
    // Everything matched, return true
    return true;
  }
}
// Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
/*-------------------------------------------------------------------------*/
/*   DvtStringUtils         Miscellaneous string utility functions         */
/*-------------------------------------------------------------------------*/
/**
  *  @class  DvtStringUtils  A static class providing miscellaneous string utility
  *  functions.
  */
var  DvtStringUtils = {} ;

DvtObj.createSubclass(DvtStringUtils, DvtObj, "DvtStringUtils");

// Perform a check to see if native String APIs is available, since they are much faster.
DvtStringUtils._hasTrim = "hello".trim != null;
DvtStringUtils._hasEndsWith = "hello".endsWith != null;

/**
  *   Removes leading and trailing whitespace from a string.
  *   @base DvtStringUtils
  *   @param {String} s  The string to be trimmed.
  *   @type String
  *   @returns A string with leading and trailing whitespace removed.
  */
DvtStringUtils.trim = function(s)
{
  if(DvtStringUtils._hasTrim)
    return s.trim();
  else
    return s.replace(/^\s+|\s+$/g,"");
}

/**
 * Returns true if the specified string ends with the specified suffix.
 * @param {string} s The string to check.
 * @param {string} suffix The suffix that the search string should end with.
 * @return {boolean}
 */
DvtStringUtils.endsWith = function(s, suffix)
{
  if(DvtStringUtils._hasEndsWith)
    return s.endsWith(suffix);
  else
    return (s.match(suffix+"$")==suffix)
}
// Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.
/**
 * Context object corresponding to an SVG document. The constructor creates a SVG document inside the specified
 * container.
 * @param {Element} container The div element under which the SVG document will be created.
 * @param {string} id
 * @extends DvtObj
 * @class DvtContext
 * @constructor
 * @export
 */
var DvtContext = function (container, id) {
  // Create the SVG document and add to the container
  this._root = DvtToolkitUtils.createSvgDocument(id + '_svg');
  container.appendChild(this._root);

  // Create the impl factory, defs, and stage
  this._implFactory = new DvtSvgImplFactory(this) ;
  this._defs = this._implFactory.newDefs();
  DvtToolkitUtils.appendChildElem(this._root, this._defs);

  // Pass to the superclass
  this.Init(this._implFactory, this._root, id);

  // Add the stage element
  DvtToolkitUtils.appendChildElem(this._root, this._stage.getElem());
} 

DvtObj.createSubclass(DvtContext, DvtObj, "DvtContext");

/**
  * Initializes this context object with the platform dependent objects.
  * @param  {DvtSvgImplFactory} implFactory
  * @param  {DvtStage} stage
  * @param  {DvtTooltipManager} tooltipManager
  * @protected
  */
DvtContext.prototype.Init = function (implFactory, root, id) {
  this._implFactory    = implFactory;
  this._stage          = new DvtStage(this, root, id + "_stage" );     // TODO use naming utils

  this._tooltipManagers = new Object();
  this._customTooltipManagers = new Object();
  
  this._scheduler      = null;
  
  //BUG FIX 14187937: DvtSvgEventFactory.newEvent(), for example, can use these to store the latest events in
  //order to return the same logical event instance for the same native event instance instead of creating a 
  //new logical event instance every time
  this._nativeEvent = null;
  this._logicalEvent = null;
  
  //BUG FIX 12613719: map of DvtClipPath objects stored by id
  this._clipPathMap = {};
}

/**
 *  Returns a platform dependent implementation factory of the one and only
 *  implementation factory object.
 *  @type DvtSvgImplFactory 
 */
DvtContext.prototype.getImplFactory = function () {
  return this._implFactory;
}


/**
 *  Returns a platform dependent implementation of the one and only
 *  stage.
 *  @type DvtStage 
 *  @export
 */
DvtContext.prototype.getStage = function () {
  return this._stage;
}

/**
 * Returns the SVG document corresponding to this context instance.
 * @return {Element}
 * @export
 */
DvtContext.prototype.getSvgDocument = function() {
  return this._root;
}

/**
 * Specifies the reading direction for the context.  This is used by DvtAgent.isRightToLeft(context) overriding the 
 * reading direction from the DOM when specified.
 * @param {string} dir The reading direction string, such as "rtl" or "ltr".
 * @export
 */
DvtContext.prototype.setReadingDirection = function(dir) {
  this._readingDirection = dir;
}

/**
 * Returns the reading direction for the context, if specified.  Component developers should use DvtAgent.isRightToLeft
 * instead, as that function will determine the reading direction from the DOM when not specified on the context.
 * @return {string} The reading direction string if specified on the context, null otherwise.
 */
DvtContext.prototype.getReadingDirection = function() {
  return this._readingDirection;
}

/**
  * Adds a reference count for the given clip path id
  * @param {string}  id  id of the clipping path
  */
DvtContext.prototype.addClipPath = function (id) {
  // The id of the clip path must be valid to continue
  if(id == null)
    return;

  if (this._clipPathMap[id])
    this._clipPathMap[id] = this._clipPathMap[id]++;
  else
    this._clipPathMap[id] = 1;
};

/**
  * Removes a reference count for the given clip path id
  * @param {string}  id  id of the clipping path
  */
DvtContext.prototype.removeClipPath = function (id) {
  // The id of the clip path must be valid to continue
  if(id == null)
    return;

  var refCount = this._clipPathMap[id];
  if (refCount) {
    if (refCount == 1)
     delete this._clipPathMap[id];
    else
     this._clipPathMap[id] = refCount--;
  }
}

/**
  * Determines if the clipping path already exists and has any references.
  * @param {string}  id  id of the clipping path
  * @type boolean
  */
DvtContext.prototype.hasClipPath = function (id) {
  return this._clipPathMap[id] >= 1;
}

/**
 *  Returns a platform dependent implementation of the one and only
 *  tooltip manager.
 *  @type DvtTooltipManager 
 */
DvtContext.prototype.getTooltipManager = function (id) {
    if (!id)
      id = "_dvtTooltip";
    var stageId = this.getStage().getId();
    id = id+stageId;
    var manager = this._tooltipManagers[id];
    if (!manager) {
        this._tooltipManagers[id] = this._implFactory.newTooltipManager(id);
    }
    return this._tooltipManagers[id];
}

/**
  * Get the single scheduler instance for this context.
  * 
  * @type DvtScheduler
  */
DvtContext.prototype.getScheduler = function () {
  if (!this._scheduler)
  {
    this._scheduler = new DvtScheduler(this);
  }
  
  return this._scheduler;
}

/**
  * Obtain document utils singleton.
  *
  * @type Object
  */
DvtContext.prototype.getDocumentUtils = function () {
  return this._implFactory.getDocumentUtils();
}

/**
 * Returns the specified page coordinates relative to the stage.
 * @param {number} pageX
 * @param {number} pageY
 * @return {DvtPoint}
 */
DvtContext.prototype.pageToStageCoords = function(pageX, pageY) {
  var stagePos = this.getStageAbsolutePosition();
  var xPos = pageX - stagePos.x;
  var yPos = pageY - stagePos.y;
  return new DvtPoint(xPos, yPos);
}

/**
 * Returns the specified stage coordinates relative to the page.
 * @param {number} stageX The x coordinate, relative to the stage.
 * @param {number} stageY The y coordinate, relative to the stage.
 * @return {DvtPoint}
 */
DvtContext.prototype.stageToPageCoords = function(stageX, stageY) {
  var stagePos = this.getStageAbsolutePosition();
  var xPos = stageX + stagePos.x;
  var yPos = stageY + stagePos.y;
  return new DvtPoint(xPos, yPos);
}

/**
 * Returns the coordinates of the stage, relative to the page.  This is an expensive operation which is optimized by
 * using a cache, managed by DvtEventManager.
 * @return {DvtPoint}
 */
DvtContext.prototype.getStageAbsolutePosition = function() {
  // If a cache value is available, use it
  if(this._stageAbsolutePosition)
    return this._stageAbsolutePosition;
    
  var svgRoot = this.getStage().getImpl().getSVGRoot();
  
  // Use a reference element at the same position at the SVG whenever possible.  The browser functions used in DvtAgent's
  // getElementPosition do not always return the correct values for SVG elements, especially in Firefox.  Note that we 
  // can ensure the presence of a parent div at the same coordinates across all our supported frameworks, so this
  // issue will never occur in the real product.
  var referenceElem = svgRoot;
  if (window && window.AdfAgent)
    referenceElem = svgRoot.parentNode;
  else if (svgRoot.parentNode && svgRoot.parentNode.firstChild == svgRoot) // Otherwise require element to be the first child      
    referenceElem = svgRoot.parentNode;
  
  // Note: As mentioned above, this returns the wrong position in Firefox for SVG elements.
  var svgPos = DvtAgent.getElementPosition(referenceElem);
  
  this._stageAbsolutePosition = new DvtPoint(parseInt(svgPos.x), parseInt(svgPos.y));
  return this._stageAbsolutePosition;
}

/**
 * Clears the cached value for the stage position.
 */
DvtContext.prototype.clearStageAbsolutePosition = function() {
  this._stageAbsolutePosition = null;
}

DvtContext.prototype.getCustomTooltipManager = function(id)
{
    if (!id)
      id = "_dvtCustomTooltip";
    var stageId = this.getStage().getId();
    id = id+stageId;
    var manager = this._customTooltipManagers[id];
    if (!manager) {
        this._customTooltipManagers[id] = new DvtCustomTooltipManager(this, id);
    }
    return this._customTooltipManagers[id];
}


/**
 * Append element(s) to the application global <defs> element.
 */
DvtContext.prototype.appendDefs = function(elem)
{
  DvtToolkitUtils.appendChildElem(this._defs, elem) ;
};

/**
  *   @returns {DOM_Element}  the global <defs> DOM element
  */
DvtContext.prototype.getDefs = function()
{
  return this._defs ;
};

/**
  *   @returns {DvtSvgImplFactory}  the platform implementation factory.
  */
DvtContext.prototype.getImplFactory = function()
{
  return this._implFactory ;
};

/**
  *   Removes the specified element from the global <defs> element.
  */
DvtContext.prototype.removeDefs = function(elem)
{
  this._defs.removeChild(elem) ;
};

/**
  *   Removes the element with the specified id from the global <defs> element.
  */
DvtContext.prototype.removeDefsById = function(id)
{
  var defs = this._defs.childNodes;
  var len = defs.length;
  for (var i=0; i<len; i++) {
    var def = defs[i];
    if (def.id === id) {
      this._defs.removeChild(def);
      return;
    }
  }
}

DvtContext.prototype.removeClipPath = function (id) {
  // remove clip path from the global defs if not used
  if (!this.hasClipPath(id))
    this.removeDefsById(id);
}

/**
 * Returns the value of the attribute on the root element
 * @param {string} attrName Attribute name
 * @return {string|null} value of the attribute
 */
DvtContext.prototype.getRootAttribute = function(attrName) {
  return DvtToolkitUtils.getAttrNullNS(this._root, attrName);
}

/**
 * Clears all unique seeds used for filter, clip path, gradient, and af component id generation.
 * Should only be called by Junit tests.
 * @export
 */
DvtContext.resetUniqueSeeds = function () {
  if (typeof DvtAfComponent != 'undefined')
    DvtAfComponent._uniqueSeed = 0;
  DvtSvgFilterUtils._counter = 0;
  DvtClipPath._uniqueSeed = 0;
  DvtSvgShapeUtils._uniqueSeed = 0;
  DvtOutputText._cache = null;
}
/**
 * A base class for shape fills, strokes, shadows, etc.
 * {@link DvtLockable}.
 * @extends DvtObj
 * @class DvtLockable  A base class for shape fills, strokes,shadows, etc.
 * @constructor  Do not create/use directly.
 */
var DvtLockable = function () {
  this._Init();
}

DvtObj.createSubclass(DvtLockable, DvtObj, "DvtLockable");

/** 
 * @private 
 */
DvtLockable.prototype._Init = function () {
  this._bLocked = false;
}

/**
 *  Returns true if the fill object is immutable, else false.
 *  @type Boolean
 */
DvtLockable.prototype.isLocked = function () {
  return this._bLocked;
}

/**
 *  Makes the property set immutable.  The only way to change the object's
 *  properties once it is immutable is to clone it and apply property changes
 *  to the cloned object.  This method should not be called by application code
 *  and should only be used by toolkit code.
 *  @private
 */
DvtLockable.prototype.__lock = function () {
  this._bLocked = true;
}
// Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved. 
/**
  * Class representing an item that can be scheduled to run with a scheduler.
  * @extends DvtObj
  * @class DvtScheduled
  * @constructor
  * 
  * @param {DvtContext}  context  platform specific context object
  * @param {DvtScheduler}  scheduler  scheduler used to run this item
  * @param {number}  duration  length of time to run item, in seconds
  * @param {number}  delay  time to delay start of item, in seconds
  * @param {function}  easing  easing function to use with this item
  */
var DvtScheduled = function(context, scheduler, duration, delay, easing)
{
  this.Init(context, scheduler, duration, delay, easing);
};

DvtObj.createSubclass(DvtScheduled, DvtObj, "DvtScheduled");

/**
  * @private
  * State: initialize.
  */
DvtScheduled._STATE_INITIALIZE = 0;
/**
  * @private
  * State: begin.
  */
DvtScheduled._STATE_BEGIN = 1;
/**
  * @private
  * State: run.
  */
DvtScheduled._STATE_RUN = 2;

/**
  * @protected
  * Calculate the percent progress of the given value between the min and max.
  * 
  * @param {number}  val  current value
  * @param {number}  min  minimum value
  * @param {number}  max  maximum value
  * @type number
  */
DvtScheduled.CalcProgress = function(val, min, max)
{
  var diff = (max - min);
  if (diff == 0)
  {
    return 0.5;
  }
  else
  {
    var ret = ((val - min) / diff);
    if (ret > 1)
    {
      ret = 1;
    }
    return ret;
  }
};

/**
  * @protected
  */
DvtScheduled.prototype.Init = function(context, scheduler, duration, delay, easing)
{
  this._scheduler = scheduler;
  this.setDuration(duration); //in seconds
  this.setDelay(delay); //in seconds
  this.setEasing(easing);
  
  this._bRunning = false;
  this._startTime = null;
  this._progress = 0;
  this._state = DvtScheduled._STATE_INITIALIZE;
  
  this._onInit = null;
  this._onInitObj = null;
  this._onStart = null;
  this._onStartObj = null;
  this._onEnd = null;
  this._onEndObj = null;
  this._onStep = null;
  this._onStepObj = null;
};

/**
  * Get the duration of this item, in seconds.
  * 
  * @type number
  */
DvtScheduled.prototype.getDuration = function()
{
  return this._duration;
};

/**
  * Set the duration of this item.
  * 
  * @param {number}  duration  duration of this item, in seconds
  */
DvtScheduled.prototype.setDuration = function(duration)
{
  this._duration = (duration ? duration : 0.5);
};

/**
  * Get the delay for the start of this item, in seconds.
  * 
  * @type number
  */
DvtScheduled.prototype.getDelay = function()
{
  return this._delay;
};

/**
  * Set the delay for the start of this item.
  * 
  * @param {number}  delay  delay for the start of this item, in seconds
  */
DvtScheduled.prototype.setDelay = function(delay)
{
  this._delay = (delay ? delay : 0);
};

/**
  * Get the easing function for this animation.
  * 
  * @type function
  */
DvtScheduled.prototype.getEasing = function()
{
  return this._easing;
};

/**
  * Set the easing function for this animation.
  * 
  * @param {function}  easing  easing function
  */
DvtScheduled.prototype.setEasing = function(easing)
{
  this._easing = (easing ? easing : DvtEasing.cubicInOut);
};

/**
  * Set the function to call when this item initializes.
  * 
  * @param {function}  onInit  function to call when this item initializes
  * @param {object}  onInitObj  optional reference to object instance on which the 
  *        function is defined
  */
DvtScheduled.prototype.setOnInit = function(onInit, onInitObj)
{
  this._onInit = onInit;
  if (onInitObj)
  {
    this._onInitObj = onInitObj;
  }
  else
  {
    this._onInitObj = null;
  }
};

/**
  * Get the function to call when this item initializes.
  * Returns an array of two elements: 
  * [0] the function
  * [1] optional reference to object instance on which the function is defined
  * 
  * @type array
  */
DvtScheduled.prototype.getOnInit = function()
{
  return [this._onInit, this._onInitObj];
};

/**
  * Set the function to call when this item starts.
  * 
  * @param {function}  onStart  function to call when this item starts
  * @param {object}  onStartObj  optional reference to object instance on which the 
  *        function is defined
  */
DvtScheduled.prototype.setOnStart = function(onStart, onStartObj)
{
  this._onStart = onStart;
  if (onStartObj)
  {
    this._onStartObj = onStartObj;
  }
  else
  {
    this._onStartObj = null;
  }
};

/**
  * Get the function to call when this item starts.
  * Returns an array of two elements: 
  * [0] the function
  * [1] optional reference to object instance on which the function is defined
  * 
  * @type array
  */
DvtScheduled.prototype.getOnStart = function()
{
  return [this._onStart, this._onStartObj];
};

/**
  * Set the function to call when this item ends.
  * 
  * @param {function}  onEnd  function to call when this item ends
  * @param {object}  onEndObj  optional reference to object instance on which the 
  *        function is defined
  */
DvtScheduled.prototype.setOnEnd = function(onEnd, onEndObj)
{
  this._onEnd = onEnd;
  if (onEndObj)
  {
    this._onEndObj = onEndObj;
  }
  else
  {
    this._onEndObj = null;
  }
};

/**
  * Get the function to call when this item ends.
  * Returns an array of two elements: 
  * [0] the function
  * [1] optional reference to object instance on which the function is defined
  * 
  * @type array
  */
DvtScheduled.prototype.getOnEnd = function()
{
  return [this._onEnd, this._onEndObj];
};


/**
  * Set the function to call at each step of this item.
  * 
  * @param {function}  onStep  function to call at each step of this item
  * @param {object}  onStepObj  optional reference to object instance on which the 
  *        function is defined
  */
DvtScheduled.prototype.setOnStep = function(onStep, onStepObj)
{
  this._onStep = onStep;
  if (onStepObj)
  {
    this._onSepObj = onStepObj;
  }
  else
  {
    this._onStepObj = null;
  }
};

/**
  * Get the function to call at each step of this item.
  * Returns an array of two elements: 
  * [0] the function
  * [1] optional reference to object instance on which the function is defined
  * 
  * @type array
  */
DvtScheduled.prototype.getOnStep = function()
{
  return [this._onStep, this._onStepObj];
};

/**
  * Determine if this item is running.
  * 
  * @type boolean
  */
DvtScheduled.prototype.isRunning = function()
{
  return this._bRunning;
};

/**
  * Play this item.
  */
DvtScheduled.prototype.play = function()
{
  if (!this._bRunning)
  {
    this._bRunning = true;
    this.ProcessPlay();
    this._scheduler.addScheduled(this);
  }
};

/**
  * Stop this item.
  * 
  * @param {boolean}  bJumpToEnd  true to jump to 100% progress, 
  *        false to stop at current progress
  */
DvtScheduled.prototype.stop = function(bJumpToEnd)
{
  this._scheduler.removeScheduled(this);
  if (bJumpToEnd)
  {
    this.ProcessStep(1);
  }
  this.ProcessEnd();
};

/**
  * Pause this item.
  */
DvtScheduled.prototype.pause = function()
{
  this._bRunning = false;
  //this._scheduler.removeScheduled(this);
};

/**
  * Reset this item.
  */
DvtScheduled.prototype.reset = function()
{
  this._state = DvtScheduled._STATE_INITIALIZE;
};

/**
  * Process this item for the given timestamp.
  * 
  * @param {number}  time  current timestamp, in milliseconds
  */
DvtScheduled.prototype.processTime = function(time)
{
  if (!this._bRunning)
  {
    return;
  }
  
  var elapsedTime = time - this._startTime;
  if (elapsedTime < 0)
  {
    return false;
  }
  
  var duration = 1000 * this.GetTotalDuration();
  var progress = 1;
  if (duration != 0)
  {
    progress = elapsedTime / duration;
  }
  if (progress > 1)
  {
    progress = 1;
   }
  this.ProcessStep(progress);
  
  var bDone = (progress >= 1);
  if (bDone)
  {
    this.ProcessEnd();
  }
  return bDone;
};

/**
  * @protected
  * Get the total duration of this item, in seconds.
  * 
  * @type number
  */
DvtScheduled.prototype.GetTotalDuration = function()
{
  return this._delay + this._duration;
};

/**
  * @protected
  * Process when this item is played.
  */
DvtScheduled.prototype.ProcessPlay = function()
{
  if (this._state == DvtScheduled._STATE_INITIALIZE)
  {
    this.ProcessInitialize();
  }
  
  if (this._state == DvtScheduled._STATE_BEGIN)
  {
    this._startTime = new Date().getTime();
    this.ProcessStart();
  }
  else
  {
    var elapsedTime = this._progress * 1000 * this.GetTotalDuration();
    this._startTime = new Date().getTime() - elapsedTime;
  }
  
  this._state = DvtScheduled._STATE_RUN;
};

/**
  * @protected
  * Process initialization of this item when it starts to play.
  */
DvtScheduled.prototype.ProcessInitialize = function()
{
  if (this._onInit)
  {
    this._onInit.call(this._onInitObj);
  }
  this.Initialize();
  this._state = DvtScheduled._STATE_BEGIN;
};

/**
  * @protected
  * Process the start of this item after it initializes.
  */
DvtScheduled.prototype.ProcessStart = function()
{
  this._bRunning = true;
  this._progress = 0;
  this.Start();
  if (this._onStart)
  {
    this._onStart.call(this._onStartObj);
  }
};

/**
  * @protected
  * Process a step of this item as it plays.
  * 
  * @param {number}  progress  percent progress of this item
  */
DvtScheduled.prototype.ProcessStep= function(progress)
{
  this._progress = progress;
  var prog = progress;
  if (this._delay > 0)
  {
    prog = DvtScheduled.CalcProgress(progress, this._delay / this.GetTotalDuration(), 1);
  }
  if (prog >= 0)
  {
    if (this._easing)
    {
      prog = this._easing(prog);
    }
    this.Step(prog);
    
    if (this._onStep)
    {
      this._onStep.call(this._onStepObj, prog);
    }
  }
};

/**
  * @protected
  * Process when this item stops.
  */
DvtScheduled.prototype.ProcessEnd = function()
{
  //only process end if still running
  if (this._bRunning)
  {
    this._bRunning = false;
    this._progress = 1;
    this.End();
    this._state = DvtScheduled._STATE_BEGIN;
    if (this._onEnd)
    {
      this._onEnd.call(this._onEndObj);
    }
  }
};

/**
  * @protected
  * Initialize this item.
  */
DvtScheduled.prototype.Initialize = function()
{
  //do nothing; subclasses should implement
};

/**
  * @protected
  * Start playing this item.
  */
DvtScheduled.prototype.Start = function()
{
  //do nothing; subclasses should implement
};

/**
  * @protected
  * Step this item.
  * 
  * @param {number}  progress  percent progress of this item
  */
DvtScheduled.prototype.Step = function(progress)
{
  //do nothing; subclasses should implement
};

/**
  * @protected
  * End this item.
  */
DvtScheduled.prototype.End = function()
{
  //do nothing; subclasses should implement
};
// Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved. 
/**
  * Class representing a scheduling service.
  * @extends DvtObj
  * @class DvtScheduler
  * @constructor
  * 
  * @param {DvtContext}  context  platform specific context object
  */
var DvtScheduler = function(context)
{
  this.Init(context);
};

DvtObj.createSubclass(DvtScheduler, DvtObj, "DvtScheduler");

/**
  * @protected
  */
DvtScheduler.prototype.Init = function(context)
{
  this._timer = new DvtTimer(context, 1000 / 30, this.HandleTimer, this);
  this._scheduledItems = new Array();
  this._bRunning = false;
};

/**
  * Set the interval between timer ticks, in milliseconds.
  * 
  * @param {number}  interval  interval between timer ticks, in milliseconds
  */
DvtScheduler.prototype.setInterval = function(interval)
{
  var i = interval;
  if (i < 0)
  {
    i = 0;
  }
  this.pause();
  this._timer.setInterval(i);
  this.play();
};

/**
  * Get the interval between timer ticks.
  * 
  * @type number
  */
DvtScheduler.prototype.getInterval = function()
{
  return this._timer.getInterval();
};

/**
  * @protected
  * Handle a timer tick.
  */
DvtScheduler.prototype.HandleTimer = function()
{
  var time = new Date().getTime();
  for (var i = 0; i < this._scheduledItems.length; i++)
  {
    var scheduled = this._scheduledItems[i];
    if (scheduled.processTime(time))
    {
      this.removeScheduled(scheduled);
    }
  }
  
  if (this._scheduledItems.length < 1)
  {
    this.pause();
  }
};

/**
  * Add a scheduled item to be run.  
  * 
  * @param {DvtScheduled}  scheduled  item to add
  */
DvtScheduler.prototype.addScheduled = function(scheduled)
{
  var i = DvtArrayUtils.getIndex(this._scheduledItems, scheduled)
  if (i < 0)
  {
    this._scheduledItems.push(scheduled);
  }
  
  this.play();
};

/**
  * Remove a scheduled item.
  * 
  * @param {DvtScheduled}  scheduled  item to remove
  */
DvtScheduler.prototype.removeScheduled = function(scheduled)
{
  var i = DvtArrayUtils.getIndex(this._scheduledItems, scheduled);
  if (i >= 0)
  {
    this._scheduledItems.splice(i, 1);
  }
};

/**
  * Play the scheduler.
  */
DvtScheduler.prototype.play = function()
{
  if (!this._bRunning)
  {
    for (var i = 0; i < this._scheduledItems.length; i++)
    {
      var scheduled = this._scheduledItems[i];
      if (!scheduled.isRunning())
      {
        scheduled.play();
      }
    }
    
    this._bRunning = true;
    this._timer.start();
  }
};

/**
  * Pause the scheduler.
  */
DvtScheduler.prototype.pause = function()
{
  if (this._bRunning)
  {
    this._bRunning = false;
    this._timer.stop();
    
    for (var i = 0; i < this._scheduledItems.length; i++)
    {
      var scheduled = this._scheduledItems[i];
      if (scheduled.isRunning())
      {
        scheduled.pause();
      }
    }
  }
};
// Copyright (c) 2011, 2013, Oracle and/or its affiliates. 
// All rights reserved. 
/**
 * Class representing an animator that animates a property change.
 * @extends DvtScheduled
 * @class DvtAnimator
 * @constructor
 * 
 * @param {DvtContext}  context  platform specific context object
 * @param {number}  duration  length of animation, in seconds
 * @param {number}  delay  time to delay start of animation, in seconds
 * @param {function}  easing  easing function to use with this animation
 */
var DvtAnimator = function(context, duration, delay, easing) {
  this.Init(context, duration, delay, easing);
};

DvtObj.createSubclass(DvtAnimator, DvtScheduled, "DvtAnimator");

/**
 * Property type: number.
 */
DvtAnimator.TYPE_NUMBER = "typeNumber";
/**
 * Property type: matrix.
 */
DvtAnimator.TYPE_MATRIX = "typeMatrix";
/**
 * Property type: array of numbers.
 */
DvtAnimator.TYPE_NUMBER_ARRAY = "typeNumberArray";
/**
 * Property type: color.
 */
DvtAnimator.TYPE_COLOR = "typeColor";
/**
 * Property type: array of colors.
 */
DvtAnimator.TYPE_COLOR_ARRAY = "typeColorArray";
/**
 * Property type: grow polyline points.
 */
DvtAnimator.TYPE_GROW_POLYLINE = "typeGrowPolyline";
/**
 * Property type: rectangle.
 */
DvtAnimator.TYPE_RECTANGLE = "typeRectangle";
/**
 * Property type: point.
 */
DvtAnimator.TYPE_POINT = "typePoint";
/**
 * Property type: path.
 */
DvtAnimator.TYPE_PATH = "typePath";
/**
 * Property type: grow path points.
 */
DvtAnimator.TYPE_GROW_PATH = "typeGrowPath";
/**
 * Property type: fill.
 */
DvtAnimator.TYPE_FILL = "typeFill";
/**
 * Property type: stroke.
 */
DvtAnimator.TYPE_STROKE = "typeStroke";
/**
 * Property type: polyline.
 */
DvtAnimator.TYPE_POLYLINE = "typePolyline";

DvtAnimator._KEY_PREFIX = "dvtAnimPropMap_";

/**
 * @protected
 */
DvtAnimator.prototype.Init = function(context, duration, delay, easing) {
  DvtAnimator.superclass.Init.call(this, context, context.getScheduler(), duration, delay, easing);
  
  this._context = context;
  this._props = {};
};

/**
 * Add a property to animate.
 * 
 * @param {string}  type  type of property
 * @param {object}  obj  object being animated
 * @param {function}  getter  getter function for property being animated
 * @param {function}  setter  setter function for property being animated
 * @param  destVal  destination value to animate to
 */
DvtAnimator.prototype.addProp = function(type, obj, getter, setter, destVal) {
  var item = this.GetPropItem(obj, getter);
  if (item) {
    item.destVal = destVal;
  }
  else {
    var item = new DvtAnimatorPropItem(type, obj, getter, setter, destVal);
    //map keys must be strings, so always generate a string key for objects 
    //and functions
    var keyObj = DvtAnimator.GetKey(obj);
    if (!this._props[keyObj]) {
      this._props[keyObj] = {};
    }
    this._props[keyObj][DvtAnimator.GetKey(getter)] = item;
  }
};

/**
 * Removes a property to animate.
 * 
 * @param {object}  obj  object being animated
 * @param {function}  getter  getter function for property being animated
 */
DvtAnimator.prototype.removeProp = function(obj, getter) {
  var item = this.GetPropItem(obj, getter);
  if (item) {
    var destVal = item.destVal;
    delete this._props[DvtAnimator.GetKey(obj)][DvtAnimator.GetKey(getter)];
    return destVal;
  }
  return null;
};


/**
 * Get the destination value for a property being animated.
 * 
 * @param {object}  obj  object being animated
 * @param {function}  getter  getter function for property being animated
 * @param {boolean} callGetter (optional) If no destination value is found, indicates whether the getter should be called directly rather than returning null
 */
DvtAnimator.prototype.getDestVal = function(obj, getter, callGetter) {
  var item = this.GetPropItem(obj, getter);
  if (item) {
    return item.destVal;
  }
  //if not part of the animation, return null
  return callGetter ? getter.call(obj) : null;
};

/**
 * @protected
 * Get the index of the given property in the storage array, 
 * or -1 if the property is not found.
 * 
 * @param {object}  obj  object being animated
 * @param {function}  getter  getter function for property being animated
 */
DvtAnimator.prototype.GetPropItem = function(obj, getter) {
  var keyObj = DvtAnimator.GetKey(obj);
  if (this._props[keyObj]) {
    return this._props[keyObj][DvtAnimator.GetKey(getter)];
  }
  return null;
};

/**
 * @protected
 * Get the key to use for the given obj in the prop map.
 */
DvtAnimator.GetKey = function(obj) {
  if (!obj._dvtAnimPropMapKey) {
    obj._dvtAnimPropMapKey = DvtAnimator._KEY_PREFIX + Math.random();
  }
  return obj._dvtAnimPropMapKey;
};

/**
 * @protected
 * @override
 */
DvtAnimator.prototype.Initialize = function() {
  for (var keyObj in this._props) {
    for (var keyGetter in this._props[keyObj]) {
      var item = this._props[keyObj][keyGetter];
      item.startVal = item.getter.call(item.obj);
    }
  }
};

/**
 * @protected
 * @override
 */
DvtAnimator.prototype.Step = function(progress) {
  for (var keyObj in this._props) {
    for (var keyGetter in this._props[keyObj]) {
      var item = this._props[keyObj][keyGetter];
      var type = item.type;
      var obj = item.obj;
      var setter = item.setter;
      var destVal = item.destVal;
      
      var startVal  = item.startVal;
      var interpVal = DvtInterpolator.interpolate(this._context, type, startVal, destVal, progress);
      setter.call(obj, interpVal);
    }
  }
};

// Nested class begin //////////////////////////////////////

var DvtAnimatorPropItem = function(type, obj, getter, setter, destVal) {
  this.type = type;
  this.obj = obj;
  this.getter = getter;
  this.setter = setter;
  this.destVal = destVal;
  this.startVal = null;
};

DvtObj.createSubclass(DvtAnimatorPropItem, DvtObj, "DvtAnimatorPropItem");

// Nested class end ////////////////////////////////////////
// Copyright (c) 2011, 2012, Oracle and/or its affiliates. 
// All rights reserved. 
/**
  * Abstract base class representing something that can be played, like an animation.
  * @extends DvtObj
  * @class DvtPlayable
  * @constructor
  * 
  * @param {DvtContext}  context  platform specific context object
  */
var DvtPlayable = function(context)
{
  this.Init(context);
};

DvtObj.createSubclass(DvtPlayable, DvtObj, "DvtPlayable");

/**
  * Append a function to the end of the given playable's current onEnd function.
  * 
  * @param {DvtPlayable}  playable  playable to append onEnd function to
  * @param {function}  onEnd  new function to append to current onEnd function
  * @param {object}  onEndObj  optional reference to object instance on which the new
  *        onEnd function is defined
  */
DvtPlayable.appendOnEnd = function(playable, onEnd, onEndObj)
{
  if (!playable || !onEnd)
  {
    return;
  }
  
  var arOnEnd = playable.getOnEnd();
  if (!arOnEnd || !arOnEnd[0])
  {
    playable.setOnEnd(onEnd, onEndObj);
  }
  else
  {
    var newOnEnd = function() 
      {
        arOnEnd[0].call(arOnEnd[1]);
        onEnd.call(onEndObj);
      };
    playable.setOnEnd(newOnEnd);
  }
};

/**
  * Prepend a function to the start of the given playable's current onEnd function.
  * 
  * @param {DvtPlayable}  playable  playable to prepend onEnd function to
  * @param {function}  onEnd  new function to prepend to current onEnd function
  * @param {object}  onEndObj  optional reference to object instance on which the new
  *        onEnd function is defined
  */
DvtPlayable.prependOnEnd = function(playable, onEnd, onEndObj)
{
  if (!playable || !onEnd)
  {
    return;
  }
  
  var arOnEnd = playable.getOnEnd();
  if (!arOnEnd || !arOnEnd[0])
  {
    playable.setOnEnd(onEnd, onEndObj);
  }
  else
  {
    var newOnEnd = function() 
      {
        onEnd.call(onEndObj);
        arOnEnd[0].call(arOnEnd[1]);
      };
    playable.setOnEnd(newOnEnd);
  }
};

/**
  * Append a function to the end of the given playable's current onStart function.
  * 
  * @param {DvtPlayable}  playable  playable to append onStart function to
  * @param {function}  onStart  new function to append to current onStart function
  * @param {object}  onStartObj  optional reference to object instance on which the new
  *        onStart function is defined
  */
DvtPlayable.appendOnStart = function(playable, onStart, onStartObj)
{
  if (!playable || !onStart || !playable.getOnStart || !playable.setOnStart)
  {
    return;
  }
  
  var arOnStart = playable.getOnStart();
  if (!arOnStart || !arOnStart[0])
  {
    playable.setOnStart(onStart, onStartObj);
  }
  else
  {
    var newOnStart = function() 
      {
        arOnStart[0].call(arOnStart[1]);
        onStart.call(onStartObj);
      };
    playable.setOnStart(newOnStart);
  }
};

/**
  * Prepend a function to the start of the given playable's current onStart function.
  * 
  * @param {DvtPlayable}  playable  playable to prepend onStart function to
  * @param {function}  onStart  new function to prepend to current onStart function
  * @param {object}  onStartObj  optional reference to object instance on which the new
  *        onStart function is defined
  */
DvtPlayable.prependOnStart = function(playable, onStart, onStartObj)
{
  if (!playable || !onStart || !playable.getOnStart || !playable.setOnStart)
  {
    return;
  }
  
  var arOnStart = playable.getOnStart();
  if (!arOnStart || !arOnStart[0])
  {
    playable.setOnStart(onStart, onStartObj);
  }
  else
  {
    var newOnStart = function() 
      {
        onStart.call(onStartObj);
        arOnStart[0].call(arOnStart[1]);
      };
    playable.setOnStart(newOnStart);
  }
};

/**
  * Append a function to the end of the given playable's current onInit function.
  * 
  * @param {DvtPlayable}  playable  playable to append onInit function to
  * @param {function}  onInit  new function to append to current onInit function
  * @param {object}  onInitObj  optional reference to object instance on which the new
  *        onInit function is defined
  */
DvtPlayable.appendOnInit = function(playable, onInit, onInitObj)
{
  if (!playable || !onInit || !playable.getOnInit || !playable.setOnInit)
  {
    return;
  }
  
  var arOnInit = playable.getOnInit();
  if (!arOnInit || !arOnInit[0])
  {
    playable.setOnInit(onInit, onInitObj);
  }
  else
  {
    var newOnInit = function() 
      {
        arOnInit[0].call(arOnInit[1]);
        onInit.call(onInitObj);
      };
    playable.setOnInit(newOnInit);
  }
};

/**
  * Prepend a function to the start of the given playable's current onInit function.
  * 
  * @param {DvtPlayable}  playable  playable to prepend onInit function to
  * @param {function}  onInit  new function to prepend to current onInit function
  * @param {object}  onInitObj  optional reference to object instance on which the new
  *        onInit function is defined
  */
DvtPlayable.prependOnInit = function(playable, onInit, onInitObj)
{
  if (!playable || !onInit || !playable.getOnInit || !playable.setOnInit)
  {
    return;
  }
  
  var arOnInit = playable.getOnInit();
  if (!arOnInit || !arOnInit[0])
  {
    playable.setOnInit(onInit, onInitObj);
  }
  else
  {
    var newOnInit = function() 
      {
        onInit.call(onInitObj);
        arOnInit[0].call(arOnInit[1]);
      };
    playable.setOnInit(newOnInit);
  }
};

/**
  * @protected
  */
DvtPlayable.prototype.Init = function(context)
{
  this.Context = context;
  this._onEnd = null;
  this._onEndObj = null;
};

/**
  * Set the function to call when this playable ends.
  * 
  * @param {function}  onEnd  function to call when this playable ends
  * @param {object}  onEndObj  optional reference to object instance on which the 
  *        onEnd function is defined
  */
DvtPlayable.prototype.setOnEnd = function(onEnd, onEndObj)
{
  this._onEnd = onEnd;
  if (onEndObj)
  {
    this._onEndObj = onEndObj;
  }
  else
  {
    this._onEndObj = null;
  }
  this.OnEndUpdated();
};

/**
  * Get the function to call when this playable ends.
  * Returns an array of two elements: 
  * [0] the function
  * [1] optional reference to object instance on which the function is defined
  * 
  * @type array
  */
DvtPlayable.prototype.getOnEnd = function()
{
  return [this._onEnd, this._onEndObj];
};

/**
  * @protected
  * Called when the onEnd funciton on this playable is set.
  */
DvtPlayable.prototype.OnEndUpdated = function()
{
  //subclasses must override
};

/**
  * Play this playable.
  */
DvtPlayable.prototype.play = function()
{
  //subclasses must override
};

/**
  * Stop this playable.
  */
DvtPlayable.prototype.stop = function(bJumpToEnd)
{
  //subclasses must override
};

/**
  * Pause this playable.
  */
DvtPlayable.prototype.pause = function()
{
  //subclasses must override
};
// Copyright (c) 2011, 2012, Oracle and/or its affiliates. 
// All rights reserved. 
/**
  * Class representing a set of DvtPlayables that are played at the same time.
  * The playables should be passed into the constructor as either:
  * 1) individual arguments, for example:
  *    new DvtParallelPlayable(context, playable1, playable2, ...), or
  * 2) a single Array, for example:
  *    new DvtParallelPlayable(context, [playable1, playable2, ...]);
  * @extends DvtPlayable
  * @class DvtParallelPlayable
  * @constructor
  * 
  * @param {DvtContext}  context  platform specific context object
  */
var DvtParallelPlayable = function(context)
{
  var arPlayables;
  if (arguments && arguments.length > 1 && arguments[1] instanceof Array)
  {
    arPlayables = arguments[1];
  }
  else
  {
    arPlayables = DvtArrayUtils.argsToArray(arguments);
    //remove the context from the arPlayables array
    arPlayables.splice(0, 1);
  }
  
  this.Init(context, arPlayables);
};

DvtObj.createSubclass(DvtParallelPlayable, DvtPlayable, "DvtParallelPlayable");

/**
  * @protected
  * @override
  */
DvtParallelPlayable.prototype.Init = function(context, arPlayables)
{
  DvtParallelPlayable.superclass.Init.call(this, context);
  
  this._runningCounter = 0;
  this._arPlayables = arPlayables;
  this._bStarted = false;
};

/**
  * Get the list of playables.
  * @type Array
  */
DvtParallelPlayable.prototype.getPlayables = function()
{
  return this._arPlayables;
};

/**
  * @override
  */
DvtParallelPlayable.prototype.play = function()
{
  if (this._arPlayables && this._arPlayables.length > 0)
  {
    this._runningCounter = this._arPlayables.length;
    
    var playable;
    for (var i = 0; i < this._arPlayables.length; i++)
    {
      playable = this._arPlayables[i];
      if (playable instanceof DvtPlayable)
      {
        if (!this._bStarted)
        {
          //call internal onEnd function when each Playable ends
          DvtPlayable.appendOnEnd(playable, this.OnPlayableEnd, this);
        }
        playable.play();
      }
    }
    
    this._bStarted = true;
  }
  else {
    // The onEnd listener should still be called.
    var timer = new DvtTimer(this.Context, 0, this.DoEnd, this, 1);
    timer.start();
  }
};

/**
  * @override
  */
DvtParallelPlayable.prototype.stop = function(bJumpToEnd)
{
  if (this._arPlayables)
  {
    var playable;
    for (var i = 0; i < this._arPlayables.length; i++)
    {
      playable = this._arPlayables[i];
      if (playable instanceof DvtPlayable)
      {
        playable.stop(bJumpToEnd);
      }
    }
  }
};

/**
  * @override
  */
DvtParallelPlayable.prototype.pause = function()
{
  if (this._arPlayables)
  {
    var playable;
    for (var i = 0; i < this._arPlayables.length; i++)
    {
      playable = this._arPlayables[i];
      if (playable instanceof DvtPlayable)
      {
        playable.pause();
      }
    }
  }
};

/**
  * @protected
  * Called after each playable ends.
  */
DvtParallelPlayable.prototype.OnPlayableEnd = function()
{
  //decrement the count of running playables
  this._runningCounter--;
  
  //if no more running, call the onEnd function for this ParallelPlayable
  if (this._runningCounter < 1)
  {
    this.DoEnd();
  }
};

/**
  * @protected
  * Called after all the playables have finished.
  */
DvtParallelPlayable.prototype.DoEnd = function()
{
  if (this._onEnd)
  {
    this._onEnd.call(this._onEndObj);
  }
};
// Copyright (c) 2011, 2012, Oracle and/or its affiliates. 
// All rights reserved. 
/**
  * Class representing a set of DvtPlayables that are played one after another.
  * The playables should be passed into the constructor as either:
  * 1) individual arguments, for example:
  *    new DvtParallelPlayable(context, playable1, playable2, ...), or
  * 2) a single Array, for example:
  *    new DvtParallelPlayable(context, [playable1, playable2, ...]);
  * @extends DvtPlayable
  * @class DvtParallelPlayable
  * @constructor
  * 
  * @param {DvtContext}  context  platform specific context object
  */
var DvtSequentialPlayable = function(context)
{
  var arPlayables;
  if (arguments && arguments.length > 1 && arguments[1] instanceof Array)
  {
    arPlayables = arguments[1];
  }
  else
  {
    arPlayables = DvtArrayUtils.argsToArray(arguments);
    //remove the context from the arPlayables array
    arPlayables.splice(0, 1);
  }
  
  this.Init(context, arPlayables);
};

DvtObj.createSubclass(DvtSequentialPlayable, DvtPlayable, "DvtSequentialPlayable");

/**
  * @protected
  * @override
  */
DvtSequentialPlayable.prototype.Init = function(context, arPlayables)
{
  DvtSequentialPlayable.superclass.Init.call(this, context);
  
  this._arPlayables = arPlayables;
  this._currIndex = -1;
  this._bStarted = false;
};

/**
  * Get the list of playables.
  * @type Array
  */
DvtSequentialPlayable.prototype.getPlayables = function()
{
  return this._arPlayables;
};

/**
  * @override
  */
DvtSequentialPlayable.prototype.play = function()
{
  if (this._arPlayables && this._arPlayables.length > 0)
  {
    if (this._bStarted)
    {
      var currPlayable = this._arPlayables[this._currIndex];
      if (currPlayable instanceof DvtPlayable)
      {
        currPlayable.play();
      }
      return;
    }
    
    var firstPlayable;
    if (this._arPlayables[0] instanceof DvtPlayable)
      firstPlayable = this._arPlayables[0];
    var lastPlayable;
    if (this._arPlayables[this._arPlayables.length - 1] instanceof DvtPlayable)
      lastPlayable = this._arPlayables[this._arPlayables.length - 1];
    
    //var prevPlayable = firstPlayable;
    var playable;
    for (var i = 0; i < this._arPlayables.length - 1; i++)
    {
      playable = this._arPlayables[i];
      if (playable instanceof DvtPlayable)
      {
        //at the end of each playable, play the next one
        //DvtPlayable.appendOnEnd(prevPlayable, playable.play, playable);
        //prevPlayable = playable;
        
        DvtPlayable.appendOnEnd(playable, this.DoSequenceStep, this);
      }
    }
    
    //call the onEnd function for this DvtSequentialPlayable at the very
    //end of the sequence
    //if (playable)
    //  DvtPlayable.appendOnEnd(playable, this.DoEnd, this);
    if (lastPlayable)
      DvtPlayable.appendOnEnd(lastPlayable, this.DoEnd, this);
    
    this._bStarted = true;
    this._currIndex = 0;
    
    if (firstPlayable)
      firstPlayable.play();
  }
  else {
    // The onEnd listener should still be called.
    var timer = new DvtTimer(this.Context, 0, this.DoEnd, this, 1);
    timer.start();
  }
};

/**
  * @protected
  * Called after each playable, except the last one, ends.
  */
DvtSequentialPlayable.prototype.DoSequenceStep = function()
{
  var playable = this._arPlayables[++this._currIndex];
  if (playable instanceof DvtPlayable)
  {
    playable.play();
  }
  else
  {
    this.DoSequenceStep();
  }
};

/**
  * @override
  */
DvtSequentialPlayable.prototype.stop = function(bJumpToEnd)
{
  if (this._arPlayables)
  {
    var playable;
    for (var i = this._currIndex; i < this._arPlayables.length; i++)
    {
      playable = this._arPlayables[i];
      if (playable && playable instanceof DvtPlayable)
      {
        playable.stop(bJumpToEnd);
      }
    }
  }
};

/**
  * @override
  */
DvtSequentialPlayable.prototype.pause = function()
{
  if (this._arPlayables)
  {
    var playable = this._arPlayables[this._currIndex];
    if (playable instanceof DvtPlayable)
    {
      playable.pause();
    }
  }
};

/**
  * @protected
  * Called after the last playable has finished.
  */
DvtSequentialPlayable.prototype.DoEnd = function()
{
  if (this._onEnd)
  {
    this._onEnd.call(this._onEndObj);
  }
};
// Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved. 
/**
  * Class defining easing functions for animations.
  * @extends DvtObj
  * @class DvtEasing
  * @constructor
  */
var DvtEasing = function()
{
  this.Init();
};

DvtObj.createSubclass(DvtEasing, DvtObj, "DvtEasing");

/**
  * Linear easing function.
  * Returns the percent progress of the animation after applying the easing function.
  * @param {number}  progress  percent progress of the animation
  * @type number
  */
DvtEasing.linear = function(progress)
{
  return progress;
};

/**
  * Quadratic easing function that starts slow and speeds up at the beginning.
  * Returns the percent progress of the animation after applying the easing function.
  * @param {number}  progress  percent progress of the animation
  * @type number
  */
DvtEasing.quadraticIn = function(progress)
{
  return DvtEasing.PolyIn(progress, 2);
};

/**
  * Quadratic easing function that starts fast and slows down at the end.
  * Returns the percent progress of the animation after applying the easing function.
  * @param {number}  progress  percent progress of the animation
  * @type number
  */
DvtEasing.quadraticOut = function(progress)
{
  return DvtEasing.PolyOut(progress, 2);
};

/**
  * Quadratic easing function that starts slow, speeds up, and then slows down at the end.
  * Returns the percent progress of the animation after applying the easing function.
  * @param {number}  progress  percent progress of the animation
  * @type number
  */
DvtEasing.quadraticInOut = function(progress)
{
  return DvtEasing.PolyInOut(progress, 2);
};

/**
  * Cubic easing function that starts slow and speeds up at the beginning.
  * Returns the percent progress of the animation after applying the easing function.
  * @param {number}  progress  percent progress of the animation
  * @type number
  */
DvtEasing.cubicIn = function(progress)
{
  return DvtEasing.PolyIn(progress, 3);
};

/**
  * Cubic easing function that starts fast and slows down at the end.
  * Returns the percent progress of the animation after applying the easing function.
  * @param {number}  progress  percent progress of the animation
  * @type number
  */
DvtEasing.cubicOut = function(progress)
{
  return DvtEasing.PolyOut(progress, 3);
};

/**
  * Cubic easing function that starts slow, speeds up, and then slows down at the end.
  * Returns the percent progress of the animation after applying the easing function.
  * @param {number}  progress  percent progress of the animation
  * @type number
  */
DvtEasing.cubicInOut = function(progress)
{
  return DvtEasing.PolyInOut(progress, 3);
};

/**
  * Cubic easing function that starts fast and slows down at the end, 
  * overshooting the target and then coming back.
  * Returns the percent progress of the animation after applying the easing function.
  * @param {number}  progress  percent progress of the animation
  * @param {number}  overshoot  value to overshoot, with higher values 
  *        overshooting more (value of 0 means no overshoot, 
  *        default value of 1.7 overshoots by about 10%)
  * @type number
  */
DvtEasing.backOut = function(progress, overshoot)
{
  //t = progress, s = overshoot
  //(s+1)*t^3 - s*t^2
  if (!overshoot)
  {
    overshoot = 1.70158;
  }
  progress = 1 - progress;
  return 1 - progress*progress*((overshoot+1)*progress - overshoot);
};

/**
  * Cubic easing function that starts slow and speeds up at the beginning, 
  * overshooting the starting value in the opposite direction and then 
  * proceeding forward.
  * Returns the percent progress of the animation after applying the easing function.
  * @param {number}  progress  percent progress of the animation
  * @param {number}  overshoot  value to overshoot, with higher values 
  *        overshooting more (value of 0 means no overshoot, 
  *        default value of 1.7 overshoots by about 10%)
  * @type number
  */
DvtEasing.backIn = function(progress, overshoot)
{
  //t = progress, s = overshoot
  //(s+1)*t^3 - s*t^2
  if (!overshoot)
  {
    overshoot = 1.70158;
  }
  return progress*progress*((overshoot+1)*progress - overshoot);
};
	
/**
  * Easing function that oscillates at the start with an exponentially 
  * decaying sine wave.
  *
  * @param {number}  progress  percent progress of the animation
  * @param {number}  amplitude  amplitude of the sine wave
  * @param {number}  period  period of the sine wave
  * @type number
  */
DvtEasing.elasticIn = function(progress, amplitude, period)
{
  if (progress <= 0 || progress >= 1)
  {
    return progress;
  }
  if (!period)
  {
    period = 0.45;
  }
  var s;
  if (!amplitude || amplitude < 1)
  {
    amplitude = 1; 
    s = period / 4;
  }
  else
  {
    s = period / (2 * Math.PI) * Math.asin(1 / amplitude);
  }
  return -(amplitude*Math.pow(2,10*(progress-=1)) * Math.sin( (progress-s)*(2*Math.PI)/period ));
};
		
/**
  * Easing function that oscillates at the end with an exponentially 
  * decaying sine wave.
  *
  * @param {number}  progress  percent progress of the animation
  * @param {number}  amplitude  amplitude of the sine wave
  * @param {number}  period  period of the sine wave
  * @type number
  */
DvtEasing.elasticOut = function(progress, amplitude, period) {
  return 1 - DvtEasing.elasticIn(1-progress, amplitude, period);
};

/**
  * @protected
  * Polynomial easing function that starts slow and speeds up at the beginning.
  * Returns the percent progress of the animation after applying the easing function.
  * @param {number}  progress  percent progress of the animation
  * @param {number}  exp  exponent of the polynomial
  * @type number
  */
DvtEasing.PolyIn = function(progress, exp)
{
  if (progress < 0)
  {
    return 0;
  }
  if (progress > 1)
  {
    return 1;
  }
  else
  {
    return Math.pow(progress, exp);
  }
};

/**
  * @protected
  * Polynomial easing function that starts fast and slows down at the end.
  * Returns the percent progress of the animation after applying the easing function.
  * @param {number}  progress  percent progress of the animation
  * @param {number}  exp  exponent of the polynomial
  * @type number
  */
DvtEasing.PolyOut = function(progress, exp)
{
  if (progress < 0)
  {
    return 0;
  }
  if (progress > 1)
  {
    return 1;
  }
  else
 {
    return 1 - Math.pow(1 - progress, exp);
  }
};

/**
  * @protected
  * Polynomial easing function that starts slow, speeds up, and then slows down at the end.
  * Returns the percent progress of the animation after applying the easing function.
  * @param {number}  progress  percent progress of the animation
  * @param {number}  exp  exponent of the polynomial
  * @type number
  */
DvtEasing.PolyInOut = function(progress, exp)
{
  if (progress < 0)
  {
    return 0;
  }
  if (progress > 1)
  {
    return 1;
  }
  if (progress < .5)
  {
    return .5 * Math.pow(2 * progress, exp);
  }
  else
  {
    return .5 * (2 - Math.pow(2 * (1 - progress), exp));
  }
};

/**
  * @protected
  */
DvtEasing.prototype.Init = function()
{
};
// Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved.
/**
  * Class defining interpolation functions for animations.
  * @extends DvtObj
  * @class DvtInterpolator
  * @constructor
  */
var DvtInterpolator = function()
{
  this.Init();
};

DvtObj.createSubclass(DvtInterpolator, DvtObj, "DvtInterpolator");

/**
  * Add an interpolator function to use for a given type of value.
  * @param {string}  type  type of value to use interpolator for
  * @param {function}  func  interpolator function
  */
DvtInterpolator.addInterpolator = function(type, func) {
  DvtInterpolator._map[type] = func;
};

/**
  * Remove an interpolator function.
  * @param {string}  type  type of value to remove interpolator for
  */
DvtInterpolator.removeInterpolator = function(type) {
  delete DvtInterpolator._map[type];
};

/**
  * Interpolate a value between the original and destination values for the 
  * given percent progress.
  * @param {DvtContext}  context  platform specific context object
  * @param {string}  type  type of value being interpolated
  * @param  origVal  original property value
  * @param  destVal  destination property value
  * @param {number}  progress  percent progress to interpolate
  */
DvtInterpolator.interpolate = function(context, type, origVal, destVal, progress)
{
  //don't pin progress, so that we can do elastic type easing functions,
  //like backIn and backOut for popIn and popOut anims
  /*if (progress <= 0)
  {
    return origVal;
  }
  
  if (progress >= 1)
  {
    return destVal;
  }*/
  
  var interpolatorFunc = DvtInterpolator._getInterpolator(type);
  if (interpolatorFunc) {
    return interpolatorFunc(context, origVal, destVal, progress);
  }
  
  return destVal;
};

/**
  * @private
  * Get the interpolator to use for the given type of value.
  * @param {string}  type  type of value to interpolate
  * @type function
  */
DvtInterpolator._getInterpolator = function(type) {
  return DvtInterpolator._map[type];
};

/**
  * Interpolate a number between the original and destination values for the 
  * given percent progress.
  * @param {DvtContext}  context  platform specific context object
  * @param {number}  origVal  original property value
  * @param {number}  destVal  destination property value
  * @param {number}  progress  percent progress to interpolate
  * @type number
  * @protected
  */
DvtInterpolator.InterpolateNumber = function(context, origVal, destVal, progress)
{
  //return (origVal + progress * (destVal - origVal));
  return DvtMath.interpolateNumber(origVal, destVal, progress);
};

/**
  * Interpolate an array of numbers between the original and destination 
  * values for the given percent progress.
  * @param {DvtContext}  context  platform specific context object
  * @param {number}  origVal  original property value
  * @param {number}  destVal  destination property value
  * @param {number}  progress  percent progress to interpolate
  * @type array
  * @protected
  */
DvtInterpolator.InterpolateNumberArray = function(context, origVal, destVal, progress)
{
  var origLength = origVal.length;
  var destLength = destVal.length;
  var array = [];
  for (var i = 0; i < Math.max(origLength, destLength); i++)
  {
    //if one array is shorter than the other, use the last actual value
    //from the shorter array to interpolate with all the extra elements
    //in the longer array
    var n1;
    var n2;
    if (i < origLength)
    {
      n1 = origVal[i];
    }
    else
    {
      n1 = origVal[origLength - 1];
    }
    if (i < destLength)
    {
      n2 = destVal[i];
    }
    else
    {
      n2 = destVal[destLength - 1];
    }
    array.push(DvtInterpolator.InterpolateNumber(context, n1, n2, progress));
  }
  return array;
};

/**
  * Interpolate a matrix between the original and destination values for the 
  * given percent progress.
  * @param {DvtContext}  context  platform specific context object
  * @param {DvtMatrix}  origVal  original property value
  * @param {DvtMatrix}  destVal  destination property value
  * @param {number}  progress  percent progress to interpolate
  * @type DvtMatrix
  * @protected
  */
DvtInterpolator.InterpolateMatrix = function(context, origVal, destVal, progress)
{
  var newA = DvtInterpolator.InterpolateNumber(context, origVal.getA(), destVal.getA(), progress);
  var newB = DvtInterpolator.InterpolateNumber(context, origVal.getB(), destVal.getB(), progress);
  var newC = DvtInterpolator.InterpolateNumber(context, origVal.getC(), destVal.getC(), progress);
  var newD = DvtInterpolator.InterpolateNumber(context, origVal.getD(), destVal.getD(), progress);
  var newTx = DvtInterpolator.InterpolateNumber(context, origVal.getTx(), destVal.getTx(), progress);
  var newTy = DvtInterpolator.InterpolateNumber(context, origVal.getTy(), destVal.getTy(), progress);
  
  return new DvtMatrix(newA, newB, newC, newD, newTx, newTy);
};

/**
  * Interpolate a color between the original and destination values for the 
  * given percent progress.
  * @param {DvtContext}  context  platform specific context object
  * @param {number}  origVal  original property value
  * @param {number}  destVal  destination property value
  * @param {number}  progress  percent progress to interpolate
  * @protected
  */
DvtInterpolator.InterpolateColor = function(context, origVal, destVal, progress)
{
  return DvtColorUtils.interpolateColor(origVal, destVal, progress);
};

/**
  * Interpolate an array of colors between the original and destination 
  * values for the given percent progress.
  * @param {DvtContext}  context  platform specific context object
  * @param {number}  origVal  original property value
  * @param {number}  destVal  destination property value
  * @param {number}  progress  percent progress to interpolate
  * @type array
  * @protected
  */
DvtInterpolator.InterpolateColorArray = function(context, origVal, destVal, progress)
{
  var origLength = origVal.length;
  var destLength = destVal.length;
  var array = [];
  for (var i = 0; i < Math.max(origLength, destLength); i++)
  {
    //if one array is shorter than the other, use the last actual value
    //from the shorter array to interpolate with all the extra elements
    //in the longer array
    var n1;
    var n2;
    if (i < origLength)
    {
      n1 = origVal[i];
    }
    else
    {
      n1 = origVal[origLength - 1];
    }
    if (i < destLength)
    {
      n2 = destVal[i];
    }
    else
    {
      n2 = destVal[destLength - 1];
    }
    array.push(DvtInterpolator.InterpolateColor(context, n1, n2, progress));
  }
  return array;
};

/**
  * Interpolate an array of polyline points between the original and 
  * destination values for the given percent progress.
  * @param {DvtContext}  context  platform specific context object
  * @param {number}  origVal  original property value
  * @param {number}  destVal  destination property value
  * @param {number}  progress  percent progress to interpolate
  * @type array
  * @protected
  */
DvtInterpolator.InterpolateGrowPolyline = function(context, origVal, destVal, progress)
{
  if (progress === 0)
  {
    return [destVal[0], destVal[1]];
  }
  else if (progress === 1)
  {
    return destVal;
  }
  
  var destLength = destVal.length;
  var array = [destVal[0], destVal[1]];
  var totalLength = DvtInterpolator.CalcPolylineLength(destVal);
  var partialLength = progress * totalLength;
  var accumLength = 0;
  var currSegLength;
  for (var i = 2; i < destLength - 1; i+=2)
  {
    var x1 = destVal[i-2];
    var y1 = destVal[i-1];
    var x2 = destVal[i];
    var y2 = destVal[i+1];
    
    currSegLength = DvtInterpolator.CalcPolylineLength([x1, y1, x2, y2]);
    
    if (accumLength + currSegLength > partialLength)
    {
      var ratio = (partialLength - accumLength) / currSegLength;
      var diffX = x2 - x1;
      var diffY = y2 - y1;
      array.push(x1 + ratio * diffX);
      array.push(y1 + ratio * diffY);
      break;
    }
    else
    {
      accumLength += currSegLength;
      
      array.push(x2);
      array.push(y2);
    }
  }
  return array;
};

/**
  * Interpolate an array of path commands between the original and 
  * destination values for the given percent progress.
  * @param {DvtContext}  context  platform specific context object
  * @param {number}  origVal  original property value
  * @param {number}  destVal  destination property value
  * @param {number}  progress  percent progress to interpolate
  * @type array
  * @protected
  */
DvtInterpolator.InterpolateGrowPath = function(context, origVal, destVal, progress)
{
  if (progress === 0)
  {
    return [destVal[0], destVal[1]];
  }
  else if (progress === 1)
  {
    return destVal;
  }
  
  var destLength = destVal.length;
  var array = [];
  var totalLength = DvtInterpolator.CalcPathLength(destVal);
  var partialLength = progress * totalLength;
  var accumLength = 0;
  var currSegLength;
  var x1;
  var y1;
  var cpx1;
  var cpy1;
  var cpx2;
  var cpy2;
  var prevX;
  var prevY;
  for (var i = 0; i < destLength; i++)
  {
    var cmd = destVal[i];
    var segArray;
    switch (cmd)
    {
      case "M":
        x1 = destVal[++i];
        y1 = destVal[++i];
        prevX = x1;
        prevY = y1;
        segArray = [prevX, prevY, prevX, prevY];
        break;
      case "L":
        x1 = destVal[++i];
        y1 = destVal[++i];
        segArray = [prevX, prevY, x1, y1];
        break;
      case "Q":
        cpx1 = destVal[++i];
        cpy1 = destVal[++i];
        x1 = destVal[++i];
        y1 = destVal[++i];
        segArray = [prevX, prevY, x1, y1];
        break;
      case "C":
        cpx1 = destVal[++i];
        cpy1 = destVal[++i];
        cpx2 = destVal[++i];
        cpy2 = destVal[++i];
        x1 = destVal[++i];
        y1 = destVal[++i];
        segArray = [prevX, prevY, x1, y1];
        break;
    }
    
    currSegLength = DvtInterpolator.CalcPolylineLength(segArray);
    
    if (accumLength + currSegLength > partialLength)
    {
      var ratio = (partialLength - accumLength) / currSegLength;
      
      array.push(cmd);
      switch (cmd)
      {
        case "Q":
          array.push(prevX + ratio * (cpx1 - prevX), 
                     prevY + ratio * (cpy1 - prevY));
          break;
        case "C":
          array.push(prevX + ratio * (cpx1 - prevX), 
                     prevY + ratio * (cpy1 - prevY), 
                     prevX + ratio * (cpx2 - prevX), 
                     prevY + ratio * (cpy2 - prevY));
          break;
      }
      array.push(prevX + ratio * (x1 - prevX), 
                 prevY + ratio * (y1 - prevY));
      break;
    }
    else
    {
      accumLength += currSegLength;
      
      array.push(cmd);
      switch (cmd)
      {
        case "Q":
          array.push(cpx1, cpy1);
          break;
        case "C":
          array.push(cpx1, cpy1, cpx2, cpy2);
          break;
      }
      array.push(x1);
      array.push(y1);
    }
    prevX = x1;
    prevY = y1;
  }
  return array;
};

DvtInterpolator.CalcPolylineLength = function(arPoints)
{
  var length = 0;
  var oldX;
  var oldY;
  var xx;
  var yy;
  for (var i = 0; i < arPoints.length; i+=2)
  {
    xx = arPoints[i];
    yy = arPoints[i+1];
    
    if (i > 0)
    {
      if (xx === oldX)
      {
        length += (Math.abs(yy - oldY));
      }
      else if (yy === oldY)
      {
        length += (Math.abs(xx - oldX));
      }
      else
      {
        var diffX = Math.abs(xx - oldX);
        var diffY = Math.abs(yy - oldY);
        length += Math.sqrt((diffX * diffX) + (diffY * diffY));
      }
    }
    
    oldX = xx;
    oldY = yy;
  }
  return length;
};

DvtInterpolator.CalcPathLength = function(arPoints)
{
  var length = 0;
  var oldX;
  var oldY;
  var xx;
  var yy;
  var cmd;
  for (var i = 0; i < arPoints.length; )
  {
    cmd = arPoints[i];
    switch (cmd)
    {
      case "M":
        xx = arPoints[i+1];
        yy = arPoints[i+2];
        oldX = xx;
        oldY = yy;
        i += 3;
        continue;
        break;
      case "L":
        xx = arPoints[i+1];
        yy = arPoints[i+2];
        i += 3;
        break;
      case "Q":
        xx = arPoints[i+3];
        yy = arPoints[i+4];
        i += 5;
        break;
      case "C":
        xx = arPoints[i+5];
        yy = arPoints[i+6];
        i += 7;
        break;
    }
    
    if (i > 0)
    {
      if (xx === oldX)
      {
        length += (Math.abs(yy - oldY));
      }
      else if (yy === oldY)
      {
        length += (Math.abs(xx - oldX));
      }
      else
      {
        var diffX = Math.abs(xx - oldX);
        var diffY = Math.abs(yy - oldY);
        length += Math.sqrt((diffX * diffX) + (diffY * diffY));
      }
    }
    
    oldX = xx;
    oldY = yy;
  }
  return length;
};

/**
  * Interpolate a rectangle between the original and destination values for
  * the given percent progress.
  * @param {DvtContext}  context  platform specific context object
  * @param {DvtRectangle}  origVal  original property value
  * @param {DvtRectangle}  destVal  destination property value
  * @param {number}  progress  percent progress to interpolate
  * @type DvtRectangle
  * @protected
  */
DvtInterpolator.InterpolateRectangle = function(context, origVal, destVal, progress)
{
  var newX = DvtInterpolator.InterpolateNumber(context, origVal.x, destVal.x, progress);
  var newY = DvtInterpolator.InterpolateNumber(context, origVal.y, destVal.y, progress);
  var newW = DvtInterpolator.InterpolateNumber(context, origVal.w, destVal.w, progress);
  var newH = DvtInterpolator.InterpolateNumber(context, origVal.h, destVal.h, progress);
  
  return new DvtRectangle(newX, newY, newW, newH);
};

/**
  * Interpolate a point between the original and destination values for
  * the given percent progress.
  * @param {DvtContext}  context  platform specific context object
  * @param {DvtPoint}  origVal  original property value
  * @param {DvtPoint}  destVal  destination property value
  * @param {number}  progress  percent progress to interpolate
  * @type DvtPoint
  * @protected
  */
DvtInterpolator.InterpolatePoint = function(context, origVal, destVal, progress)
{
  var newX = DvtInterpolator.InterpolateNumber(context, origVal.x, destVal.x, progress);
  var newY = DvtInterpolator.InterpolateNumber(context, origVal.y, destVal.y, progress);
  
  return new DvtPoint(newX, newY);
};

/**
  * Interpolate a path between the original and destination 
  * values for the given percent progress.
  * @param {DvtContext}  context  platform specific context object
  * @param {number}  origVal  original property value
  * @param {number}  destVal  destination property value
  * @param {number}  progress  percent progress to interpolate
  * @type array
  * @protected
  */
DvtInterpolator.InterpolatePath = function(context, origVal, destVal, progress)
{
  var origLength = origVal.length;
  var destLength = destVal.length;
  //TO DO:
  //for now, if the paths are not of equal length, just return the dest val
  if (origLength != destLength)
  {
    return destVal;
  }
  
  var array = [];
  var i = 0;
  var j = 0;
  for (; i < origLength && j < destLength; )
  {
    var n1 = origVal[i];
    var n2 = destVal[j];
    var bNumberN1 = !isNaN(n1);
    var bNumberN2 = !isNaN(n2);
    if (!bNumberN1 && !bNumberN2)
    {
      if (n1 === n2)
      {
        array.push(n1);
      }
      //TO DO: handle case where commands are different
    }
    else if (bNumberN1 && bNumberN2)
    {
      array.push(DvtInterpolator.InterpolateNumber(context, n1, n2, progress));
    }
    i++;
    j++;
  }
  return array;
};

/**
  * Interpolate a fill between the original and destination values for the 
  * given percent progress.
  * @param {DvtContext}  context  platform specific context object
  * @param {number}  origVal  original property value
  * @param {number}  destVal  destination property value
  * @param {number}  progress  percent progress to interpolate
  * @protected
  */
DvtInterpolator.InterpolateFill = function(context, origVal, destVal, progress)
{
  if (origVal instanceof DvtSolidFill && destVal instanceof DvtSolidFill) {
    var color = DvtInterpolator.InterpolateColor(context, origVal.getColor(), destVal.getColor(), progress);
    var alpha = DvtInterpolator.InterpolateNumber(context, origVal.getAlpha(), destVal.getAlpha(), progress);
    var rgb = DvtColorUtils.makeRGB(DvtColorUtils.getRed(color),
                                    DvtColorUtils.getGreen(color),
                                    DvtColorUtils.getBlue(color));
    return new DvtSolidFill(rgb, alpha);
  }
  
  return destVal;
};

/**
  * Interpolate a stroke between the original and destination values for the 
  * given percent progress.
  * @param {DvtContext}  context  platform specific context object
  * @param {number}  origVal  original property value
  * @param {number}  destVal  destination property value
  * @param {number}  progress  percent progress to interpolate
  * @protected
  */
DvtInterpolator.InterpolateStroke = function(context, origVal, destVal, progress)
{
  if (origVal instanceof DvtSolidStroke && destVal instanceof DvtSolidStroke) {
    var color = DvtInterpolator.InterpolateColor(context, origVal.getColor(), destVal.getColor(), progress);
    var alpha = DvtInterpolator.InterpolateNumber(context, origVal.getAlpha(), destVal.getAlpha(), progress);
    var width = DvtInterpolator.InterpolateNumber(context, origVal.getWidth(), destVal.getWidth(), progress);
    var rgb = DvtColorUtils.makeRGB(DvtColorUtils.getRed(color),
                                    DvtColorUtils.getGreen(color),
                                    DvtColorUtils.getBlue(color));
    //clone the destVal because it may have other properties set that
    //we can't interpolate between
    var stroke = destVal.clone();
    stroke.setColor(rgb);
    stroke.setAlpha(alpha);
    stroke.setWidth(width);
    return stroke;
  }
  
  return destVal;
};

/**
  * Interpolate an array of polyline coordinates between the original and 
  * destination values for the given percent progress.
  * @param {DvtContext}  context  platform specific context object
  * @param {number}  origVal  original property value
  * @param {number}  destVal  destination property value
  * @param {number}  progress  percent progress to interpolate
  * @type array
  * @protected
  */
DvtInterpolator.InterpolatePolyline = function(context, origVal, destVal, progress)
{
  var origLength = origVal.length;
  var destLength = destVal.length;
  var array = [];
  for (var i = 0; i < Math.max(origLength, destLength); i++)
  {
    //if one array is shorter than the other, use the last actual coords
    //from the shorter array to interpolate with all the extra coords
    //in the longer array
    //BUG FIX #13376738: use the last coordinate pair, not just the last 
    //element in the array
    var endOffset = 2;
    if (i % 2 == 1) {
      endOffset = 1;
    }
    var n1;
    var n2;
    if (i < origLength)
    {
      n1 = origVal[i];
    }
    else
    {
      n1 = origVal[origLength - endOffset];
    }
    if (i < destLength)
    {
      n2 = destVal[i];
    }
    else
    {
      n2 = destVal[destLength - endOffset];
    }
    array.push(DvtInterpolator.InterpolateNumber(context, n1, n2, progress));
  }
  
  //trim the array to remove redundant coords at the end
  if (destLength < origLength) {
    var arLength = array.length;
    var lastX = array[arLength - 2];
    var lastY = array[arLength - 1];
    for (var i = arLength - 4; i >= 0; i-=2) {
      var currX = array[i];
      var currY = array[i+1];
      if (currX == lastX && currY == lastY) {
        array.splice(i, 2);
      }
      else {
        break;
      }
    }
  }
  
  return array;
};

/**
  * @protected
  */
DvtInterpolator.prototype.Init = function()
{
};

//need to define the map after the functions are defined above
/**
  * @private
  */
DvtInterpolator._map = {};
DvtInterpolator._map[DvtAnimator.TYPE_NUMBER] = DvtInterpolator.InterpolateNumber;
DvtInterpolator._map[DvtAnimator.TYPE_MATRIX] = DvtInterpolator.InterpolateMatrix;
DvtInterpolator._map[DvtAnimator.TYPE_NUMBER_ARRAY] = DvtInterpolator.InterpolateNumberArray;
DvtInterpolator._map[DvtAnimator.TYPE_COLOR] = DvtInterpolator.InterpolateColor;
DvtInterpolator._map[DvtAnimator.TYPE_COLOR_ARRAY] = DvtInterpolator.InterpolateColorArray;
DvtInterpolator._map[DvtAnimator.TYPE_GROW_POLYLINE] = DvtInterpolator.InterpolateGrowPolyline;
DvtInterpolator._map[DvtAnimator.TYPE_RECTANGLE] = DvtInterpolator.InterpolateRectangle;
DvtInterpolator._map[DvtAnimator.TYPE_POINT] = DvtInterpolator.InterpolatePoint;
DvtInterpolator._map[DvtAnimator.TYPE_PATH] = DvtInterpolator.InterpolatePath;
DvtInterpolator._map[DvtAnimator.TYPE_GROW_PATH] = DvtInterpolator.InterpolateGrowPath;
DvtInterpolator._map[DvtAnimator.TYPE_FILL] = DvtInterpolator.InterpolateFill;
DvtInterpolator._map[DvtAnimator.TYPE_STROKE] = DvtInterpolator.InterpolateStroke;
DvtInterpolator._map[DvtAnimator.TYPE_POLYLINE] = DvtInterpolator.InterpolatePolyline
// Copyright (c) 2011, 2014, Oracle and/or its affiliates. All rights reserved.
/**
  * Class representing a timer.
  * @extends DvtObj
  * @class DvtTimer
  * @constructor
  * 
  * @param {DvtContext}  context  platform specific context object
  * @param {number}  interval  interval between timer ticks, in milliseconds
  * @param {function}  callback  function to call for each timer tick
  * @param {object}  callbackObj  optional object instance that callback function is defined on
  * @param {number}  repeatCount  optional number of times for timer to repeat;
  *        timer repeats indefinitely if 0 or undefined
  */
var DvtTimer = function(context, interval, callback, callbackObj, repeatCount)
{
  this.Init(context, interval, callback, callbackObj, repeatCount);
};

DvtObj.createSubclass(DvtTimer, DvtObj, "DvtTimer");

/**
  * @protected
  */
DvtTimer.prototype.Init = function(context, interval, callback, callbackObj, repeatCount)
{
  this._interval = interval; //in ms
  this._callback = callback;
  this._callbackObj = callbackObj;
  
  this._repeatCount = repeatCount;
  this._bRunning = false;
  this._numIterations = 0;
}

/**
  * Start this timer.
  */
DvtTimer.prototype.start = function()
{
  if (!this._bRunning)
  {
    this._bRunning = true;
    this.StartTimer();
  }
}

/**
  * Stop this timer.
  */
DvtTimer.prototype.stop = function()
{
  if (this._bRunning)
  {
    this._bRunning = false;
    this.StopTimer();
  }
}

/**
 * Reset this timer.
 */
DvtTimer.prototype.reset = function()
{
  if (this._bRunning) {
    this.stop();
  }
  
  this._numIterations = 0;
}

/**
  * Determine if this timer is running.
  * @type boolean
  */
DvtTimer.prototype.isRunning = function()
{
  return this._bRunning;
}

/**
  * @protected
  * Handle a timer tick.
  */
DvtTimer.prototype.HandleTimer = function()
{
  if (this._callback)
  {
    this._callback.call(this._callbackObj);
    
    if (this._repeatCount)
    {
      this._numIterations++;
      if (this._numIterations >= this._repeatCount)
      {
        this.stop();
      }
    }
  }
}

/**
  * Set the interval between timer ticks, in milliseconds.
  * @param {number}  interval  interval between timer ticks, in milliseconds
  */
DvtTimer.prototype.setInterval = function(interval)
{
  var i = interval;
  if (i < 0)
  {
    i = 0;
  }
  var oldBRunning = this._bRunning;
  if (oldBRunning)
  {
    this.stop();
  }
  this._interval = i;
  if (oldBRunning)
  {
    this.start();
  }
}

/**
  * Get the interval between timer ticks.
  * @type number
  */
DvtTimer.prototype.getInterval = function()
{
  return this._interval;
}

/**
 * Starts the internal timer implementation.  Called when the timer is started.
 * @protected
 */
DvtTimer.prototype.StartTimer = function()
{
  var timer = this;
  var timerCallback = this.HandleTimer;
  this._timerId = window.setInterval(function() {timerCallback.call(timer)}, this.getInterval());
}

/**
 * Stops the internal timer implementation.  Called when the timer is stopped.
 * @protected
  */
DvtTimer.prototype.StopTimer = function()
{
  if (this._timerId)
  {
    window.clearInterval(this._timerId);
    this._timerId = null;
  }
}
// Copyright (c) 2011, 2013, Oracle and/or its affiliates. 
// All rights reserved. 
/**
  * Abstract base class representing an animation.
  * @extends DvtPlayable
  * @class DvtBaseAnimation
  * @constructor
  * 
  * @param {DvtContext}  context  platform specific context object
  * @param objs  a single DvtContainer or Array of DvtContainers to animate
  * @param {number}  duration  length of animation, in seconds
  * @param {number}  delay  time to delay start of animation, in seconds
  */
var DvtBaseAnimation = function(context, objs, duration, delay)
{
  this.Init(context, objs, duration, delay);
};

DvtObj.createSubclass(DvtBaseAnimation, DvtPlayable, "DvtBaseAnimation");

/**
  * Easing: linear.
  */
DvtBaseAnimation.EASING_LINEAR = 1;
/**
  * Easing: cubic in and out.
  */
DvtBaseAnimation.EASING_CUBIC_IN_OUT = 2;
/**
  * Easing: cubic in.
  */
DvtBaseAnimation.EASING_CUBIC_IN = 3;
/**
  * Easing: cubic out.
  */
DvtBaseAnimation.EASING_CUBIC_OUT = 4;
/**
  * Easing: quadratic in and out.
  */
DvtBaseAnimation.EASING_QUADRATIC_IN_OUT = 5;
/**
  * Easing: quadratic in.
  */
DvtBaseAnimation.EASING_QUADRATIC_IN = 6;
/**
  * Easing: quadratic out.
  */
DvtBaseAnimation.EASING_QUADRATIC_OUT = 7;
/**
  * Easing: bounce in.
  */
DvtBaseAnimation.EASING_BOUNCE_IN = 8;
/**
  * Easing: bounce out.
  */
DvtBaseAnimation.EASING_BOUNCE_OUT = 9;
/**
  * Easing: elastic in.
  */
DvtBaseAnimation.EASING_ELASTIC_IN = 10;
/**
  * Easing: elastic out.
  */
DvtBaseAnimation.EASING_ELASTIC_OUT = 11;

/**
  * Direction: center.
  */
DvtBaseAnimation.DIR_C = 1;
/**
  * Direction: north.
  */
DvtBaseAnimation.DIR_N = 2;
/**
  * Direction: northeast.
  */
DvtBaseAnimation.DIR_NE = 3;
/**
  * Direction: east.
  */
DvtBaseAnimation.DIR_E = 4;
/**
  * Direction: southeast.
  */
DvtBaseAnimation.DIR_SE = 5;
/**
  * Direction: south.
  */
DvtBaseAnimation.DIR_S = 6;
/**
  * Direction: southwest.
  */
DvtBaseAnimation.DIR_SW = 7;
/**
  * Direction: west.
  */
DvtBaseAnimation.DIR_W = 8;
/**
  * Direction: northwest.
  */
DvtBaseAnimation.DIR_NW = 9;

//axis constants
/**
 * Axis: x-axis
 */
DvtBaseAnimation.AXIS_X = 1;
/**
 * Axis: y-axis
 */
DvtBaseAnimation.AXIS_Y = 2;

//rotation directions
/**
 * Rotation direction: clockwise
 */
DvtBaseAnimation.ROT_DIR_CLOCKWISE = 1;
/**
 * Rotation direction: counter-clockwise
 */
DvtBaseAnimation.ROT_DIR_COUNTERCLOCKWISE = 2;

/**
  * @protected
  * Get the easing function corresponding to the given constant.
  * @param easing  constant representing the easing function
  * @type function
  */
DvtBaseAnimation.GetEasingFunction = function(easing)
{
  switch (easing)
  {
    case DvtBaseAnimation.EASING_LINEAR:
      return DvtEasing.linear;
    case DvtBaseAnimation.EASING_CUBIC_IN:
      return DvtEasing.cubicIn;
    case DvtBaseAnimation.EASING_CUBIC_OUT:
      return DvtEasing.cubicOut;
    case DvtBaseAnimation.EASING_QUADRATIC_IN_OUT:
      return DvtEasing.quadraticInOut;
    case DvtBaseAnimation.EASING_QUADRATIC_IN:
      return DvtEasing.quadraticIn;
    case DvtBaseAnimation.EASING_QUADRATIC_OUT:
      return DvtEasing.quadraticOut;
    case DvtBaseAnimation.EASING_BOUNCE_IN:
      return DvtEasing.backIn;
    case DvtBaseAnimation.EASING_BOUNCE_OUT:
      return DvtEasing.backOut;
    case DvtBaseAnimation.EASING_ELASTIC_IN:
      return DvtEasing.elasticIn;
    case DvtBaseAnimation.EASING_ELASTIC_OUT:
      return DvtEasing.elasticOut;
    case DvtBaseAnimation.EASING_CUBIC_IN_OUT:
    default:
      return DvtEasing.cubicInOut;
  }
};

/**
  * @protected
  * Get the point corresponding to the given compass direction
  * on the given bounding box.
  * @param {DvtRectangle}  boundsRect  bounding box
  * @param direction  constant representing the compass direction
  * @type DvtPoint
  */
DvtBaseAnimation.GetCompassPoint = function(boundsRect, direction)
{
  switch (direction)
  {
    case DvtBaseAnimation.DIR_N:
      return new DvtPoint(boundsRect.x + 0.5 * boundsRect.w, boundsRect.y);
    case DvtBaseAnimation.DIR_NE:
      return new DvtPoint(boundsRect.x + boundsRect.w,      boundsRect.y);
    case DvtBaseAnimation.DIR_E:
      return new DvtPoint(boundsRect.x + boundsRect.w,      boundsRect.y + 0.5 * boundsRect.h);
    case DvtBaseAnimation.DIR_SE:
      return new DvtPoint(boundsRect.x + boundsRect.w,      boundsRect.y + boundsRect.h);
    case DvtBaseAnimation.DIR_S:
      return new DvtPoint(boundsRect.x + 0.5 * boundsRect.w, boundsRect.y + boundsRect.h);
    case DvtBaseAnimation.DIR_SW:
      return new DvtPoint(boundsRect.x,                         boundsRect.y + boundsRect.h);
    case DvtBaseAnimation.DIR_W:
      return new DvtPoint(boundsRect.x,                         boundsRect.y + 0.5 * boundsRect.h);
    case DvtBaseAnimation.DIR_NW:
      return new DvtPoint(boundsRect.x,                         boundsRect.y);
    case DvtBaseAnimation.DIR_C:
    default:
      return new DvtPoint(boundsRect.x + 0.5 * boundsRect.w, boundsRect.y + 0.5 * boundsRect.h);
  }
};

/**
  * @protected
  * Get the point to position the given object rectangle so that it aligns to the 
  * boundary rectangle in the compass direction.
  * @param {DvtRectangle}  objRect  object bounding box
  * @param {DvtRectangle}  boundsRect  bounding box
  * @param direction  constant representing the compass direction
  * @type DvtPoint
  */
DvtBaseAnimation.GetAlignCompassPoint = function(objRect, boundsRect, direction)
{
  var compassPoint = DvtBaseAnimation.GetCompassPoint(boundsRect, direction);
  var point;
  switch (direction)
  {
    case DvtBaseAnimation.DIR_N:
      return new DvtPoint(compassPoint.x - 0.5 * objRect.w, compassPoint.y);
    case DvtBaseAnimation.DIR_NE:
      return new DvtPoint(compassPoint.x - objRect.w,      compassPoint.y);
    case DvtBaseAnimation.DIR_E:
      return new DvtPoint(compassPoint.x - objRect.w,      compassPoint.y - 0.5 * objRect.h);
    case DvtBaseAnimation.DIR_SE:
      return new DvtPoint(compassPoint.x - objRect.w,      compassPoint.y - objRect.h);
    case DvtBaseAnimation.DIR_S:
      return new DvtPoint(compassPoint.x - 0.5 * objRect.w, compassPoint.y - objRect.h);
    case DvtBaseAnimation.DIR_SW:
      return new DvtPoint(compassPoint.x,                      compassPoint.y - objRect.h);
    case DvtBaseAnimation.DIR_W:
      return new DvtPoint(compassPoint.x,                      compassPoint.y - 0.5 * objRect.h);
    case DvtBaseAnimation.DIR_NW:
      return new DvtPoint(compassPoint.x,                      compassPoint.y);
    case DvtBaseAnimation.DIR_C:
    default:
      return new DvtPoint(compassPoint.x - 0.5 * objRect.w, compassPoint.y - 0.5 * objRect.h);
  }
};

/**
  * @protected
  * @override
  */
DvtBaseAnimation.prototype.Init = function(context, objs, duration, delay)
{
  DvtBaseAnimation.superclass.Init.call(this, context);
  
  this._context = context;
  
  if (objs instanceof Array)
  {
    this._arObjects = objs;
  }
  else
  {
    this._arObjects = [objs];
  }
  
  this._duration = (duration ? duration : .5);
  this._delay = (delay ? delay : 0);
  this._easing = DvtBaseAnimation.EASING_CUBIC_IN_OUT;
  this._bInitialized = false;
  
  this._bSaveAndRestoreOriginalMatrices = false;
  this._origMatrixArray = null;
  this._bHideObjectsOnEnd = false;
  
  this.CreateAnimator(context);
};

/**
  * @protected
  * Get the platform dependent context object.
  * @type DvtContext
  */
DvtBaseAnimation.prototype.GetContext = function()
{
  return this._context;
};

/**
 * Determine if this animation is running.
 * @type boolean
 */
DvtBaseAnimation.prototype.isRunning = function()
{
  if (this._animator) {
    return this._animator.isRunning();
  }
  return false;
};

/**
  * @override
  */
DvtBaseAnimation.prototype.play = function()
{
  if (!this._bInitialized)
  {
    //initialize the desired end results of the animation before the start
    //states because the end results may depend on the object states
    //before the start states are applied
    this.InitializeEndStates(this._arObjects);
    //initialize the display objects appropriately for the start of the animation
    this.InitializeStartStates(this._arObjects);
    
    this.InitializePlay();
    
    this._bInitialized = true;
  }
  
  if (this._animator)
    this._animator.play();
};

/**
  * @override
  */
DvtBaseAnimation.prototype.stop = function(bJumpToEnd)
{
  if (this._animator)
    this._animator.stop(bJumpToEnd);
};

/**
  * @override
  */
DvtBaseAnimation.prototype.pause = function()
{
  if (this._animator)
    this._animator.pause();
};

/**
  * Get the duration of this animation, in seconds.
  * @type number
  */
DvtBaseAnimation.prototype.getDuration = function()
{
  return this._duration;
};

/**
  * Set the duration of this animation.
  * @param {number}  duration  duration of this animation, in seconds
  */
DvtBaseAnimation.prototype.setDuration = function(duration)
{
  this._duration = (duration ? duration : 0);
  
  if (this._animator)
    this._animator.setDuration(this._duration);
};

/**
  * Get the delay for the start of this animation, in seconds.
  * @type number
  */
DvtBaseAnimation.prototype.getDelay = function()
{
  return this._delay;
};

/**
  * Set the delay for the start of this animation.
  * @param {number}  delay  delay for the start of this animation, in seconds
  */
DvtBaseAnimation.prototype.setDelay = function(delay)
{
  this._delay = (delay ? delay : 0);
  
  if (this._animator)
    this._animator.setDelay(this._delay);
};

/**
  * Get the easing function for this animation.
  * Returns one of the EASING_ constants defined on DvtBaseAnimation.
  */
DvtBaseAnimation.prototype.getEasing = function()
{
  return this._easing;
};

/**
  * Set the easing function for this animation.
  * @param  easing  one of the EASING_ constants defined on DvtBaseAnimation
  */
DvtBaseAnimation.prototype.setEasing = function(easing)
{
  this._easing = easing;
  
  if (this._animator)
    this._animator.setEasing(DvtBaseAnimation.GetEasingFunction(this._easing));
};

/**
  * @protected
  * Create the underlying animator used by this animation.
  * @param {DvtContext}  context  platform specific context object
  */
DvtBaseAnimation.prototype.CreateAnimator = function(context)
{
  this._animator = new DvtAnimator(context, this._duration, this._delay, DvtBaseAnimation.GetEasingFunction(this._easing));
  this._animator.setOnEnd(this.OnAnimEnd, this);
};

/**
  * @protected
  * Called when the underlying animator ends.
  */
DvtBaseAnimation.prototype.OnAnimEnd = function()
{
  //hide objects first
  if (this._bHideObjectsOnEnd)
  {
    this.HideObjects();
  }
  
  //restore original transforms after hiding objects
  if (this._bSaveAndRestoreOriginalMatrices)
  {
    this.RestoreOriginalMatrices();
  }
  
  //call external onEnd func after any internal cleanup
  if (this._onEnd)
  {
    this._onEnd.call(this._onEndObj);
  }
};

/**
  * @protected
  * Called when play is called.
  */
DvtBaseAnimation.prototype.InitializePlay = function()
{
  //for subclasses to implement
};

/**
  * @protected
  * Called when play is called to initialize the start states of
  * the objects being animated.
  * @param {array}  arObjects  array of objects being animated
  */
DvtBaseAnimation.prototype.InitializeStartStates = function(arObjects)
{
  if (arObjects)
  {
    var obj;
    for (var i = 0; i < arObjects.length; i++)
    {
      obj = arObjects[i];
      if (obj)
      {
        if (this._bSaveAndRestoreOriginalMatrices)
        {
          if (!this._origMatrixArray)
          {
            this._origMatrixArray = [];
          }
          
          this._origMatrixArray.push(obj.getMatrix());
        }
        
        this.InitStartState(obj);
      }
    }
  }
};

/**
  * @protected
  * Called when play is called to initialize the end states of
  * the objects being animated.
  * @param {array}  arObjects  array of objects being animated
  */
DvtBaseAnimation.prototype.InitializeEndStates = function(arObjects)
{
  if (arObjects)
  {
    var obj;
    for (var i = 0; i < arObjects.length; i++)
    {
      obj = arObjects[i];
      if (obj)
      {
        this.InitEndState(obj);
      }
    }
  }
};

/**
  * @protected
  * Initialize the start state of the given object being animated.
  * @param {object}  obj  object being animated
  */
DvtBaseAnimation.prototype.InitStartState = function(obj)
{
  //subclasses must implement
};

/**
  * @protected
  * Initialize the end state of the given object being animated.
  * @param {object}  obj  object being animated
  */
DvtBaseAnimation.prototype.InitEndState = function(obj)
{
  //subclasses must implement
};

/**
  * @protected
  * Set objects to be visible.  
  */
DvtBaseAnimation.prototype.ShowObjects = function()
{
  this.SetObjectsVisible(true);
};

/**
  * @protected
  * Set objects to be hidden.
  */
DvtBaseAnimation.prototype.HideObjects = function()
{
  this.SetObjectsVisible(false);
};

/**
 * @protected
 * Set visibility of objects.
 * 
 * @param {boolean}  bVisible  true to show, false to hide
 */
DvtBaseAnimation.prototype.SetObjectsVisible = function(bVisible)
{
  if (this._arObjects)
  {
    var obj;
    for (var i = this._arObjects.length - 1; i >= 0; i--)
    {
      obj = this._arObjects[i];
      if (obj)
      {
        obj.setVisible(bVisible);
      }
    }
  }
};

/**
  * @protected
  * Restore objects' original matrices as they were before animation.
  */
DvtBaseAnimation.prototype.RestoreOriginalMatrices = function()
{
  if (this._arObjects)
  {
    var obj;
    for (var i = this._arObjects.length - 1; i >= 0; i--)
    {
      obj = this._arObjects[i];
      if (obj)
      {
        if (this._origMatrixArray)
        {
          obj.setMatrix(this._origMatrixArray.pop());
        }
      }
    }
  }
};
// Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved. 
/**
 * Class providing the ability to create a custom animation using a DvtAnimator.
 * @param {DvtContext} context The platform specific context object.
 * @param {obj} obj The object to animate.
 * @param {number} duration The length of animation, in seconds.
 * @param {number} delay The time to delay start of animation, in seconds.
 * @extends DvtBaseAnimation
 * @class DvtSunburstAnimation
 * @constructor
 */
var DvtCustomAnimation = function(context, obj, duration, delay)
{
  this.Init(context, obj, duration, delay);
};

DvtObj.createSubclass(DvtCustomAnimation, DvtBaseAnimation, "DvtCustomAnimation");

/**
 * Returns the animator, which can be used to add animated properties.
 * @return {DvtAnimator} The animator for this animation.
 */
DvtCustomAnimation.prototype.getAnimator = function()
{
  return this._animator;
};
// Copyright (c) 2011, 2013, Oracle and/or its affiliates. 
// All rights reserved. 
/**
  * Class representing an animation to move an object into view as 
  * if on a conveyor belt.  The object will in from the background on 
  * its side and then rotate to face forward.
  * @extends DvtBaseAnimation
  * @class DvtAnimConveyorIn
  * @constructor
  * 
  * @param {DvtContext}  context  platform specific context object
  * @param objs  a single DvtContainer or Array of DvtContainers to animate
  * @param direction compass direction to move display objects in from; 
  *        can be one of: DIR_N, DIR_E, DIR_S, DIR_W
  * @param {number}  duration  length of animation, in seconds
  * @param {number}  delay  time to delay start of animation, in seconds
  */
var DvtAnimConveyorIn = function(context, objs, direction, duration, delay)
{
  this.Init(context, objs, direction, duration, delay);
};

DvtObj.createSubclass(DvtAnimConveyorIn, DvtBaseAnimation, "DvtAnimConveyorIn");

/**
  * @protected
  * @override
  */
DvtAnimConveyorIn.prototype.Init = function(context, objs, direction, duration, delay)
{
  DvtAnimConveyorIn.superclass.Init.call(this, context, objs, duration, delay);
  
  this._direction = direction;
  
  this._SCALE = .2;
  this._SKEW_ANGLE = Math.PI / 12;
  
  this._bSaveAndRestoreOriginalMatrices = true;
};

/**
  * @protected
  * @override
  */
DvtAnimConveyorIn.prototype.CreateAnimator = function(context)
{
  DvtAnimConveyorIn.superclass.CreateAnimator.call(this, context);
  
  this.setEasing(DvtBaseAnimation.EASING_CUBIC_IN);
  this._animator.setDuration(this.getDuration() / 2);
  this._animator.setOnEnd(this.PlayEndAnim, this);
  
  this._endAnim = new DvtAnimator(context, this.getDuration() / 2, 0, DvtBaseAnimation.GetEasingFunction(DvtBaseAnimation.EASING_CUBIC_OUT));
  this._endAnim.setOnEnd(this.OnAnimEnd, this);
};

/**
  * @protected
  * @override
  */
DvtAnimConveyorIn.prototype.InitializePlay = function()
{
  DvtAnimConveyorIn.superclass.InitializePlay.call(this);
  
  this.ShowObjects();
};

/**
  * @protected
  * @override
  */
DvtAnimConveyorIn.prototype.InitStartState = function(obj)
{
  DvtAnimConveyorIn.superclass.InitStartState.call(this, obj);
  
  obj.setVisible(false);
  
  //rotate first
  var scale = this._SCALE;
  var diffScale = 1 - scale;
  
  var bounds = obj.getDimensions();
  var halfWidth = bounds.w * diffScale;
  var halfHeight = bounds.h * diffScale;
  
  var mat = this.GetConcatenatedRotationMatrix(obj, bounds);
  
  //slide into background after
  var mat2 = new DvtMatrix();
  if (this._direction === DvtBaseAnimation.DIR_W ||
      this._direction === DvtBaseAnimation.DIR_E)
  {
    if (this._direction === DvtBaseAnimation.DIR_W)
    {
      mat2.translate(bounds.w, 0);
    }
    else
    {
      mat2.translate(-bounds.w, 0);
    }
  }
  else
  {
    if (this._direction === DvtBaseAnimation.DIR_N)
    {
      mat2.translate(0, bounds.h);
    }
    else
    {
      mat2.translate(0, -bounds.h);
    }
  }
  mat2.concat(mat);
  obj.setMatrix(mat2);
  obj.setAlpha(0);
};

/**
  * @protected
  * @override
  */
DvtAnimConveyorIn.prototype.InitEndState = function(obj)
{
  DvtAnimConveyorIn.superclass.InitEndState.call(this, obj);
  
  var bounds = obj.getDimensions();
  
  //slide into foreground first
  var concatRotMat = this.GetConcatenatedRotationMatrix(obj, bounds);
  this._animator.addProp(DvtAnimator.TYPE_MATRIX, obj, obj.getMatrix, obj.setMatrix, concatRotMat);
  this._animator.addProp(DvtAnimator.TYPE_NUMBER, obj, obj.getAlpha, obj.setAlpha, 1);
  
  //rotate after
  var currMat = obj.getMatrix();
  this._endAnim.addProp(DvtAnimator.TYPE_MATRIX, obj, obj.getMatrix, obj.setMatrix, currMat);
};

/**
  * @protected
  * Play the end animation, which rotates the object to face forward again.
  */
DvtAnimConveyorIn.prototype.PlayEndAnim = function()
{
  this._endAnim.play();
};

/**
  * @protected
  * Get the concatenation of the rotation matrix with the current matrix.
  * 
  * @param  obj  display object being animated
  * @param {DvtRectangle}  bounds  bounding box for the object
  * @type DvtMatrix
  */
DvtAnimConveyorIn.prototype.GetConcatenatedRotationMatrix = function(obj, bounds)
{
  var scale = this._SCALE;
  var diffScale = 1 - scale;
  
  var halfWidth = bounds.w * diffScale;
  var halfHeight = bounds.h * diffScale;
  
  var skewAngle = this._SKEW_ANGLE;
  if (this._direction === DvtBaseAnimation.DIR_W ||
      this._direction === DvtBaseAnimation.DIR_S)
  {
    skewAngle = -skewAngle;
  }
  var tanAngle = Math.tan(skewAngle);
  
  var currMat = obj.getMatrix();
  var mat = new DvtMatrix();
  if (this._direction === DvtBaseAnimation.DIR_W ||
      this._direction === DvtBaseAnimation.DIR_E)
  {
    mat.skew(0, skewAngle);
    mat.scale(scale, 1);
    if (this._direction === DvtBaseAnimation.DIR_W)
    {
      mat.translate(0, 0);
    }
    else
    {
      mat.translate(halfWidth, -bounds.w * tanAngle);
    }
  }
  else
  {
    mat.skew(skewAngle, 0);
    mat.scale(1, scale);
    if (this._direction === DvtBaseAnimation.DIR_N)
    {
      mat.translate(0, 0);
    }
    else
    {
      mat.translate(-bounds.h * tanAngle, halfHeight);
    }
  }
  mat.concat(currMat);
  return mat;
};
// Copyright (c) 2011, 2013, Oracle and/or its affiliates. 
// All rights reserved. 
/**
  * Class representing an animation to move an object out of view as 
  * if on a conveyor belt.  The object will rotate onto its side and 
  * slide into the background.  
  * @extends DvtBaseAnimation
  * @class DvtAnimConveyorOut
  * @constructor
  * 
  * @param {DvtContext}  context  platform specific context object
  * @param objs  a single DvtContainer or Array of DvtContainers to animate
  * @param direction compass direction to move display objects out; 
  *        can be one of: DIR_N, DIR_E, DIR_S, DIR_W
  * @param {number}  duration  length of animation, in seconds
  * @param {number}  delay  time to delay start of animation, in seconds
  */
var DvtAnimConveyorOut = function(context, objs, direction, duration, delay)
{
  this.Init(context, objs, direction, duration, delay);
};

DvtObj.createSubclass(DvtAnimConveyorOut, DvtBaseAnimation, "DvtAnimConveyorOut");

/**
  * @protected
  * @override
  */
DvtAnimConveyorOut.prototype.Init = function(context, objs, direction, duration, delay)
{
  DvtAnimConveyorOut.superclass.Init.call(this, context, objs, duration, delay);
  
  this._direction = direction;
  
  this._bSaveAndRestoreOriginalMatrices = true;
  this._bHideObjectsOnEnd = true;
};

/**
  * @protected
  * @override
  */
DvtAnimConveyorOut.prototype.CreateAnimator = function(context)
{
  DvtAnimConveyorOut.superclass.CreateAnimator.call(this, context);
  
  this.setEasing(DvtBaseAnimation.EASING_CUBIC_IN);
  this._animator.setDuration(this.getDuration() / 2);
  this._animator.setOnEnd(this.PlayEndAnim, this);
  
  this._endAnim = new DvtAnimator(context, this.getDuration() / 2, 0, DvtBaseAnimation.GetEasingFunction(DvtBaseAnimation.EASING_CUBIC_OUT));
  this._endAnim.setOnEnd(this.OnAnimEnd, this);
};

/**
  * @protected
  * @override
  */
DvtAnimConveyorOut.prototype.InitEndState = function(obj)
{
  DvtAnimConveyorOut.superclass.InitEndState.call(this, obj);
  
  //rotate first
  var scale = .2;
  var diffScale = 1 - scale;
  
  var bounds = obj.getDimensions();
  var halfWidth = bounds.w * diffScale;
  var halfHeight = bounds.h * diffScale;
  
  var skewAngle = Math.PI / 12;
  if (this._direction === DvtBaseAnimation.DIR_W ||
      this._direction === DvtBaseAnimation.DIR_S)
  {
    skewAngle = -skewAngle;
  }
  var tanAngle = Math.tan(skewAngle);
  
  var currMat = obj.getMatrix();
  var mat = new DvtMatrix();
  if (this._direction === DvtBaseAnimation.DIR_W ||
      this._direction === DvtBaseAnimation.DIR_E)
  {
    mat.skew(0, skewAngle);
    mat.scale(scale, 1);
    if (this._direction === DvtBaseAnimation.DIR_W)
    {
      mat.translate(0, 0);
    }
    else
    {
      mat.translate(halfWidth, -bounds.w * tanAngle);
    }
  }
  else
  {
    mat.skew(skewAngle, 0);
    mat.scale(1, scale);
    if (this._direction === DvtBaseAnimation.DIR_N)
    {
      mat.translate(0, 0);
    }
    else
    {
      mat.translate(-bounds.h * tanAngle, halfHeight);
    }
  }
  mat.concat(currMat);
  this._animator.addProp(DvtAnimator.TYPE_MATRIX, obj, obj.getMatrix, obj.setMatrix, mat);
  
  //slide into background after
  var mat2 = new DvtMatrix();
  if (this._direction === DvtBaseAnimation.DIR_W ||
      this._direction === DvtBaseAnimation.DIR_E)
  {
    if (this._direction === DvtBaseAnimation.DIR_W)
    {
      mat2.translate(bounds.w, 0);
    }
    else
    {
      mat2.translate(-bounds.w, 0);
    }
  }
  else
  {
    if (this._direction === DvtBaseAnimation.DIR_N)
    {
      mat2.translate(0, bounds.h);
    }
    else
    {
      mat2.translate(0, -bounds.h);
    }
  }
  mat2.concat(mat);
  this._endAnim.addProp(DvtAnimator.TYPE_MATRIX, obj, obj.getMatrix, obj.setMatrix, mat2);
  this._endAnim.addProp(DvtAnimator.TYPE_NUMBER, obj, obj.getAlpha, obj.setAlpha, 0);
};

/**
  * @protected
  * Play the end animation, which slides the object into the background.
  */
DvtAnimConveyorOut.prototype.PlayEndAnim = function()
{
  this._endAnim.play();
};
// Copyright (c) 2011, 2013, Oracle and/or its affiliates. 
// All rights reserved. 
/**
  * Class representing an animation to flip an object into view,
  * as if flipping a playing card.
  * @extends DvtBaseAnimation
  * @class DvtAnimFlipIn
  * @constructor
  * 
  * @param {DvtContext}  context  platform specific context object
  * @param objs  a single DvtContainer or Array of DvtContainers to animate
  * @param axis axis of rotation; can be one of: AXIS_X, AXIS_Y
  * @param rotationDir direction of rotation about the axis; can be one of:
  *        ROT_DIR_CLOCKWISE, ROT_DIR_COUNTERCLOCKWISE;
  *        direction is determined by looking down the axis from the positive side
  * @param {number}  duration  length of animation, in seconds
  * @param {number}  delay  time to delay start of animation, in seconds
  */
var DvtAnimFlipIn = function(context, objs, axis, rotationDir, duration, delay)
{
  this.Init(context, objs, axis, rotationDir, duration, delay);
};

DvtObj.createSubclass(DvtAnimFlipIn, DvtBaseAnimation, "DvtAnimFlipIn");

/**
  * @protected
  * @override
  */
DvtAnimFlipIn.prototype.Init = function(context, objs, axis, rotationDir, duration, delay)
{
  DvtAnimFlipIn.superclass.Init.call(this, context, objs, duration, delay);
  
  this._axis = axis;
  this._rotationDir = rotationDir;
  
  this._bSaveAndRestoreOriginalMatrices = true;
  this._cubeEffect = false;
};

/**
  * @protected
  * @override
  */
DvtAnimFlipIn.prototype.InitStartState = function(obj)
{
  DvtAnimFlipIn.superclass.InitStartState.call(this, obj);
  
  obj.setVisible(false);
  
  var bounds = obj.getDimensions();
  var halfWidth = bounds.w / 2;
  var halfHeight = bounds.h / 2;
  
  var skewAngle = Math.PI / 6;
  if (this._rotationDir === DvtBaseAnimation.ROT_DIR_COUNTERCLOCKWISE)
  {
    skewAngle = -skewAngle;
  }
  var tanAngle = Math.tan(skewAngle);
  
  var currMat = obj.getMatrix();
  var mat = new DvtMatrix();
  if (this._axis === DvtBaseAnimation.AXIS_Y)
  {
    mat.skew(0, skewAngle);
    mat.scale(0, 1);
    if (this._cubeEffect)
    {
      if (this._rotationDir === DvtBaseAnimation.ROT_DIR_COUNTERCLOCKWISE)
      {
        mat.translate(bounds.w, 0);
      }
      else
      {
        mat.translate(0, -bounds.w * tanAngle);
      }
    }
    else
    {
      mat.translate(halfWidth, -halfWidth * tanAngle);
    }
  }
  else
  {
    mat.skew(skewAngle, 0);
    mat.scale(1, 0);
    if (this._cubeEffect)
    {
      if (this._rotationDir === DvtBaseAnimation.ROT_DIR_COUNTERCLOCKWISE)
      {
        mat.translate(-bounds.h *tanAngle, 0);
      }
      else
      {
        mat.translate(0, bounds.h);
      }
    }
    else
    {
      mat.translate(-halfHeight * tanAngle, halfHeight);
    }
  }
  mat.concat(currMat);
  obj.setMatrix(mat);
  
  if (this._cubeEffect)
  {
    obj.setAlpha(0);
  }
};

/**
  * @protected
  * @override
  */
DvtAnimFlipIn.prototype.InitEndState = function(obj)
{
  DvtAnimFlipIn.superclass.InitEndState.call(this, obj);
  
  var currMat = obj.getMatrix();
  this._animator.addProp(DvtAnimator.TYPE_MATRIX, obj, obj.getMatrix, obj.setMatrix, currMat);
  
  if (this._cubeEffect)
  {
    this._animator.addProp(DvtAnimator.TYPE_NUMBER, obj, obj.getAlpha, obj.setAlpha, 1);
  }
};

/**
  * @protected
  * @override
  */
DvtAnimFlipIn.prototype.InitializePlay = function()
{
  DvtAnimFlipIn.superclass.InitializePlay.call(this);
  
  this.ShowObjects();
};
// Copyright (c) 2011, 2013, Oracle and/or its affiliates. 
// All rights reserved. 
/**
  * Class representing an animation to flip an object out of view,
  * as if flipping a playing card.
  * @extends DvtBaseAnimation
  * @class DvtAnimFlipOut
  * @constructor
  * 
  * @param {DvtContext}  context  platform specific context object
  * @param objs  a single DvtContainer or Array of DvtContainers to animate
  * @param axis axis of rotation; can be one of: AXIS_X, AXIS_Y
  * @param rotationDir direction of rotation about the axis; can be one of:
  *        ROT_DIR_CLOCKWISE, ROT_DIR_COUNTERCLOCKWISE;
  *        direction is determined by looking down the axis from the positive side
  * @param {number}  duration  length of animation, in seconds
  * @param {number}  delay  time to delay start of animation, in seconds
  */
var DvtAnimFlipOut = function(context, objs, axis, rotationDir, duration, delay)
{
  this.Init(context, objs, axis, rotationDir, duration, delay);
};

DvtObj.createSubclass(DvtAnimFlipOut, DvtBaseAnimation, "DvtAnimFlipOut");

/**
  * @protected
  * @override
  */
DvtAnimFlipOut.prototype.Init = function(context, objs, axis, rotationDir, duration, delay)
{
  DvtAnimFlipOut.superclass.Init.call(this, context, objs, duration, delay);
  
  this._axis = axis;
  this._rotationDir = rotationDir;
  
  this._bSaveAndRestoreOriginalMatrices = true;
  this._bHideObjectsOnEnd = true;
  this._cubeEffect = false;
};

/**
  * @protected
  * @override
  */
DvtAnimFlipOut.prototype.InitEndState = function(obj)
{
  DvtAnimFlipOut.superclass.InitEndState.call(this, obj);
  
  var bounds = obj.getDimensions();
  var halfWidth = bounds.w / 2;
  var halfHeight = bounds.h / 2;
  
  var skewAngle = Math.PI / 6;
  if (this._rotationDir === DvtBaseAnimation.ROT_DIR_CLOCKWISE)
  {
    skewAngle = -skewAngle;
  }
  var tanAngle = Math.tan(skewAngle);
  
  var currMat = obj.getMatrix();
  var mat = new DvtMatrix();
  if (this._axis === DvtBaseAnimation.AXIS_Y)
  {
    mat.skew(0, skewAngle);
    mat.scale(0, 1);
    if (this._cubeEffect)
    {
      if (this._rotationDir === DvtBaseAnimation.ROT_DIR_CLOCKWISE)
      {
        mat.translate(bounds.w, 0);
      }
      else
      {
        mat.translate(0, -bounds.w * tanAngle);
      }
    }
    else
    {
      mat.translate(halfWidth, -halfWidth * tanAngle);
    }
  }
  else
  {
    mat.skew(skewAngle, 0);
    mat.scale(1, 0);
    if (this._cubeEffect)
    {
      if (this._rotationDir === DvtBaseAnimation.ROT_DIR_CLOCKWISE)
      {
        mat.translate(-bounds.h *tanAngle, 0);
      }
      else
      {
        mat.translate(0, bounds.h);
      }
    }
    else
    {
      mat.translate(-halfHeight * tanAngle, halfHeight);
    }
  }
  mat.concat(currMat);
  this._animator.addProp(DvtAnimator.TYPE_MATRIX, obj, obj.getMatrix, obj.setMatrix, mat);
  
  if (this._cubeEffect)
  {
    this._animator.addProp(DvtAnimator.TYPE_NUMBER, obj, obj.getAlpha, obj.setAlpha, 0);
  }
};
// Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved. 
/**
  * Class representing an animation to rotate an object into view,
  * as if rotating a cube.
  * @extends DvtAnimFlipIn
  * @class DvtAnimCubeIn
  * @constructor
  * 
  * @param {DvtContext}  context  platform specific context object
  * @param objs  a single DvtContainer or Array of DvtContainers to animate
  * @param axis axis of rotation; can be one of: AXIS_X, AXIS_Y
  * @param rotationDir direction of rotation about the axis; can be one of:
  *        ROT_DIR_CLOCKWISE, ROT_DIR_COUNTERCLOCKWISE;
  *        direction is determined by looking down the axis from the positive side
  * @param {number}  duration  length of animation, in seconds
  * @param {number}  delay  time to delay start of animation, in seconds
  */
var DvtAnimCubeIn = function(context, objs, axis, rotationDir, duration, delay)
{
  this.Init(context, objs, axis, rotationDir, duration, delay);
};

DvtObj.createSubclass(DvtAnimCubeIn, DvtAnimFlipIn, "DvtAnimCubeIn");

/**
  * @protected
  * @override
  */
DvtAnimCubeIn.prototype.Init = function(context, objs, axis, rotationDir, duration, delay)
{
  DvtAnimCubeIn.superclass.Init.call(this, context, objs, axis, rotationDir, duration, delay);
  
  this._cubeEffect = true;
};
// Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved. 
/**
  * Class representing an animation to rotate an object out of view,
  * as if rotating a cube.
  * @extends DvtAnimFlipOut
  * @class DvtAnimCubeOut
  * @constructor
  * 
  * @param {DvtContext}  context  platform specific context object
  * @param objs  a single DvtContainer or Array of DvtContainers to animate
  * @param axis axis of rotation; can be one of: AXIS_X, AXIS_Y
  * @param rotationDir direction of rotation about the axis; can be one of:
  *        ROT_DIR_CLOCKWISE, ROT_DIR_COUNTERCLOCKWISE;
  *        direction is determined by looking down the axis from the positive side
  * @param {number}  duration  length of animation, in seconds
  * @param {number}  delay  time to delay start of animation, in seconds
  */
var DvtAnimCubeOut = function(context, objs, axis, rotationDir, duration, delay)
{
  this.Init(context, objs, axis, rotationDir, duration, delay);
};

DvtObj.createSubclass(DvtAnimCubeOut, DvtAnimFlipOut, "DvtAnimCubeOut");

/**
  * @protected
  * @override
  */
DvtAnimCubeOut.prototype.Init = function(context, objs, axis, rotationDir, duration, delay)
{
  DvtAnimCubeOut.superclass.Init.call(this, context, objs, axis, rotationDir, duration, delay);
  
  this._cubeEffect = true;
};
// Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved. 
/**
  * Class representing an animation to fade in an object.
  * @extends DvtBaseAnimation
  * @class DvtAnimFadeIn
  * @constructor
  * 
  * @param {DvtContext}  context  platform specific context object
  * @param objs  a single DvtContainer or Array of DvtContainers to animate
  * @param {number}  duration  length of animation, in seconds
  * @param {number}  delay  time to delay start of animation, in seconds
  */
var DvtAnimFadeIn = function(context, objs, duration, delay)
{
  this.Init(context, objs, duration, delay);
};

DvtObj.createSubclass(DvtAnimFadeIn, DvtBaseAnimation, "DvtAnimFadeIn");

/**
  * @protected
  * @override
  */
DvtAnimFadeIn.prototype.Init = function(context, objs, duration, delay)
{
  DvtAnimFadeIn.superclass.Init.call(this, context, objs, duration, delay);
};

/**
  * @protected
  * @override
  */
DvtAnimFadeIn.prototype.InitStartState = function(obj)
{
  obj.setAlpha(0);
};

/**
  * @protected
  * @override
  */
DvtAnimFadeIn.prototype.InitEndState = function(obj)
{
  this._animator.addProp(DvtAnimator.TYPE_NUMBER, obj, obj.getAlpha, obj.setAlpha, 1);
};
// Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved. 
/**
  * Class representing an animation to fade out an object.
  * @extends DvtBaseAnimation
  * @class DvtAnimFadeOut
  * @constructor
  * 
  * @param {DvtContext}  context  platform specific context object
  * @param objs  a single DvtContainer or Array of DvtContainers to animate
  * @param {number}  duration  length of animation, in seconds
  * @param {number}  delay  time to delay start of animation, in seconds
  */
var DvtAnimFadeOut = function(context, objs, duration, delay)
{
  this.Init(context, objs, duration, delay);
};

DvtObj.createSubclass(DvtAnimFadeOut, DvtBaseAnimation, "DvtAnimFadeOut");

/**
  * @protected
  * @override
  */
DvtAnimFadeOut.prototype.Init = function(context, objs, duration, delay)
{
  DvtAnimFadeOut.superclass.Init.call(this, context, objs, duration, delay);
};

/**
  * @protected
  * @override
  */
DvtAnimFadeOut.prototype.InitEndState = function(obj)
{
  this._animator.addProp(DvtAnimator.TYPE_NUMBER, obj, obj.getAlpha, obj.setAlpha, 0);
};
// Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved. 
/**
  * Class representing an animation to transform an object by a given matrix.
  * @extends DvtBaseAnimation
  * @class DvtAnimMatrixTransformBy
  * @constructor
  * 
  * @param {DvtContext}  context  platform specific context object
  * @param objs  a single DvtContainer or Array of DvtContainers to animate
  * @param {DvtMatrix}  transformMat  the matrix to use for transforming
  * @param {number}  duration  length of animation, in seconds
  * @param {number}  delay  time to delay start of animation, in seconds
  */
var DvtAnimMatrixTransformBy = function(context, objs, transformMatrix, duration, delay)
{
  this.Init(context, objs, transformMatrix, duration, delay);
};

DvtObj.createSubclass(DvtAnimMatrixTransformBy, DvtBaseAnimation, "DvtAnimMatrixTransformBy");

/**
  * @protected
  * @override
  */
DvtAnimMatrixTransformBy.prototype.Init = function(context, objs, transformMatrix, duration, delay)
{
  this._transformMatrix = transformMatrix;
  
  DvtAnimMatrixTransformBy.superclass.Init.call(this, context, objs, duration, delay);
};

/**
  * @protected
  * @override
  */
DvtAnimMatrixTransformBy.prototype.InitEndState = function(obj)
{
  var mat = obj.getMatrix();
  if (mat)
  {
    mat = mat.clone();
    mat.concat(this._transformMatrix);
    
    this._animator.addProp(DvtAnimator.TYPE_MATRIX, obj, obj.getMatrix, obj.setMatrix, mat);
  }
};
// Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved. 
/**
  * Class representing an animation to move an object by a given amount.
  * @extends DvtBaseAnimation
  * @class DvtAnimMoveBy
  * @constructor
  * 
  * @param {DvtContext}  context  platform specific context object
  * @param objs  a single DvtContainer or Array of DvtContainers to animate
  * @param offsets  a single DvtPoint or Array of DvtPoints to move by
  * @param {number}  duration  length of animation, in seconds
  * @param {number}  delay  time to delay start of animation, in seconds
  */
var DvtAnimMoveBy = function(context, objs, offsets, duration, delay)
{
  this.Init(context, objs, offsets, duration, delay);
};

DvtObj.createSubclass(DvtAnimMoveBy, DvtBaseAnimation, "DvtAnimMoveBy");

/**
  * @protected
  * @override
  */
DvtAnimMoveBy.prototype.Init = function(context, objs, offsets, duration, delay)
{
  if (offsets instanceof Array)
  {
    this._arOffsets = offsets;
  }
  else if (offsets instanceof DvtPoint)
  {
    this._arOffsets = [offsets];
  }
  else
  {
    this._arOffsets = [new DvtPoint(0, 0)];
  }
  
  this._currIndex = 0;
  
  DvtAnimMoveBy.superclass.Init.call(this, context, objs, duration, delay);
};

/**
  * @protected
  * @override
  */
DvtAnimMoveBy.prototype.InitEndState = function(obj)
{
  var offset;
  if (this._currIndex < this._arOffsets.length)
  {
    offset = this._arOffsets[this._currIndex];
  }
  else
  {
    offset = this._arOffsets[this._arOffsets.length - 1];
  }
  
  this._animator.addProp(DvtAnimator.TYPE_NUMBER, obj, obj.getTranslateX, obj.setTranslateX, obj.getTranslateX() + offset.x);
  this._animator.addProp(DvtAnimator.TYPE_NUMBER, obj, obj.getTranslateY, obj.setTranslateY, obj.getTranslateY() + offset.y);
  
  this._currIndex++;
};
// Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved. 
/**
  * Class representing an animation to move an object to a given point.
  * @extends DvtBaseAnimation
  * @class DvtAnimMoveTo
  * @constructor
  * 
  * @param {DvtContext}  context  platform specific context object
  * @param objs  a single DvtContainer or Array of DvtContainers to animate
  * @param points  a single DvtPoint or Array of DvtPoints to move to
  * @param {number}  duration  length of animation, in seconds
  * @param {number}  delay  time to delay start of animation, in seconds
  */
var DvtAnimMoveTo = function(context, objs, points, duration, delay)
{
  this.Init(context, objs, points, duration, delay);
};

DvtObj.createSubclass(DvtAnimMoveTo, DvtBaseAnimation, "DvtAnimMoveTo");

/**
  * @protected
  * @override
  */
DvtAnimMoveTo.prototype.Init = function(context, objs, points, duration, delay)
{
  if (points instanceof Array)
  {
    this._arPoints = points;
  }
  else if (points instanceof DvtPoint)
  {
    this._arPoints = [points];
  }
  else
  {
    this._arPoints = [new DvtPoint(0, 0)];
  }
  
  this._currIndex = 0;
  
  DvtAnimMoveTo.superclass.Init.call(this, context, objs, duration, delay);
};

/**
  * @protected
  * @override
  */
DvtAnimMoveTo.prototype.InitEndState = function(obj)
{
  var point;
  if (this._currIndex < this._arPoints.length)
  {
    point = this._arPoints[this._currIndex];
  }
  else
  {
    point = this._arPoints[this._arPoints.length - 1];
  }
  
  this._animator.addProp(DvtAnimator.TYPE_NUMBER, obj, obj.getTranslateX, obj.setTranslateX, point.x);
  this._animator.addProp(DvtAnimator.TYPE_NUMBER, obj, obj.getTranslateY, obj.setTranslateY, point.y);
  
  this._currIndex++;
};
// Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved. 
/**
  * Class representing an animation to rotate an object by a given angle.
  * @extends DvtBaseAnimation
  * @class DvtAnimRotateBy
  * @constructor
  * 
  * @param {DvtContext}  context  platform specific context object
  * @param objs  a single DvtContainer or Array of DvtContainers to animate
  * @param angles  a single number or Array of numbers to rotate by, in radians
  * @param {number}  duration  length of animation, in seconds
  * @param {number}  delay  time to delay start of animation, in seconds
  */
var DvtAnimRotateBy = function(context, objs, angles, duration, delay)
{
  this.Init(context, objs, angles, duration, delay);
};

DvtObj.createSubclass(DvtAnimRotateBy, DvtBaseAnimation, "DvtAnimRotateBy");

/**
  * @protected
  * @override
  */
DvtAnimRotateBy.prototype.Init = function(context, objs, angles, duration, delay)
{
  if (angles instanceof Array)
  {
    this._arAngles = angles;
  }
  else if (typeof angles == 'number')
  {
    this._arAngles = [angles];
  }
  else
  {
    this._arAngles = [0];
  }
  
  this._currIndex = 0;
  
  DvtAnimRotateBy.superclass.Init.call(this, context, objs, duration, delay);
};

/**
  * @protected
  * @override
  */
DvtAnimRotateBy.prototype.InitEndState = function(obj)
{
  var angle;
  if (this._currIndex < this._arAngles.length)
  {
    angle = this._arAngles[this._currIndex];
  }
  else
  {
    angle = this._arAngles[this._arAngles.length - 1];
  }
  
  this._animator.addProp(DvtAnimator.TYPE_NUMBER, obj, obj.getRotation, obj.setRotation, obj.getRotation() + angle);
  
  this._currIndex++;
};
// Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved. 
/**
  * Class representing an animation to rotate an object to a given angle.
  * @extends DvtBaseAnimation
  * @class DvtAnimRotateTo
  * @constructor
  * 
  * @param {DvtContext}  context  platform specific context object
  * @param objs  a single DvtContainer or Array of DvtContainers to animate
  * @param angles  a single number or Array of numbers to rotate to, in radians
  * @param {number}  duration  length of animation, in seconds
  * @param {number}  delay  time to delay start of animation, in seconds
  */
var DvtAnimRotateTo = function(context, objs, angles, duration, delay)
{
  this.Init(context, objs, angles, duration, delay);
};

DvtObj.createSubclass(DvtAnimRotateTo, DvtBaseAnimation, "DvtAnimRotateTo");

/**
  * @protected
  * @override
  */
DvtAnimRotateTo.prototype.Init = function(context, objs, angles, duration, delay)
{
  if (angles instanceof Array)
  {
    this._arAngles = angles;
  }
  else if (typeof angles == 'number')
  {
    this._arAngles = [angles];
  }
  else
  {
    this._arAngles = [0];
  }
  
  this._currIndex = 0;
  
  DvtAnimRotateTo.superclass.Init.call(this, context, objs, duration, delay);
};

/**
  * @protected
  * @override
  */
DvtAnimRotateTo.prototype.InitEndState = function(obj)
{
  var angle;
  if (this._currIndex < this._arAngles.length)
  {
    angle = this._arAngles[this._currIndex];
  }
  else
  {
    angle = this._arAngles[this._arAngles.length - 1];
  }
  
  this._animator.addProp(DvtAnimator.TYPE_NUMBER, obj, obj.getRotation, obj.setRotation, angle);
  
  this._currIndex++;
};
// Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved. 
/**
  * Class representing an animation to scale an object by a given amount.
  * @extends DvtBaseAnimation
  * @class DvtAnimScaleBy
  * @constructor
  * 
  * @param {DvtContext}  context  platform specific context object
  * @param objs  a single DvtContainer or Array of DvtContainers to animate
  * @param scales  a single DvtPoint or Array of DvtPoints to scale by
  * @param {number}  duration  length of animation, in seconds
  * @param {number}  delay  time to delay start of animation, in seconds
  */
var DvtAnimScaleBy = function(context, objs, scales, duration, delay)
{
  this.Init(context, objs, scales, duration, delay);
};

DvtObj.createSubclass(DvtAnimScaleBy, DvtBaseAnimation, "DvtAnimScaleBy");

/**
  * @protected
  * @override
  */
DvtAnimScaleBy.prototype.Init = function(context, objs, scales, duration, delay)
{
  if (scales instanceof Array)
  {
    this._arScales = scales;
  }
  else if (scales instanceof DvtPoint)
  {
    this._arScales = [scales];
  }
  else
  {
    this._arScales = [new DvtPoint(1, 1)];
  }
  
  this._currIndex = 0;
  
  DvtAnimScaleBy.superclass.Init.call(this, context, objs, duration, delay);
};

/**
  * @protected
  * @override
  */
DvtAnimScaleBy.prototype.InitEndState = function(obj)
{
  var scale;
  if (this._currIndex < this._arScales.length)
  {
    scale = this._arScales[this._currIndex];
  }
  else
  {
    scale = this._arScales[this._arScales.length - 1];
  }
  
  this._animator.addProp(DvtAnimator.TYPE_NUMBER, obj, obj.getScaleX, obj.setScaleX, obj.getScaleX() * scale.x);
  this._animator.addProp(DvtAnimator.TYPE_NUMBER, obj, obj.getScaleY, obj.setScaleY, obj.getScaleY() * scale.y);
  
  this._currIndex++;
};
// Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved.
/**
  * Class representing an animation to move and fade in an object.  The object 
  * is moved in from the edges of a provided rectangle as it fades.  
  * The object is also scaled as it fades, so it becomes larger as it is 
  * more opaque.
  * @extends DvtAnimFadeIn
  * @class DvtAnimScaleFadeIn
  * @constructor
  * 
  * @param {DvtContext}  context  platform specific context object
  * @param objs  a single DvtContainer or Array of DvtContainers to animate
  * @param {DvtRectangle}  boundsRect  a rectangle defining the bounds for moving the object
  * @param direction  compass direction to move display object in from; 
  *        can be one of the values defined in DvtBaseAnimation:
  *        DIR_C, DIR_N, DIR_NE, DIR_E, DIR_SE, DIR_S, DIR_SW, DIR_W, DIR_NW (default is DIR_NW)
  * @param {number}  minScale  minimum scale to make the object as it starts
  * @param {number}  duration  length of animation, in seconds
  * @param {number}  delay  time to delay start of animation, in seconds
  */
var DvtAnimScaleFadeIn = function(context, objs, boundsRect, direction, minScale, duration, delay)
{
  this.Init(context, objs, boundsRect, direction, minScale, duration, delay);
};

DvtObj.createSubclass(DvtAnimScaleFadeIn, DvtAnimFadeIn, "DvtAnimScaleFadeIn");

/**
  * @protected
  * @override
  */
DvtAnimScaleFadeIn.prototype.Init = function(context, objs, boundsRect, direction, minScale, duration, delay)
{
  this._boundsRect = boundsRect;
  this._direction = (direction ? direction : DvtBaseAnimation.DIR_NW);
  this._minScale = (minScale ? minScale : 0.5);
  
  DvtAnimScaleFadeIn.superclass.Init.call(this, context, objs, duration, delay);
  
  //need to do this AFTER calling superclass Init because member will
  //initially be defined there
  this._bSaveAndRestoreOriginalMatrices = true;
};

/**
  * @protected
  * @override
  */
DvtAnimScaleFadeIn.prototype.InitStartState = function(obj)
{
  DvtAnimScaleFadeIn.superclass.InitStartState.call(this, obj);
  
  var newScaleX = this._minScale * obj.getScaleX();
  var newScaleY = this._minScale * obj.getScaleY();
  
  //move the dispObj to the edge of the bounding rect and scale it down
  var objBounds = obj.getDimensions();
  var rect = new DvtRectangle(0, 0, newScaleX * objBounds.w, newScaleY * objBounds.h);
  var point = DvtBaseAnimation.GetAlignCompassPoint(rect, this._boundsRect, this._direction);
  obj.setTranslate(point.x, point.y);
  obj.setScale(newScaleX, newScaleY);
};

/**
  * @protected
  * @override
  */
DvtAnimScaleFadeIn.prototype.InitEndState = function(obj)
{
  DvtAnimScaleFadeIn.superclass.InitEndState.call(this, obj);
  
  var currMat = obj.getMatrix();
  this._animator.addProp(DvtAnimator.TYPE_MATRIX, obj, obj.getMatrix, obj.setMatrix, currMat);
};
// Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved. 
/**
  * Class representing an animation to move and fade out an object.  The object 
  * is moved out toward the edges of a provided rectangle as it fades.  
  * The object is also scaled as it fades, so it becomes smaller as it is 
  * more transparent.
  * @extends DvtAnimFadeOut
  * @class DvtAnimScaleFadeOut
  * @constructor
  * 
  * @param {DvtContext}  context  platform specific context object
  * @param objs  a single DvtContainer or Array of DvtContainers to animate
  * @param {DvtRectangle}  boundsRect  a rectangle defining the bounds for moving the object
  * @param direction  compass direction to move display object out to; 
  *        can be one of the values defined in DvtBaseAnimation:
  *        DIR_C, DIR_N, DIR_NE, DIR_E, DIR_SE, DIR_S, DIR_SW, DIR_W, DIR_NW (default is DIR_NE)
  * @param {number}  minScale  minimum scale to make the object as it starts
  * @param {number}  duration  length of animation, in seconds
  * @param {number}  delay  time to delay start of animation, in seconds
  */
var DvtAnimScaleFadeOut = function(context, objs, boundsRect, direction, minScale, duration, delay)
{
  this.Init(context, objs, boundsRect, direction, minScale, duration, delay);
};

DvtObj.createSubclass(DvtAnimScaleFadeOut, DvtAnimFadeOut, "DvtAnimScaleFadeOut");

/**
  * @protected
  * @override
  */
DvtAnimScaleFadeOut.prototype.Init = function(context, objs, boundsRect, direction, minScale, duration, delay)
{
  this._boundsRect = boundsRect;
  this._direction = (direction ? direction : DvtBaseAnimation.DIR_NE);
  this._minScale = (minScale ? minScale : 0.5);
  
  DvtAnimScaleFadeOut.superclass.Init.call(this, context, objs, duration, delay);
  
  //need to do this AFTER calling superclass Init because member will
  //initially be defined there
  this._bSaveAndRestoreOriginalMatrices = true;
};

/**
  * @protected
  * @override
  */
DvtAnimScaleFadeOut.prototype.InitEndState = function(obj)
{
  DvtAnimScaleFadeOut.superclass.InitEndState.call(this, obj);
  
  var newScaleX = this._minScale * obj.getScaleX();
  var newScaleY = this._minScale * obj.getScaleY();
  
  //move the dispObj to the edge of the bounding rect and scale it down
  var objBounds = obj.getDimensions();
  var rect = new DvtRectangle(0, 0, newScaleX * objBounds.w, newScaleY * objBounds.h);
  var point = DvtBaseAnimation.GetAlignCompassPoint(rect, this._boundsRect, this._direction);
  
  this._animator.addProp(DvtAnimator.TYPE_NUMBER, obj, obj.getScaleX, obj.setScaleX, newScaleX);
  this._animator.addProp(DvtAnimator.TYPE_NUMBER, obj, obj.getScaleY, obj.setScaleY, newScaleY);
  
  this._animator.addProp(DvtAnimator.TYPE_NUMBER, obj, obj.getTranslateX, obj.setTranslateX, point.x);
  this._animator.addProp(DvtAnimator.TYPE_NUMBER, obj, obj.getTranslateY, obj.setTranslateY, point.y);
};
// Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved. 
/**
  * Class representing an animation to scale an object to a given value.
  * @extends DvtBaseAnimation
  * @class DvtAnimScaleTo
  * @constructor
  * 
  * @param {DvtContext}  context  platform specific context object
  * @param objs  a single DvtContainer or Array of DvtContainers to animate
  * @param scales  a single DvtPoint or Array of DvtPoints to scale to
  * @param {number}  duration  length of animation, in seconds
  * @param {number}  delay  time to delay start of animation, in seconds
  */
var DvtAnimScaleTo = function(context, objs, scales, duration, delay)
{
  this.Init(context, objs, scales, duration, delay);
};

DvtObj.createSubclass(DvtAnimScaleTo, DvtBaseAnimation, "DvtAnimScaleTo");

/**
  * @protected
  * @override
  */
DvtAnimScaleTo.prototype.Init = function(context, objs, scales, duration, delay)
{
  if (scales instanceof Array)
  {
    this._arScales = scales;
  }
  else if (scales instanceof DvtPoint)
  {
    this._arScales = [scales];
  }
  else
  {
    this._arScales = [new DvtPoint(1, 1)];
  }
  
  this._currIndex = 0;
  
  DvtAnimScaleTo.superclass.Init.call(this, context, objs, duration, delay);
};

/**
  * @protected
  * @override
  */
DvtAnimScaleTo.prototype.InitEndState = function(obj)
{
  var scale;
  if (this._currIndex < this._arScales.length)
  {
    scale = this._arScales[this._currIndex];
  }
  else
  {
    scale = this._arScales[this._arScales.length - 1];
  }
  
  this._animator.addProp(DvtAnimator.TYPE_NUMBER, obj, obj.getScaleX, obj.setScaleX, scale.x);
  this._animator.addProp(DvtAnimator.TYPE_NUMBER, obj, obj.getScaleY, obj.setScaleY, scale.y);
  
  this._currIndex++;
};
// Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved.
/**
  * Class representing an animation to pop an object in.
  * @extends DvtBaseAnimation
  * @class DvtAnimPopIn
  * @constructor
  * 
  * @param {DvtContext}  context  platform specific context object
  * @param objs  a single DvtContainer or Array of DvtContainers to animate
  * @param {boolean}  bCenter  true to scale the object from its center, 
  *        false to scale from its origin
  * @param {number}  duration  length of animation, in seconds
  * @param {number}  delay  time to delay start of animation, in seconds
  */
var DvtAnimPopIn = function(context, objs, bCenter, duration, delay)
{
  this.Init(context, objs, bCenter, duration, delay);
};

DvtObj.createSubclass(DvtAnimPopIn, DvtBaseAnimation, "DvtAnimPopIn");

/**
  * @protected
  */
DvtAnimPopIn.BackOut = function(progress)
{
  return DvtEasing.backOut(progress, 2.5);
};

/**
  * @protected
  * @override
  */
DvtAnimPopIn.prototype.Init = function(context, objs, bCenter, duration, delay)
{
  this._bCenter = bCenter;
  if (this._bCenter) {
    //temporary containers used to scale an object from its center
    this._tempContainers = [];
    //current index in array of temp containers
    this._currIndex = 0;
  }
  DvtAnimPopIn.superclass.Init.call(this, context, objs, duration, delay);
};

/**
  * @override
  */
DvtAnimPopIn.prototype.setEasing = function(easing)
{
  //do nothing because we want to use our own easing
};

/**
  * @protected
  * @override
  */
DvtAnimPopIn.prototype.CreateAnimator = function(context)
{
  DvtAnimPopIn.superclass.CreateAnimator.call(this, context);
  this._animator.setEasing(DvtAnimPopIn.BackOut);
  if (this._bCenter) {
    //need to remove temporary containers at end of anim
    DvtPlayable.appendOnEnd(this._animator, this.RemoveTempContainers, this);
  }
};

/**
  * @protected
  * @override
  */
DvtAnimPopIn.prototype.InitStartState = function(obj)
{
  if (this._bCenter) {
    //For centering, the idea is to insert a temporary container between the obj and its 
    //parent.  The temp container will be positioned such that its origin is at the center
    //of the obj.  Then, when the temp container is scaled about its origin, it will look 
    //like the obj is scaled about its own center point.  
    var tempContainer = this._tempContainers[this._currIndex];
    
    var dims = obj.getDimensions();
    //store the original translate on the temp container
    tempContainer._dvtAnimPopInOrigTx = obj.getTranslateX();
    tempContainer._dvtAnimPopInOrigTy = obj.getTranslateY();
    //calculate the center point of the obj
    var dx = dims.x + .5 * dims.w;
    var dy = dims.y + .5 * dims.h;
    //position the origin of the temp container at the center point of the obj 
    //so that the obj appears to scale from its center
    tempContainer.setTranslate(tempContainer._dvtAnimPopInOrigTx + dx, tempContainer._dvtAnimPopInOrigTy + dy);
    //translate the obj so that its center point is at the origin of the temp container
    obj.setTranslate(-dx, -dy);
    //reparent the obj to the temp container, and insert the temp container into
    //the obj's original parent at the same index
    var childIndex = obj.getParent().getChildIndex(obj);
    tempContainer._dvtAnimPopInChildIndex = childIndex;
    obj.getParent().addChildAt(tempContainer, childIndex);
    tempContainer.addChild(obj);
    
    //scale the temp container instead of the obj
    tempContainer.setScale(.01, .01);
    
    this._currIndex++;
  }
  else {
    //scale the obj
    obj.setScale(.01, .01);
  }
  obj.setVisible(true);
};

/**
  * @protected
  * @override
  */
DvtAnimPopIn.prototype.InitEndState = function(obj)
{
  if (this._bCenter) {
    //create a temp container
    var tempContainer = new DvtContainer(this._context);
    this._tempContainers.push(tempContainer);
    //scale the temp container to full size
    this._animator.addProp(DvtAnimator.TYPE_NUMBER, tempContainer, tempContainer.getScaleX, tempContainer.setScaleX, 1);
    this._animator.addProp(DvtAnimator.TYPE_NUMBER, tempContainer, tempContainer.getScaleY, tempContainer.setScaleY, 1);
  }
  else {
    this._animator.addProp(DvtAnimator.TYPE_NUMBER, obj, obj.getScaleX, obj.setScaleX, 1);
    this._animator.addProp(DvtAnimator.TYPE_NUMBER, obj, obj.getScaleY, obj.setScaleY, 1);
  }
};

/**
  * @protected
  */
DvtAnimPopIn.prototype.RemoveTempContainers = function() {
  //remove temp containers used for scaling from center
  if (this._tempContainers) {
    for (var i = 0; i < this._tempContainers.length; i++) {
      var tempContainer = this._tempContainers[i];
      this._tempContainers[i] = null;
      if (tempContainer.getNumChildren() > 0) {
        //obj should be first child of temp container
        var obj = tempContainer.getChildAt(0);
        if (obj) {
          //translate the obj back to its original position and reparent it back to 
          //its original container at the same z-index
          obj.setTranslate(tempContainer._dvtAnimPopInOrigTx, tempContainer._dvtAnimPopInOrigTy);
          tempContainer.getParent().addChildAt(obj, tempContainer._dvtAnimPopInChildIndex);
        }
      }
      //remove the temp container from the display list
      tempContainer.getParent().removeChild(tempContainer);
    }
    this._tempContainers = null;
  }
};
// Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved.
/**
  * Class representing an animation to pop an object out.
  * @extends DvtBaseAnimation
  * @class DvtAnimPopOut
  * @constructor
  * 
  * @param {DvtContext}  context  platform specific context object
  * @param objs  a single DvtContainer or Array of DvtContainers to animate
  * @param {boolean}  bCenter  true to scale the object from its center, 
  *        false to scale from its origin
  * @param {number}  duration  length of animation, in seconds
  * @param {number}  delay  time to delay start of animation, in seconds
  */
var DvtAnimPopOut = function(context, objs, bCenter, duration, delay)
{
  this.Init(context, objs, bCenter, duration, delay);
};

DvtObj.createSubclass(DvtAnimPopOut, DvtBaseAnimation, "DvtAnimPopOut");

/**
  * @protected
  */
DvtAnimPopOut.BackIn = function(progress)
{
  return DvtEasing.backIn(progress, 2.5);
};

/**
  * @protected
  * @override
  */
DvtAnimPopOut.prototype.Init = function(context, objs, bCenter, duration, delay)
{
  this._bCenter = bCenter;
  if (this._bCenter) {
    //temporary containers used to scale an object from its center
    this._tempContainers = [];
    //current index in array of temp containers
    this._currIndex = 0;
  }
  DvtAnimPopOut.superclass.Init.call(this, context, objs, duration, delay);
  
  //need to do this AFTER calling superclass Init because member will
  //initially be defined there
  //only need to restore original matrices if not centering (temp containers not used)
  this._bSaveAndRestoreOriginalMatrices = !this._bCenter;
  this._bHideObjectsOnEnd = true;
};

/**
  * @override
  */
DvtAnimPopOut.prototype.setEasing = function(easing)
{
  //do nothing because we want to use our own easing
};

/**
  * @protected
  * @override
  */
DvtAnimPopOut.prototype.CreateAnimator = function(context)
{
  DvtAnimPopOut.superclass.CreateAnimator.call(this, context);
  this._animator.setEasing(DvtAnimPopOut.BackIn);
  if (this._bCenter) {
    //need to remove temporary containers at end of anim
    DvtPlayable.appendOnEnd(this._animator, this.RemoveTempContainers, this);
  }
};

/**
  * @protected
  * @override
  */
DvtAnimPopOut.prototype.InitStartState = function(obj)
{
  if (this._bCenter) {
    //For centering, the idea is to insert a temporary container between the obj and its 
    //parent.  The temp container will be positioned such that its origin is at the center
    //of the obj.  Then, when the temp container is scaled about its origin, it will look 
    //like the obj is scaled about its own center point.  
    var tempContainer = this._tempContainers[this._currIndex];
    
    var dims = obj.getDimensions();
    //store the original translate on the temp container
    tempContainer._dvtAnimPopInOrigTx = obj.getTranslateX();
    tempContainer._dvtAnimPopInOrigTy = obj.getTranslateY();
    //calculate the center point of the obj
    var dx = dims.x + .5 * dims.w;
    var dy = dims.y + .5 * dims.h;
    //position the origin of the temp container at the center point of the obj 
    //so that the obj appears to scale from its center
    tempContainer.setTranslate(tempContainer._dvtAnimPopInOrigTx + dx, tempContainer._dvtAnimPopInOrigTy + dy);
    //translate the obj so that its center point is at the origin of the temp container
    obj.setTranslate(-dx, -dy);
    //reparent the obj to the temp container, and insert the temp container into
    //the obj's original parent at the same index
    var childIndex = obj.getParent().getChildIndex(obj);
    tempContainer._dvtAnimPopInChildIndex = childIndex;
    obj.getParent().addChildAt(tempContainer, childIndex);
    tempContainer.addChild(obj);
    
    this._currIndex++;
  }
};

/**
  * @protected
  * @override
  */
DvtAnimPopOut.prototype.InitEndState = function(obj)
{
  if (this._bCenter) {
    //create a temp container
    var tempContainer = new DvtContainer(this._context);
    this._tempContainers.push(tempContainer);
    //scale the temp container to small size
    this._animator.addProp(DvtAnimator.TYPE_NUMBER, tempContainer, tempContainer.getScaleX, tempContainer.setScaleX, .01);
    this._animator.addProp(DvtAnimator.TYPE_NUMBER, tempContainer, tempContainer.getScaleY, tempContainer.setScaleY, .01);
  }
  else {
    this._animator.addProp(DvtAnimator.TYPE_NUMBER, obj, obj.getScaleX, obj.setScaleX, .01);
    this._animator.addProp(DvtAnimator.TYPE_NUMBER, obj, obj.getScaleY, obj.setScaleY, .01);
  }
};

/**
  * @protected
  */
DvtAnimPopOut.prototype.RemoveTempContainers = function() {
  //remove temp containers used for scaling from center
  if (this._tempContainers) {
    for (var i = 0; i < this._tempContainers.length; i++) {
      var tempContainer = this._tempContainers[i];
      this._tempContainers[i] = null;
      if (tempContainer.getNumChildren() > 0) {
        //obj should be first child of temp container
        var obj = tempContainer.getChildAt(0);
        if (obj) {
          //translate the obj back to its original position and reparent it back to 
          //its original container at the same z-index
          obj.setTranslate(tempContainer._dvtAnimPopInOrigTx, tempContainer._dvtAnimPopInOrigTy);
          tempContainer.getParent().addChildAt(obj, tempContainer._dvtAnimPopInChildIndex);
        }
      }
      //remove the temp container from the display list
      tempContainer.getParent().removeChild(tempContainer);
    }
    this._tempContainers = null;
  }
};
// Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved. 
/**
  * Class used to animate replacing one set of display objects with another
  * set by rotating and moving them as if on a conveyor belt.  The old 
  * objects will move back into the display while the new objects will be 
  * moved to the front.
  * @extends DvtParallelPlayable
  * @class DvtCombinedAnimConveyor
  * @constructor
  * 
  * @param {DvtContext}  context  platform specific context object
  * @param outObjs  a single DvtContainer or Array of DvtContainers to fade out
  * @param inObjs  a single DvtContainer or Array of DvtContainers to fade in
  * @param outDir compass direction to move old display objects out; can be 
  *        one of: DIR_N, DIR_E, DIR_S, DIR_W
  * @param inDir compass direction to move new display objects in from; can 
  *        be one of: DIR_N, DIR_E, DIR_S, DIR_W
  * @param {number}  duration  length of individual out and in animations, in seconds
  * @param {number}  delay  time to delay start of animation, in seconds
  */
var DvtCombinedAnimConveyor = function(context, outObjs, inObjs, outDir, inDir, duration, delay)
{
  this.Init(context, outObjs, inObjs, outDir, inDir, duration, delay);
};

DvtObj.createSubclass(DvtCombinedAnimConveyor, DvtParallelPlayable, "DvtCombinedAnimConveyor");

/**
  * @protected
  * @override
  */
DvtCombinedAnimConveyor.prototype.Init = function(context, outObjs, inObjs, outDir, inDir, duration, delay)
{
  if (!duration)
    duration = 0.5;
  if (!delay)
    delay = 0;
  
  var conveyorOut = new DvtAnimConveyorOut(context, outObjs, outDir, duration, delay);
  var conveyorIn = new DvtAnimConveyorIn(context, inObjs, inDir, duration, (duration / 3) + delay);
  
  DvtCombinedAnimConveyor.superclass.Init.call(this, context, [conveyorOut, conveyorIn]);
};
// Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved. 
/**
  * Class used to animate replacing one set of display objects with 
  * another set by rotating out the old and rotating in the new, 
  * as if on a cube.
  * @extends DvtParallelPlayable
  * @class DvtCombinedAnimCube
  * @constructor
  * 
  * @param {DvtContext}  context  platform specific context object
  * @param outObjs  a single DvtContainer or Array of DvtContainers to fade out
  * @param inObjs  a single DvtContainer or Array of DvtContainers to fade in
  * @param axis axis of rotation; can be one of: AXIS_X, AXIS_Y
  * @param rotationDir direction of rotation about the axis; can be one of:
  *        ROT_DIR_CLOCKWISE, ROT_DIR_COUNTERCLOCKWISE;
  *        direction is determined by looking down the axis from the positive side
  * @param {number}  duration  length of individual out and in animations, in seconds
  * @param {number}  delay  time to delay start of animation, in seconds
  */
var DvtCombinedAnimCube = function(context, outObjs, inObjs, axis, rotationDir, duration, delay)
{
  this.Init(context, outObjs, inObjs, axis, rotationDir, duration, delay);
};

DvtObj.createSubclass(DvtCombinedAnimCube, DvtParallelPlayable, "DvtCombinedAnimCube");

/**
  * @protected
  * @override
  */
DvtCombinedAnimCube.prototype.Init = function(context, outObjs, inObjs, axis, rotationDir, duration, delay)
{
  if (!duration)
    duration = 0.5;
  if (!delay)
    delay = 0;
  
  var cubeOut = new DvtAnimCubeOut(context, outObjs, axis, rotationDir, duration, delay);
  var cubeIn = new DvtAnimCubeIn(context, inObjs, axis, rotationDir, duration, delay);
  
  DvtCombinedAnimCube.superclass.Init.call(this, context, [cubeOut, cubeIn]);
};
// Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved. 
/**
  * Class used to animate replacing one set of display objects with another set by
  * fading out the old and fading in the new.
  * @extends DvtParallelPlayable
  * @class DvtCombinedAnimFade
  * @constructor
  * 
  * @param {DvtContext}  context  platform specific context object
  * @param outObjs  a single DvtContainer or Array of DvtContainers to fade out
  * @param inObjs  a single DvtContainer or Array of DvtContainers to fade in
  * @param {number}  duration  length of individual out and in animations, in seconds
  * @param {number}  delay  time to delay start of animation, in seconds
  */
var DvtCombinedAnimFade = function(context, outObjs, inObjs, duration, delay)
{
  this.Init(context, outObjs, inObjs, duration, delay);
};

DvtObj.createSubclass(DvtCombinedAnimFade, DvtParallelPlayable, "DvtCombinedAnimFade");

/**
  * @protected
  * @override
  */
DvtCombinedAnimFade.prototype.Init = function(context, outObjs, inObjs, duration, delay)
{
  if (!duration)
    duration = 0.5;
  if (!delay)
    delay = 0;
  
  var fadeOut = new DvtAnimFadeOut(context, outObjs, duration, delay);
  //delay the fade out by a little bit to make both animations easier to see
  var fadeIn = new DvtAnimFadeIn(context, inObjs, duration, 0.5 * fadeOut.getDuration() + delay);
  
  DvtCombinedAnimFade.superclass.Init.call(this, context, [fadeOut, fadeIn]);
};
// Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved. 
/**
  * Class used to animate replacing one set of display objects with 
  * another set by flipping out the old and flipping in the new, 
  * as if on a playing card.
  * @extends DvtSequentialPlayable
  * @class DvtCombinedAnimFlip
  * @constructor
  * 
  * @param {DvtContext}  context  platform specific context object
  * @param outObjs  a single DvtContainer or Array of DvtContainers to fade out
  * @param inObjs  a single DvtContainer or Array of DvtContainers to fade in
  * @param axis axis of rotation; can be one of: AXIS_X, AXIS_Y
  * @param rotationDir direction of rotation about the axis; can be one of:
  *        ROT_DIR_CLOCKWISE, ROT_DIR_COUNTERCLOCKWISE;
  *        direction is determined by looking down the axis from the positive side
  * @param {number}  duration  length of individual out and in animations, in seconds
  * @param {number}  delay  time to delay start of animation, in seconds
  */
var DvtCombinedAnimFlip = function(context, outObjs, inObjs, axis, rotationDir, duration, delay)
{
  this.Init(context, outObjs, inObjs, axis, rotationDir, duration, delay);
};

DvtObj.createSubclass(DvtCombinedAnimFlip, DvtSequentialPlayable, "DvtCombinedAnimFlip");

/**
  * @protected
  * @override
  */
DvtCombinedAnimFlip.prototype.Init = function(context, outObjs, inObjs, axis, rotationDir, duration, delay)
{
  if (!duration)
    duration = 0.5;
  if (!delay)
    delay = 0;
  
  var flipOut = new DvtAnimFlipOut(context, outObjs, axis, rotationDir, duration, delay);
  //adjust easing so that animation is slow at the beginning, 
  //but fast at the end
  flipOut.setEasing(DvtBaseAnimation.EASING_CUBIC_IN);
  var flipIn = new DvtAnimFlipIn(context, inObjs, axis, rotationDir, duration, delay);
  //adjust easing so that animation is fast at the beginning, 
  //but slow at the end
  flipIn.setEasing(DvtBaseAnimation.EASING_CUBIC_OUT);
  
  //because the flipOut and flipIn animations are played in sequence,
  //and because the initState of the flipIn won't be set until it starts
  //to play, we need to explicitly hide the flipIn objects here so that
  //they're not visible during the first flipOut part of the sequence
  flipIn.HideObjects();
  
  DvtCombinedAnimFlip.superclass.Init.call(this, context, [flipOut, flipIn]);
};
// Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved. 
/**
  * Class used to animate replacing one set of display objects with another set by
  * moving out the old and moving in the new.
  * @extends DvtParallelPlayable
  * @class DvtCombinedAnimMoveBy
  * @constructor
  * 
  * @param {DvtContext}  context  platform specific context object
  * @param outObjs  a single DvtContainer or Array of DvtContainers to move out
  * @param inObjs  a single DvtContainer or Array of DvtContainers to move in
  * @param outOffsets  a single DvtPoint or Array of DvtPoints to move out by
  * @param inOffsets  a single DvtPoint or Array of DvtPoints to move in by
  * @param {number}  duration  length of individual out and in animations, in seconds
  * @param {number}  delay  time to delay start of animation, in seconds
  */
var DvtCombinedAnimMoveBy = function(context, outObjs, inObjs, outOffsets, inOffsets, duration, delay)
{
  this.Init(context, outObjs, inObjs, outOffsets, inOffsets, duration, delay);
};

DvtObj.createSubclass(DvtCombinedAnimMoveBy, DvtParallelPlayable, "DvtCombinedAnimMoveBy");

/**
  * @protected
  * @override
  */
DvtCombinedAnimMoveBy.prototype.Init = function(context, outObjs, inObjs, outOffsets, inOffsets, duration, delay)
{
  if (!duration)
    duration = 0.5;
  if (!delay)
    delay = 0;
  
  var moveOut = new DvtAnimMoveBy(context, outObjs, outOffsets, duration, delay);
  var moveIn = new DvtAnimMoveBy(context, inObjs, inOffsets, duration, delay);
  
  DvtCombinedAnimMoveBy.superclass.Init.call(this, context, [moveOut, moveIn]);
};
// Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved. 
/**
  * Class used to animate replacing one set of display objects with another set by
  * moving and fading out the old and moving and fading in the new.  The objects 
  * are moved out toward and in from the edges of a provided rectangle as they fade.  
  * The objects are also scaled as they fade, so they become smaller as they are 
  * more transparent.
  * @extends DvtParallelPlayable
  * @class DvtCombinedAnimScaleFade
  * @constructor
  * 
  * @param {DvtContext}  context  platform specific context object
  * @param outObjs  a single DvtContainer or Array of DvtContainers to fade out
  * @param inObjs  a single DvtContainer or Array of DvtContainers to fade in
  * @param {DvtRectangle}  boundsRect  a rectangle defining the bounds for moving the objects
  * @param outDirection  compass direction to move old display objects out to; 
  *        can be one of the values defined in DvtBaseAnimation:
  *        DIR_C, DIR_N, DIR_NE, DIR_E, DIR_SE, DIR_S, DIR_SW, DIR_W, DIR_NW (default is DIR_NE)
  * @param inDirection  compass direction to move new display objects in from; 
  *        can be one of the values defined in DvtBaseAnimation:
  *        DIR_C, DIR_N, DIR_NE, DIR_E, DIR_SE, DIR_S, DIR_SW, DIR_W, DIR_NW (default is DIR_NW)
  * @param {number}  minScale  minimum scale to make the objects as they fade
  * @param {number}  duration  length of individual out and in animations, in seconds
  * @param {number}  delay  time to delay start of animation, in seconds
  */
var DvtCombinedAnimScaleFade = function(context, outObjs, inObjs, boundsRect, outDirection, inDirection, minScale, duration, delay)
{
  this.Init(context, outObjs, inObjs, boundsRect, outDirection, inDirection, minScale, duration, delay);
};

DvtObj.createSubclass(DvtCombinedAnimScaleFade, DvtParallelPlayable, "DvtCombinedAnimScaleFade");

/**
  * @protected
  * @override
  */
DvtCombinedAnimScaleFade.prototype.Init = function(context, outObjs, inObjs, boundsRect, outDirection, inDirection, minScale, duration, delay)
{
  if (!outDirection)
    outDirection = DvtBaseAnimation.DIR_NE;
  if (!inDirection)
    inDirection = DvtBaseAnimation.DIR_NW;
  if (!minScale)
    minScale = 0.5;
  if (!duration)
    duration = 0.5;
  if (!delay)
    delay = 0;
  
  var fadeOut = new DvtAnimScaleFadeOut(context, outObjs, boundsRect, outDirection, minScale, duration, delay);
  var fadeIn = new DvtAnimScaleFadeIn(context, inObjs, boundsRect, inDirection, minScale, duration, 0.3 * fadeOut.getDuration() + delay);
  
  DvtCombinedAnimScaleFade.superclass.Init.call(this, context, [fadeOut, fadeIn]);
};
// Copyright (c) 2011, 2012, Oracle and/or its affiliates. 
// All rights reserved. 
/**
  * Class used to animate a set of display objects popping into the display
  * at staggered times.  
  * @extends DvtParallelPlayable
  * @class DvtCombinedAnimPopIn
  * @constructor
  * 
  * @param {DvtContext}  context  platform specific context object
  * @param objs  a single DvtContainer or Array of DvtContainers to pop in
  * @param {boolean}  bCenter  true to scale the object from its center, 
  *        false to scale from its origin (true is not implemented yet)
  * @param {number}  popDuration  length of individual pop animations, 
  *        in seconds
  * @param {number}  totalDuration  total length of time in which all 
  *        individiual animations must run, in seconds
  * @param {number}  delay  time to delay start of animation, in seconds
  */
var DvtCombinedAnimPopIn = function(context, objs, bCenter, popDuration, totalDuration, delay)
{
  this.Init(context, objs, bCenter, popDuration, totalDuration, delay);
};

DvtObj.createSubclass(DvtCombinedAnimPopIn, DvtParallelPlayable, "DvtCombinedAnimPopIn");

/**
  * @protected
  * @override
  */
DvtCombinedAnimPopIn.prototype.Init = function(context, objs, bCenter, popDuration, totalDuration, delay)
{
  var array = [];
  var dispObjArray;
    
  if (objs instanceof Array)
  {
    dispObjArray = objs;
  }
  else
  {
    dispObjArray = [objs];
  }
  
  delay = (delay === null || isNaN(delay)) ? 0 : delay;
  
  for (var i = 0; i < dispObjArray.length; i++)
  {
    var dispObj = dispObjArray[i];
    //if (dispObj instanceof DvtDisplayable)
    //{
      var individualDelay = delay + (Math.random() * (totalDuration - popDuration));
      var popIn = new DvtAnimPopIn(context, dispObj, bCenter, popDuration, individualDelay);
      array.push(popIn);
    //}
  }
  
  DvtCombinedAnimPopIn.superclass.Init.call(this, context, array);
};
// Copyright (c) 2011, 2012, Oracle and/or its affiliates. 
// All rights reserved. 
/**
  * Class used to animate a set of display objects popping out of the display
  * at staggered times.  
  * @extends DvtParallelPlayable
  * @class DvtCombinedAnimPopOut
  * @constructor
  * 
  * @param {DvtContext}  context  platform specific context object
  * @param objs  a single DvtContainer or Array of DvtContainers to pop out
  * @param {boolean}  bCenter  true to scale the object from its center, 
  *        false to scale from its origin (true is not implemented yet)
  * @param {number}  popDuration  length of individual pop animations, 
  *        in seconds
  * @param {number}  totalDuration  total length of time in which all 
  *        individiual animations must run, in seconds
  * @param {number}  delay  time to delay start of animation, in seconds
  */
var DvtCombinedAnimPopOut = function(context, objs, bCenter, popDuration, totalDuration, delay)
{
  this.Init(context, objs, bCenter, popDuration, totalDuration, delay);
};

DvtObj.createSubclass(DvtCombinedAnimPopOut, DvtParallelPlayable, "DvtCombinedAnimPopOut");

/**
  * @protected
  * @override
  */
DvtCombinedAnimPopOut.prototype.Init = function(context, objs, bCenter, popDuration, totalDuration, delay)
{
  var array = [];
  var dispObjArray;
  
    
  if (objs instanceof Array)
  {
    dispObjArray = objs;
  }
  else
  {
    dispObjArray = [objs];
  }
  
  delay = (delay === null || isNaN(delay)) ? 0 : delay;
  
  for (var i = 0; i < dispObjArray.length; i++)
  {
    var dispObj = dispObjArray[i];
    //if (dispObj instanceof DvtDisplayable)
    //{
      var individualDelay = delay + (Math.random() * (totalDuration - popDuration));
      var popIn = new DvtAnimPopOut(context, dispObj, bCenter, popDuration, individualDelay);
      array.push(popIn);
    //}
  }
  
  DvtCombinedAnimPopOut.superclass.Init.call(this, context, array);
};
// Copyright (c) 2008, 2011, Oracle and/or its affiliates. 
// All rights reserved. 
/*-------------------------------------------------------------------------*/
/*   DvtBaseDrawEffect                                                     */
/*-------------------------------------------------------------------------*/
/**
 * A base class for draw effects like sahodws, glows, etc.
 * {@link DvtBaseDrawEffect}.
 * @extends DvtLockable
 * @class DvtBaseDrawEffect  A base class for draw effects like sahodws, glows, etc.
 * @constructor  Do not create/use directly.
 */
var DvtBaseDrawEffect = function () {
  this._Init();
}

DvtObj.createSubclass(DvtBaseDrawEffect, DvtLockable, "DvtBaseDrawEffect");

/** 
 * @private 
 */
DvtBaseDrawEffect.prototype._Init = function () {
   DvtBaseDrawEffect.superclass._Init.call(this) ;
}

/**
 *   Returns the id of this draw effect.
 *   @type String
 */
DvtBaseDrawEffect.prototype.getId = function () {
  return this._id;
}

/**
 *   Sets the id of this fill.
 *   @param {String} id  The id for the fill.
 */
DvtBaseDrawEffect.prototype.setId = function (id) {
  this._id = id;
}

/**
 *   Merge properties in the current object into the supplied object.
 *   Abstract method, subclasses must implement. Used internally by clone().
 *   @param {DvtObj}
 *   @private
 */
DvtBaseDrawEffect.prototype.mergeProps = function (obj) {
  obj.setId(this._id);
}
// Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
/*-------------------------------------------------------------------------*/
/*   DvtColorUtils       A static class for css color manipulation         */
/*-------------------------------------------------------------------------*/
/*   The static utility functions operate on color specifications of the   */
/*   format #rrggbb, or rgb(r,g,b), or rgba(r,g,b,a).                      */
/*-------------------------------------------------------------------------*/
/**  Static utility functions that operate on color specification strings of the
  *  format #rrggbb, or rgb(r,g,b), or rgba(r,g,b,a).
  *  @base DvtColorUtils
  */
var DvtColorUtils = {} ;

DvtObj.createSubclass(DvtColorUtils, DvtObj, "DvtColorUtils");

//  Channel definition constants

DvtColorUtils._RED   = 0 ;  // Channels. Don't change
DvtColorUtils._GREEN = 1 ;  // defs unless the routines
DvtColorUtils._BLUE  = 2 ;  // below are changed.
DvtColorUtils._ALPHA = 3 ;

//  private constants

DvtColorUtils._RGBA  = 'rgba(' ;
DvtColorUtils._RGB   = 'rgb(' ;
DvtColorUtils._POUND = '#'

DvtColorUtils._FACTOR = 0.15 ;  // default darkening percentage.

/** @private */
DvtColorUtils._names ;          // associative array


/*-------------------------------------------------------------------------*/
/*  getColorFromName()                                                     */
/*-------------------------------------------------------------------------*/
/**
  * Returns a color definition string from the named color.
  * @param {String}  name  The color name.
  * @type String
  * @return  An #rrggbb color string.
  */
DvtColorUtils.getColorFromName = function(name)
{
  if (! DvtColorUtils._names) {
    var ar = [] ;
    ar['aqua']    = '#00FFFF';
    ar['black']   = '#000000';
    ar['blue']    = '#0000FF'
    ar['white']   = '#FFFFFF';
    ar['fuchsia'] = '#FF00FF';
    ar['gray']    = '#848284';
    ar['lime']    = '#00FF00';
    ar['maroon']  = '#840000';
    ar['green']   = '#008200';
    ar['navy']    = '#000084';
    ar['olive']   = '#848200';
    ar['red']     = '#FF0000';
    ar['silver']  = '#C6C3C6';
    ar['teal']    = '#008284';
    ar['yellow']  = '#FFFF00';
    ar['purple']  = '#800080';

    // name colors for testing
    ar['cyan']          = '#D2B48C';
    ar['goldenrod']     = '#DAA520';
    ar['lightblue']     = '#ADD8E6';
    ar['lightyellow']   = '#FFFFE0';
    ar['orange']        = '#FFA500';
    ar['paleGoldenRod'] = '#EEE8AA';
    ar['paleturquoise'] = '#AFEEEE';
    ar['peachpuff']     = '#FFDAB9';
    ar['pink']          = '#FFC0CB';
    ar['tan']           = '#D2B48C';
    ar['thistle']       = '#D8BFD8';

    ar['transparent']   = 'rgba(255,255,255,0)';

    DvtColorUtils._names = ar ;
  }
  return DvtColorUtils._names[name] ;

} ;


/*-------------------------------------------------------------------------*/
/*  isColor()                                                              */
/*-------------------------------------------------------------------------*/
/**
 * Determine if the given string specifies a color value.
 * @param {String}  s  The string to be evaluated.
 * @param {Boolean}  bValid  Optional.  If omitted or false, the string prefix
 *                           is checked for validity only. If true, a deeper
 *                           check of the rgb component values is performed.
 * @type Boolean
 * @returns true if the string specifies a color value, else false.
 */
DvtColorUtils.isColor = function(s, bValid)
{
  if (! bValid) {
    return ((s.charAt(0) === DvtColorUtils._POUND) ||
            (s.indexOf(DvtColorUtils._RGBA) === 0) ||
            (s.indexOf(DvtColorUtils._RGB) === 0)) ;
  }

  // Deeper validation

  var bRet = false ;

  s = DvtStringUtils.trim(s);
  s = s.toLowerCase() ;

  if  (s.charAt(0) === DvtColorUtils._POUND) {
     if (s.length === 7) {
       var pat = new RegExp(/^#[0-9a-f]{6}$/i);
       bRet = pat.test(s);
     }
  }
  else {
    var bRGBA = (s.indexOf(DvtColorUtils._RGBA) === 0) ;
    var bRGB  ;
    
    if (! bRGBA) {
      bRGB = (s.indexOf(DvtColorUtils._RGB) === 0) ;
    }

    if (bRGBA || bRGB) {
      var x = s.indexOf(')') ;

      if (x >= 0) {
        var ar  = s.substring((bRGBA? 5 : 4), x).split(',') ;
        var len = ar.length ;
        var bVals = true ;

        for (var i = 0; i < len; i++) {
           var n = ar[i] ;
           if (( (1 < 3) && (n < 0 || n > 255)) ||  ((i > 3) && (n < 0 || n > 1))) {
             bVals = false ;
             break ;
           }
        }

        if (bVals) {
          bRet = (bRGBA? (len === 4) : (len === 3)) ;
        }
      }
    }
  }

  return bRet ;
} ;



/*-------------------------------------------------------------------------*/
/*   get/setAlpha()                                                        */
/*-------------------------------------------------------------------------*/
/**
  *  Returns the alpha value (or implied value) of the specified color string.
  *  @param {String} c The color specification.
  *  @type {number}
  *  @returns {number}  The alpha-channel value (between 0 and 1).
  */
DvtColorUtils.getAlpha = function(c)
{
   return DvtColorUtils._getChannel(c, DvtColorUtils._ALPHA) ;
} ;


/**
  *  Changes the alpha channel in the supplied color string.
  *  @param {String} c The color specification.
  *  @param {number} a The alpha value (range 0 to 1).
  *  @type String
  *  @returns  A new color specification.
  */
DvtColorUtils.setAlpha = function(c, a)
{
   return DvtColorUtils._setChannel(c, DvtColorUtils._ALPHA, a) ;
} ;


/*-------------------------------------------------------------------------*/
/*   get/setRed()                                                          */
/*-------------------------------------------------------------------------*/
/**
  *  Returns the red-channel value of the specified color string.
  *  @param {String} c The color specification.
  *  @type number
  *  @returns   The red-channel value as a decimal number between 0 and 255.
  */
DvtColorUtils.getRed = function(c)
{
   return DvtColorUtils._getChannel(c, DvtColorUtils._RED) ;
} ;

/**
  *  Changes the red-channel value in the supplied color string.
  *  @param {String} c The color specification.
  *  @param {number} r The red channel value as a decimal number between 0 and 255.
  *  @type String
  *  @returns  A new color string specification.
  */
DvtColorUtils.setRed = function(c, r)
{
   return DvtColorUtils._setChannel(c, DvtColorUtils._RED, r) ;
} ;



/*-------------------------------------------------------------------------*/
/*   get/setBlue()                                                         */
/*-------------------------------------------------------------------------*/
/**
  *  Returns the blue-channel value of the specified color string.
  *  @param {String} c The color specification.
  *  @type number
  *  @returns  The blue-channel value as a decimal number between 0 and 255.
  */
DvtColorUtils.getBlue = function(c)
{
   return DvtColorUtils._getChannel(c, DvtColorUtils._BLUE) ;
} ;


/**
  *  Changes the blue-channel value in the supplied color string.
  *  @param {String} c The color specification.
  *  @param {number} b The blue channel value as a decimal number.
  *  @type String
  *  @returns  A new color string specification.
  */
DvtColorUtils.setBlue = function(c, b)
{
   return DvtColorUtils._setChannel(c, DvtColorUtils._BLUE, b) ;
} ;



/*-------------------------------------------------------------------------*/
/*   get/setGreen()                                                        */
/*-------------------------------------------------------------------------*/
/**
  *  Returns the green-channel value of the specified color string.
  *  @param {String} c The color specification.
  *  @type number
  *  @returns   The green value as a decimal number between 0 and 255.
  */
DvtColorUtils.getGreen = function(c)
{
   return DvtColorUtils._getChannel(c, DvtColorUtils._GREEN) ;
} ;

/**
  *  Changes the green-channel value in the supplied color string.
  *  @param {String} c The color specification.
  *  @param {number} g The green channel value as a decimal number between 0 and 255.
  *  @type String
  *  @returns  A new color string specification.
  */
DvtColorUtils.setGreen = function(c, g)
{
   return DvtColorUtils._setChannel(c, DvtColorUtils._GREEN, g) ;
} ;



/*-------------------------------------------------------------------------*/
/*   getChannel()     Returns a channel from a #, rgb or rgba string.      */
/*                    (Note: if an alpha channel is requested and a # or   */
/*                    rgb string is supplied, the implied value of 1 is    */
/*                    returned.                                            */
/*-------------------------------------------------------------------------*/
/**
  *  Returns a specifed channel value from a css color specification (#, rgb(), rgba()).
  *  If an alpha channel is requested and a # or rgb string is supplied,
  *  an implied value of 1 is returned.
  *  @private
  *  @param  {String} c  The color string. 
  *  @param  {number} chan  The channel (see {@DvtColorUtils#_RED} for example).
  *  @type number
  *  @returns The channel value as a decimal number (between 0 and 255).
  */
DvtColorUtils._getChannel = function(c, chan)
{
    var clr = c;
    var chval = null;// the return value
    
    // If clr is a named color, then convert into usable format
    var namedColor = DvtColorUtils.getColorFromName(clr);
    if(namedColor)
      clr = namedColor;
    
    // Alpha support
    if (chan === DvtColorUtils._ALPHA) {
      if (clr.charAt(0) === '#') 
        return (clr.length > 7) ? parseInt(clr.substring(1, 3), 16) / 255 : 1;//check for MT extended format of #aarrggbb
      else if (clr === 'none') 
        return 0;
    }

    var x1 = clr.indexOf('(');
    if (x1 < 0) {
        ar = [];
        //BUG FIX 13704008: parse channels for different # formats
        if (clr.length > 7) {
            //  #aarrggbb format
            ar[0] = parseInt(clr.substr(3, 2), 16);
            ar[1] = parseInt(clr.substr(5, 2), 16);
            ar[2] = parseInt(clr.substr(7, 2), 16);
            ar[3] = parseInt(clr.substr(1, 2), 16) / 255;
        }
        else {
            //  #rrggbb format
            ar[0] = parseInt(clr.substr(1, 2), 16);
            ar[1] = parseInt(clr.substr(3, 2), 16);
            ar[2] = parseInt(clr.substr(5, 2), 16);
            ar[3] = 1;
        }
        chval = ar[chan];
    }
    else {

        //  rgb() or rgba() format
        var x2 = clr.indexOf(')');
        var ar = clr.substring(x1 + 1, x2).split(',');

        if (ar.length === 3 && chan === DvtColorUtils._ALPHA) {
            chval = 1;
        }
        else {
            chval = ar[chan];
            chval = parseFloat(chval);
        }
    }

    return chval;
} ;



/*-------------------------------------------------------------------------*/
/*   getDarker()                                                           */
/*-------------------------------------------------------------------------*/
/**
  * Returns the specified color made darker by the specified percentage.
  * <p>
  * Example:<br><br><code>
  * // create a color darkened by 25%). 
  *  var darker = DvtColorUtils.getDarker("rgba(220,128,49)", 0.25) ;<br>
  *  </code>
  * @param {String} color   A color specification.
  * @param {number} factor  An optional percentage by which each color component is to be
  *                         darkened (0 returns unchanged) specified as a decimal
  *                         (e.g. 25% = 0.25).  If omitted, a default percentage of
  *                         15% (i.e 0.15) is applied.
  * @type String
  * @returns A darkened color specification in RGBA format.
  */
DvtColorUtils.getDarker = function(color, factor)
{
   //TDO

   var  r = DvtColorUtils._getChannel(color, DvtColorUtils._RED);
   var  g = DvtColorUtils._getChannel(color, DvtColorUtils._GREEN);
   var  b = DvtColorUtils._getChannel(color, DvtColorUtils._BLUE);
   var  a = DvtColorUtils._getChannel(color, DvtColorUtils._ALPHA);

   if (! factor) {
     factor = DvtColorUtils._FACTOR ;    // use default factor
   }
   
   r = Math.max(parseInt(r * factor), 0);
   g = Math.max(parseInt(g * factor), 0);
   b = Math.max(parseInt(b * factor), 0);

   return DvtColorUtils.makeRGBA(r, g, b, a);
}; 



/*-------------------------------------------------------------------------*/
/*   getGrey()                                                             */
/*-------------------------------------------------------------------------*/
/**
  * @this {DvtColorUtils}
  *   Returns a greyscale version of the supplied color (in the same format).
  *   @param {String} color  The color to be converted.
  *   @returns a greyscale version of the supplied color
  *   @type String
  *   @returns a greyscale version of the supplied color (in the same format).
  */
DvtColorUtils.getGrey = function(color)
{
   var  ret ;

   var  r = DvtColorUtils._getChannel(color, DvtColorUtils._RED);
   var  g = DvtColorUtils._getChannel(color, DvtColorUtils._BLUE);
   var  b = DvtColorUtils._getChannel(color, DvtColorUtils._GREEN);

   var gray = Math.round((r * 0.3) + (g * 0.59) + (b * 0.11));

   return this.setRGB(color, gray, gray, gray) ;
} ;



/*-------------------------------------------------------------------------*/
/*   invert()                                                              */
/*-------------------------------------------------------------------------*/
/**
  *   Inverts the specified color. 
  *   @param {String} c   The color to be inverted.
  *   @type  String
  *   @returns The inverted color in the same color format as supplied.
  */
DvtColorUtils.invert = function(c) {

   var  ret ;

   var  r = 255 - DvtColorUtils._getChannel(c, DvtColorUtils._RED);
   var  g = 255 - DvtColorUtils._getChannel(c, DvtColorUtils._BLUE);
   var  b = 255 - DvtColorUtils._getChannel(c, DvtColorUtils._GREEN);

   if (c.charAt(0) === '#') {
      ret = DvtColorUtils.makePound(r,g,b) ;
   }
   else if (c.substr(0,4) === DvtColorUtils._RGB) {
      ret = DvtColorUtils.makeRGB(r,g,b) ;
   }
   else {
      ret = DvtColorUtils.makeRGBA(r,g,b,DvtColorUtils._getChannel(c, DvtColorUtils._ALPHA)) ;
   }

   return ret ;
} ;



/*-------------------------------------------------------------------------*/
/*   isRGBA()                                                              */
/*-------------------------------------------------------------------------*/
/**
  *   Returns true if the color string is of rgba(...) format.
  *   @param {String} c   the color to be tested.
  *   @returns {boolean}  true if the color is of rgba(. . .) type, else false.
  */
DvtColorUtils.isRGBA = function(c)
{
   return (c.substr(0,5) === DvtColorUtils._RGBA) ;
};



/*-------------------------------------------------------------------------*/
/*   makeRGB()                                                             */
/*-------------------------------------------------------------------------*/
/**
  *  Creates an rgb(...) format from the supplied red, green, blue channel values.
  *  @param {number} r  The red value as a decimal number in the range 0 - 255. 
  *  @param {number} g  The green value as a decimal number in the range 0 - 255. 
  *  @param {number} b  The blue value as a decimal number in the range 0 - 255. 
  *  @type String
  *  @returns A new rgb(. . .) format string.
  */
DvtColorUtils.makeRGB = function(r,g,b)
{
   b = ((b === null || isNaN(b)) ? 0 : b);
   g = ((g === null || isNaN(g)) ? 0 : g);
   r = ((r === null || isNaN(r)) ? 0 : r);

   return  DvtColorUtils._RGB  + r + ',' + g + ',' + b + ')' ;
} ;


/*-------------------------------------------------------------------------*/
/*   makeRGBA()                                                            */
/*-------------------------------------------------------------------------*/
/**
  *  Creates an rgba(...) format string using the supplied red, green, blue,
  *   and alpha channel values.
  *  @param {number} r  The red value as a decimal number in the range 0 - 255. 
  *  @param {number} g  The green value as a decimal number in the range 0 - 255. 
  *  @param {number} b  The blue value as a decimal number in the range 0 - 255. 
  *  @param {number} a  The alpha value as a decimal number in the range 0 - 1.
  *                  If omitted, 1 is assumed.
  *  @type String
  *  @returns A new rgba(. . .) format string.
  */
DvtColorUtils.makeRGBA = function(r,g,b,a)
{
   b = ((b === null || isNaN(b)) ? 0 : b);
   g = ((g === null || isNaN(g)) ? 0 : g);
   r = ((r === null || isNaN(r)) ? 0 : r);
   a = ((a === null || isNaN(a)) ? 1 : a);

   return  DvtColorUtils._RGBA  + r + ',' + g + ',' + b + ',' + a + ')' ;
} ;


/*-------------------------------------------------------------------------*/
/*   makePound()                                                           */
/*-------------------------------------------------------------------------*/
/**
  *  Creates a #rrggbb format string using the supplied red, green and blue
  *  channel values.
  *  @param {number} r  The red value as a decimal number in the range 0 - 255. 
  *  @param {number} g  The green value as a decimal number in the range 0 - 255. 
  *  @param {number} b  The blue value as a decimal number in the range 0 - 255. 
  *  @type String
  *  @returns A new #rrggbb format string.
  */
DvtColorUtils.makePound = function(r,g,b)
{
  var rr = Math.round(r);
  var gg = Math.round(g);
  var bb = Math.round(b);
   var red   = rr.toString(16) ;
   var green = gg.toString(16) ;
   var blue  = bb.toString(16) ;

   return '#' + (red.length === 1  ? '0' : '') + red + (green.length === 1 ? '0' : '') + green +
                (blue.length === 1 ? '0' : '') + blue ;
} ;



/*-------------------------------------------------------------------------*/
/*   getPound()  Returns a "#rrggbb" string from a color string            */
/*              specification such as #rr[gg[bb[aa]]], rgba(...), rgb(...) */
/*-------------------------------------------------------------------------*/
/**
  *   Returns a "#rrggbb"  color string from the supplied color string. Formats
  *   accepted are the extended middle-tier "#aarrggbb" string, "rgba(r,g,b,a)",
  *   or an "rgb(r,g,b)". If a "#rrggbb" is supplied, the same object will be
  *   returned.  (See also {@link DvtColorUtils#makePound}.)
  *   @param {String} s  A color string specification.
  *   @returns {String}  a string of the format "#rrggbb".
  */
DvtColorUtils.getPound = function(s)
{
   var ret ;

   if (s.charAt(0) === '#') {

     var len = s.length ;

     if (len <= 7) {
       return s ;
     }
     else  {             // alpha specified (#aarrggbb) - middle-tier extended format
       ret = DvtColorUtils._POUND ;
       ret += s.substring(3, 5) + s.substring(5,7) + s.substring(7,9)  ;
     }
   }
   else {
     var r =  DvtColorUtils.getRed(s);
     var g =  DvtColorUtils.getGreen(s);
     var b =  DvtColorUtils.getBlue(s);
     ret   = DvtColorUtils.makePound(r,g,b) ;
   }

   return ret;

} ;



/*-------------------------------------------------------------------------*/
/*   getRGB()   Returns an rgb(rr,gg,bb) string from a color string        */
/*              specification such as #rr[gg[bb[aa]]], rgba(...), rgb(...) */
/*-------------------------------------------------------------------------*/
/**
  *   Returns an "rgb(r,g,b)"  color string from a supplied "#rrggbb" or
  *   extended middle-tier "#aarrggbb" string, or an rgb(r,g,b,a).
  *   If an "rgb(r,g,b)" is supplied, the same object will be returned.  (See also {@link DvtColorUtils#makePound}.)
  *   @param {String} s  A color string specification.
  *   @type String.
  */
DvtColorUtils.getRGB = function(s)
{
   var ret ;
   
   // If clr is a named color, then convert into usable format
   var namedColor = DvtColorUtils.getColorFromName(s);
   if(namedColor)
     s = namedColor;

   if (s.charAt(0) === '#') {
     ret = DvtColorUtils._RGB ;

     var len = s.length ;

     if (len > 7) {             // alpha specified (#aarrggbb) - middle-tier extended format
       ret += parseInt(s.substring(3, 5),16) + ","  +  parseInt(s.substring(5,7),16) + "," +
              parseInt(s.substring(7,9),16)  ;
     }
     else if (len === 7) {      // alpha not specified (#rrggbb)
       ret += parseInt(s.substring(1, 3),16) + "," + parseInt(s.substring(3,5),16) + "," + 
              parseInt(s.substr(5),16) ;
     }
     else if (len === 4) {      // #rgb
         var r = s.substring(1, 2);
             r += r ;
         var g = s.substring(2, 3);
             g += g ;
         var b = s.substring(3);
             b += b ;
             
         ret += parseInt(r,16) + "," + parseInt(g,16) + "," + parseInt(b, 16) ;
     }
     else if (len === 5) {      // #rrgg
         ret += parseInt(s.substring(1, 3),16) + "," + parseInt(s.substring(3,5),16) + ",0,1" ;
     }
     else if (len === 3) {      // #rr
         ret += parseInt(s.substring(1, 3),16) + ",0,0,1" ;
     }
     
     ret += ')' ;
   }
   else if (s.substr(0,5) === DvtColorUtils._RGBA) {
     var x = s.lastIndexOf(',') ;
     ret = DvtColorUtils._RGB ;
     ret += s.substring(5, x);
     ret += ')' ;
   }
   else {
     ret = s ;
   }
   return ret;

} ;




/*-------------------------------------------------------------------------*/
/*   getRGBA()  Returns an rgba(rr,gg,bb,aa) string from a color string    */
/*              specification such as #rr[gg[bb[aa]]], rgb(...), rgba(...) */
/*-------------------------------------------------------------------------*/
/**
  *   Returns an "rgba(r,g,b,a)"  color string from a supplied "#rrggbb" or
  *   extended middle-tier "#aarrggbb" string.  Will also accept an rgb(r,g,b)
  *   string (in which case the implied alpha is 1).  If an "rgba(r,g,b,a)" is
  *   supplied, the same object will be returned.  (See also {@link DvtColorUtils#makePound}.)
  *   @param {String} s  A color string specification.
  *   @type String.
  */
DvtColorUtils.getRGBA = function(s)
{
   var ret ;
   
   // If clr is a named color, then convert into usable format
   var namedColor = DvtColorUtils.getColorFromName(s);
   if(namedColor)
     s = namedColor;

   if (s.charAt(0) === '#') {
     ret = DvtColorUtils._RGBA ;

     var len = s.length ;

     if (len > 7) {             // alpha specified (#aarrggbb)
       ret += parseInt(s.substring(3, 5),16) + ","  +  parseInt(s.substring(5,7),16) + "," +
              parseInt(s.substring(7,9),16)  + ","  + (parseInt(s.substring(1, 3),16)/255)  ;
     }
     else if (len === 7) {      // alpha not specified (#rrggbb)  - alpha of 1 is assumed
       ret += parseInt(s.substring(1, 3),16) + "," + parseInt(s.substring(3,5),16) + "," + 
              parseInt(s.substr(5),16)  + ",1" ;
     }
     else if (len === 5) {      // #rrgg
         ret += parseInt(s.substring(1, 3),16) + "," + parseInt(s.substring(3,5),16) + ",0,1" ;
     }
     else if (len === 4) {      // #rgb
         var r = s.substring(1, 2);
             r += r ;
         var g = s.substring(2, 3);
             g += g ;
         var b = s.substring(3);
             b += b ;
             
         ret += parseInt(r,16) + "," + parseInt(g,16) + "," + parseInt(b, 16) + ",1" ;
     }
     else if (len === 3) {      // #rr
         ret += parseInt(s.substring(1, 3),16) + ",0,0,1" ;
     }
     
     ret += ')' ;
   }
   else if (s.substr(0,4) === DvtColorUtils._RGB) {
     ret = DvtColorUtils._RGBA ;
     ret += s.substring(4, s.length -1) + ',1)';
   }
   else {
     ret = s ;
   }
   return ret;

} ;


/*-------------------------------------------------------------------------*/
/*  _setChannel()     Replaces a channel in an rgb or rgba string.  (Note: */
/*                    if an alpha channel is added and an rgb string was   */
/*                    supplied, the string is changed to an rgba string.)  */
/*-------------------------------------------------------------------------*/
/**
  *  Returns a new color String with the specifed channel value set.
  *  If an alpha channel is requested and a # or rgb string is supplied,
  *  an rgba(...) string is returned.
  *  @private
  *  @param {String} s     A color specification to be changed.
  *  @param {number} chan  The channel to be changed.
  *  @param {number} chval The new channel value (as a decimal number).
  *  @type {String}
  */
DvtColorUtils._setChannel = function(s, chan, chval)
{
   if ((chan === undefined) || (chval === undefined) || (chan < DvtColorUtils._RED) || (chan > DvtColorUtils._ALPHA)) {
     return s ;
   }
   
   // If named color, then convert into usable format
   var namedColor = DvtColorUtils.getColorFromName(s);
   if(namedColor)
     s = namedColor;

   var  ar ;
   var  bPound = (s.charAt(0) === '#') ;
   var  bRGBA ;
   var ret ;
   if (bPound) {
     ar = [] ;
     ar.push(parseInt(s.substr(1,2), 16)) ;
     ar.push(parseInt(s.substr(3,2), 16)) ;
     ar.push(parseInt(s.substr(5,2), 16)) ;
     if (chan === DvtColorUtils._ALPHA) {
       ar.push(chval) ;
       bPound = false ;
       bRGBA  = true ;
     }
   } 
   else {
     var  bRGBA = (s.substr(0,5) === DvtColorUtils._RGBA);
     var x1     = s.indexOf('(') ;
     var x2     = s.indexOf(')') ;
     var ar     = s.substring(x1+1, x2).split(',') ;

     if ((! bRGBA) && chan === DvtColorUtils._ALPHA) {
       ar.push(chval) ;
       bRGBA = true ;
     }
   }

   ar[chan] = chval ;

   if (bPound) {
     ret = DvtColorUtils.makePound(ar[0],ar[1],ar[2]) ;
   }
   else {
      ret = (bRGBA?  DvtColorUtils.makeRGBA(ar[0],ar[1],ar[2], ar[3]) :
                     DvtColorUtils.makeRGB(ar[0],ar[1],ar[2])) ;
   }
   return ret ;
   
} ;


/*-------------------------------------------------------------------------*/
/*   setRGB()                                                              */
/*-------------------------------------------------------------------------*/
/**
  *  Returns a string of the same format as the input string, with the red, green,
  *  and blue channels replaced.
  *  @param {String}  s  The input string.
  *  @param {number}  r  The red value as a decimal number. 
  *  @param {number}  g  The green value as a decimal number. 
  *  @param {number}  b  The blue value as a decimal number. 
  *  @type String
  *  @returns A new color string of the same format as the input string, with
  *  the new color values.
  */
DvtColorUtils.setRGB = function(s, r, g, b)
{
   b = ((b === null || isNaN(b)) ? 0 : b);
   g = ((g === null || isNaN(g)) ? 0 : g);
   r = ((r === null || isNaN(r)) ? 0 : r);

   if (s.charAt(0) === '#')
   {
      return DvtColorUtils.makePound(r, g, b);
   }

   var  bRGBA = (s.substr(0,5) === DvtColorUtils._RGBA);

   var ret = (bRGBA? DvtColorUtils._RGBA : DvtColorUtils._RGB) + r + ',' + g + ',' + b ;

   if (bRGBA) {
     var x1 = s.lastIndexOf(5,',') ;
     var x2 = s.indexOf(')') ;

     ret += ',' + s.substring(x1+1, x2) ;
   }
   ret += ')' ;
   return ret ;
} ;




/**
  * Returns a brighter color of the supplied color based on a percentage factor.
  * @param {String} color   A color specification.
  * @param {number} factor  An optional percentage by which the color is to be brightened
  *                         lightened (0 returns unchanged) specified as a decimal
  *                         (e.g. 25% = 0.25).  If omitted, a default percentage of
  *                         15% (i.e 0.15) is applied.
  * @type String
  * @returns  A new color string brightened by the factor <code>uint</code> containing the new color value.
  */
DvtColorUtils.getBrighter = function(color, factor)
{
   var  r = DvtColorUtils._getChannel(color, DvtColorUtils._RED);
   var  g = DvtColorUtils._getChannel(color, DvtColorUtils._GREEN);
   var  b = DvtColorUtils._getChannel(color, DvtColorUtils._BLUE);
   var  a = DvtColorUtils._getChannel(color, DvtColorUtils._ALPHA);

   if (! factor) {
     factor = DvtColorUtils._FACTOR ;    // use default factor
   }

   // From 2D group:
   // 1. black.brighter() should return grey
   // 2. applying brighter to blue will always return blue, brighter
   // 3. non pure color (non zero rgb) will eventually return white
   
   var i = parseInt(1.0 / (1.0 - factor));
   if (r === 0 && g === 0 && b ===0) {
     //if factor=.5, then this only creates a color of rgb(2,2,2),
     //which is still black, so instead, just use the factor times white
     //return DvtColorUtils.makeRGBA(i, i, i, a);
     var newI = parseInt(255 * factor);
     return DvtColorUtils.makeRGBA(newI, newI, newI, a);
   }
   
   if (r > 0 && r < i) {
     r = i;
   }
   if (g > 0 && g < i) {
     g = i;
   }
   if (b > 0 && b < i) {
     b = i;
   }
   
   r = Math.min(parseInt(r / factor), 255);
   g = Math.min(parseInt(g / factor), 255);
   b = Math.min(parseInt(b / factor), 255);

   return DvtColorUtils.makeRGBA(r, g, b, a);
};
 
/**
 * Returns the hsl values for a color with the given rgb.
 * @param {number} r The r value, on a scale from 0 to 255
 * @param {number} g The g value, on a scale from 0 to 255
 * @param {number} b The b value, on a scale from 0 to 255
 * @return {object} The object containing the h, s, and l fields.  The h field is on a scale from 0 to 360, and the s 
 *                  and l fields are on a scale from 0 to 1.
 */
DvtColorUtils.rgb2hsl = function(r, g, b) {
  // Scale rgb to be from 0 to 1
  r /= 255;
  g /= 255;
  b /= 255;
  
  var max = Math.max(r, g, b)
  var min = Math.min(r, g, b);
  var sum = max + min;
  
  var h, s;
  var l = sum/2;

  if (max == min) {
    h = 0;
    s = 0;
  }
  else {
    var diff = max - min;
    s = l > 0.5 ? diff/(2 - sum) : diff/sum;
    
    if(max == r)
      h = (g - b)/diff + (g < b ? 6 : 0);
    else if(max == g)
      h = (b - r)/diff+2;
    else if(max == b)
      h = (r - g)/diff+4;
    
    h /= 6;
  }

  return {h:h*360, s:s, l:l};
}

/**
 * Returns the rgb values for a color with the given hsl.
 * @param {number} h The h value, on a scale from 0 to 360
 * @param {number} s The s value, on a scale from 0 to 1
 * @param {number} l The l value, on a scale from 0 to 1
 * @return {object} The object containing the r, g, and b fields on a scale from 0 to 255.
 */
DvtColorUtils.hsl2rgb = function(h, s, l) {
  // Scale h to be from 0 to 1
  h /= 360;

  var r, g, b;
  if (s == 0)
    r = g = b = l;
  else {
    var q = l < 0.5 ? l * (1+s) : l + s - (l*s);
    var p = 2 * l - q;
    r = DvtColorUtils._hue2rgb(p, q, h + 1/3);
    g = DvtColorUtils._hue2rgb(p, q, h);
    b = DvtColorUtils._hue2rgb(p, q, h - 1/3);
  }

  return {r: r * 255, g: g * 255, b: b * 255};
}

/**
 * @private
 */
DvtColorUtils._hue2rgb = function(p, q, t) {
  if (t < 0)
    t += 1;
  else if (t > 1)
    t -= 1;
    
  if (t < 1/6)
    return p + (q-p) * 6 * t;
  else if (t < 1 / 2)
    return q;
  else if (t < 2 / 3)
    return p + (q-p) * (2/3 - t) * 6;
  else 
    return p;
}

/**
  * Converts an HSV color to RGB.
  * 
  * @param (number) hue hue of the HSV color
  * @param (number) sat saturation of the HSV color
  * @param (number) val value of the HSV color
  * 
  * @type object
  * @returns an object defining r,g,b for the color
  */
DvtColorUtils.hsv2rgb = function(hue, sat, val)
{
  var red;
  var grn;
  var blu; 
  var i; 
  var f; 
  var p; 
  var q; 
  var t;
  
  hue %= 360;
  if (val == 0)
  {
    return (
    {
      r : 0, g : 0, v : 0
    });
  }
  sat /= 100;
  val /= 100;
  hue /= 60;
  i = Math.floor(hue);
  f = hue - i;
  p = val * (1 - sat);
  q = val * (1 - (sat * f));
  t = val * (1 - (sat * (1 - f)));
  if (i == 0)
  {
    red = val;
    grn = t;
    blu = p;
  }
  else if (i == 1)
  {
    red = q;
    grn = val;
    blu = p;
  }
  else if (i == 2)
  {
    red = p;
    grn = val;
    blu = t;
  }
  else if (i == 3)
  {
    red = p;
    grn = q;
    blu = val;
  }
  else if (i == 4)
  {
    red = t;
    grn = p;
    blu = val;
  }
  else if (i == 5)
  {
    red = val;
    grn = p;
    blu = q;
  }
  red = Math.floor(red * 255);
  grn = Math.floor(grn * 255);
  blu = Math.floor(blu * 255);
  return ({r : red, g : grn, b : blu});
}



/**
  * Converts an RGB color to HSV.
  * 
  * @param (number) red red of the RGB color
  * @param (number) grn green of the RGB color
  * @param (number) blu blue of the RGB color
  * 
  * @type object
  * @returns an object defining h,s,v for the color
  */
DvtColorUtils.rgb2hsv = function(red, grn, blu)
{
  var x;
  var val;
  var f;
  var i;
  var hue;
  var sat;
  
  red /= 255;
  grn /= 255;
  blu /= 255;
  x = Math.min(red, grn, blu);
  val = Math.max(red, grn, blu);
  if (x == val)
  {
    return ({h : undefined, s : 0, v : val * 100});
  }
  f = (red == x) ? grn - blu : ((grn == x) ? blu - red : red - grn);
  i = (red == x) ? 3 : ((grn == x) ? 5 : 1);
  hue = Math.floor((i - f / (val - x)) * 60) % 360;
  sat = Math.floor(((val - x) / val) * 100);
  val = Math.floor(val * 100);
  return ({h : hue, s : sat, v : val});
};

 

/**
  * Returns a pastel color using the supplied color based on a ratio.
  *
  *
  * @param (String) color  A color specification.
  * @param (number) factor An optional percentage by which to apply the pastel effect (0 returns unchanged) 
  *                        specified as a decimal (e.g., 25% = 0.25).  If omitted, the default percentage of 
  *                        15% (i.e., 0.15) is applied.
  *
  * @return A <code>uint</code> containing the new color value.
  */
DvtColorUtils.getPastel = function(color, factor)
{
  // TDO
  var a = DvtColorUtils._getChannel(color, DvtColorUtils._ALPHA) ;
  var r = DvtColorUtils._getChannel(color, DvtColorUtils._RED) ;
  var g = DvtColorUtils._getChannel(color, DvtColorUtils._GREEN) ;
  var b = DvtColorUtils._getChannel(color, DvtColorUtils._BLUE) ; ;

  var gR = Math.min(r + parseInt((255 - r) * factor), 255) ;
  var gG = Math.min(g + parseInt((255 - g) * factor), 255) ;
  var gB = Math.min(b + parseInt((255 - b) * factor), 255) ;
   
  return DvtColorUtils.makeRGBA( gR, gG, gB, a ) ;    
     
};

/**
 * Returns a color whose lightness has been adjusted by the specified amount.
 * @param {string} color The original color.
 * @param {number} dh The change in hue.
 * @param {number} ds The change in saturation.
 * @param {number} dl The change in lightness.
 * @return {string} The adjusted color.
 */
DvtColorUtils.adjustHSL = function(color, dh, ds, dl) 
{
  // Break down in rgb
  var r = DvtColorUtils._getChannel(color, DvtColorUtils._RED) ;
  var g = DvtColorUtils._getChannel(color, DvtColorUtils._GREEN) ;
  var b = DvtColorUtils._getChannel(color, DvtColorUtils._BLUE) ;
    
  // Get the color as HSL
  var hslColor = DvtColorUtils.rgb2hsl(r, g, b);
  
  // Add the changes, bounded to the min and max for each value
  var h = Math.min(Math.max(0, hslColor.h + dh), 360);
  var s = Math.min(Math.max(0, hslColor.s + ds), 1);
  var l = Math.min(Math.max(0, hslColor.l + dl), 1);
  
  // Convert back to rgba and return
  var rgbColor = DvtColorUtils.hsl2rgb(h, s, l);
  return DvtColorUtils.makePound(rgbColor.r, rgbColor.g, rgbColor.b);
}

/**
  * Interpolate a color between the original and destination values for the 
  * given percent.
  * @param  origVal  original color value, a string
  * @param  destVal  destination color value, a string
  * @param {number}  percent  percent value to interpolate
  */
DvtColorUtils.interpolateColor = function(origVal, destVal, percent)
{
    var oldR = DvtColorUtils.getRed(origVal);
    var oldG = DvtColorUtils.getGreen(origVal);
    var oldB = DvtColorUtils.getBlue(origVal);
    var oldA = DvtColorUtils.getAlpha(origVal);

    var destR = DvtColorUtils.getRed(destVal);
    var destG = DvtColorUtils.getGreen(destVal);
    var destB = DvtColorUtils.getBlue(destVal);
    var destA = DvtColorUtils.getAlpha(destVal);

    var newR = Math.round(DvtMath.interpolateNumber(oldR, destR, percent));
    var newG = Math.round(DvtMath.interpolateNumber(oldG, destG, percent));
    var newB = Math.round(DvtMath.interpolateNumber(oldB, destB, percent));
    var newA = Math.round(DvtMath.interpolateNumber(oldA, destA, percent));

    return DvtColorUtils.makeRGBA(newR, newG, newB, newA);
};

DvtColorUtils.inferColor = function(baseColor1, baseColor2, newColor1) {
  if (baseColor1 == baseColor2) {
    return newColor1;
  }

  if (newColor1 == baseColor1) {
    return baseColor2;
  }

  var red;
  var divisor = DvtColorUtils.getRed(baseColor1);
  var dividend = DvtColorUtils.getRed(baseColor2);
  if (divisor == dividend) {
    red = DvtColorUtils.getRed(newColor1);
  }
  else {
    if (divisor == 0) {
      divisor = 1;
    }
    red = dividend / divisor * DvtColorUtils.getRed(newColor1);
  }
  var green;
  divisor = DvtColorUtils.getGreen(baseColor1);
  dividend = DvtColorUtils.getGreen(baseColor2);
  if (divisor == dividend) {     
    green = DvtColorUtils.getGreen(newColor1);
  }
  else {
    if (divisor == 0) {
      divisor = 1;
    }
    green = dividend / divisor * DvtColorUtils.getGreen(newColor1);
  }
  var blue;
  divisor = DvtColorUtils.getBlue(baseColor1);
  dividend = DvtColorUtils.getBlue(baseColor2);
  if (divisor == dividend) {
    blue = DvtColorUtils.getBlue(newColor1);
  }
  else {
    if (divisor == 0) {
      divisor = 1;
    }
    blue = dividend / divisor * DvtColorUtils.getBlue(newColor1);
  }
  //return (0xffffff & (red << 16)) + (0xffff & (green << 8)) + (0xff & blue);
  return DvtColorUtils.makePound(red, green, blue);
}

/**
 * Returns a contrasting text color for the specified background color.
 * @param {string} backgroundColor The background color.
 * @return {string} A constrasting color for use on text.
 */
DvtColorUtils.getContrastingTextColor = function(backgroundColor) {
  var r = DvtColorUtils.getRed(backgroundColor);
  var g = DvtColorUtils.getGreen(backgroundColor);
  var b = DvtColorUtils.getBlue(backgroundColor);
  var yiq = (r*299 + g*587 + b*114)/1000;
  return (yiq >= 128) ? "#000000" : "#FFFFFF";
}
// Copyright (c) 2008, 2013, Oracle and/or its affiliates. 
// All rights reserved. 

/**
  *  @class DvtClipPath
  *  Defines a clipping region composed of the union of one or more outlines.
  *  @param {String} prefix  An optional prefix for the clip path id.
  *  @constructor
  */
var DvtClipPath = function(prefix)
{
   /** Id of the clip path. @type String  */
   this._id = (prefix ? prefix+'$' : '') + 'cp' + DvtClipPath._uniqueSeed++;
   /** the clipping outline  @type Object  */
   this._regions  = [] ;
} ;

DvtObj.createSubclass(DvtClipPath, DvtObj, "DvtClipPath");

DvtClipPath._uniqueSeed = 0;

//  Clipping path outlines

/**  @final  @type number  */
DvtClipPath.NONE    = 0 ;
/**  @final  @type number  */
DvtClipPath.RECT    = 1 ;
/**  @final  @type number  */
DvtClipPath.PATH    = 2 ;
/**  @final  @type number  */
DvtClipPath.POLYGON = 3 ;
/**  @final  @type number  */
DvtClipPath.ELLIPSE = 4 ;
/**  @final  @type number  */
DvtClipPath.CIRCLE = 5 ;

/**
  *   @private
  */
DvtClipPath.prototype._addRegion = function(obj)
{
   if (obj)
    this._regions.push(obj);
};


/**
  *   Returns the ID of the clip path
  *   @returns {String}  The ID of the clip path
  */ 

DvtClipPath.prototype.getId = function()
{
   return this._id ;
};

/**
 *   Returns a  clipping region outline object (by index).
 *   @type Object
 */

DvtClipPath.prototype.getRegions = function(idx)
{
  return this._regions ;
};

/**
  *  Adds a rectangular clipping region to the clip path.
  *  @param {number}  x   The top left x position of the rectangular region.
  *  @param {number}  y   The top left y position of the rectangular region.
  *  @param {number}  w   The width of the rectangular region.
  *  @param {number}  h   The height of the rectangular region.
  *  @param {number}  rx  Optional x-axis radius of the ellipse used to round off the cornders of the rectangle.
  *  @param {number}  ry  Optional y-axis radius of the ellipse used to round off the cornders of the rectangle.
  */ 
DvtClipPath.prototype.addRect = function(x, y, w, h, rx, ry)
{
   var obj  = {} ;
   obj.type = DvtClipPath.RECT ;
   obj.x    = x ;
   obj.y    = y ;
   obj.w    = w ;
   obj.h    = h ;
   obj.rx   = rx ;
   obj.ry   = ry ;
   this._addRegion(obj);
};

/**
  *  Adds a circular clipping region to the clip path.
  *  @param {number}  cx  The x-axis coordinate of the center of the circle.
  *  @param {number}  cy  The y-axis coordinate of the center of the circle.
  *  @param {number}  r   The radius of the circle.
  */ 
DvtClipPath.prototype.addCircle = function(cx, cy, r)
{
   var obj  = {} ;
   obj.type = DvtClipPath.CIRCLE ;
   obj.cx   = cx ;
   obj.cy   = cy ;
   obj.r    = r ;
   this._addRegion(obj);
};

/**
  *  Adds an ellipse clipping region to the clip path.
  *  @param {number}  cx  The x-axis coordinate of the center of the circle.
  *  @param {number}  cy  The y-axis coordinate of the center of the circle.
  *  @param {number}  rx  The x-axis radius of the ellipse.
  *  @param {number}  ry  The y-axis radius of the ellipse.
  */ 
DvtClipPath.prototype.addEllipse = function(cx, cy, rx, ry)
{
  var obj  = {} ;
   obj.type = DvtClipPath.ELLIPSE ;
   obj.cx   = cx ;
   obj.cy   = cy ;
   obj.rx   = rx ;
   obj.ry   = ry ;
   this._addRegion(obj);
};

/**
  *  Adds a polygon clipping region to the clip path.
  *  @param {string}  points  The points that make up the polygon.
  */ 
DvtClipPath.prototype.addPolygon = function(points)
{
  var obj  = {} ;
  obj.type = DvtClipPath.POLYGON ;
  obj.points   = points ;
  this._addRegion(obj);
};

/**
  *  Adds a path clipping region to the clip path.
  *  @param {string}  d  Path data.
  */ 
DvtClipPath.prototype.addPath = function(d)
{
  var obj  = {} ;
  obj.type = DvtClipPath.PATH ;
  obj.d   = d ;
  this._addRegion(obj);
};
// Copyright (c) 2008, 2011, Oracle and/or its affiliates. 
// All rights reserved. 
/*-------------------------------------------------------------------------*/
/*   DvtFill                                                               */
/*-------------------------------------------------------------------------*/
/**
  * A base class for shape fills. DvtFill is intended to be subclassed (e.g.
  * {@link DvtSolidFill}).
  * @extends DvtBaseDrawEffect
  * @class DvtFill  is a base class for shape fill specifications.  DvtFill is intended to be subclassed (e.g.
  * {@link DvtSolidFill}).
  * @constructor  Do not create/use directly.  
  * @param {String} id  Optional ID for the object (see also {@link DvtBaseDrawEffect#setId}). 
  */
var  DvtFill = function()
{
   this._Init() ;
};

DvtObj.createSubclass(DvtFill, DvtLockable, "DvtFill");


//  Fill type definitions

/**   @final @type number  */
DvtFill.NONE     = 0 ;            // No fill specified.
/**   @final @type number  */
DvtFill.COLOR    = 1 ;            // Solid color fill. 
/**   @final @type number  */
DvtFill.GRADIENT = 2 ;            // Gradient fill.
/**   @final @type number  */
DvtFill.PATTERN  = 3 ;            // Pattern fill.
/**   @final @type number  */
DvtFill.IMAGE    = 4 ;            // Image fill.

/** 
 * @private 
 */
DvtFill.prototype._Init = function() {
  DvtFill.superclass._Init.call(this) ;
}

/**
 *   Returns the id of this draw effect.
 *   @type String
 */
DvtFill.prototype.getId = function () {
  return this._id;
}

/**
 *   Sets the id of this fill.
 *   @param {String} id  The id for the fill.
 */
DvtFill.prototype.setId = function (id) {
  this._id = id;
}
// Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
/**
  * A shape fill class rendering a solid fill color.
  * @constructor
  * @param {String} fc  A css color specification for the fill color.
  * @param {String} fa  An optional alpha. Can be used to supplement the alpha specified by the fill color.  If omitted, the alpha specifed
  *                     by the fill color (or 1 if it does not specify an alpha) is used.
 */
var  DvtSolidFill = function(fc, fa)
{
   this._Init(fc, fa) ;
};

DvtObj.createSubclass(DvtSolidFill, DvtFill, "DvtSolidFill") ;

DvtSolidFill._INVISIBLE_FILL;

/**
  *  Returns an (unlocked) copy of this object.
  *  @type DvtSolidFill
  */
DvtSolidFill.prototype.clone = function()
{
   var o = new DvtSolidFill() ;

   this.mergeProps(o) ;    // merge properties into cloned obj.

   return o ;
};

/** 
 * Helper method to initialize this object.
  * @param {String} fc  A css color specification for the fill color.
  * @param {String} fa  An optional alpha. Can be used to supplement the alpha specified by the fill color.  If omitted, the alpha specifed
  *                     by the fill color (or 1 if it does not specify an alpha) is used.
 * @private 
 */
DvtSolidFill.prototype._Init = function(fc, fa)
{
   DvtSolidFill.superclass._Init.call(this) ;
   this._fc  = fc ;
   this._fa  = fa != null ? fa : 1;
};

/**
  *  Returns the fill's solid color (and alpha).
  *  @type String
  */
DvtSolidFill.prototype.getColor = function()
{
   return  this._fc ;
} ;

/**
  *  Sets the fill color.
  *  @param  {String} fc  A color specification. 
  *  e.g.  #123456, &nbsp; rgb(128,42,200), &nbsp; rgba(28, 128, 56, 0.7)
  *  &nbsp;or &nbsp;'green'&nbsp; or&nbsp; 'none'
  */
DvtSolidFill.prototype.setColor = function(fc)
{
   if (! this.isLocked()) {
     this._fc = fc ;
   }
} ;

/**
  *  Returns the fill's solid color alpha channel value in the range 0 (invisible) to 1 (opaque).
  *  @type number
  */
DvtSolidFill.prototype.getAlpha = function()
{
   return this._fa ;
};

/**
  *  Sets the fill alpha.
  *  @param {number} alpha  A value between 0 (invisible) and 1 (opaque).
  */
DvtSolidFill.prototype.setAlpha = function(alpha)
{
   if (! this.isLocked()) {
     this._fa = alpha ;
   }
};

/**
  *   Merges the fill properties in the current object into the supplied fill
  *   object.
  *   Used internally by clone().
  *   @private
  */
DvtSolidFill.prototype.mergeProps = function(obj)
{
   DvtSolidFill.superclass.mergeProps.call(this, obj) ;   // merge in subclass props

   obj._fc  = this._fc ;   // color
   obj._fa  = this._fa ;   // alpha
};

/**
 * Returns an instance of DvtSolidFill that is invisible and can be used for event detection.
 * @return {DvtSolidFill}
 */
DvtSolidFill.invisibleFill = function() {
  if (!DvtSolidFill._INVISIBLE_FILL) 
    DvtSolidFill._INVISIBLE_FILL = new DvtSolidFill("rgba(0,0,0,0)");
  return DvtSolidFill._INVISIBLE_FILL;
}
// Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
/*-------------------------------------------------------------------------*/
/*   DvtStroke                 Base stroke properties                      */
/*-------------------------------------------------------------------------*/
/**
  * An abstract base class representing stroke properties.  
  * @class DvtStroke
  * @extends DvtObj
  * @constructor
  * @param {number} sw  The width of the stroke line.  If omitted, default is 1.
  * @param {String} id  Optional ID for the object (see also {@link DvtBaseDrawEffect#setId}). 
  */
var  DvtStroke = function(sw, id)
{
   this._Init(sw, id) ;
};

DvtObj.createSubclass(DvtStroke, DvtLockable, "DvtStroke");

/**
  * Stroke Types
  */
DvtStroke.SOLID         = 0 ;
DvtStroke.DASHED        = 1 ;
DvtStroke.DOTTED        = 2 ;
DvtStroke.DASHED_DOTTED = 3 ;

/**
  * Stroke joins
  */
DvtStroke.SQUARE = 'square' ;
DvtStroke.ROUND  = 'round' ;
DvtStroke.BEVEL  = 'bevel' ;
DvtStroke.MITER  = 'miter';

/**
  * Stroke endings
  */
//DvtSTROKE.SQUARE  ;     // same as for join
//DvtSTROKE.ROUND   ;     //  ..   .  ..  ..
DvtStroke.BUTT    = 'butt' ;

/**
 * Converts the specified stroke type string to its constant value.
 * @param {string} shape The stroke type.
 * @return {number} The corresponding constant value.
 */
DvtStroke.convertTypeString = function(type) {
  if(type == "solid")
    return DvtStroke.SOLID;
  else if(type == "dashed")
    return DvtStroke.DASHED;
  else if(type == "dotted")
    return DvtStroke.DOTTED;
  else
    return DvtStroke.SOLID;
}




/*-------------------------------------------------------------------------*/
/*   _Init()                                                               */
/*-------------------------------------------------------------------------*/
/** @private */
DvtStroke.prototype._Init = function(sw)
{
   this._sw   = ((sw === null || isNaN(sw)) ? 1 : sw);    // stroke_width

   DvtStroke.superclass._Init.call(this) ;
   this._bFixedWidth = false;
};

/**
 *   Returns the id of this draw effect.
 *   @type String
 */
DvtStroke.prototype.getId = function () {
  return this._id;
}

/**
 *   Sets the id of this fill.
 *   @param {String} id  The id for the fill.
 */
DvtStroke.prototype.setId = function (id) {
  this._id = id;
}


/*-------------------------------------------------------------------------*/
/*   mergeProps()                                                          */
/*-------------------------------------------------------------------------*/

DvtStroke.prototype.mergeProps = function(to)
{
   to._sw   = this._sw ;      // stroke width
   to._st   = this._st ;      // stroke type (solid, dashed, etc)
   to._sd   = this._sd ;      // dash details 
   to._sdo  = this._sdo;      // dash offset
   to._sj   = this._sj ;      // line join style
   to._se   = this._se ;      // line ending style
   to._sm   = this._sm ;      // miter limit
   to._bFixedWidth = this._bFixedWidth ;

   DvtStroke.superclass.mergeProps.call(this, to) ;
} ;


/*-------------------------------------------------------------------------*/
/*   setStyle()                                                            */
/*-------------------------------------------------------------------------*/
/**
  *  Sets the stroke style (e.g solid line, or intermittent line, and optionally
  *  the stroke join type and the line ending type). Null may be used to ignore
  *  any argument.
  *  <p>
  *  Dashed line examples :<br><br><code>   
  *  // 3 pixel dash followed by a 3 pixel gap<br><br>
  *  obj.setStyle(DvtStroke.DASHED, "3");<br><br>
  *  // 5 pixel dash, 3 pixel gap, 9 pixel dash, 2 pixel gap.  The pattern then repeats
  *  to fill the line<br><br>
  *  obj.setStyle(DvtStroke.DASHED, "5,3,9,2");
  *
  *  @param {number} type  DvtStroke.SOLID or DvtStroke.DASHED.
  *  @param {String} dashsize  For dashed lines, specifies the dash and space size.
  *                            The string contains a list of numbers separated by commas
  *                            or whitespace, specifying dash length and gaps. The list
  *                            should have an even number of entries, but if an odd number
  *                            is used the list will be repeated so that the entry count is even.
  *  @param {String} join  Specifies the type of line join.  May be DvtStroke.SQUARE,
  *                        DvtStroke.ROUND, DvtStroke.BEVEL, or DvtStroke.MITER.
  *  @param {String} end   Specifies the type of line end.  May be DvtSTROKE.SQUARE,
  *                        DvtSTROKE.ROUND, or DvtStroke.BUTT.
  *  @param {number} miter miter limit when join is DvtStroke.MITER
  */
DvtStroke.prototype.setStyle = function(type, dashsize, join, end, miter)
{
   if (this.isLocked()) {
     return ;
   }

   //  Line-type attributes

   if (type && !dashsize)
     dashsize = DvtStroke.getDefaultDash(type, this._sw);

   this._st = type ;
   this._sd = dashsize ;
   

   //  Line-joining attributes

   if (join) {
     this._sj = join ;
   } 

   //  Line-ending attributes

   if (end) {
     this._se = end ;
   } 

   //  miter limit attributes

   if (miter) {
     this._sm = miter ;
   } 

} ;


DvtStroke.prototype.getDash = function()
{
   return this._sd ;
};

DvtStroke.prototype.getDashOffset = function()
{
   return this._sdo ;
};


DvtStroke.prototype.getLineJoin = function()
{
   return this._sj ;
};

DvtStroke.prototype.setLineJoin = function(join)
{
   if (! this.isLocked()) {
     this._sj = join ;
   }
};

DvtStroke.prototype.getLineEnd = function()
{
   return this._se ;
};

DvtStroke.prototype.setLineEnd = function(end)
{
   if (! this.isLocked()) {
     this._se = end ;
   }
};

DvtStroke.prototype.getMiterLimit = function()
{
   return this._sm ;
};

DvtStroke.prototype.setMiterLimit = function(limit)
{
   if (! this.isLocked()) {
     this._sm = limit ;
   }
};


/*-------------------------------------------------------------------------*/
/*   get/setType()     Gets/Sets the type of stroke (e.g. solid or dashed  */
/*-------------------------------------------------------------------------*/

DvtStroke.prototype.getType = function()
{
   return this._st ;
};

//  dash size is optional.  May also specify alternating sizes  e.g. "3, 5, 3"
/**
  *  Sets the type of the stroke.
  *  @param {number} type  The stroke type, such as {@link DvtStroke#DASHED}. 
  *  @param {number} dashsize  Optional dash details if the stroke type is not {@link DvtStroke#SOLID}.
  *  @param {number} dashoffset  Optional dash offset if the stroke type is not {@link DvtStroke#SOLID}.
  */
DvtStroke.prototype.setType = function(type, dashsize, dashoffset)
{
   if (this.isLocked()) {
     return ;
   }

   if (type === DvtStroke.SOLID) {
     dashsize = null ;
     dashoffset = null;
   }
   else  if (! dashsize) {
     dashsize = DvtStroke.getDefaultDash(type, this._sw);
   }

   this._st  = type ;
   this._sd  = dashsize ;
   this._sdo = dashoffset;

} ;


/*-------------------------------------------------------------------------*/
/*   get/setWidth()                                                        */
/*-------------------------------------------------------------------------*/
/**
  *  Returns the stroke width.
  *  @type number
  */
DvtStroke.prototype.getWidth = function()
{
   return this._sw ;
} ;

/**
  *  Sets the stroke width.
  *  @param {number} sw  The stroke width.
  */
DvtStroke.prototype.setWidth = function(sw)
{
 if (! this.isLocked()) {
   this._sw = sw ;
 }
} ;

DvtStroke.prototype.setFixedWidth = function(bFixedWidth)
{
   this._bFixedWidth = bFixedWidth;
}

DvtStroke.prototype.isFixedWidth = function()
{
   return this._bFixedWidth ;
}

/**
 * Gets a default dash size based on the stroke type and stroke width.
 * @return {string} dash size string, e.g. "6,3,4,3"
 */
DvtStroke.getDefaultDash = function(type, width) {
  width = Math.ceil(width);
  var dashSize = Math.max(6, width * 2); // dash is at least 6px
  var dotSize = Math.max(2, width); // dot is at least 2px
  var dashDotGap = Math.floor((dashSize + dotSize) / 2);
  
  if (type == DvtStroke.DASHED)
    return "" + dashSize;
  if (type == DvtStroke.DOTTED)
    return "" + dotSize;
  if (type == DvtStroke.DASHED_DOTTED)
    return "" + dashSize + "," + dashDotGap + "," + dotSize + "," + dashDotGap; 
  else
    return null;
}
// Copyright (c) 2008, 2013, Oracle and/or its affiliates. 
// All rights reserved. 
/*---------------------------------------------------------------------------*/
/*    DvtGradientStroke            Gradient stroke definition class          */
/*---------------------------------------------------------------------------*/
/*  Can be used to share a gradient definition among several shapes, or as a */
/*  convenience to maintain a gradient definition separately from a shape.   */
/*---------------------------------------------------------------------------*/
/**
  *   Creates a gradient specification (shareable by other shapes).
  *   @extends DvtStroke
  *   @class
  *   @constructor
  *   @param {Array} arColors  An array of color specifications (which do not include alpha values).
  *   @param {Array} arAlphas  An optional array of alpha values (between 0 and 1).  If omitted,
  *                            alphas of 1 are assumed.
  *   @param {Array} arStops   An optional array of stop boundary positions (between 0 and 1).
  *                            If omitted, an equal distribution of colors is assumed.
  *   @param {Array} arBounds  An optional bounding box array (x, y, w, h).
  *   @param {number} sw       Stroke width
  *   @param {String} id
  */
var  DvtGradientStroke = function(arColors, arAlphas, arStops, arBounds, sw, id)
{
   this._Init(arColors, arAlphas, arStops, arBounds, sw, id) ;
};


DvtObj.createSubclass(DvtGradientStroke, DvtStroke, "DvtGradientStroke") ;




/**
 * Return the first alpha in the alphas array
 * 
 * @return {number}
 */
DvtGradientStroke.prototype.getAlpha = function()
{
  return 1;
}

/**
  *   Returns an array of alpha's.
  *   @type Array
  */
DvtGradientStroke.prototype.getAlphas = function()
{
   return  this._arAlphas ;
} ;
/**
  *   Returns the bounding box for the gradient as an array (x, y, w, h).
  *   @type Array
  */
DvtGradientStroke.prototype.getBounds = function()
{
   return  this._arBounds ;
} ;

/**
  *   Returns an array of colors.
  *   @type Array
  */
DvtGradientStroke.prototype.getColors = function()
{
   return  this._arColors ;
} ;

/**
  *   Returns an array of stop ratios.
  *   @type Array
  */
DvtGradientStroke.prototype.getStops = function()
{
   return  this._arStops ;
} ;



/*---------------------------------------------------------------------------*/
/*    _Init()                                                                */
/*---------------------------------------------------------------------------*/
/**
  *  @private
  */
DvtGradientStroke.prototype._Init = function(arColors, arAlphas, arStops, arBounds, sw, id)
{
   DvtGradientStroke.superclass._Init.call(this, sw, id) ;

   this._arColors = arColors ;
   this._arBounds = arBounds ;

   var len = 0;
   if (arColors) {
     len = arColors.length - 1;
   }

   if (! arAlphas) {
     arAlphas = DvtGradientStroke.createDefaultAlphas(len);
   }
   this._arAlphas = arAlphas ;

   if (! arStops) {     // if no stops, generate default stops
                        // for a uniform distribution of colors.
      arStops = DvtGradientStroke.createDefaultStops(len) ;
   }

   this._arStops = arStops ;
} ;

/**
 * @param {number} size
 * @return {Array} An array with size number of elements, with each element equal to 1, or null if size 
 *                  is less than 0.
 */
DvtGradientStroke.createDefaultAlphas = function(size)
{
  if(size < 0)
    return null;
    
  var arAlphas = [] ;
  for (var i = 0; i < size; i++) 
  {
    arAlphas.push(1) ;
  }
  return arAlphas;
}

/**
 * Creates a uniformly distributed range of gradient stops
 * 
 * @param {number} numStops
 * @return {Array}
 */
 DvtGradientStroke.createDefaultStops = function(numStops)
 {
  var arStops = [] ;
  var  incr   = 1/numStops ;
  var curStop = 0 ;

  do {
    arStops.push(curStop) ;
    curStop += incr ;
  } while ( --numStops > 0) ;
  arStops.push(1) ;   
  
  return arStops;
 }

/*-------------------------------------------------------------------------*/
/*   mergeProps()                                                          */
/*-------------------------------------------------------------------------*/
/**
  *   Merges the gradient properties in the current object into the supplied gradient object.
  *   Used internally by clone().
  *   @private
  */
DvtGradientStroke.prototype.mergeProps = function(obj)
{
   obj._arColors = this._arColors ;
   obj._arStops  = this._arStops ;
   obj._arAlphas = this._arAlphas ;
   obj._arBounds = this._arBounds ;

   DvtGradientStroke.superclass.mergeProps.call(this, obj) ;
};
// Copyright (c) 2008, 2012, Oracle and/or its affiliates. 
// All rights reserved. 
/*---------------------------------------------------------------------------*/
/*    DvtLinearGradientStroke       Linear Gradient stroke class             */
/*---------------------------------------------------------------------------*/
/**
  *   Creates a linear gradient stroke.
  *   @extends DvtGradientStroke
  *   @class
  *   <p>
  *   <b>Example usage:</b><br><br><code>
  *
  *   //  Fill rectangle with a left-to-right gradient of red through blue to green.<br> 
  *   //  The colors are evenly graduated because the stop values have been omitted.<br><br> 
  *   rect.setStroke(<b>new DvtLinearGradientStroke(0, ['red', 'green, 'blue']</b>) ;<br><br>
  *
  *   //  Fill rectangle with a north-east direction gradient of red to green
  *   with an unequal gradient distribution of colors.<br><br> 
  *   rect.setStroke(<b>new DvtLinearGradientStroke(45, ['red', 'green], [0, 0.75,1]</b>) ;<br><br>

  *   @constructor
  *   @param {number} angle  Specifies the direction of the gradient as an
  *                          angle in degrees (using the standard anti-clockwise convention
  *                           for positive angles, i.e. 0 = horizontal and 90 = vertically up, etc).
  *   @param {Array} arColors  An array of color specifications (which do not include alpha values).
  *   @param {Array} arColors  An optional array of alpha values (between 0 and 1).  If omitted,
  *                            alphas of 1 are assumed.
  *   @param {Array} arStops   An optional array of stop boundary positions (between 0 and 1).
  *                            If omitted, an equal distribution of colors is assumed.
  *   @param {Array} arBounds  An optional bounding box array (x, y, w, h).
  *   @param {number} sw    An optional number for stroke width. 
  *   @param {String} id
  */
var  DvtLinearGradientStroke = function(angle, arColors, arAlphas, arStops, arBounds, sw, id)
{
   this._Init(angle, arColors, arAlphas, arStops, arBounds, sw, id) ;
};

DvtObj.createSubclass(DvtLinearGradientStroke, DvtGradientStroke, "DvtLinearGradientStroke") ;



/*---------------------------------------------------------------------------*/
/*    clone()                                                                */
/*---------------------------------------------------------------------------*/
/**
  *  Returns an (unlocked) copy of this object.
  *  @type DvtLinearGradientStroke
  */
DvtLinearGradientStroke.prototype.clone = function()
{
   var o = new DvtLinearGradientStroke() ;

   this.mergeProps(o) ;    // merge properties into cloned obj.
   return o ;
};



/*---------------------------------------------------------------------------*/
/*     Init()                                                                */
/*---------------------------------------------------------------------------*/
/**
  *  @private
  */
DvtLinearGradientStroke.prototype._Init = function(angle, arColors, arAlphas, arStops, arBounds, sw, id)
{
   DvtLinearGradientStroke.superclass._Init.call(this, arColors, arAlphas, arStops, arBounds, sw, id) ;

   this._angle = ((angle === null || isNaN(angle)) ? 0 : angle);
} ;



/*---------------------------------------------------------------------------*/
/*   getAngle()    Returns the gradient angle property for linear gradients  */
/*                 see also setAngle().                                      */
/*---------------------------------------------------------------------------*/
/**
  *  Gets the angle of the gradient in degrees.
  *  @type number
  *  @returns The angle of the gradient in degrees.  The zero degree direction is
  *  left-to-right (due east). Positive angles rotate anti-clockwise, and negative
  *  angles rotate clockwise.
  */
DvtLinearGradientStroke.prototype.getAngle = function()
{
    return this._angle ;
} ;


/*-------------------------------------------------------------------------*/
/*   mergeProps()                                                          */
/*-------------------------------------------------------------------------*/
/**
  *   Merges the linear gradient properties in the current object into the
  *   DvtLinearGradientStroke object.
  *   Used internally by clone().
  *   @private
  */
DvtLinearGradientStroke.prototype.mergeProps = function(obj)
{
   DvtLinearGradientStroke.superclass.mergeProps.call(this, obj) ;

   obj._angle  = this._angle ;      // gradient angle
};



/*---------------------------------------------------------------------------*/
/*   setAngle()         Set the gradient angle for linear gradients          */
/*---------------------------------------------------------------------------*/
//  Be default, the gradient angle is zero (due east).  Angles greater
// than zero rotate anti-clockwise.  Angles less than zero rotate clockwise.

/**
  * Sets the angle of the gradient in degrees.  The zero degree direction is
  * left-to-right (due east). Positive angles rotate anti-clockwise, and negative
  * angles rotate clockwise.
  * @param {number} The gradient direction in degrees.
  */
DvtLinearGradientStroke.prototype.setAngle = function(degrees)
{
   if (this.isLocked()) {
     return ;
   }

   if (degrees !== 0) {
     if (Math.abs(degrees) > 360) {
       degrees %= 360 ;
     }
     this._angle = degrees ;
   }
} ;

// Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
/**
  * A class representing the stroke properties for a solid line.
  * @param {String} sc  A css color specification for the stroke color.
  * @param {String} sa  An optional alpha. Can be used to supplement the alpha specified by the stroke color.  
  *                     If omitted, the alpha specifed by the stroke color (or 1 if it does not specify an alpha) is used.
  * @param {number} sw  The width of the stroke line.  If omitted, the default width is 1.
  */
var  DvtSolidStroke = function(sc, sa, sw)
{
   this._Init(sc, sa, sw) ;
};

DvtObj.createSubclass(DvtSolidStroke, DvtStroke, "DvtSolidStroke") ;


/**
  *  Returns an (unlocked) copy of this stroke object.
  *  @type DvtSolidStroke
  */
DvtSolidStroke.prototype.clone = function()
{
   var o = new DvtSolidStroke() ;

   this.mergeProps(o) ;    // merge properties into cloned obj.
   return o ;
};

/** 
 * Helper method to initialize this object.
  * @param {String} sc  A css color specification for the stroke color.
  * @param {String} sa  An optional alpha. Can be used to supplement the alpha specified by the stroke color.  
  *                     If omitted, the alpha specifed by the stroke color (or 1 if it does not specify an alpha) is used.
  * @param {number} sw  The width of the stroke line.  If omitted, the default width is 1.
 * @private 
 */
DvtSolidStroke.prototype._Init = function(sc, sa, sw)
{
   this._sc = sc ;
   this._sa = sa != null ? sa : 1;
   this._st = DvtStroke.SOLID ;
   DvtSolidStroke.superclass._Init.call(this, sw) ;
};

/**
  *  Returns the stroke alpha as a value between 0 (invisible) and 1 (opaque).
  *  @type {number}
  */
DvtSolidStroke.prototype.getAlpha = function()
{
   return this._sa;
};

/**
  *  Sets the stroke alpha.
  *  @param {number} alpha  A value between 0 (invisible) and 1 (opaque).
  */
DvtSolidStroke.prototype.setAlpha = function(alpha)
{
   if (! this.bLocked)
     this._sa = alpha ;
};

/**
  *  Returns the stroke color.
  *  @type String
  */
DvtSolidStroke.prototype.getColor = function()
{
   return this._sc ;
} ;

/**
  *  Sets the stroke color.
  *  @param {String}  sc  A css color specification. e.g.  '#123456',  'rgb(128,42,200)',
  *                       rgba(128,42,200,0.8), or 'green'
  */
DvtSolidStroke.prototype.setColor = function(sc)
{
   if (! this.bLocked)
     this._sc = sc ;
} ;

/**
  *   Merges the stroke properties in the current object into the supplied
  *   stroke object.
  *   Used internally by clone().
  *   @private
  */
DvtSolidStroke.prototype.mergeProps = function(obj)
{
   DvtSolidStroke.superclass.mergeProps.call(this, obj) ;   // merge in the subclass's props

   obj._sc  = this._sc ;      // stroke color
   obj._sa  = this._sa ;      // stroke alpha
};
// Copyright (c) 2011, 2012, Oracle and/or its affiliates. 
// All rights reserved. 
/*-------------------------------------------------------------------------*/
/*   DvtGlow                     Base glow effect                          */
/*-------------------------------------------------------------------------*/
/**
  * @class DvtGlow
  * Represents a glow effect.  The glow object properties are a superset of values, and 
  *                            each platform implementation should take those required
  *                            by that specfic platform.
  *                             
  * @constructor
  * @param {String} rgba  The color and transparency of the glow.  Default is rgb(255,255,255,1).
  * @param {number} blurX  The amount of horizontal blur. Valid values are 0.0 to 255.0  Default is 4.
  * @param {number} blurY  The amount of vertical blur (float). Valid values are 0.0 to 255.0  Default is 4.    
  * @param {number} strength  The strength of the imprint or spread. Default is 1.
  *                           Note: The higher the value, the more color is imprinted and the
  *                           stronger the contrast between the shadow and the background.
  *                           Valid values are from 0 to 255.
  * @param {number} quality  An integer number of times to apply the effect. Valid values are 0
  *                          to 15.  Default is 1.  Note: glows with lower values are rendered
  *                          more quickly. For most applications, a quality value of 1 (low), 2
  *                          (medium), or 3 (high) is sufficient.  Although you can use additional     
  *                          numeric values up to 15 to achieve different effects, higher values
  *                          are rendered more slowly. Instead of increasing the value of quality,
  *                          you can often get a similar effect, and with faster rendering, by
  *                          simply increasing the values of the blurX and blurY properties.              
  * @param {Boolean} inner  A boolean value indicating whether or not the glow is an inner glow.
  *                         A true value specifies an inner glow. False specifies an outer glow 
  *                         (a glow around the outer edges of the object).  Default is false.
  * @param {Boolean} knockout  Applies a knockout effect if true which effectively makes the object's  
  *                         fill transparent, and reveals the background color of the document.
  *                         Default is false.
  *
  */
var DvtGlow = function(rgba, blurX, blurY, strength, 
                        quality, inner, knockout)

{
   this.Init(rgba, blurX, blurY, strength, 
             quality, inner, knockout) ;
} ;


DvtObj.createSubclass(DvtGlow, DvtBaseDrawEffect, "DvtGlow");


DvtGlow._uniqueId = 1 ;

/** 
  * @protected
  */
DvtGlow.prototype.Init = function(rgba, blurX, blurY, strength,
                                   quality, inner, knockout)
{
  DvtGlow.superclass._Init.call(this) ;
  
  // The type of this draw effect, used in Flash to differentiate between filter effects
  this.__type = "glow";
  
  this._rgba       = (rgba ? rgba : "rgba(255,255,255,1)");
  this._blurX      = ((blurX === null || isNaN(blurX)) ? 4 : blurX);
  this._blurY      = ((blurY === null || isNaN(blurY)) ? 4 : blurY);
  this._strength   = ((strength === null || isNaN(strength)) ? 1 : strength);
  this._quality    = ((quality === null || isNaN(quality)) ? 1 : quality);
  this._bInner     = (inner ? true : false) ;
  this._bKnockout  = (knockout ? true : false) ;
  this._Id         = 'dg' + (DvtGlow._uniqueId++) ;
};

/**
  *  Returns an (unlocked) copy of this object.
  *  @type DvtGlow
  */
DvtGlow.prototype.clone = function()
{
   var o = new DvtGlow() ;

   this.mergeProps(o) ;    // merge properties into cloned obj.

   return o ;
};

/**
  *   Merges the fill properties in the current object into the supplied fill
  *   object.
  *   Used internally by clone().
  *   @private
  */
DvtGlow.prototype.mergeProps = function(obj)
{
   DvtGlow.superclass.mergeProps.call(this, obj) ;   // merge in subclass props

   obj._rgba = this._rgba;
   obj._blurX = this._blurX;
   obj._blurY = this._blurY;
   obj._strength = this._strength;
   obj._quality = this._quality;
   obj._bInner = this._bInner;
   obj._bKnockout = this._bKnockout;
   obj._Id = this._Id;
};
// Copyright (c) 2008, 2012, Oracle and/or its affiliates. 
// All rights reserved. 
/*-------------------------------------------------------------------------*/
/*   DvtShadow                     Base drop shadow                        */
/*-------------------------------------------------------------------------*/
/**
  * @class DvtShadow
  * Represents a drop shadow.  The shadow object properties are a superset of values, and 
  *                            each platform implementation should take those required
  *                            by that specfic platform.
  *                             
  * @constructor
  * @param {number} sw  The width of the stroke line.  If omitted, default is 1.
  * @param {String} id  Optional ID for the object (see also {@link DvtBaseDrawEffect#setId}). 
  * @param {String} rgba  The color and transparency of the shadow.  Default is      0x59333333.
  * @param {number} distance The offset distance for the shadow, in pixels.   Default is 4.
  * @param {number} strength  The strength of the imprint or spread. Default is 1.
  *                           Note: The higher the value, the more color is imprinted and the
  *                           stronger the contrast between the shadow and the background.
  *                           Valid values are from 0 to 255.0               
  * @param {number} angle  The angle of the shadow. Valid values are 0.0 to 360.0 degrees.  Default is 45 deg.                
  * @param {number} blurX  The amount of horizontal blur. Valid values are 0.0 to 255.0  Default is 4.                                    
  * @param {number} blurY  The amount of vertical blur (float). Valid values are 0.0 to 255.0  Default is 4.                                       
  * @param {number} quality  An integer number of times to apply the effect. Valid values are 0
  *                          to 15.  Default is 1.  Note: shadows with lower values are rendered
  *                          more quickly. For most applications, a quality value of 1 (low), 2
  *                          (medium), or 3 (high) is sufficient.  Although you can use additional     
  *                          numeric values up to 15 to achieve different effects, higher values
  *                          are rendered more slowly. Instead of increasing the value of quality,
  *                          you can often get a similar effect, and with faster rendering, by
  *                          simply increasing the values of the blurX and blurY properties.              
  * @param {Boolean} inner  A boolean value indicating whether or not the shadow is an inner shadow.
  *                         A true value specifies an inner shadow. False specifies an outer shadow 
  *                         (a shadow around the outer edges of the object).
  * @param {Boolean} knockout  Applies a knockout effect if true which effectively makes the object's  
  *                         fill transparent, and reveals the background color of the document.                                                 
  * @param {Boolean} hide   A value indicating whether or not the object is hidden. A true value
  *                         indicates that the object itself is not drawn; only the shadow is visible.    
  *                         If false, the object is shown.                                                     
  *
  */
var  DvtShadow = function(rgba, distance, blurX, blurY, angle, strength,
                          quality,inner,knockout,hide)

{
   this._Init(rgba, distance, blurX, blurY, angle, strength, quality,inner,knockout,hide) ;
} ;


DvtObj.createSubclass(DvtShadow, DvtBaseDrawEffect, "DvtShadow");


DvtShadow._uniqueId = 1 ;

/*-------------------------------------------------------------------------*/
/*   _Init()                                                               */
/*-------------------------------------------------------------------------*/
/** @private */
DvtShadow.prototype._Init = function(rgba, distance, blurX, blurY, angle, strength,
                                     quality,inner,knockout,hide)
{
  DvtShadow.superclass._Init.call(this) ;
  
  // The type of this draw effect, used in Flash to differentiate between filter effects
  this.__type = "shadow";

   this._rgba       = (rgba ? rgba : "rgba(48,48,48,0.35)");
   this._distance   = ((distance === null || isNaN(distance)) ?  4 : distance);

   this._strength   = ((strength === null || isNaN(strength)) ? 1 : strength);
   this._blurX      = ((blurX === null || isNaN(blurX)) ? 4 : blurX);
   this._blurY      = ((blurY === null || isNaN(blurY)) ? 4 : blurY);
   this._angle      = ((angle === null || isNaN(angle)) ? 45 : angle);
   this._quality    = ((quality === null || isNaN(quality)) ? 1 : quality);
   this._bInner     = (inner ? true : false);
   this._bKnockout  = false ;
   this._bHide      = false ;
   this._Id         = 'ds' + DvtShadow._uniqueId++ ;
};

/**
  *  Returns an (unlocked) copy of this object.
  *  @type DvtShadow
  */
DvtShadow.prototype.clone = function()
{
   var o = new DvtShadow() ;

   this.mergeProps(o) ;    // merge properties into cloned obj.

   return o ;
};

/**
  *   Merges the fill properties in the current object into the supplied fill
  *   object.
  *   Used internally by clone().
  *   @private
  */
DvtShadow.prototype.mergeProps = function(obj)
{
   DvtShadow.superclass.mergeProps.call(this, obj) ;   // merge in subclass props

   obj._rgba = this._rgba;
   obj._distance = this._distance;
   obj._strength = this._strength;
   obj._blurX = this._blurX;
   obj._blurY = this._blurY;
   obj._angle = this._angle;
   obj._quality = this._quality;
   obj._bInner = this._bInner;
   obj._bKnockout = this._bKnockout;
   obj._bHide = this._bHide;
   obj._Id = this._Id;
};


// Copyright (c) 2008, 2011, Oracle and/or its affiliates. 
// All rights reserved. 
/*---------------------------------------------------------------------------*/
/*    DvtGradientFill            Gradient fill definition class              */
/*---------------------------------------------------------------------------*/
/*  Can be used to share a gradient definition among several shapes, or as a */
/*  convenience to maintain a gradient definition separately from a shape.   */
/*---------------------------------------------------------------------------*/
/**
  *   Creates a gradient specification (shareable by other shapes).
  *   @extends DvtFill
  *   @class
  *   @constructor
  *   @param {Array} arColors  An array of color specifications (which do not include alpha values).
  *   @param {Array} arColors  An optional array of alpha values (between 0 and 1).  If omitted,
  *                            alphas of 1 are assumed.
  *   @param {Array} arStops   An optional array of stop boundary positions (between 0 and 1).
  *                            If omitted, an equal distribution of colors is assumed.
  *   @param {Array} arBounds  An optional bounding box array (x, y, w, h).
  */
var  DvtGradientFill = function(arColors, arAlphas, arStops, arBounds)
{
   this._Init(arColors, arAlphas, arStops, arBounds) ;
};


DvtObj.createSubclass(DvtGradientFill, DvtFill, "DvtGradientFill") ;





/**
  *   Returns an array of alpha's.
  *   @type Array
  */
DvtGradientFill.prototype.getAlphas = function()
{
   return  this._arAlphas ;
} ;
/**
  *   Returns the bounding box for the gradient as an array (x, y, w, h).
  *   @type Array
  */
DvtGradientFill.prototype.getBounds = function()
{
   return  this._arBounds ;
} ;

/**
  *   Returns an array of colors.
  *   @type Array
  */
DvtGradientFill.prototype.getColors = function()
{
   return  this._arColors ;
} ;

/**
  *   Returns an array of stop ratios.
  *   @type Array
  */
DvtGradientFill.prototype.getStops = function()
{
   return  this._arStops ;
} ;



/*---------------------------------------------------------------------------*/
/*     Init()                                                                */
/*---------------------------------------------------------------------------*/
/**
  *  @private
  */
DvtGradientFill.prototype._Init = function(arColors, arAlphas, arStops, arBounds)
{
   DvtGradientFill.superclass._Init.call(this) ;

   this._arColors = arColors ;
   this._arBounds = arBounds ;

   var len = 0;
   if (arColors) {
       len = arColors.length - 1;
   }

   if (! arAlphas) {
     arAlphas = [] ;
     for (var i = 0; i < len; i++) {
        arAlphas.push(1) ;
     }
   }
   this._arAlphas = arAlphas ;

   if (! arStops) {     // if no stops, generate default stops
                        // for a uniform distribution of colors.
      arStops = [] ;
      var  incr   = (len > 0) ? 1/len : 0 ;
      var curStop = 0 ;

      do {
         arStops.push(curStop) ;
         curStop += incr ;
      } while ( --len > 0) ;
      arStops.push(1) ;
   }

   this._arStops = arStops ;
} ;



/*-------------------------------------------------------------------------*/
/*   mergeProps()                                                          */
/*-------------------------------------------------------------------------*/
/**
  *   Merges the gradient properties in the current object into the supplied gradient object.
  *   Used internally by clone().
  *   @private
  */
DvtGradientFill.prototype.mergeProps = function(obj)
{
   obj._arColors = this._arColors ;
   obj._arStops  = this._arStops ;
   obj._arAlphas = this._arAlphas ;
   obj._arBounds = this._arBounds ;

   DvtGradientFill.superclass.mergeProps.call(this, obj) ;
};
// Copyright (c) 2008, 2012, Oracle and/or its affiliates. 
// All rights reserved. 
/*---------------------------------------------------------------------------*/
/*    DvtLinearGradientFill       Linear Gradient fill class                     */
/*---------------------------------------------------------------------------*/
/**
  *   Creates a linear gradient fill.
  *   @extends DvtGradientFill
  *   @class
  *   <p>
  *   <b>Example usage:</b><br><br><code>
  *
  *   //  Fill rectangle with a left-to-right gradient of red through blue to green.<br> 
  *   //  The colors are evenly graduated because the stop values have been omitted.<br><br> 
  *   rect.setFill(<b>new DvtLinearGradientFill(0, ['red', 'green, 'blue']</b>) ;<br><br>
  *
  *   //  Fill rectangle with a north-east direction gradient of red to green
  *   with an unequal gradient distribution of colors.<br><br> 
  *   rect.setFill(<b>new DvtLinearGradientFill(45, ['red', 'green], [0, 0.75,1]</b>) ;<br><br>

  *   @constructor
  *   @param {number} angle  Specifies the direction of the gradient as an
  *                          angle in degrees (using the standard anti-clockwise convention
  *                           for positive angles, i.e. 0 = horizontal and 90 = vertically up, etc).
  *   @param {Array} arColors  An array of color specifications (which do not include alpha values).
  *   @param {Array} arColors  An optional array of alpha values (between 0 and 1).  If omitted,
  *                            alphas of 1 are assumed.
  *   @param {Array} arStops   An optional array of stop boundary positions (between 0 and 1).
  *                            If omitted, an equal distribution of colors is assumed.
  *   @param {Array} arBounds  An optional bounding box array (x, y, w, h).
  */
var  DvtLinearGradientFill = function(angle, arColors, arAlphas, arStops, arBounds)
{
   this._Init(angle, arColors, arAlphas, arStops, arBounds) ;
};

DvtObj.createSubclass(DvtLinearGradientFill, DvtGradientFill, "DvtLinearGradientFill") ;



/*---------------------------------------------------------------------------*/
/*    clone()                                                                */
/*---------------------------------------------------------------------------*/
/**
  *  Returns an (unlocked) copy of this object.
  *  @type DvtLinearGradientFill
  */
DvtLinearGradientFill.prototype.clone = function()
{
   var o = new DvtLinearGradientFill() ;

   this.mergeProps(o) ;    // merge properties into cloned obj.
   return o ;
};



/*---------------------------------------------------------------------------*/
/*     Init()                                                                */
/*---------------------------------------------------------------------------*/
/**
  *  @private
  */
DvtLinearGradientFill.prototype._Init = function(angle, arColors, arAlphas, arStops, arBounds)
{
   DvtLinearGradientFill.superclass._Init.call(this, arColors, arAlphas, arStops, arBounds) ;

   this._angle = ((angle === null || isNaN(angle)) ? 0 : angle) ;
} ;



/*---------------------------------------------------------------------------*/
/*   getAngle()    Returns the gradient angle property for linear gradients  */
/*                 see also setAngle().                                      */
/*---------------------------------------------------------------------------*/
/**
  *  Gets the angle of the gradient in degrees.
  *  @type number
  *  @returns The angle of the gradient in degrees.  The zero degree direction is
  *  left-to-right (due east). Positive angles rotate anti-clockwise, and negative
  *  angles rotate clockwise.
  */
DvtLinearGradientFill.prototype.getAngle = function()
{
    return this._angle ;
} ;


/*-------------------------------------------------------------------------*/
/*   mergeProps()                                                          */
/*-------------------------------------------------------------------------*/
/**
  *   Merges the linear gradient properties in the current object into the
  *   DvtLinearGradientFill object.
  *   Used internally by clone().
  *   @private
  */
DvtLinearGradientFill.prototype.mergeProps = function(obj)
{
   DvtLinearGradientFill.superclass.mergeProps.call(this, obj) ;

   obj._angle  = this._angle ;      // gradient angle
};



/*---------------------------------------------------------------------------*/
/*   setAngle()         Set the gradient angle for linear gradients          */
/*---------------------------------------------------------------------------*/
//  Be default, the gradient angle is zero (due east).  Angles greater
// than zero rotate anti-clockwise.  Angles less than zero rotate clockwise.

/**
  * Sets the angle of the gradient in degrees.  The zero degree direction is
  * left-to-right (due east). Positive angles rotate anti-clockwise, and negative
  * angles rotate clockwise.
  * @param {number} The gradient direction in degrees.
  */
DvtLinearGradientFill.prototype.setAngle = function(degrees)
{
   if (this.isLocked()) {
     return ;
   }

   if (degrees !== 0) {
     if (Math.abs(degrees) > 360) {
       degrees %= 360 ;
     }
     this._angle = degrees ;
   }
} ;

// Copyright (c) 2008, 2011, Oracle and/or its affiliates. 
// All rights reserved. 
/*---------------------------------------------------------------------------*/
/*    DvtImageFill            Image fill definition class                    */
/*---------------------------------------------------------------------------*/
/*  Can be used to share an image fill definition among several shapes, or   */
/*  as a convenience to maintain an image fill definition separately from a  */
/*  shape.                                                                   */
/*---------------------------------------------------------------------------*/
/**
  *   Creates an image fill specification (shareable by other shapes).
  *   @extends DvtFill
  *   @class
  *   @constructor
  *   @param {String} src  image source
  *   @param {dimension} bound  bounding box (x, y, w, h).
  *   @param {String} repeat  specify how background image is repeated.
  *                           valid values: repeat-x, repeat-y, repeat, no-repeat
  */
var DvtImageFill = function(src, bound, repeat)
{
  this._Init(src, bound, repeat) ;
};


DvtObj.createSubclass(DvtImageFill, DvtFill, "DvtImageFill") ;






/**
  *   Returns the bounding box for the image fill as (x, y, w, h).
  *   @type (x, y, w, h)
  */
DvtImageFill.prototype.getBound = function()
{
   return this._bound ;
} ;

/**
  *   Returns the image source
  *   @type String
  */
DvtImageFill.prototype.getSrc = function()
{
   return this._src ;
} ;

/**
  *   Returns how the image is repeated
  *   @type String
  */
DvtImageFill.prototype.getRepeat = function()
{
   return this._repeat ;
} ;


/*---------------------------------------------------------------------------*/
/*     Init()                                                                */
/*---------------------------------------------------------------------------*/
/**
  *  @private
  */
DvtImageFill.prototype._Init = function(src, bound, repeat)
{
   DvtImageFill.superclass._Init.call(this) ;

   this._src = src ;
   this._bound = bound ;
   this._repeat = repeat ;

} ;



/*-------------------------------------------------------------------------*/
/*   mergeProps()                                                          */
/*-------------------------------------------------------------------------*/
/**
  *   Merges the image fill properties in the current object into the 
  *   supplied image fill object.
  *   Used internally by clone().
  *   @private
  */
DvtImageFill.prototype.mergeProps = function(obj)
{
   obj._src = this._src ;
   obj._bound = this._bound ;
   obj._repeat = this._repeat ;

   DvtImageFill.superclass.mergeProps.call(this) ;
};
// Copyright (c) 2011, 2013, Oracle and/or its affiliates. 
// All rights reserved. 
/*---------------------------------------------------------------------------*/
/*    DvtPatternFill            Pattern definition class                     */
/*---------------------------------------------------------------------------*/
/*  Can be used to share a pattern definition among several shapes, or as a  */
/*  convenience to maintain a pattern definition separately from a shape.    */
/*---------------------------------------------------------------------------*/
/**
 *   Creates a pattern specification (shareable by other shapes).
 *   @extends DvtFill
 *   @class
 *   @constructor
 *   @param {String} pattern  constant for the type of pattern
 *   @param {String} fillColor  color of the pattern
 *   @param {String} backgroundColor  background color of the pattern
 */
var DvtPatternFill = function(pattern, fillColor, backgroundColor)
{
  this.Init(pattern, fillColor, backgroundColor);
};


DvtObj.createSubclass(DvtPatternFill, DvtFill, "DvtPatternFill");


/**   @final @type String  */
DvtPatternFill.SM_DIAG_UP_LT = "sDUL";
/**   @final @type String  */
DvtPatternFill.LG_DIAG_UP_LT = "lDUL";
/**   @final @type String  */
DvtPatternFill.SM_DIAG_UP_RT = "sDUR";
/**   @final @type String  */
DvtPatternFill.LG_DIAG_UP_RT = "lDUR";
/**   @final @type String  */
DvtPatternFill.SM_CROSSHATCH = "sC";
/**   @final @type String  */
DvtPatternFill.LG_CROSSHATCH = "lC";
/**   @final @type String  */
DvtPatternFill.SM_CHECK = "sCh";
/**   @final @type String  */
DvtPatternFill.LG_CHECK = "lCh";
/**   @final @type String  */
DvtPatternFill.SM_TRIANGLE_CHECK = "sTCh";
/**   @final @type String  */
DvtPatternFill.LG_TRIANGLE_CHECK = "lTCh";
/**   @final @type String  */
DvtPatternFill.SM_DIAMOND_CHECK = "sDCh";
/**   @final @type String  */
DvtPatternFill.LG_DIAMOND_CHECK = "lDCh";

/**
 *  @protected
 */
DvtPatternFill.prototype.Init = function(pattern, fillColor, backgroundColor)
{
  DvtPatternFill.superclass._Init.call(this);

  this._pattern = (pattern ? DvtPatternFill._convertPatternValue(pattern) : DvtPatternFill.SM_DIAG_UP_LT);
  this._fillColor = (fillColor ? fillColor : "#000000");
  this._backgroundColor = (backgroundColor ? backgroundColor : "#ffffff");
};

/**
 *   Returns the type of pattern
 *   @type String
 */
DvtPatternFill.prototype.getPattern = function()
{
  return this._pattern;
};

/**
 *   Returns the color of the pattern
 *   @type String
 */
DvtPatternFill.prototype.getColor = function()
{
  return this._fillColor;
};

/**
 *   Returns the background color of the pattern
 *   @type String
 */
DvtPatternFill.prototype.getBackgroundColor = function()
{
  return this._backgroundColor;
};

/**
 *   Merges the pattern properties in the current object into the supplied
 *   pattern object.
 *   Used internally by clone().
 *   @private
 */
DvtPatternFill.prototype.mergeProps = function(obj)
{
  obj._pattern = this._pattern;
  obj._fillColor = this._fillColor;
  obj._backgroundColor = this._backgroundColor;

  DvtPatternFill.superclass.mergeProps.call(this);
};

/**
 * Return the transformation matrix applied to this container.
 *  @type DvtMatrix
 *  @returns transformation matrix
 */
DvtPatternFill.prototype.getMatrix = function () {
  if (this._matrix)
    return this._matrix;

  return new DvtMatrix();
};

/**
 * Set the transformation matrix to apply to this container.
 *  When set, the matrix is locked so that it becomes immutable.
 *  To make changes, clone the matrix, apply changes to it, and then
 *  set the matrix again.
 *  @param {DvtMatrix} mat   The transformation matrix to apply.
 */
DvtPatternFill.prototype.setMatrix = function (mat) {    
  this._matrix = mat;
  
  // Lock the new matrix if it isn't already locked. 
  // The same matrix can be set on more than one object irregardless of locking.
  if (this._matrix && !this._matrix.isLocked())
    this._matrix.__lock();
    

};

/** 
 * Returns the pattern constant given the API string name for the pattern.  Returns the unmodified string if the value
 * is already a predefined constant or if it's not recognized.
 * @return {string}
 * @private 
 */
DvtPatternFill._convertPatternValue = function(patternStr) {
  if(patternStr == "smallDiagonalLeft")
    return DvtPatternFill.SM_DIAG_UP_LT;
  else if(patternStr == "largeDiagonalLeft")
    return DvtPatternFill.LG_DIAG_UP_LT;
  else if(patternStr == "smallDiagonalRight")
    return DvtPatternFill.SM_DIAG_UP_RT;
  else if(patternStr == "largeDiagonalRight")
    return DvtPatternFill.LG_DIAG_UP_RT;
  else if(patternStr == "smallCrosshatch")
    return DvtPatternFill.SM_CROSSHATCH;
  else if(patternStr == "largeCrosshatch")
    return DvtPatternFill.LG_CROSSHATCH;
  else if(patternStr == "smallChecker")
    return DvtPatternFill.SM_CHECK;
  else if(patternStr == "largeChecker")
    return DvtPatternFill.LG_CHECK;
  else if(patternStr == "smallTriangle")
    return DvtPatternFill.SM_TRIANGLE_CHECK;
  else if(patternStr == "largeTriangle")
    return DvtPatternFill.LG_TRIANGLE_CHECK;
  else if(patternStr == "smallDiamond")
    return DvtPatternFill.SM_DIAMOND_CHECK;
  else if(patternStr == "largeDiamond")
    return DvtPatternFill.LG_DIAMOND_CHECK;
  else
    return patternStr;
}
// Copyright (c) 2008, 2011, Oracle and/or its affiliates. 
// All rights reserved. 
/*---------------------------------------------------------------------------*/
/*    DvtRadialGradientFill       Radial Gradient fill class                 */
/*---------------------------------------------------------------------------*/
/**
  *   Creates a radial gradient specification (shareable by other shapes).
  *   @extends DvtGradientFill
  *   @class
  *   <p>
  *   <b>Example usage:</b><br><br><code>
  *
  *   //  Fill a circle with a radial gradient of red to green.<br><br> 
  *   circle.setFill(<b>new DvtRadialGradientFill(0, ['red', 'green]</b>) ;<br><br>
  *
  *   //  Fill rectangle with a north-east direction gradient of red to green
  *   with an unequal gradient distribution of colors.<br><br> 
  *   rect.setFill(<b>new DvtRadialGradientFill(45, ['red', 'green], [0, 0.75,1]</b>) ;<br><br>

  *   @constructor
  *   @param {number} radius 
  *   @param {Array} arColors  An array of color specifications (which do not include alpha values).
  *   @param {Array} arAlphas  An optional array of alpha values (between 0 and 1).  If omitted,
  *                            alphas of 1 are assumed.
  *   @param {Array} arStops   An optional array of stop boundary positions (between 0 and 1).
  *                            If omitted, an equal distribution of colors is assumed.
  *   @param {Number} cx       the radial gradient center x position.
  *   @param {Number} cy       the radial gradient center y position.
  *   @param {Number} r        the radius of the radial gradient.
  *   @param {Array} arBounds  An optional bounding box array (x, y, w, h).
  */
var  DvtRadialGradientFill = function(arColors, arAlphas, arStops, cx, cy, r, arBounds)
{
   this._Init(arColors, arAlphas, arStops, cx, cy, r, arBounds) ;
};

DvtObj.createSubclass(DvtRadialGradientFill, DvtGradientFill, "DvtRadialGradientFill") ;



/*---------------------------------------------------------------------------*/
/*    clone()                                                                */
/*---------------------------------------------------------------------------*/
/**
  *  Returns an (unlocked) copy of this object.
  *  @type DvtRadialGradientFill
  */
DvtRadialGradientFill.prototype.clone = function()
{
   var o = new DvtRadialGradientFill() ;

   this.mergeProps(o) ;    // merge properties into cloned obj.

   return o ;
};



/*---------------------------------------------------------------------------*/
/*    getRadius()                                                            */
/*---------------------------------------------------------------------------*/
/**
  *  Returns the radial-gradient radius.
  *  @type number
  */
DvtRadialGradientFill.prototype.getRadius = function()
{
    return this._r ;
};


/*---------------------------------------------------------------------------*/
/*    getCx()                                                                */
/*---------------------------------------------------------------------------*/
/**
  *  Returns the radial-gradient center x coordinate.
  *  @type number
  */
DvtRadialGradientFill.prototype.getCx = function()
{
    return this._cx ;
};


/*---------------------------------------------------------------------------*/
/*    getCy()                                                                */
/*---------------------------------------------------------------------------*/
/**
  *  Returns the radial-gradient center y coordinate.
  *  @type number
  */
DvtRadialGradientFill.prototype.getCy = function()
{
    return this._cy ;
};


/*---------------------------------------------------------------------------*/
/*     Init()                                                                */
/*---------------------------------------------------------------------------*/
/**
  *  @private
  */
DvtRadialGradientFill.prototype._Init = function(arColors, arAlphas, arStops, cx, cy, r, arBounds)
{
   DvtRadialGradientFill.superclass._Init.call(this, arColors, arAlphas, arStops, arBounds) ;

   this._cx = cx;
   this._cy = cy;
   this._r  = r;


} ;


/*-------------------------------------------------------------------------*/
/*   mergeProps()                                                          */
/*-------------------------------------------------------------------------*/
/**
  *   Merges the radial gradient properties in the current object into the
  *   supplied DvtRadialGradientFill object.
  *   Used internally by clone().
  *   @private
  */
DvtRadialGradientFill.prototype.mergeProps = function(obj)
{
   DvtRadialGradientFill.superclass.mergeProps.call(this, obj) ;

   obj._cx = this._cx ;
   obj._cy = this._cy ;
   obj._r  = this._r ;
};

// Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved.

/**
  *   Selection effect utilities.
  *   @class DvtSelectionEffectUtils
  *   @constructor
  */
var DvtSelectionEffectUtils = {};

DvtObj.createSubclass(DvtSelectionEffectUtils, DvtObj, "DvtSelectionEffectUtils");

/** 
 * @protected
 */
DvtSelectionEffectUtils.SEL_TYPE_STROKE_FILTERS  = 0;
/** 
 * @protected
 */
DvtSelectionEffectUtils.SEL_TYPE_STROKE_NO_FILTERS = 1;

/**
 * Get the border color to use for a selectable marker when the mouse hovers over it.
 * @param {String} color The color of the data marker.
 * @return String The resulting color. 
 * @private
 */
DvtSelectionEffectUtils._getHoverBorderColor = function(color)
{
  return DvtColorUtils.adjustHSL(color, 0, 0, 0.15);
}

/**
 * Apply a draw effect to a given displayable object.
 * 
 * @param {DvtDisplayable}  displayable  object to apply draw effect to
 * @param {DvtBaseDrawEffect}  drawEffect  effect to apply
 */
DvtSelectionEffectUtils.applyDrawEffect = function(displayable, drawEffect)
{
  var numEffects = displayable.getNumDrawEffects();
  if (numEffects == 0) {
    displayable.addDrawEffect(drawEffect);
  } else {
    var pos = displayable.getDrawEffectIndex(drawEffect);
    if (pos > -1) {
      displayable.removeDrawEffectAt(pos);
      displayable.addDrawEffectAt(drawEffect, pos);
    } else {
      displayable.addDrawEffect(drawEffect);
    }
  }
};

/**
 * Create a stroke to use when the mouse hovers over a selectable marker.
 * 
 * @param {String}  selColor  color of the data marker
 * 
 * @type DvtStroke
 */
DvtSelectionEffectUtils.createSelectingStroke = function(selColor)
{
  var stroke = new DvtSolidStroke(DvtSelectionEffectUtils._getHoverBorderColor(selColor), 1, 2);
  stroke.setMiterLimit(1); // Set low miter limit to avoid bits sticking out at corners of 3D bars, for example
  return stroke;
};

/**
 * Get the type of cursor to use when the mouse hovers over a selectable marker.
 * @return {string}
 */
DvtSelectionEffectUtils.getSelectingCursor = function()
{
  return "pointer";
};

/**
 * TODO JSONDOC: All this code needs to be ripped out, as it's just awful to rely on the private property access.
 */
DvtSelectionEffectUtils.applyHoverState = function(selectable, strokeColor)
{  
  if (selectable._bSelecting) {
    DvtSelectionEffectUtils._saveUpStrokeFill(selectable);
    var stroke = DvtSelectionEffectUtils.createSelectingStroke(strokeColor);
    selectable._savedHoverStroke = stroke;
    selectable._savedHoverFill = selectable._savedUpFill;
  } else {
    selectable._savedHoverStroke = selectable._savedUpStroke;
    selectable._savedHoverFill = selectable._savedUpFill;
  }

  DvtSelectionEffectUtils._applyHoverStrokeFill(selectable);
}
/**
 * Apply any selection effects to this object.
 * @param {DvtDisplayable} selectable
 * @param {string} dataColor The CSS color string of the primary color of the data item.
 * @param {string} innerColor The CSS color string of the inner color of the selection effect.
 * @param {string} outerColor The CSS color string of the outer color of the selection effect.
 */
DvtSelectionEffectUtils.applySelectionState = function(selectable, dataColor, innerColor, outerColor)
{
  var bUseSimpleEffects = innerColor || outerColor; // New selection effects used if either inner or outer colors are passed

  if(selectable._bSelected) 
    DvtSelectionEffectUtils._saveUpStrokeFill(selectable);
  
  if(selectable._bSelecting) {
    selectable._savedSelectionFill = selectable._savedHoverFill;
    selectable._savedSelectionStroke = selectable._savedHoverStroke;
  } else {
    // If not hovering, use the original fill and stroke
    selectable._savedSelectionFill = selectable._savedUpFill;
    selectable._savedSelectionStroke = selectable._savedUpStroke;
  }

  // Apply the selection effects
  if(selectable._selectionType == DvtSelectionEffectUtils.SEL_TYPE_STROKE_NO_FILTERS) {
    // No filter effects for older browsers
    if (selectable._bSelected) {
      selectable._savedSelectionStroke = new DvtSolidStroke(dataColor, 1, 2);
      selectable._savedSelectionFill = new DvtSolidFill("#ffffff", 1);
    }
  }
  else { 
    // Modern browsers with filter support
    // Create the selection effect filters if they don't already exist
    var filters = selectable._selectionEffects;
    if (!filters)
    {
      filters = [];
      
      // Inner Glow: Use slightly different params for backwards compatibility
      if(!innerColor) {
        innerColor = DvtSelectionEffectUtils._getHoverBorderColor(dataColor);
        filters.push(new DvtGlow(DvtColorUtils.setAlpha(innerColor, 1), 4, 4, 10, 3, true, false));
      }
      else // innerColor is defined, graph does not use this path
        filters.push(new DvtGlow(innerColor, 3, 3, 100, 100, true, false));
      
      // Outer Glow
      if(!outerColor && bUseSimpleEffects)
        outerColor = dataColor;
      else if(!outerColor)
        outerColor = "#000000";
      
      if(!outerColor) // backwards compatibility
        filters.push(new DvtGlow(DvtColorUtils.setAlpha(outerColor, 1), 2, 2, 20, 3, true, false));
      else // chart uses this path
        filters.push(new DvtGlow(DvtColorUtils.setAlpha(outerColor, 1), 2, 2, 7, 3, true, false));
      
      // Shadow
      if(selectable._bSelectedShadow)
        filters.push(new DvtShadow(DvtColorUtils.setAlpha("#05283f", .7), 2, 10, 7, 35, 1));
      
      selectable._selectionEffects = filters;
    }
    
    // Apply the filters if the object is selected, otherwise clear the filters
    var i;
    if(selectable._bSelected)
    {
      for (i=0; i<filters.length; i++)
      {
        DvtSelectionEffectUtils.applyDrawEffect(selectable, filters[i]);
      }
    }
    else
    {
      for (i=0; i<filters.length; i++)
      {
        selectable.removeDrawEffect(filters[i]);
      }
    }
  }
  
  // Update the fill and stroke
  var transferObj = new DvtSelectionEffectTransferObj();
  var stroke = null;
  var fill = null;

  if (selectable._bSelected) {
    stroke = selectable._savedSelectionStroke;
    fill = selectable._savedSelectionFill;
  } 
  else if (selectable._bSelecting) { // hover, not selected
    stroke = selectable._savedHoverStroke;
    fill = selectable._savedHoverFill;
  } 
  else { // neither hover nor selected
    stroke = selectable._savedUpStroke;
    fill = selectable._savedUpFill;
  }
    
  transferObj._fill = fill;
  transferObj._stroke = stroke;
  transferObj._applyFill = true;

  DvtSelectionEffectUtils.PerformStrokeFillUpdate(selectable, transferObj, true);
};

/**
 * @private
 */
DvtSelectionEffectUtils._saveUpStrokeFill = function(selectable)
{
  //if there is already a saved stroke, don't save again
  if (!selectable._savedUpStroke && !selectable._upStrokeSaved)
  {
    selectable._savedUpStroke = selectable.getStroke();
    selectable._upStrokeSaved = true;
  }
  //if there is already a saved fill, don't save again
  if (!selectable._savedUpFill && !selectable._upFillSaved)
  {
    selectable._savedUpFill = selectable.getFill();
    selectable._upFillSaved = true;
  }
}

/**
 * @private
 */
DvtSelectionEffectUtils._applyHoverStrokeFill = function(selectable) {
  var transferObj = new DvtSelectionEffectTransferObj();

  var stroke = null;
  var fill = null;
  if (selectable._bSelecting) 
    stroke = selectable._savedHoverStroke;
  else if (selectable._bSelected) {
    stroke = selectable._savedSelectionStroke ;
    fill = selectable._savedSelectionFill ;
  } 
  else {
    stroke = selectable._savedUpStroke ;
    fill = selectable._savedUpFill ;
  }
  
  transferObj._fill = fill;
  transferObj._stroke = stroke;
  transferObj._applyFill = selectable._bSelecting ? false : true;
  
  DvtSelectionEffectUtils.PerformStrokeFillUpdate(selectable, transferObj, true);
}

DvtSelectionEffectUtils.PerformStrokeFillUpdate = function(selectable, transferObj, allowTimeout) {
  transferObj._selectable = selectable;
  if (allowTimeout && selectable.getCtx().getDocumentUtils().isStrokeTimeoutRequired()) {
      //TODO: either figure out a better way to handle this,
      //or only do the defer if in Chrome and rendering to SVG
      //deferring the setStroke call because in Chrome setting
      //the stroke at the same time as changing z-order results
      //in the new stroke not being displayed

      //if there is an existing saved timer, stop and clear it
      if (selectable._applyStrokeTimer)
      {
        selectable._applyStrokeTimer.stop();
        selectable._applyStrokeTimer = null;
      }
      selectable._applyStrokeTimer = new DvtTimer(selectable.getCtx(), 0, transferObj.applyStrokeFill, transferObj, 1);
      transferObj._timer = selectable._applyStrokeTimer ;
      selectable._applyStrokeTimer.start();
  } else {
      transferObj.applyStrokeFill();
  }
}

/*
 * Temporary object used to apply the stroke and fill to the selectable object 
*/
var DvtSelectionEffectTransferObj = function(){};  

DvtObj.createSubclass(DvtSelectionEffectTransferObj, DvtObj, "DvtSelectionEffectTransferObj");


DvtSelectionEffectTransferObj.prototype.applyStrokeFill = function() {
 this._selectable.setStroke(this._stroke);
  
  if(this._applyFill)
    this._selectable.setFill(this._fill);
        
  // Cear the saved timer that called this func
  if(this._timer) {
    this._timer.stop();
    this._timer = null;
  }
}
// Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.
/*---------------------------------------------------------------------*/
/*    DvtKeyboardFocusEffect     Manages keyboard focus effect         */
/*---------------------------------------------------------------------*/
/**
  *  Creates a rectangular shape that represents keyboard focus
  *  @extends DvtRect
  */
var  DvtKeyboardFocusEffect = function(context, displayable, bounds, matrix,id)
{
   this.Init(context, displayable, bounds, matrix, id) ;
};

DvtObj.createSubclass(DvtKeyboardFocusEffect, DvtObj, "DvtKeyboardFocusEffect") ;

DvtKeyboardFocusEffect.FOCUS_COLOR_DEFAULT = "#0645AD";
DvtKeyboardFocusEffect.FOCUS_COLOR_SAFARI = "#6B9ED7";
DvtKeyboardFocusEffect.FOCUS_COLOR_CHROME = "#EDC67B";
DvtKeyboardFocusEffect.FOCUS_COLOR_IE = "#090909";
DvtKeyboardFocusEffect.FOCUS_BORDER_RADIUS = 1;
DvtKeyboardFocusEffect.FOCUS_STROKE_WIDTH = 1;
DvtKeyboardFocusEffect.FOCUS_STROKE_ALPHA = 1;
DvtKeyboardFocusEffect.FOCUS_STROKE_TYPE = DvtStroke.DOTTED;

/*---------------------------------------------------------------------*/
/*  Init()                                                             */
/*---------------------------------------------------------------------*/
/**
  *  Object initializer.
  *  @protected
  */
DvtKeyboardFocusEffect.prototype.Init = function(context, container, bounds, matrix, id)
{
  this._container = container;
  this._focusEffect = new DvtRect(context, bounds.x, bounds.y, bounds.w, bounds.h, id );
  
  var stroke = this.CreateStroke();
  this._focusEffect.setStroke(stroke);
  this._focusEffect.setRx(DvtKeyboardFocusEffect.FOCUS_BORDER_RADIUS);
  this._focusEffect.setRy(DvtKeyboardFocusEffect.FOCUS_BORDER_RADIUS);
  if (matrix)
    this._focusEffect.setMatrix(matrix);
  this._focusEffect.setFill(null);
};

DvtKeyboardFocusEffect.prototype.CreateStroke = function()
{
  var color = DvtKeyboardFocusEffect.FOCUS_COLOR_DEFAULT;
  var width = DvtKeyboardFocusEffect.FOCUS_STROKE_WIDTH;
  var alpha = DvtKeyboardFocusEffect.FOCUS_STROKE_ALPHA;
  var type = DvtKeyboardFocusEffect.FOCUS_STROKE_TYPE;
  
  if (DvtAgent.isBrowserSafari()) {
    color = DvtKeyboardFocusEffect.FOCUS_COLOR_SAFARI;
    width = 2;
    type = DvtStroke.SOLID;
  }
  else if (DvtAgent.isBrowserChrome()) {
    color = DvtKeyboardFocusEffect.FOCUS_COLOR_CHROME;
    width = 2;
    type = DvtStroke.SOLID;
  }
  else if (DvtAgent.isPlatformIE()) {
    color = DvtKeyboardFocusEffect.FOCUS_COLOR_IE;
  }
  else {
    color = DvtKeyboardFocusEffect.FOCUS_COLOR_DEFAULT;
  }
  
  var stroke = new DvtSolidStroke(color, 
                              alpha, 
                              width);
  stroke.setType(type, width, width);                              
  return stroke;                              
};

DvtKeyboardFocusEffect.prototype.getEffect = function() 
{
  return this._focusEffect;
};

DvtKeyboardFocusEffect.prototype.setEffect = function(effect) 
{
  this._focusEffect = effect;
};

DvtKeyboardFocusEffect.prototype.show = function() {
  if (this._focusEffect instanceof DvtShape)
    this._container.addChildAt(this._focusEffect, 0);
};

DvtKeyboardFocusEffect.prototype.hide = function() {
  if (this._focusEffect instanceof DvtShape)
    this._container.removeChild(this._focusEffect);
};
// Copyright (c) 2008, 2012, Oracle and/or its affiliates. 
// All rights reserved. 

/**
  *  Defines a (w,h) dimension.
  *  @class DvtDimension
  *  @extends DvtObj
  *  @constructor
  *  @param {number} w   the dimension width
  *  @param {number} h   the dimension height
  */
var DvtDimension = function(w,h)
{
  this.Init(w, h);
};


DvtObj.createSubclass(DvtDimension, DvtObj, "DvtDimension");

/**
  *   @protected
  */
DvtDimension.prototype.Init = function(w, h)
{
  this.w = ((w === null || isNaN(w)) ? 0 : w);
  this.h = ((h === null || isNaN(h)) ? 0 : h);
};
// Copyright (c) 2011, 2013, Oracle and/or its affiliates. 
// All rights reserved. 

/**
 *  Creates a matrix object.
 *  @extends DvtObj
 *  @class DvtMatrix is a platform independent class representing a transformation
 *  matrix.
 *  <p>
 *  The matrix is in the form:<br>
 *  [ a  b  tx ]<br>
 *  [ c  d  ty ]<br>
 *  [ 0  0  1  ]<br>
 *  <p>
 *  <b>Example:</b><br><br> <code>
  *  var mat = new DvtMatrix(context) ;<br>
 *  mat.translate(15, 30) ;<br>
 *</code>
 *  @constructor
 *  @param {number} a Optional
 *  @param {number} b Optional
 *  @param {number} c Optional
 *  @param {number} d Optional
 *  @param {number} tx Optional
 *  @param {number} ty Optional
 */
var DvtMatrix = function (a, b, c, d, tx, ty) 
{
  //don't allow users to set individual elements, because we
  //may need to adjust transforms for different platforms, for
  //example if the angle of rotation increases in different 
  //directions on different platforms, and we don't want to try
  //to deconstruct the matrix
  this.Init(a, b, c, d, tx, ty);
};

DvtObj.createSubclass(DvtMatrix, DvtLockable, "DvtMatrix");

//   [ a  b  tx ]
//   [ c  d  ty ]
//   [ 0  0  1  ]

/**
 *  @private
 */
DvtMatrix._DECOMP_TX = 0;
/**
 *  @private
 */
DvtMatrix._DECOMP_TY = 1;
/**
 *  @private
 */
DvtMatrix._DECOMP_R = 2;
/**
 *  @private
 */
DvtMatrix._DECOMP_SKEWX = 3;
/**
 *  @private
 */
DvtMatrix._DECOMP_SX = 4;
/**
 *  @private
 */
DvtMatrix._DECOMP_SY = 5;

/**
 * Users should becareful when setting individual elements, because we may need to adjust transforms for different
 * platforms, for example if the angle of rotation increases in different directions on different platforms,
 * and we don't want to try to deconstruct the matrix
 *  @protected
 */
DvtMatrix.prototype.Init = function (a, b, c, d, tx, ty) 
{
  this._a = (a == null) ? 1 : a;
  this._b = (b == null) ? 0 : b;
  this._c = (c == null) ? 0 : c;
  this._d = (d == null) ? 1 : d;
  this._tx = (tx == null) ? 0 : tx;
  this._ty = (ty == null) ? 0 : ty;

  this._u = 0;
  this._v = 0;
  this._w = 1;

  DvtMatrix.superclass._Init.call(this);
};

/**
 *  @protected
 *  Make this matrix the identity matrix.
 */
DvtMatrix.prototype.Identity = function () 
{
  this._a = 1;
  this._b = 0;
  this._c = 0;
  this._d = 1;
  this._tx = 0;
  this._ty = 0;
};

/**
 *  Get the A element of this matrix.
 *  @returns {Number}  The A element of this matrix.
 */
DvtMatrix.prototype.getA = function()
{
  return this._a;
};

/**
 *  Get the B element of this matrix.
 *  @returns {Number}  The B element of this matrix.
 */
DvtMatrix.prototype.getB = function()
{
  return this._b;
};

/**
 *  Get the C element of this matrix.
 *  @returns {Number}  The C element of this matrix.
 */
DvtMatrix.prototype.getC = function()
{
  return this._c;
};

/**
 *  Get the D element of this matrix.
 *  @returns {Number}  The D element of this matrix.
 */
DvtMatrix.prototype.getD = function()
{
  return this._d;
};

/**
 *  Get the TX element of this matrix.
 *  @returns {Number}  The TX element of this matrix.
 */
DvtMatrix.prototype.getTx = function()
{
  return this._tx;
};

/**
 *  Get the TY element of this matrix.
 *  @returns {Number}  The TY element of this matrix.
 */
DvtMatrix.prototype.getTy = function()
{
  return this._ty;
};

/**
 *  Clone this matrix.
 *  @returns {DvtMatrix}  A clone of this matrix.
 */
DvtMatrix.prototype.clone = function () 
{
  return new DvtMatrix(this._a, this._b, this._c, this._d, this._tx, this._ty);
};

/**
 *  Concatenate the given matrix with this matrix.
 *  @param {DvtMatrix} mat   The matrix to concatenate with this matrix.
 */
DvtMatrix.prototype.concat = function(mat)
{
  // A * B = B.concat(A) = childMatrix.concat(parentMatrix)
  
  if (this.isLocked())
  {
    return;
  }

  var newA = this._a * mat._a + this._c * mat._b + this._u * mat._tx;
  var newB = this._b * mat._a + this._d * mat._b + this._v * mat._tx;
  var newTX = this._tx * mat._a + this._ty * mat._b + this._w * mat._tx;

  var newC = this._a * mat._c + this._c * mat._d + this._u * mat._ty;
  var newD = this._b * mat._c + this._d * mat._d + this._v * mat._ty;
  var newTY = this._tx * mat._c + this._ty * mat._d + this._w * mat._ty;

  //var newU = this._a * mat._u + this._c * mat._v + this._u * mat._w;
  //var newV = this._b * mat._u + this._d * mat._v + this._v * mat._w;
  //var newW = this._tx * mat._u + this._ty * mat._v + this._w * mat._w;
  
  this._a = newA;
  this._b = newB;
  this._c = newC;
  this._d = newD;
  this._tx = newTX;
  this._ty = newTY;
};

/**
 *  Translate this matrix.
 *  @param {Number} dx   The horizontal distance to translate by, in pixels.
 *  @param {Number} dy   The vertical distance to translate by, in pixels.
 */
DvtMatrix.prototype.translate = function(dx, dy)
{
  if (this.isLocked())
  {
    return;
  }

  var tMat = new DvtMatrix();
  tMat._tx = dx;
  tMat._ty = dy;

  this.concat(tMat);
};

/**
 *  Scale this matrix, optionally around a specified point
 *  @param {number} sx   The horizontal value to scale by.
 *  @param {number} sy   The vertical value to scale by.
 *  @param {number} px   The x value of the point to scale around (optional)
 *  @param {number} py   The y value of the point to scale around (optional)
 */
DvtMatrix.prototype.scale = function(sx, sy, px, py)
{
  if (this.isLocked())
  {
    return;
  }

  if (px || py) {
    this.translate(-px, -py);
  }
  var tMat = new DvtMatrix();
  tMat._a = sx;
  tMat._d = sy;

  this.concat(tMat);
  if (px || py) {
    this.translate(px, py);
  }
};

/**
 *  Rotate this matrix.
 *  @param {Number} angleRads   The angle to rotate by, in radians.
 */
DvtMatrix.prototype.rotate = function(angleRads)
{
  if (this.isLocked())
  {
    return;
  }

  var tMat = new DvtMatrix();
  tMat._a = Math.cos(angleRads);
  tMat._d = tMat._a;
  tMat._c = Math.sin(angleRads);
  tMat._b =  - tMat._c;

  this.concat(tMat);
};

/**
 *  Skew this matrix.
 *  @param {Number} sxRads   The horizontal angle to skew by, in radians.
 *  @param {Number} syRads   The vertical angle to skew by, in radians.
 */
DvtMatrix.prototype.skew = function(sxRads, syRads)
{
  if (this.isLocked())
  {
    return;
  }

  var tMat = new DvtMatrix();
  tMat._b = Math.tan(sxRads);
  tMat._c = Math.tan(syRads);

  this.concat(tMat);
};

/**
 *  @protected
 *  Calculate the determinant of this matrix.
 *  @return {number} determinant of this matrix
 */
DvtMatrix.prototype.Determinant = function()
{
  var determinant = this._a * (this._d * this._w - this._ty * this._v) - 
                    this._b * (this._c * this._w - this._ty * this._u) + 
                    this._tx * (this._c * this._v - this._d * this._u);
  return determinant;
};

/**
 *  Invert this matrix.
 */
DvtMatrix.prototype.invert = function()
{
  if (this.isLocked())
  {
    return;
  }

  var determinant = this.Determinant();
  var A = (this._d * this._w - this._ty * this._v);
  var B = (this._tx * this._v - this._b * this._w);
  var TX = (this._b * this._ty - this._tx * this._d);
  var C = (this._ty * this._u - this._c * this._w);
  var D = (this._a * this._w - this._tx * this._u);
  var TY = (this._tx * this._c - this._a * this._ty);
  //var U = (this._c * this._v - this._d * this._u);
  //var V = (this._b * this._u - this._a * this._v);
  //var W = (this._a * this._d - this._b * this._c);
  
  this._a = A / determinant;
  this._b = B / determinant;
  this._tx = TX / determinant;
  this._c = C / determinant;
  this._d = D / determinant;
  this._ty = TY / determinant;
  //this._u = U / determinant;
  //this._v = V / determinant;
  //this._w = W / determinant;
};

/**
 *  @private
 *  Decompose this matrix into its constituent transforms.
 *  @returns {Array} array of transform values in the form
 *           [translateX, translateY, rotationRadians, skewXRadians, scaleX, scaleY],
 *           of null if decomposition doesn't exist
 */
DvtMatrix.prototype._decompose = function()
{
  var A = this._a;
  var B = this._b;
  var C = this._c;
  var D = this._d;
  var Tx = this._tx;
  var Ty = this._ty;

  if (A * D - B * C === 0)
    return null;

  //x scale factor
  var Sx = Math.sqrt(A * A + C * C);
  A = A / Sx;
  C = C / Sx;

  //xy shear
  var K = A * B + C * D;
  B = B - A * K;
  D = D - C * K;

  //y scale factor
  var Sy = Math.sqrt(B * B + D * D);
  B = B / Sy;
  D = D / Sy;
  K = K / Sy;

  var determinant = A * D - B * C;
  if (determinant === -1)
  {
    K =  - K;
    Sy =  - Sy;
  }

  //rotation
  var R = Math.atan2(C, A);

  //skew
  var skewX = Math.atan(K);

  //to create new matrix with same transforms, use order:
  //1) scale(Sx, Sy)
  //2) skew(skewX, 0);
  //3) rotate(R);
  //4) translate(Tx, Ty);
  return [Tx, Ty, R, skewX, Sx, Sy];
};

/**
 *  @private
 *  Recompose this matrix from the given decomposition.
 *  @param {Array}  arDecomposition  array of transform values returned from
 *         calling decompose()
 */
DvtMatrix.prototype._recompose = function(arDecomposition)
{
  if (this.isLocked())
  {
    return;
  }

  this.Identity();

  var Tx = arDecomposition[0];
  var Ty = arDecomposition[1];
  var R = arDecomposition[2];
  var skewX = arDecomposition[3];
  var Sx = arDecomposition[4];
  var Sy = arDecomposition[5];

  this.scale(Sx, Sy);
  this.skew(skewX, 0);
  this.rotate(R);
  this.translate(Tx, Ty);
};

/**
 *  @private
 *  Determine whether this matrix is equal to another.
 *  @param {DvtMatrix} mat   The matrix to compare with this matrix.
 *  @return {Boolean} True if equal, false if not.
 */
DvtMatrix.prototype.equals = function (mat) {
    if (!this && mat) return false;
    else if (this && !mat) return false;
    else if (!this && !mat) return true;
    else return (this._a == mat._a && this._b == mat._b && this._c == mat._c &&
            this._d == mat._d && this._tx == mat._tx && this._ty == mat._ty);
};

/**
 * Transform a point using this matrix.
 * @param {DvtPoint}  p  point to transform
 * @type DvtPoint
 */
DvtMatrix.prototype.transformPoint = function(p)
{
  var newX = this._a * p.x + this._b * p.y + this._tx * 1;
  var newY = this._c * p.x + this._d * p.y + this._ty * 1;
  return new DvtPoint(newX, newY);
};


/**
 * Test if this matrix is an indentity matrix.  Returns true if an identity matrix, else false.
 * @type boolean
 */
DvtMatrix.prototype.isIdentity = function()
{
  return (this._a == 1 && this._b == 0 && this._c == 0 && this._d == 1 && this._tx == 0 && this._ty == 0);
};

// Copyright (c) 2008, 2012, Oracle and/or its affiliates. 
// All rights reserved. 

/**
  *  Defines an (x,y) coordinate.
  *  @class DvtPoint
  *  @extends DvtObj
  *  @constructor
  *  @param {number} x
  *  @param {number} y
  */

var DvtPoint = function(x,y)
{
  this.Init(x, y);
};


DvtObj.createSubclass(DvtPoint, DvtObj, "DvtPoint");

DvtPoint.prototype.Init = function(x, y)
{
  this.x = ((x === null || isNaN(x)) ? 0 : x);
  this.y = ((y === null || isNaN(y)) ? 0 : y);
}
// Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.

/**
  *  Defines the geometry of a rectangle. Top-left (x,y), and width and height.
  *  @class DvtRectangle
  *  @extends DvtObj
  *  @constructor
  *  @param {number} x
  *  @param {number} y
  *  @param {number} w
  *  @param {number} h
  *  @type {DvtRectangle}
  */
var   DvtRectangle = function(x,y,w,h)
{
  this.x = ((x === null || isNaN(x)) ? 0 : x);
  this.y = ((y === null || isNaN(y)) ? 0 : y);
  this.w = ((w === null || isNaN(w)) ? 0 : w);
  this.h = ((h === null || isNaN(h)) ? 0 : h);
};

DvtObj.createSubclass(DvtRectangle, DvtObj, "DvtRectangle");


/**
 * Creates a new DvtRectangle from an array of coordinates.
 * @param {Array} ar  an array of rectangle coordinates, where x = ar[0], y = ar[1], w = ar[2], h = ar[3].
 * @returns  {DvtRectangle}
 */ 
DvtRectangle.create = function (ar)
{
  return new DvtRectangle (ar[0], ar[1], ar[2], ar[3]);
};


/**
 * Returns true if the rectangle contains the given point.
 */ 
DvtRectangle.prototype.containsPoint = function(nX, nY) 
{
   return (nX >= this.x && nX <= this.x + this.w && nY >= this.y && nY <= this.y + this.h);
};


DvtRectangle.prototype.getCenter = function ()
{
  return new DvtPoint(this.x + (this.w / 2.0), this.y + (this.h / 2.0));
};



/**
 * Returns the union of this and the supplied rectangle.
 * @param {DvtRectangle}  rect  the supplied rectangle.
 * @returns {DvtRectangle} a new rectangle that is the union of this and the supplied rectangle.
 */ 
DvtRectangle.prototype.getUnion = function(rect) 
{
   var  u = new DvtRectangle() ;

   if (rect && rect.w !== 0 && rect.h !== 0) {  // ignore zero size rect's
     if (this.w !== 0 && this.h !== 0) {        //  ..     ..   ..    ..
       var  thisR = this.x + this.w ;             // this right
       var  thisB = this.y + this.h ;             // this bottom
       var  rectR = rect.x + rect.w ;             // rect right
       var  rectB = rect.y + rect.h ;             // rect bottom

       var  minx  = Math.min(this.x, rect.x) ;
       var  miny  = Math.min(this.y, rect.y) ;

       u.w = (thisR < rectR)? (rectR - minx) : (thisR - minx) ;
       u.h = (thisB > rectB)? (thisB - miny) : (rectB - miny) ;
       u.x = minx ;
       u.y = miny ;
     }
     else {
      u.x = rect.x ;
      u.y = rect.y ;
      u.w = rect.w ;
      u.h = rect.h ;
     }
   }
   else  {
      u.x = this.x ;
      u.y = this.y ;
      u.w = this.w ;
      u.h = this.h ;
   }

   return u ;
};

/**
 * Grow this rectangle to include the given coordinates.
 * @param {number}  xx  x coordinate
 * @param {number}  yy  y coordinate
 */ 
DvtRectangle.prototype.grow = function(xx, yy) 
{
  var minX = this.x;
  var minY = this.y;
  var maxX = this.x + this.w;
  var maxY = this.y + this.h;
  
  if (xx < minX) {
    minX = xx;
  }
  if (xx > maxX) {
    maxX = xx;
  }
  if (yy < minY) {
    minY = yy;
  }
  if (yy > maxY) {
    maxY = yy;
  }
  this.x = minX;
  this.y = minY;
  this.w = maxX - minX;
  this.h = maxY - minY;
};

/**
 * Returns true if the rectangle intersectes the supplied rectangle.
 * @param {DvtRectangle}  rect  the supplied rectangle.
 */ 
DvtRectangle.prototype.intersects = function(rect) 
{
   if (rect && rect.w !== 0 && rect.h !== 0) {  // ignore zero size rect's
     if (this.w !== 0 && this.h !== 0) {        //  ..     ..   ..    ..
       var  thisR = this.x + this.w ;             // this right
       var  thisB = this.y + this.h ;             // this bottom
       var  rectR = rect.x + rect.w ;             // rect right
       var  rectB = rect.y + rect.h ;             // rect bottom

       return !(rect.x > thisR || rectR < this.x || rect.y > thisB || rectB < this.y);
     }
  }
  return false;
};

/**
 * Returns a clone of itself.
 * @return {DvtRectangle} Its clone.
 */
DvtRectangle.prototype.clone = function() {
  return new DvtRectangle(this.x, this.y, this.w, this.h);
}

/**
 * @override
 */
DvtRectangle.prototype.toString = function() {
  return this.x + ", "+ this.y + ", " + this.w + ", " + this.h;
}
// Copyright (c) 2008, 2012, Oracle and/or its affiliates. 
// All rights reserved. 
/*-------------------------------------------------------------------------*/
/*  DvtGeomUtils()       Utility geometry functions                        */
/*-------------------------------------------------------------------------*/

var DvtGeomUtils = {} ;

DvtObj.createSubclass(DvtGeomUtils, DvtObj, "DvtGeomUtils");

DvtGeomUtils.getCenterPoint = function (rect) {
    return new DvtPoint(rect.x+rect.w/2, rect.y+rect.h/2);
}

DvtGeomUtils.intersects = function (rect1, rect2) {
    if (rect1.x > rect2.x + rect2.w || rect1.x + rect1.w < rect2.x || rect1.y > rect2.y + rect2.h || rect1.y + rect1.h < rect2.y)
        return false;
    return true;
}

DvtGeomUtils.getPaddedRectangle = function (rect, buffer) {
    return DvtGeomUtils.getSpecificPaddedRectangle(rect, buffer, buffer, buffer, buffer);
}

DvtGeomUtils.getSpecificPaddedRectangle = function (rect, bufferTop, bufferBottom, bufferLeft, bufferRight) {
    return new DvtRectangle(rect.x - bufferLeft, rect.y - bufferTop, rect.w + bufferLeft + bufferRight, rect.h + bufferTop + bufferBottom);
}

DvtGeomUtils.GetOffsetValues = function(objBounds, containerBounds, padding) {
    var offsetY = 0;
    var lowerY = objBounds.y;
    var higherY = objBounds.y + objBounds.h;     
    if (lowerY < padding) {
        offsetY += padding - lowerY;
    } else if (higherY > containerBounds.h - padding) {
        offsetY += containerBounds.h - padding - higherY;
    }

    // Adjust position of box depending on stage bounds    
    var lowerX = objBounds.x;
    var higherX = objBounds.x + objBounds.w;     

    var offsetX = 0;
    if (lowerX < padding) {
        offsetX += padding - lowerX;
    } else if (higherX > containerBounds.w - padding) {
        offsetX += containerBounds.w - padding - higherX;
    }
    return {offsetX: offsetX, offsetY: offsetY};
}
// Copyright (c) 2008, 2012, Oracle and/or its affiliates. 
// All rights reserved. 
/*-------------------------------------------------------------------------*/
/*  DvtLineUtils()       Utility functions for lines                       */
/*-------------------------------------------------------------------------*/

var DvtLineUtils = {} ;

DvtObj.createSubclass(DvtLineUtils, DvtObj, "DvtLineUtils");

/**
 * Computes the point of intersection of two lines in the same plane.
 * @param   {DvtPoint} p1 end point on line 1
 * @param   {DvtPoint} p2 other end point on line 1
 * @param   {DvtPoint} p3 end point on line 2
 * @param   {DvtPoint} p4 other end point on line 2
 * @param   {DvtPoint} pt optional DvtPoint object that will be updated with the
 *                     point of intersection.  If omitted, a new DvtPoint will be created
 *                     and returned.
 * @returns {DvtPoint} the point of intersection. If null is returned, then either
 *                     the lines are parallel, or both of the lines have a zero length.
 */
DvtLineUtils.intersect2Lines = function(p1, p2, p3, p4, pt)
{
   //  Using Penner's Method

   var x1  = p1.x; 
   var y1  = p1.y;
   var x4  = p4.x;
   var y4  = p4.y;
   var dx1 = p2.x - x1;            // the x diff
   var dx2 = p3.x - x4;            //  .. ..  ..

   if (dx1 === 0 && dx2 === 0)     // both lines vertical? (i.e. undefined slope)
     return null ;

   var m1 = (p2.y - y1) / dx1;
   var m2 = (p3.y - y4) / dx2;

   if (m1 === m2)                  // both lines parallel?
     return null ;

   if (! pt) {
     pt =  new DvtPoint() ;        // return value
   }

   if (dx1 === 0) {
     pt.x = x1 ;
     pt.y = (m2 * (x1 - x4) + y4) ;
     return pt ;
   }
   else if (dx2 === 0) {
     pt.x = x4 ;
     pt.y = (m1 * (x4 - x1) + y1) ;
     return pt ;
   }

   var xInt  = (-m2 * x4 + y4 + m1 * x1 - y1) / (m1 - m2);
   var yInt  = m1 * (xInt - x1) + y1;

   pt.x = xInt ;
   pt.y = yInt ;
   return pt ;
} ;


/**
  * Returns the length of a line segment with end points (x1, y1) and (x2, y2).
  * @param {number} x1  endpoint x
  * @param {number} y1  endpoint y
  * @param {number} x2  other endpoint x
  * @param {number} y2  other endpoint y
  * @returns {number}   the length of the line segment with end points (x1, y1) and (x2, y2).
  */
DvtLineUtils.lineLen = function(x1, y1, x2, y2)
{
   var dx = (x2 - x1) ;
   var dy = (y2 - y1) ;
   return Math.sqrt((dx * dx) + (dy * dy)) ;
};


/**
* Returns the midpoint (x,y) of a line segment with end points (x1,y1) and (x2,y2).
* @param {number}   x1 end point x.
* @param {number}   y1 end point y.
* @param {number}   x2 other end point x
* @param {number}   y2 other end point y.
* @param {DvtPoint} pt optional DvtPoint object that will be updated with the mid-point.
*                   If omitted, a new DvtPoint will be created.
* @returns (DvtPoint} the midpoint (x,y) of the line segment in the supplied DvtPoint,
*                     or a new DvtPoint if not supplied.
*/
DvtLineUtils.midPt = function(x1, y1, x2, y2, pt)
{
   if (! pt) {
     pt = new DvtPoint() ; 
   }
   pt.x  =  (x1 + x2)/2 ;
   pt.y  =  (y1 + y2)/2 ;
   return pt ;
};

// Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.

var DvtVectorUtils = {} ;

DvtObj.createSubclass(DvtVectorUtils, DvtObj, "DvtVectorUtils");

/**
 * Creates a vector from the origin to the specified coordinate
 * 
 * @param {number} x the x coordinate of the vector
 * @param {number} y the y coordinate of the vector
 * @return {object} an object with x and y properties representing the vector
 */
DvtVectorUtils.createVector = function(x, y) {
  var v = {};
  v.x = x;
  v.y = y;
  return v;
}

/**
 * Adds two vectors
 * 
 * @param {object} v1 an object with x and y properties representing the first addend
 * @param {object} v2 an object with x and y properties representing the second addend
 * @return {object} an object with x and y properties representing the sum
 */
DvtVectorUtils.addVectors = function(v1, v2) {
  return DvtVectorUtils.createVector(v1.x + v2.x, v1.y + v2.y);
}

/**
 * Subtracts two vectors
 * 
 * @param {object} v1 an object with x and y properties representing the minuend
 * @param {object} v2 an object with x and y properties representing the subtrahend
 * @return {object} an object with x and y properties representing the difference
 */
DvtVectorUtils.subtractVectors = function(v1, v2) {
  return DvtVectorUtils.createVector(v1.x - v2.x, v1.y - v2.y);
}

/**
 * Scales a vector
 * 
 * @param {object} v an object with x and y properties representing the vector
 * @param {number} s the scalar by which to scale the vector
 * @return {object} an object with x and y properties representing the scaled vector
 */
DvtVectorUtils.scaleVector = function(v, s) {
  return DvtVectorUtils.createVector(v.x * s, v.y * s);
}

/**
 * Scales a vector
 * 
 * @param {object} v an object with x and y properties representing the vector
 * @return {number} the magnitude of the vector
 */
DvtVectorUtils.getMagnitude = function(v) {
  return Math.sqrt(v.x * v.x + v.y * v.y);
}
/**
 *  A static class for chart layout.
 *  @class DvtLayoutUtils
 *  @constructor
*/
var DvtLayoutUtils = function()
{};

DvtObj.createSubclass(DvtLayoutUtils, DvtObj, "DvtLayoutUtils");

/**
 * Positions the specified displayable in the available space.
 * @param {DvtRectangle} availSpace The available space.
 * @param {string} position The position within the available space.  Valid values are "top", "bottom", "left", and "right".
 * @param {DvtDisplayable} displayable The displayable to be positioned.
 * @param {number} width The width of the displayable.
 * @param {number} height The height of the displayable.
 * @param {number} gap The gap to leave between the displayable and other content.  This gap is applied only if
 *                     the displayable's area is greater than 0.
 */
DvtLayoutUtils.position = function(availSpace, position, displayable, width, height, gap) {
  if(!displayable)
    return;
    
  // Adjust the gap if the displayable has no area
  gap = (width*height > 0) ? gap : 0;
  
  if(position == "top") {
    displayable.setTranslate(availSpace.x + availSpace.w/2 - width/2, availSpace.y);
    availSpace.y += (height + gap);
    availSpace.h -= (height + gap);
  }
  else if(position == "bottom") {
    displayable.setTranslate(availSpace.x + availSpace.w/2 - width/2,availSpace.y + availSpace.h - height);
    availSpace.h -= (height + gap);
  }
  else if(position == "left") {
    displayable.setTranslate(availSpace.x, availSpace.y + availSpace.h/2 - height/2);
    availSpace.x += (width + gap);
    availSpace.w -= (width + gap);
  }
  else if(position == "right") {
    displayable.setTranslate(availSpace.x + availSpace.w - width, availSpace.y + availSpace.h/2 - height/2);
    availSpace.w -= (width + gap);
  }
}

/**
 * Aligns the specified displayable in the available space.
 * @param {DvtRectangle} availSpace The available space.
 * @param {string} position The position within the available space.  Valid values are "start", "center", and "end".
 * @param {DvtDisplayable} displayable The displayable to be positioned.
 * @param {number} width The width of the displayable.
 */
DvtLayoutUtils.align = function(availSpace, align, displayable, width) {
  if(!displayable)
    return;
    
  // Account for the locale and find the position  
  var position = align;
  if(position == "start")
    position = DvtAgent.isRightToLeft(displayable.getCtx()) ? "right" : "left";
  else if(position == "end")
    position = DvtAgent.isRightToLeft(displayable.getCtx()) ? "left" : "right";
    
  // Align the text  
  if(position == "left") 
    displayable.setX(availSpace.x);
  else if(position == "center") 
    displayable.setX(availSpace.x + availSpace.w/2 - width/2);
  else if(position == "right") 
    displayable.setX(availSpace.x + availSpace.w - width);
}
// Copyright (c) 2008, 2012, Oracle and/or its affiliates. 
// All rights reserved. 
/*--------------------------------------------------------------------------*/
/*   DvtMath             Miscellaneous Math constants and routines          */
/*--------------------------------------------------------------------------*/
/**
  *  @class DvtMath  Defines miscellaneous math constants and routines.
  */
var  DvtMath = new Object();

DvtObj.createSubclass(DvtMath, DvtObj, "DvtMath");

/**
  *  Number of radians in 1 degree.
  *  @type number
  */
DvtMath.RADS_PER_DEGREE = (Math.PI/180) ;
/**
  *  Number of degrees in 1 radian.
  *  @type number
  */
DvtMath.DEGREES_PER_RAD = (180/Math.PI) ;
/**
  *  Half the value of Pi radians.
  *  @type number
  */
DvtMath.HALF_PI  = (Math.PI/2) ;
/**
  *  One quarter the value of Pi radians.
  *  @type number
  */
DvtMath.QUARTER_PI  = (Math.PI/4); 

/**
  *  Fudge factor deal with floating point rounding error
  *  @type number
  */
DvtMath.TOLERANCE  = 0.1;

/**
 *   Converts degrees to radians.
 *   @param {number}  deg  The value in degrees to be converted. 
 *   @type number
 */
DvtMath.degreesToRads = function(deg)
{
   return (deg * DvtMath.RADS_PER_DEGREE);
};

/**
 *   Converts radians to degrees.
 *   @param {number}  rad  The valie in radians to be converted. 
 *   @type number
 */
DvtMath.radsToDegrees = function(rad)
{
   return (rad * DvtMath.DEGREES_PER_RAD);
};

/**
  * Interpolate a number between the original and destination values for the 
  * given percent.
  * @param {number}  origVal  original value
  * @param {number}  destVal  destination value
  * @param {number}  percent  percent value to interpolate
  * @type number
  */
DvtMath.interpolateNumber = function(origVal, destVal, percent)
{
  return (origVal + percent * (destVal - origVal));
};
/**
 * @constructor
 * property map
 */
var DvtPropMap = function() {
  this.Init();
};

DvtPropMap.REGEXP = new RegExp("#\\{([^\\}]*)\\}", "g");


/**
 * make DvtPropMap a subclass of DvtObj
 */
DvtObj.createSubclass(DvtPropMap, DvtObj, "DvtPropMap");


/**
 * Initializes the instance. 
 */
DvtPropMap.prototype.Init = function() {
  //Note: there is no Init method in superclass
  // DvtPropMap.superclass.Init.call(this);
  this._props = {};
};


/*-------------------------------------------------------------------------*/
/*   AfComponent propibutes                                                */
/*-------------------------------------------------------------------------*/
DvtPropMap.prototype.getProperty = function(propName) {
  return this._props[propName];
};

DvtPropMap.prototype.setProperty = function(propName, val) {
  this._props[propName] = val;
};


DvtPropMap.prototype.getStringProp = function(propName, defString) {
  var val = this._props[propName];
  return val ? val : defString;
};

/**
 * Returns boolean value of the specified property
 * @param {string} propName  property name
 * @param {boolean} defBool default value
 * @return {boolean} boolean value of the specified property
 */
DvtPropMap.prototype.getBooleanProp = function(propName, defBool) {
  var val = this._props[propName];
  var ret = defBool;
  if (typeof val === "boolean")
    ret = val;
  else if (val === 0)
    ret = false;
  else if (val === 1)
    ret = true;
  else if (typeof val === "string")
    ret = (val.toLowerCase() === "true");

  return ret;
};

DvtPropMap.prototype.getIntegerProp = function(propName, defInt) {
  var val = this._props[propName];
  var ret;
  if (val)
    ret = parseInt(val);
  return (ret) ? ret : defInt;
};

DvtPropMap.prototype.getFloatProp = function(propName, defFloat) {
  var val = this._props[propName];
  var ret;
  if (val)
    ret = parseFloat(val);
  return (ret) ? ret : defFloat;
};

/**
 * Returns the id of this component.
 * @type String
 */
DvtPropMap.prototype.getId = function() {
  return this.getProperty("id");
};

/**
 * Set the id of this component.
 * @param {String} id  ID for the component
 */
DvtPropMap.prototype.setId = function(id) {
  this.setProperty("id", id);
};

/**
 * set a list of properties
 * @param {NamedNodeMap} attributes array
 */
DvtPropMap.prototype.setProperties = function(attrArray) {
  for (var i = 0; i < attrArray.length; i++) {
    var attr = attrArray[i];
    if (attr.name && attr.value !== undefined) {
      this.setProperty(attr.name, attr.value);
    }
  }
};


/*-------------------------------------------------------------------------*/
/*   stamp                                                                 */
/*-------------------------------------------------------------------------*/

/**
 * Stamp out this template object only. 
 * @param {} elcontext EL binding context
 * @return {DvtAfComponent} a new DvtAfComponent tree
 */
DvtPropMap.prototype.stamp = function(elcontext) {

  // create a new DvtAfComponent object of the same type
  var result = new this.constructor();

  // copy properties
  var newProps = {};
//   var regexp = /#{([^\}]*)}/g;
  for (var attr in this._props) {
    //TODO: test for string
    if (this._props[attr].replace) {
        newProps[attr] = this._props[attr].replace(DvtPropMap.REGEXP, 
          function(str, bindVar) {
            if (elcontext && elcontext[bindVar] !== undefined) {
              return elcontext[bindVar];
            }
            return str;
          }
        );
    } else {
        newProps[attr] = this._props[attr];
    }
  }

  result._props = newProps;
  return result;
};


/**
 * Convert an attribute array of a EL node to an EL context object
 * @param {DvtXmlNode} xmlNode The EL xml node
 */
DvtPropMap.toELContext = function(xmlNode) {
  var arr = xmlNode.getAttributes();
  var prop;
  var obj = {};
  for (var i = 0; i < arr.length; i++) {
    prop = arr[i];
    obj[prop.name] = prop.value;
  }
  return obj;
}

// Copyright (c) 2008, 2012, Oracle and/or its affiliates. 
// All rights reserved. 

/**
 * usage
 * DvtImageLoader.loadImage("pic.png", function(image) {
 *   alert(image.width);
 *   alert(image.height);
 * });
 * 
 */


/**
 * DvtImageLoader
 */
var DvtImageLoader = {};

DvtObj.createSubclass(DvtImageLoader, DvtObj, "DvtImageLoader");

/**
 * Load an image.
 * 
 * @param {DvtContext} context The context object
 * @param src URL of the image to load
 * @param onComplete function to call when the image is loaded
 * 
 * @return image if image is already loaded and onComplete
 *         function is null, otherwise null
 */
DvtImageLoader.loadImage = function(context, src, onComplete) {

  var loader = context.getImplFactory().getImageLoader();
  return loader.loadImage(src, onComplete);

};


// Copyright (c) 2012, 2014, Oracle and/or its affiliates. All rights reserved.

/**
 * JSON utilities.
 * @class
 */
var DvtJSONUtils = new Object();

DvtObj.createSubclass(DvtJSONUtils, DvtObj, "DvtJSONUtils");

/**
 * Returns a deep clone of the object.
 * @param {object} obj The object to clone.
 * @param {function} keyFunc An optional boolean-valued function that will be called for each key.  If the function returns false, the key will not be copied over
 * @return {object} The clone.
 */
DvtJSONUtils.clone = function(obj, keyFunc) {
  if (obj == null)
    return null;
  var ret = null;
  
  if(obj instanceof Array) {
    ret = [];
    
    // Loop through and copy the Array
    for(var i=0; i<obj.length; i++) {
      if(DvtJSONUtils._isDeepClonable(obj[i])) // deep clone objects
        ret[i] = DvtJSONUtils.clone(obj[i], keyFunc);
      else // copy values
        ret[i] = obj[i];
    }
  }
  else if(obj instanceof DvtCSSStyle) {
    ret = obj.clone();
  }
  else if(obj instanceof Object) {
    ret = {};
    
    // Loop through all properties of the object
    var key;
    for(key in obj) {
      if (!keyFunc || keyFunc(key)) {
        var value = obj[key];
        if(DvtJSONUtils._isDeepClonable(value)) // deep clone objects
          ret[key] = DvtJSONUtils.clone(value, keyFunc);
        else // copy values
          ret[key] = value;
      }
    }
  }
  
  return ret;
}

/**
 * Returns a new object with the merged properties of the given objects.  Properties
 * in the first object take precedence.
 * @param {object} a
 * @param {object} b
 * @return {object} A new object containing the merged properties.
 */
DvtJSONUtils.merge = function(a, b) {
  // Clone so that contents aren't modified
  var one = DvtJSONUtils.clone(a);
  var two = DvtJSONUtils.clone(b);
  if (one == null)
    return two;
  else if (two == null)
    return one;
  else  {
    DvtJSONUtils._copy(one, two);
    return two;
  }
}

/**
 * Copys the properties from the first object onto the second.
 * @param {object} a The source of the properties to copy.
 * @param {object} b The destination of the copied properties.
 */
DvtJSONUtils._copy = function(a, b) {
  var key;
  for(key in a) {
    var value = a[key];
    if(value && (value instanceof Array)) {
      // Copy the array over, since we don't want arrays to be merged
      b[key] = value;      
    }
    else if(b[key] && (b[key] instanceof DvtCSSStyle)) {
      // If an object is defined as CSS in the base object, merge the CSS
      if(value instanceof DvtCSSStyle) 
        b[key].merge(value);
      else // value is String
        b[key].merge(new DvtCSSStyle(value));
    }
    else if(DvtJSONUtils._isDeepClonable(value)) {
      // Deep clone if object exists in b, copy otherwise
      if(b[key])
        DvtJSONUtils._copy(value, b[key]);
      else
        b[key] = value;
    }
    else
      b[key] = value;
  }
}

/**
 * Checks the type of an object and returns whether it is deep clonable
 * @param {Object} The object to check the type of
 * @return {boolean} Whether the object is deep clonable
 * @private
 */
DvtJSONUtils._isDeepClonable = function(obj) {
  if(typeof obj == 'undefined')
    return false;
  else
    return (obj instanceof Object) && !(obj instanceof Boolean) && !(obj instanceof String) && !(obj instanceof Number) && !(obj instanceof Function);
}
/**
 * Abstract class for Events. 
 * 
 * <p>The supported fields are:
 * <ul>
 * <li>target</li>
 * <li>type</li>
 * </ul>
 * <p>
 */
var DvtBaseEvent = function() {}

DvtObj.createSubclass(DvtBaseEvent, DvtObj, "DvtBaseEvent");

/**
 * Object initializer
 * 
 * @param {String} type
 * @param {String} target
 */
DvtBaseEvent.prototype.Init = function(type, target)
{
  this.type = type;
  this.target = target;
}

/**
 * Returns the native event that we are wrapping
 * @return {Object} The native event that we are wrapping
 */
DvtBaseEvent.prototype.getNativeEvent = function() {
  return null; // subclasses should override
}

/**
 * Prevents the default browser action that the native event would have triggered
 */
DvtBaseEvent.prototype.preventDefault = function() {
  // subclasses should override
} 

/**
 * Stops propagation of the native event in the browser's event bubbling phase.
 */
DvtBaseEvent.prototype.stopPropagation = function() {
  // subclasses should override
} 

/**
 * Checks whether event propagation was stopped
 */
DvtBaseEvent.prototype.isPropagationStopped = function() {
  // subclasses should override
  return false;
} 
/**
 * Base class for component level events.
 * @class The base class for component level events.
 * @constructor
 * @export
 */
var DvtBaseComponentEvent = function() {}

DvtObj.createSubclass(DvtBaseComponentEvent, DvtObj, "DvtBaseComponentEvent");


DvtBaseComponentEvent.CLIENT_ROW_KEY = "clientRowKey";


/**
 * @param {string} type The event type for this event.
 * @protected
 */
DvtBaseComponentEvent.prototype.Init = function(type) {
  this._type = type;
}

/**
 * Returns the event type for this event.
 * @return {string} The event type for this event.
 * @export
 */
DvtBaseComponentEvent.prototype.getType = function() {
  return this._type;
}

/**
 * Return a list of additional parameter keys
 * @return {array} paramKeys additional parameter keys
 */
DvtBaseComponentEvent.prototype.getParamKeys = function() {
  return this._paramKeys;
}

/**
 * Return a list of additional parameter values
 * @return {array} paramValues additional parameter values
 */
DvtBaseComponentEvent.prototype._getParamValues = function() {
  return this._paramValues;
}


/**
 * Add an additional parameter (key, value) to this event (ex clientRowKey)
 * @param {String} paramKey parameter key
 * @param {String} paramValue parameter value
 */
DvtBaseComponentEvent.prototype.addParam = function(paramKey, paramValue) {
  if (! this._paramKeys) {
    this._paramKeys = [];
    this._paramValues = [];
  }

  this._paramKeys.push(paramKey);
  this._paramValues.push(paramValue);
}


/**
 * Get parameter value in this event 
 * @param {String} paramKey parameter key
 * @return {String} paramValue parameter value
 */
DvtBaseComponentEvent.prototype.getParamValue = function(paramKey) {
  if (! paramKey || ! this._paramKeys || ! this._paramValues) {
    return null;
  }

  var index = -1;
  for (var i = 0; i < this._paramKeys.length; i++) {
    if (this._paramKeys[i] == paramKey) {
      index = i;
      break;
    }
  }

  if (index != -1) {
    return this._paramValues[index];
  }  

  return null;
};




/**
 * Platform independent class for Keyboard Events.  
 * 
 * <p>The supported fields are:
 * <ul>
 * <li>altKey</li>
 * <li>ctrlKey</li>
 * <li>shiftKey</li>
 * <li>charCode</li>
 * <li>keyCode</li>
 * </ul>
 * 
 * @constructor
 * @param {String} type
 * @param {boolean} bubbles
 * @param {boolean} cancelable
 * @param {Object} view
 * @param {Number} charCode
 * @param {Number} keyCode
 * @param {Number} keyLocation
 * @param {Boolean} ctrlKey
 * @param {Boolean} altKey
 * @param {Boolean} shiftKey
 * @param {Boolean} repeat
 * @param {String} locale
 */
var DvtKeyboardEvent = function(type, bubbles, cancelable, view, charCode, keyCode, keyLocation, ctrlKey, altKey, shiftKey, repeat, locale)
{
  this.Init(type, bubbles, cancelable, view, charCode, keyCode, keyLocation, ctrlKey, altKey, shiftKey, repeat, locale);
}

DvtObj.createSubclass(DvtKeyboardEvent, DvtBaseEvent, "DvtKeyboardEvent");

// Constants for keyboard event types
//FIX BUG 17075260: indirectly assign the value so the closure compiler will abbreviate references to the constant
DvtKeyboardEvent.KEYDOWN = DvtObj.defineConstant("keydown");
DvtKeyboardEvent.KEYUP = DvtObj.defineConstant("keyup");

// These constants apply for both Flash and Javascript
DvtKeyboardEvent.TAB = 9;
DvtKeyboardEvent.ENTER = 13;
DvtKeyboardEvent.SHIFT = 16;
DvtKeyboardEvent.CONTROL = 17;
DvtKeyboardEvent.ESCAPE = 27;
DvtKeyboardEvent.SPACE = 32;
DvtKeyboardEvent.PAGE_UP = 33;
DvtKeyboardEvent.PAGE_DOWN = 34;
DvtKeyboardEvent.UP_ARROW = 38;
DvtKeyboardEvent.DOWN_ARROW = 40;
DvtKeyboardEvent.DELETE = 46;
DvtKeyboardEvent.LEFT_ARROW = 37;
DvtKeyboardEvent.RIGHT_ARROW = 39;
DvtKeyboardEvent.OPEN_BRACKET = 219;
DvtKeyboardEvent.CLOSE_BRACKET = 221;
DvtKeyboardEvent.BACK_SLASH = 220;
DvtKeyboardEvent.FORWARD_SLASH = 191;
DvtKeyboardEvent.ZERO = 48;
DvtKeyboardEvent.NUMPAD_ZERO = 96;

DvtKeyboardEvent.NUMPAD_PLUS = 107;
DvtKeyboardEvent.NUMPAD_MINUS = 109;
DvtKeyboardEvent.WEBKIT_PLUS = 187;
DvtKeyboardEvent.WEBKIT_MINUS = 189;
DvtKeyboardEvent.GECKO_PLUS = 61;
DvtKeyboardEvent.GECKO_MINUS = 173;

DvtKeyboardEvent.A = 65;
DvtKeyboardEvent.F = 70;
DvtKeyboardEvent.M = 77;
DvtKeyboardEvent.PERIOD = 190;
DvtKeyboardEvent.NUMPAD_PERIOD = 110;
DvtKeyboardEvent.SINGLE_QUOTE = 222;
DvtKeyboardEvent.STAR = 56;
DvtKeyboardEvent.NUMPAD_STAR = 144;
DvtKeyboardEvent.SEMICOLON = 186;
DvtKeyboardEvent.OPEN_ANGLED_BRACKET = 188;
DvtKeyboardEvent.CLOSE_ANGLED_BRACKET = 190;
DvtKeyboardEvent.GRAVE_ACCENT = 192;

/**
 * Object initializer.  This essentially mirrors the DOM initKeyboardEvent() API
 * @param {String} type
 * @param {boolean} bubbles
 * @param {boolean} cancelable
 * @param {Object} view
 * @param {Number} charCode
 * @param {Number} keyCode
 * @param {Number} keyLocation
 * @param {Boolean} ctrlKey
 * @param {Boolean} altKey
 * @param {Boolean} shiftKey
 * @param {Boolean} repeat
 * @param {String} locale
 */
DvtKeyboardEvent.prototype.Init = function(type, bubbles, cancelable, view, charCode, keyCode, keyLocation, ctrlKey, altKey, shiftKey, repeat, locale)
{
  DvtKeyboardEvent.superclass.Init.call(this, type, null);
  this.bubbles = bubbles;
  this.cancelable = cancelable;
  this.view = view;
  this.charCode = charCode;
  this.keyCode = keyCode;
  this.keyLocation = keyLocation;
  this.ctrlKey = ctrlKey;
  this.altKey = altKey;
  this.shiftKey = shiftKey;
  this.repeat = repeat;
  this.locale = locale;
}

/**
 * Utility method that returns true if the keyboard event is a plus keystroke. Handy because keycodes differ
 * across different render kits
 * @param {DvtKeyboardEvent} event
 * @return {Boolean} true if the event is a "+" keystroke
 */
DvtKeyboardEvent.isPlus = function(event)
{
  var keyCode = event.keyCode;
  if (keyCode == DvtKeyboardEvent.NUMPAD_PLUS)
    return true;
  
  if(DvtAgent.isPlatformGecko())
  {
    // special case for Gecko/Firefox
    if(keyCode == DvtKeyboardEvent.GECKO_PLUS && event.shiftKey)
      return true;
    else
      return false;
  }
  else
  {
    if(keyCode == DvtKeyboardEvent.WEBKIT_PLUS && event.shiftKey)
      return true;
    else
      return false;
  }
  return false;
}

/**
 * Utility method that returns true if the keyboard event is a equals keystroke. Handy because keycodes differ
 * across different render kits
 * @param {DvtKeyboardEvent} event
 * @return {Boolean} true if the event is a "+" keystroke
 */
DvtKeyboardEvent.isEquals = function(event)
{
  var keyCode = event.keyCode;
  
  if(DvtAgent.isPlatformGecko())
  {
    // special case for Gecko/Firefox
    if(keyCode == DvtKeyboardEvent.GECKO_PLUS && !event.shiftKey)
      return true;
    else
      return false;
  }
  else
  {
    if(keyCode == DvtKeyboardEvent.WEBKIT_PLUS && !event.shiftKey)
      return true;
    else
      return false;
  }
  return false;
}


/**
 * Utility method that returns true if the keyboard event is a minus keystroke. Handy because keycodes differ
 * across different render kits
 * @param {DvtKeyboardEvent} event
 * @return {Boolean} true if the event is a "-" keystroke
 */
DvtKeyboardEvent.isMinus = function(event)
{
  var keyCode = event.keyCode;
  
  if (keyCode == DvtKeyboardEvent.NUMPAD_MINUS)
    return true;  
  
  if(DvtAgent.isPlatformGecko())
  {
    // special case for Gecko/Firefox
    if(keyCode == DvtKeyboardEvent.GECKO_MINUS && !event.shiftKey)
      return true;
    else
      return false;
  }
  else
  {
    if(keyCode == DvtKeyboardEvent.WEBKIT_MINUS && !event.shiftKey)
      return true;
    else
      return false;
  }
  return false;
}

/**
 * Utility method that returns true if the keyboard event is an underscore keystroke. Handy because keycodes differ
 * across different render kits
 * @param {DvtKeyboardEvent} event
 * @return {Boolean} true if the event is a "_" keystroke
 */
DvtKeyboardEvent.isUnderscore = function(event)
{
  var keyCode = event.keyCode;
  
  if(DvtAgent.isPlatformGecko())
  {
    // special case for Gecko/Firefox
    if(keyCode == DvtKeyboardEvent.GECKO_MINUS && event.shiftKey)
      return true;
    else
      return false;
  }
  else
  {
    if(keyCode == DvtKeyboardEvent.WEBKIT_MINUS && event.shiftKey)
      return true;
    else
      return false;
  }
  return false;
}
/**
 * @constructor
 * Abstract class for Mouse Events.  This class roughly follows the DOM Level 2 API.  
 * 
 * <p>The supported fields are:
 * <ul>
 * <li>ctrlKey</li>
 * <li>relatedTarget</li>
 * <li>target</li>
 * <li>type</li>
 * </ul>
 * <p>
 */
var DvtMouseEvent = function(type, target, relatedTarget, button, ctrlKey, metaKey, shiftKey, pageX, pageY) 
{
  this.Init(type, target, relatedTarget, button, ctrlKey, metaKey, shiftKey, pageX, pageY);
}

DvtObj.createSubclass(DvtMouseEvent, DvtBaseEvent, "DvtMouseEvent");

// Constants for mouse event types
//FIX BUG 17075260: indirectly assign the value so the closure compiler will abbreviate references to the constant
DvtMouseEvent.CLICK = DvtObj.defineConstant("click");
DvtMouseEvent.DBLCLICK = DvtObj.defineConstant("dblclick");
DvtMouseEvent.MOUSEOVER = DvtObj.defineConstant("mouseover");
DvtMouseEvent.MOUSEOUT = DvtObj.defineConstant("mouseout");
DvtMouseEvent.MOUSEDOWN = DvtObj.defineConstant("mousedown");
DvtMouseEvent.MOUSEUP = DvtObj.defineConstant("mouseup");
DvtMouseEvent.MOUSEMOVE = DvtObj.defineConstant("mousemove");
DvtMouseEvent.MOUSEWHEEL = DvtObj.defineConstant("mousewheel");

DvtMouseEvent.RIGHT_CLICK_BUTTON = 2;

/**
 * Object initializer. This essentially mirrors the DOM initMouseEvent() API
 * @param {String} type
 * @param {Boolean} bubbles
 * @param {Boolean} cancelable
 * @param {Object} view
 * @param {Number} detail
 * @param {Number} pageX
 * @param {Number} pageY
 * @param {Number} clientX
 * @param {Number} clientY
 * @param {Boolean} ctrlKey
 * @param {Boolean} altKey
 * @param {Boolean} shiftKey
 * @param {Boolean} metaKey
 * @param {Number} button
 * @param {Object} relatedTarget
 */
DvtMouseEvent.prototype.Init = function(type, bubbles, cancelable, view, detail, pageX, pageY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey, button, relatedTarget)
{
  DvtMouseEvent.superclass.Init.call(this, type, null);
  this.bubbles = bubbles;
  this.cancelable = cancelable;
  this.view = view;
  this.detail = detail;
  this.pageX = pageX;
  this.pageY = pageY;
  this.clientX = clientX;
  this.clientY = clientY;
  this.ctrlKey = ctrlKey || metaKey;
  this.altKey = altKey;
  this.shiftKey = shiftKey;
  this.metaKey = metaKey;
  this.button = button;
  this.relatedTarget = relatedTarget;
}

/**
 * Abstract class for Touch Events.
 * 
 * <p>The supported fields are:
 * <ul>
 * <li>touches</li>
 * <li>targetTouches</li>
 * <li>changedTouches</li>
 * <li>target</li>
 * <li>type</li>
 * </ul>
 * <p>
 */
var DvtTouchEvent = function() {}

DvtObj.createSubclass(DvtTouchEvent, DvtBaseEvent, "DvtTouchEvent");

// Constants for touch event types
//FIX BUG 17075260: indirectly assign the value so the closure compiler will abbreviate references to the constant
DvtTouchEvent.TOUCHSTART = DvtObj.defineConstant("touchstart");
DvtTouchEvent.TOUCHMOVE = DvtObj.defineConstant("touchmove");
DvtTouchEvent.TOUCHEND = DvtObj.defineConstant("touchend");
DvtTouchEvent.TOUCHCANCEL = DvtObj.defineConstant("touchcancel");

DvtTouchEvent.prototype.Init = function()
{
}
/**
 * @constructor
 * Wrapper class providing access to a Touch.
 * @extends DvtObj
 * @class DvtTouch
 * <p>The supported fields are:
 * <ul>
 * <li>clientX</li>
 * <li>clientY</li>
 * <li>screenX</li>
 * <li>screenY</li>
 * <li>pageX</li>
 * <li>pageY</li>
 * <li>target</li>
 * <li>identifier</li>
 * </ul>
 * <p>
 */
var DvtTouch = function(touch) {
  this.Init(touch);
}

DvtObj.createSubclass(DvtTouch, DvtObj, "DvtTouch");

/**
 * @protected
 * @param {Touch} the DOM Touch
 */
DvtTouch.prototype.Init = function(touch) {
  this.clientX = touch.clientX;
  this.clientY = touch.clientY;
  this.screenX = touch.screenX;
  this.screenY = touch.screenY;
  this.pageX = touch.pageX;
  this.pageY = touch.pageY;
  this.target = touch.target;
  this.identifier = (touch.identifier == null || isNaN(touch.identifier)) ? 1 : touch.identifier;
}
/**
 * @constructor
 * Keeps track of the current state of touches and fires higher-level logical events
 * @extends DvtObj
 * @class DvtTouchManager
 */
var DvtTouchManager = function(id, context) {
  this.Init(id, context);
}

DvtObj.createSubclass(DvtTouchManager, DvtObj, "DvtTouchManager");

DvtTouchManager.TOUCH_MODE = "mode";
DvtTouchManager.TOUCH_MODE_DEFAULT = "defaultMode";
DvtTouchManager.TOUCH_MODE_LONG_PRESS = "longPressMode";

DvtTouchManager.PREV_HOVER_OBJ = "prevHoverObj";

DvtTouchManager.HOVER_TOUCH_KEY = "hoverTouch";

/**
 * @protected
 * Helper method called by the constructor to initialize this object.
 * @param {string} id Id for the this TouchManager instance
 * @param {DvtContext} context An application specific context
 */
DvtTouchManager.prototype.Init = function(id, context) {
  this._context = context;
  this._id = id;
  
  // Total number of touches on the screen
  this._touchCount = 0;

  // Single timer for touch hold 
  this._touchHoldTimer = new DvtTimer(this._context, 200, this._handleTouchHoldStartTimer, this);
  this._blockTouchHold = false;
  
  // Stored mapping for history information on touches
  this._touchMap = new Object();

  // Limit the region for which this touch manager applies.
  this._touchRegionBounds = null;  

  // Save information on touches which are already associated with listeners
  this._savedTouchInfo = new Array();

  // internal listener to translate to hover
  this._addTouchHoldMoveEventListener(this._onTouchHoldHover, this);

  // Single timer for double tap
  this._doubleTapTimer = new DvtTimer(this._context, 300, this._handleDoubleTapTimer, this, 1);

}

/**
 * Block touch hold event. We might want to prevent touch hold during zoom oparation.
 */
DvtTouchManager.prototype.blockTouchHold = function () {
    this._touchHoldTimer.stop();
    this._blockTouchHold = true;
}

/**
 * Releases touch hold block.
 */
DvtTouchManager.prototype.unblockTouchHold = function () {
    this._blockTouchHold = false;
}

DvtTouchManager.prototype._addTouchHoldMoveEventListener = function (listener, obj) {
    this.addTouchEventListener(DvtComponentTouchEvent.TOUCH_HOLD_START_TYPE, listener, obj);
    this.addTouchEventListener(DvtComponentTouchEvent.TOUCH_HOLD_MOVE_TYPE, listener, obj);
    this.addTouchEventListener(DvtComponentTouchEvent.TOUCH_HOLD_END_TYPE, listener, obj);
}

/**
 * Internal touch hold listener to translate to hover events
 * @private
 * @param {DvtComponentTouchEvent} evt A touch hold event.
 */
DvtTouchManager.prototype._onTouchHoldHover = function(evt) {
    var type = evt.getType();
    var touch = evt.touch;
    
    var info = this._touchMap[touch.identifier];
    
    var obj = evt.target;
    if (type == DvtComponentTouchEvent.TOUCH_HOLD_END_TYPE) {
        var hoverEvt = new DvtComponentTouchEvent(DvtComponentTouchEvent.TOUCH_HOVER_END_TYPE, touch, obj);
        hoverEvt._isCancelEvent = this._isCancelEvent;
        
        if (obj != null)
            this.FireListener(new DvtComponentTouchEvent(DvtComponentTouchEvent.TOUCH_HOVER_OUT_TYPE, touch, obj));
        info[DvtTouchManager.PREV_HOVER_OBJ] = null;
            
        this.FireListener(hoverEvt);
    } else if (type == DvtComponentTouchEvent.TOUCH_HOLD_START_TYPE) {
        info[DvtTouchManager.PREV_HOVER_OBJ] = null;
        if (obj != null)
            this.FireListener(new DvtComponentTouchEvent(DvtComponentTouchEvent.TOUCH_HOVER_OVER_TYPE, touch, obj));
        info[DvtTouchManager.PREV_HOVER_OBJ] = obj;

        this.FireListener(new DvtComponentTouchEvent(DvtComponentTouchEvent.TOUCH_HOVER_START_TYPE, touch, obj));
    } else if (type == DvtComponentTouchEvent.TOUCH_HOLD_MOVE_TYPE) {
        this._fireHoverOverOutEvents(obj, info[DvtTouchManager.PREV_HOVER_OBJ], touch);
        info[DvtTouchManager.PREV_HOVER_OBJ] = obj;
        this.FireListener(new DvtComponentTouchEvent(DvtComponentTouchEvent.TOUCH_HOVER_MOVE_TYPE, touch, obj));

    }
}

DvtTouchManager.prototype._getObjFromTouch = function(touch) {
    var obj = null;

    if (touch) {
        var relPos = this._context.pageToStageCoords(touch.pageX, touch.pageY);
        if (!this._touchRegionBounds || this._touchRegionBounds.containsPoint(relPos.x, relPos.y)) {
        // If the rendering impl doesn't define document utils for finding the element at a point, don't continue
            var documentUtils = this._context.getDocumentUtils();
            if (documentUtils) {
                obj = documentUtils.elementFromTouch(touch);
            }
        }    
    }
    return obj;
}

// Fire logical hover events
DvtTouchManager.prototype._fireHoverOverOutEvents = function(currentObj, prevHoverObj, touch) {
    if (prevHoverObj != currentObj) {
        if (prevHoverObj != null)
            this.FireListener(new DvtComponentTouchEvent(DvtComponentTouchEvent.TOUCH_HOVER_OUT_TYPE, touch, prevHoverObj, currentObj));
        if (currentObj != null)
            this.FireListener(new DvtComponentTouchEvent(DvtComponentTouchEvent.TOUCH_HOVER_OVER_TYPE, touch, currentObj, prevHoverObj));
    }
}

/**
 * Adds an event listener.
 * @param {string} type One of the DvtComponentTouchEvent types
 * @param {function} listener Listener to add
 * @param {object} obj Optional object on which the listener function is defined
 */
DvtTouchManager.prototype.addTouchEventListener = function (type, listener, obj) {
  // Store a reference to the listener
  var listenersArray = this._getListeners(type, true);
  listenersArray.push(listener);
  listenersArray.push(obj);
}

/**
 * Removes an event listener.
 * @param {string} type One of the DvtComponentTouchEvent types
 * @param {function} listener Listener to remove
 * @param {object} obj Optional object on which the listener function is defined
 */
DvtTouchManager.prototype.removeTouchEventListener = function (type, listener, obj) {
  // Remove the listener
  var listenersArray = this._getListeners(type, false);
  if (listenersArray) {
    for (var i = 0;i < listenersArray.length;i+=2) {
      if (listenersArray[i] === listener && 
           listenersArray[i+1] === obj) {
        listenersArray.splice(i, 2);
        break;
      }
    }
  }
}

/**
 * Returns the listeners of the given event type and capture mode.
 **/
DvtTouchManager.prototype._getListeners = function (type, createNew) {
  // First find the object where the listener arrays are stored
  if (!this._listenerObj) {
    if (createNew) {
      this._listenerObj = {
      };
    }
    else {
      return null;
    }
  }

  // Then find the array for this event type, creating if necessary 
  var eventKey = type;
  var listenersArray = this._listenerObj[eventKey];
  if (!listenersArray && createNew) {
    listenersArray = [];
    this._listenerObj[eventKey] = listenersArray;
  }

  return listenersArray;
};

/**
 * Notifies all applicable event listeners of the given event.
 **/
DvtTouchManager.prototype.FireListener = function (event) {
  var listenersArray = this._getListeners(event.getType(), false);
  if (listenersArray) {
    for (var i = 0;i < listenersArray.length;i+=2) {
      var obj = listenersArray[i+1];
      listenersArray[i].call(obj, event);
    }
  }
};

DvtTouchManager.prototype.startTouchHold = function() {
    var touchid = this._startSingleFingerTouchId;
    if (touchid != null && !isNaN(touchid)) {
        var info = this._touchMap[touchid];
        if (info) {

            var touchStartObj = info["startTarget"];
            var startTouch = info["startTouch"];

            // If there are any immediate touches for this id, end it since touch hold has started            
            var matches = this._findMatches("touchId", touchid);
            for (var i=0; i<matches.length;i++) {
                var savedInfo = matches[i];
                var touchObj = savedInfo["touchObj"];
                var touchId = savedInfo["touchId"];
                if (touchObj != DvtTouchManager.HOVER_TOUCH_KEY) {
                    var touchInfo = this.getTouchInfo(touchId);
                    var touch = touchInfo["startTouch"];
                    this.performAssociatedTouchEnd(touch, touchObj, null);
                }
            }

            // Save mode on touch
            info[DvtTouchManager.TOUCH_MODE] = DvtTouchManager.TOUCH_MODE_LONG_PRESS;
            this.saveProcessedTouch(touchid, DvtTouchManager.HOVER_TOUCH_KEY, null, DvtTouchManager.HOVER_TOUCH_KEY, DvtTouchManager.HOVER_TOUCH_KEY, this.HoverMoveInternal, this.HoverEndInternal, this);
            
            var touchHoldStartEvent = new DvtComponentTouchEvent(DvtComponentTouchEvent.TOUCH_HOLD_START_TYPE, startTouch, touchStartObj);
            this.FireListener(touchHoldStartEvent);
            
        }
    }
}

// Execute listeners for logical events.
// Note that there is no way to bubble logical events in the framework at the moment
DvtTouchManager.prototype.fireLogicalEvents = function(touchEvent) {
    var type = touchEvent.type;
    if (type == DvtTouchEvent.TOUCHSTART) {
      if (!touchEvent.isTouchHoldBlocked()) {
        this.processAssociatedTouchAttempt(touchEvent, DvtTouchManager.HOVER_TOUCH_KEY, this.HoverStartInternal, this);
      }
      if (this._doubleTapAttemptStarted) {
          touchEvent.preventDefault();
      }
      else {
      //this is in here to prevent the magnifying glass from coming up in chrome on android, a la bug 14033184. Disabling default event only on legend text and markers so that the mag glass doesn't show up.
        var info = this.getTouchInfo(touchEvent.changedTouches[0].identifier);
        var targetObj = info.currentObj;
        if (DvtAgent.isBrowserChrome() && (targetObj instanceof DvtMarker || targetObj instanceof DvtText)){
          touchEvent.preventDefault();
        }
      }
    } else if (type == DvtTouchEvent.TOUCHMOVE) {
        this.processAssociatedTouchMove(touchEvent, DvtTouchManager.HOVER_TOUCH_KEY);
    } else if (type == DvtTouchEvent.TOUCHEND) {
        this.processAssociatedTouchEnd(touchEvent, DvtTouchManager.HOVER_TOUCH_KEY);
    }

    if (type == DvtTouchEvent.TOUCHEND) {
        var changedTouches = this._getStoredTouches(touchEvent.changedTouches);
        for (var i=0; i<changedTouches.length; i++) {
            var touch = changedTouches[i];
            var identifier = touch.identifier;
            var info = this.getTouchInfo(identifier);
    
            var targetObj = info.currentObj;
            
            if (info[DvtTouchManager.TOUCH_MODE] != DvtTouchManager.TOUCH_MODE_LONG_PRESS) {
                if (info.fireClick) {
                    var touchClickEvt = new DvtComponentTouchEvent(DvtComponentTouchEvent.TOUCH_CLICK_TYPE, touch, targetObj);
                    touchClickEvt.touchEvent = touchEvent;
                    this.FireListener(touchClickEvt);

                    if (this._doubleTapAttemptStarted) {
                        var prevTapObj = this._doubleTapAttemptObj;
                        this.resetDoubleTap();
                        if (targetObj == prevTapObj) {
                            var touchDblClickEvt = new DvtComponentTouchEvent(DvtComponentTouchEvent.TOUCH_DOUBLE_CLICK_TYPE, touch, targetObj);
                            touchDblClickEvt.touchEvent = touchEvent;
                            this.FireListener(touchDblClickEvt);
                        }
                    } else {
                        this.resetDoubleTap();
                        this._doubleTapTimer.start();
                        this._doubleTapAttemptStarted = true;
                        this._doubleTapAttemptObj = targetObj;
                    }
                }
            }
        }
    }
}

DvtTouchManager.prototype.getTouchInfo = function(touchId) {
    return this._touchMap[touchId];
}

/**
 * Handler for the touch event. Starts timer for the potential hover event.
 * @param {DvtTouchEvent} event Wrapper for the native event
 * @param {DvtTouch} touch Touch object for the event
 * @protected
 */
DvtTouchManager.prototype.HoverStartInternal = function(event, touch) {
    if (this._blockTouchHold)
        return;
    var identifier = touch.identifier;
    this._startSingleFingerTouchId = identifier;
    this._touchHoldTimer.stop();
    this._touchHoldTimer.start();
}

DvtTouchManager.prototype.HoverMoveInternal = function(event, touch) {
    var identifier = touch.identifier;
    var info = this.getTouchInfo(identifier);
    var targetObj = info.currentObj;
    var touchHoldMoveEvent = new DvtComponentTouchEvent(DvtComponentTouchEvent.TOUCH_HOLD_MOVE_TYPE, touch, targetObj);
    this.FireListener(touchHoldMoveEvent);
    event.preventDefault();
}

DvtTouchManager.prototype.HoverEndInternal = function(event, touch) {
    var identifier = touch.identifier;
    var info = this.getTouchInfo(identifier);
    var targetObj = info.currentObj;
    var touchHoldEndEvent = new DvtComponentTouchEvent(DvtComponentTouchEvent.TOUCH_HOLD_END_TYPE, touch, targetObj);
    this.FireListener(touchHoldEndEvent);
    if (event)
        event.preventDefault();
}

DvtTouchManager.prototype.resetTouchHold = function() {
  this._startSingleFingerTouchId = null;
  if (this._touchHoldTimer)
      this._touchHoldTimer.stop();
}

/**
 * Updates state information for current touches before logical event "bubbles"
 * @param {DvtTouchEvent} touchEvent Touch event
 */
DvtTouchManager.prototype.preEventBubble = function(touchEvent) {
  if (touchEvent.setTouchManager)
    touchEvent.setTouchManager(this);

  var type = touchEvent.type;
  if (type == DvtTouchEvent.TOUCHSTART) {
    this.processTouchStart(touchEvent); 
  } else if (type == DvtTouchEvent.TOUCHMOVE) {
    this.processTouchMove(touchEvent); 
  } else if (type == DvtTouchEvent.TOUCHEND) {
    this.processTouchEnd(touchEvent);    
  }
}

// Updates state information after logical event is done "bubbling"
DvtTouchManager.prototype.postEventBubble = function(touchEvent) {
     var type = touchEvent.type;

     if (type == DvtTouchEvent.TOUCHSTART) {
     } else if (type == DvtTouchEvent.TOUCHMOVE) {
     } else if (type == DvtTouchEvent.TOUCHEND) {
        var changedTouches = this._getStoredTouches(touchEvent.changedTouches);
        for (var i=0; i<changedTouches.length; i++)
        {
            var changedTouch = changedTouches[i];
            var identifier = changedTouch.identifier;

            delete this._touchMap[identifier];
            if (this._startSingleFingerTouchId == identifier) {
                this._startSingleFingerTouchId = null;
            }
            // Stop propagation may not allow touch manager to clear saved touch info.  Need to check for any remaining
            // info and remove
            var savedMatches = this._findMatches("touchId", identifier);
            for (var j=0;j<savedMatches.length;j++) {
                var match = savedMatches[j];
                this.removeTooltipInfo(match["touchId"], match["touchObj"]);
            }
        }
    }
}

DvtTouchManager.prototype.saveProcessedTouch = function(touchId, touchObj, tooltipObjOverride, grouping, type, moveListener, endListener, listenerObj) {
  if (touchId != null && !isNaN(touchId)) {
    var info = DvtTouchManager.createSavedTouchInfo(touchId, touchObj, tooltipObjOverride, grouping, type, moveListener, endListener, listenerObj);
    this._savedTouchInfo.push(info);
    return true;
  }
  return false;
}

DvtTouchManager.prototype.saveProcessedTouchDefault = function(touchId, touchObj, tooltipObjOverride, grouping, type, listenerObj) {
    var movedListener = null;
    if (listenerObj.immediateTouchMoved)
       movedListener = listenerObj.immediateTouchMoved;
    var endListener = null;
    if (listenerObj.immediateTouchEnded)
       endListener = listenerObj.immediateTouchEnded;

    this.saveProcessedTouch(touchId, touchObj, tooltipObjOverride, grouping, type, movedListener, endListener, listenerObj);
}

DvtTouchManager.prototype.processAssociatedTouch = function(event, uniqueKey, startListener, listenerObj) {
    var type = event.type;
    if (type == DvtTouchEvent.TOUCHSTART) {
        this.processAssociatedTouchAttempt(event, uniqueKey, startListener, listenerObj);
    } else if (type == DvtTouchEvent.TOUCHMOVE) {
        this.processAssociatedTouchMove(event, uniqueKey);
    } else if (type == DvtTouchEvent.TOUCHEND) {
        this.processAssociatedTouchEnd(event, uniqueKey);
    }
}

// immediateTouchObj implements a defined interface for handling single touches on the object
DvtTouchManager.prototype.processAssociatedTouchDefault = function(event, immediateTouchObj) {
    this.processAssociatedTouch(event, immediateTouchObj, immediateTouchObj.immediateTouchAttempted, immediateTouchObj);
}

DvtTouchManager.prototype.cancelTouchHold = function() {
    var uniqueKey = DvtTouchManager.HOVER_TOUCH_KEY;
    var touchIds = this.getTouchIdsForObj(uniqueKey);
    for (var i=0; i<touchIds.length; i++) {
        var touchId = touchIds[i];
        var info = this.getTouchInfo(touchId);
        var touch = info["startTouch"];
        if (touch) {
            this._isCancelEvent = true;
            this.performAssociatedTouchEnd(touch, uniqueKey, null);
            this._isCancelEvent = false;
            delete this._touchMap[touchId];
        }
    }

}

DvtTouchManager.prototype.performAssociatedTouchEnd = function(touch, uniqueKey, event) {
    var identifier = touch.identifier;
    var savedInfo = this.getSavedTouchInfo(identifier, uniqueKey);
    if (savedInfo) {
        var listenerObj = savedInfo["listenerObj"];
        var endListener = savedInfo["endListener"]; 

        // Remove tooltip info first
        this.removeTooltipInfo(identifier, uniqueKey);
        if (endListener) {
            endListener.call(listenerObj, event, touch, savedInfo);
        }
    }
}

DvtTouchManager.prototype.processAssociatedTouchAttempt = function(event, uniqueKey, startListener, listenerObj) {
    var touches = event.changedTouches;
    for (var i=0; i<touches.length; i++) {
        var touch = touches[i];
        if (touch) {
            if (startListener)
                startListener.call(listenerObj, event, touch);
        }
    }
}

DvtTouchManager.prototype.processAssociatedTouchMove = function(event, uniqueKey) {
    var touchIds = this.getTouchIdsForObj(uniqueKey);
    for (var i=0; i<touchIds.length; i++) {
        var touchId = touchIds[i];
        if (touchId != null && !isNaN(touchId)) {
            var touch = DvtTouchManager.getTouchById(touchId, this._getStoredTouches(event.changedTouches));
            if (touch) {
                var savedInfo = this.getSavedTouchInfo(touch.identifier, uniqueKey);
                if (savedInfo) {
                    var listenerObj = savedInfo["listenerObj"];
                    var moveListener = savedInfo["moveListener"];
    
                    if (moveListener)
                        moveListener.call(listenerObj, event, touch);
                        
                }
            }
        }
    }
}

DvtTouchManager.prototype.processAssociatedTouchEnd = function(event, uniqueKey) {
    var touchIds = this.getTouchIdsForObj(uniqueKey);
    for (var i=0; i<touchIds.length; i++) {
        var touchId = touchIds[i];
        var touch = DvtTouchManager.getTouchById(touchId, this._getStoredTouches(event.changedTouches));
        if (touch) {
            this.performAssociatedTouchEnd(touch, uniqueKey, event);
        }
    }
}

DvtTouchManager.prototype._findMatch = function(matchProp, matchValue) {
    var idx = -1;
    for (var i=0; i<this._savedTouchInfo.length; i++) {
        var info = this._savedTouchInfo[i];
        if (info[matchProp] == matchValue) {
            idx = i;
        }
    }
    return idx;
}
DvtTouchManager.prototype._findMatches = function(matchProp, matchValue) {
    var results = new Array();
    for (var i=0; i<this._savedTouchInfo.length; i++) {
        var info = this._savedTouchInfo[i];
        if (info[matchProp] == matchValue) {
            results.push(info);
        }
    }
    return results;
}



DvtTouchManager.prototype.getSavedTouchInfo = function(touchId, uniqueKey) {
    var matches = this._findMatches("touchId", touchId);
    for (var i=0; i<matches.length;i++) {
        var info = matches[i];
        if (info["touchObj"] == uniqueKey) {
            return info;
        }
    }
    return null;
}
DvtTouchManager.prototype.containsTouchId = function(touchId) {
    var matches = this._findMatches("touchId", touchId);
    return matches.length > 0;
}

DvtTouchManager.prototype.getTouchIdsForObj = function(touchObj) {
    var results = new Array();
    var matches = this._findMatches("touchObj", touchObj);
    for (var i=0; i<matches.length;i++) {
        var info = matches[i];
        var touchId = info["touchId"];
        results.push(touchId);
    }
    return results;
}

DvtTouchManager.prototype.removeTooltipInfo = function(touchId, uniqueKey) {
    var matches = this._findMatches("touchId", touchId);
    var removeObjects = new Array();
    for (var i=0; i<matches.length;i++) {
        var info = matches[i];
        if (info["touchObj"] == uniqueKey) {
            removeObjects.push(info);
        }
    }
    for (var i=0; i<removeObjects.length;i++) {
        var removeObj = removeObjects[i];
        var removeIdx = -1;
        for (var j=0; j<this._savedTouchInfo.length; j++) {
            var info = this._savedTouchInfo[j];
            if (info == removeObj) {
                removeIdx = j;
            }
        }
        if (removeIdx != -1 ){
            this._savedTouchInfo.splice(removeIdx, 1);
            if (this._savedTouchInfo.length == 0) {
                this._context.getTooltipManager().hideTooltip();
            }
        }
    }
}

DvtTouchManager.prototype.setTooltipEnabled = function(touchId, enabled) {
    var tooltipInfoArray = this._savedTouchInfo;
    for (var i=0; i<tooltipInfoArray.length; i++) {
        var tooltipInfo = tooltipInfoArray[i];
        var tooltipTouchId = tooltipInfo.touchId;
        if (tooltipTouchId == touchId) {
            tooltipInfo["allowTooltips"] = enabled;
        }
    }
}

DvtTouchManager.prototype.getTooltipInfo = function() {
  var tooltipInfoObj = new Object();
  var touchIds = new Array();
  var tooltipTarget = null;

  var firstGroup = null;
  var multipleGroups = false;

  var matches = this._findMatches("allowTooltips", true);
  for (var i=0;i<matches.length;i++) {
    var tooltipInfo = matches[i];
    var touchId = tooltipInfo["touchId"];

    if (!firstGroup) {
        firstGroup = tooltipInfo.grouping;
    } else {
        // Multiple groups are not supported for tooltips yet
        if (tooltipInfo.grouping != firstGroup) {
            multipleGroups = true;
        }
    }
    
    var touchInfo = this._touchMap[touchId];
    // By default, show tooltip for item under finger
    var tooltipObj = touchInfo["currentObj"];
    // If an override is present, use this instead
    if (tooltipInfo["tooltipObjOverride"]) {
        tooltipObj = tooltipInfo["tooltipObjOverride"];
    }
    
    touchIds.push(touchId);
    tooltipTarget = tooltipObj;
        
  }
  if (multipleGroups)
    touchIds = new Array();
  tooltipInfoObj.touchIds = touchIds;
  tooltipInfoObj.tooltipTarget = tooltipTarget;

  return tooltipInfoObj;
}


DvtTouchManager.prototype.containsGrouping = function(type) {
    var matches = this._findMatches("grouping", type);
    return matches.length > 0;
}

DvtTouchManager.prototype.processTouchStart = function(touchEvent) {
  var changedTouches = touchEvent.changedTouches;
  var touches = touchEvent.touches;

  this._touchCount = touches.length;
  for (var i=0; i<changedTouches.length; i++)
  {
    var changedTouch = changedTouches[i];
    var screenX = changedTouch.screenX;
    var screenY = changedTouch.screenY;
    var identifier = changedTouch.identifier;
    var targetObj = this._getObjFromTouch(changedTouch);
    var touchInfo = {
      "x":screenX,
      "y":screenY,
      "prevX":screenX,
      "prevY":screenY,
      "pageX":changedTouch.pageX,
      "pageY":changedTouch.pageY,
      "prevPageX":changedTouch.pageX,
      "prevPageY":changedTouch.pageY,
      "dx":0,
      "dy":0,
      "fireClick":true,
      "startTarget":targetObj,
      "currentObj":targetObj,
      "touchMoved":false,
      "touchtype":null,
      "startTouch":changedTouch
    };
    touchInfo[DvtTouchManager.TOUCH_MODE] = DvtTouchManager.TOUCH_MODE_DEFAULT;
    touchInfo["origx"] = screenX;
    touchInfo["origy"] = screenY;      
      
    this._touchMap[identifier] = touchInfo;

  }
  
  // For now, keep the restriction of only one finger being able to be in hover mode at a time
  if (this._isHovering() || !this._isTouchHoldAllowed()) {
      touchEvent.blockTouchHold();
  }
  return true;
}

DvtTouchManager.prototype._isTouchHoldAllowed = function() {
  var touchMoved = false;
  var count = 0;
  for (var id in this._touchMap) {
      var info = this.getTouchInfo(id);
      if (info.touchMoved)
        touchMoved = true;
      count++;
  }
  if (count > 1 && !touchMoved) {
    this.resetTouchHold();
    return false;
  }
  return true;
}

DvtTouchManager.prototype._isHovering = function() {
    for (var id in this._touchMap) {
        var info = this.getTouchInfo(id);
        if (info[DvtTouchManager.TOUCH_MODE] == DvtTouchManager.TOUCH_MODE_LONG_PRESS) {
            return true;
        }
    }
    return false;
}

DvtTouchManager.prototype._getStoredTouches = function(touches) {
  var storedTouches = new Array();
  for (var i=0; i<touches.length; i++) {
    var touch = touches[i];
    var touchid = touch.identifier;
    var info = this.getTouchInfo(touchid);
    if (info) {
        storedTouches.push(touch);
    }
  }
  return storedTouches;
}

DvtTouchManager.prototype.processTouchMove = function(touchEvent) {
  var changedTouches = this._getStoredTouches(touchEvent.changedTouches);
  var touches = this._getStoredTouches(touchEvent.touches);

  for (var i=0; i<changedTouches.length; i++) {
    var touch = changedTouches[i];
    var targetObj = this._getObjFromTouch(touch);
    var touchid = touch.identifier;
    var info = this.getTouchInfo(touchid);
    // If the single finger touch id moves, don't attempt a touch hold
    if (info[DvtTouchManager.TOUCH_MODE] != DvtTouchManager.TOUCH_MODE_LONG_PRESS &&
        this._startSingleFingerTouchId == touchid && 
        Math.abs(info["pageX"] - touch.pageX) > 0)  {
        this.resetTouchHold();
    }
    
    info.currentObj = targetObj;
    info.touchMoved = true;
   
    // If the move ever goes out of the initial object, don't fire a click
    if (info.fireClick) {
        if (info[DvtTouchManager.TOUCH_MODE] == DvtTouchManager.TOUCH_MODE_LONG_PRESS) {
        } else {
            if (info.currentObj != info.startTarget) {
                info.fireClick = false;
            }
        }
    }

  }

  for (var i=0; i<touches.length;i++) {
      var touch = touches[i];
      var identifier = touch.identifier;
      var info = this.getTouchInfo(identifier);
      var screenX = touch.screenX;
      var screenY = touch.screenY;
      var deltaX = screenX - info["x"];
      var deltaY = screenY - info["y"];

      info["prevX"] = info["x"];
      info["prevY"] = info["y"];
      info["dx"] = deltaX;
      info["dy"] = deltaY;
      info["x"] = screenX;
      info["y"] = screenY;
      info["prevPageX"] = info["pageX"];
      info["prevPageY"] = info["pageY"];
      info["pageX"] = touch.pageX;
      info["pageY"] = touch.pageY;
  }
  return true;
}

DvtTouchManager.prototype.processTouchEnd = function(touchEvent) {  
    var changedTouches = touchEvent.changedTouches;
    this._touchCount = touchEvent.touches.length;  

    for (var i=0; i<changedTouches.length; i++) {
        var touch = changedTouches[i];
        var targetObj = this._getObjFromTouch(touch); 
        var touchid = touch.identifier;
        var info = this.getTouchInfo(touchid);
        if (!info)
            continue;
        if (info.fireClick) {
            if (info[DvtTouchManager.TOUCH_MODE] == DvtTouchManager.TOUCH_MODE_LONG_PRESS) {
              this._startSingleFingerTouchId = null;
            } else {
                var sameTarget = targetObj == info.startTarget;
                var touchMoved = info.touchMoved;
                var fireClick = (sameTarget && !touchMoved);
                info.fireClick = fireClick;
            }
        }
    }
  return true;
}

DvtTouchManager.getTouchById = function(id, touches) {
    if (id != null && !isNaN(id)) {
        for (var i=0; i<touches.length; i++) {
            var touch = touches[i];
            if (touch.identifier == id) {
                return touch;
            }
        }
    }
    return null;
}

DvtTouchManager.createSavedTouchInfo = function(touchId, touchObj, tooltipObjOverride, grouping, type, moveListener, endListener, listenerObj) {
    var obj = {"touchId" : touchId, "tooltipObjOverride" : tooltipObjOverride, "grouping" : grouping, "type" : type, "touchObj" : touchObj, "allowTooltips" : true};
    obj["moveListener"] = moveListener;
    obj["endListener"] = endListener;
    obj["listenerObj"] = listenerObj;
    return obj;
}

DvtTouchManager.prototype.setTouchRegionBounds = function(touchRegionBounds) {
    this._touchRegionBounds = touchRegionBounds;
}

// Timer used for touch hold event
DvtTouchManager.prototype._handleTouchHoldStartTimer = function() {

    this._touchHoldTimer.stop();
    this.startTouchHold();

}

DvtTouchManager.prototype._handleDoubleTapTimer = function() {
    this.resetDoubleTap();
}

DvtTouchManager.prototype.resetDoubleTap = function() {
    this._doubleTapAttemptStarted = false;
    this._doubleTapAttemptObj = null;
    this._doubleTapTimer.stop();
}

/**
 * Returns a map containing touch data for two finger touch events. 
 * The map contins the following:
 * dz - The distance moved since the last touch event
 * cx - The current center of the two finger touch
 * dcx - The horizontal distance moved for the center of the two finger touch since the last touch event
 * dcy - The vertical distance moved for the center of the two finger touch since the last tch event
 */
DvtTouchManager.prototype.getMultiTouchData = function(touchIds) {
  if (touchIds.length == 2) {
    var touch1Data = this._touchMap[touchIds[0]];
    var touch2Data = this._touchMap[touchIds[1]];
    if (touch1Data == null || touch2Data == null)
      return null;
    
    if (touch1Data.dx == 0 && touch2Data.dy == 0)
        return null;
    
    //FIX BUG 17185041: use page coords instead of screen coords, which the component can then turn into
    //stage-relative coords
    
    // current distance 2 fingers are apart
    var dx = touch1Data.pageX - touch2Data.pageX;
    var dy = touch1Data.pageY - touch2Data.pageY;
    var dist = Math.sqrt(dx*dx + dy*dy);
    
    // previous distance 2 fingers are apart
    var prevdx = touch1Data.prevPageX - touch2Data.prevPageX;
    var prevdy = touch1Data.prevPageY - touch2Data.prevPageY;
    var prevdist = Math.sqrt(prevdx*prevdx + prevdy*prevdy);
    
    var dz = (dist-prevdist);
    
    // calculate the distance the center btwn the two fingers has moved
    var cx = (touch1Data.pageX+touch2Data.pageX)/2;
    var cy = (touch1Data.pageY+touch2Data.pageY)/2;
    var prevcx = (touch1Data.prevPageX+touch2Data.prevPageX)/2;
    var prevcy = (touch1Data.prevPageY+touch2Data.prevPageY)/2;
    var dcx = (cx - prevcx);
    var dcy = (cy - prevcy);
    
    return {dz:dz, cx:cx, cy:cy, dcx:dcx, dcy:dcy, dist:dist};
  }
  return null;
}

// pan code
DvtTouchManager.prototype.getMultiTouchDelta = function(touchIds)
{

  //Touches are a list of those currently being tracked
  // When a touch is moved, we will compare its screenX and screenY from its last known point.
  // We will then call the handlerCallback, passing in the deltaX and deltaY information.
  //var touches = touchEvent.touches;
  // Handle the case when the number of touches on the surfaces is equal to this._touchCount:
  if (touchIds)
  {
    var touchData;
    var touchType;
    // Have we determined the type of touch this is (only applicable for two finger touches)?
    if (touchIds.length == 2)
    {
      var touch1Data = this._touchMap[touchIds[0]];
      var touch2Data = this._touchMap[touchIds[1]];
      if (touch1Data == null || touch2Data == null)
      {
        // Missing touch data
        return;
      }

      if (touch1Data["touchtype"] == null)
      {
        // Determine if the touches are going away from each other, towards each other, or are
        // moving in unison.
        var touch1Direction = this._determineTouchDirection(touch1Data);
        if (touch1Direction != null)
        {
          var touch2Direction = this._determineTouchDirection(touch2Data);
          if (touch2Direction != null)
          {

            // We have enough data to determine which direction each touch is going.
            touchType = this._isSameDirection(touch1Direction, touch2Direction) ?
              "scroll" : "pinch";

            touch1Data["touchtype"] = touchType;
          }
        }
      }

      touchType = touch1Data["touchtype"];
      if (touchType == null)
      {
        return;
      }
      else if (touchType == "pinch")
      {
        return null;
      }
    }
    // If we have the right number of touches that were moved or less (the devices tend to pick up
    // one finger on occassion).
    //if (changedTouches.length <= this._touchCount)
   // {
      // Compute the average deltas:
      var averageXDelta = 0;
      var averageYDelta = 0;
      for (var j=0; j<touchIds.length; j++)
      {
        touchData = this._touchMap[touchIds[j]];
        averageXDelta += touchData["dx"];
        averageYDelta += touchData["dy"];
      }
      averageXDelta /= touchIds.length;
      averageYDelta /= touchIds.length;

      // Determine if each delta was within a small tolerance from the average:
      var changesWereMovement = true;
/*
      for (j=0; j<touchIds.length; j++)
      {
        touchId = touchIds[j];
        touchData = this._touchMap[touchId];
        var DISTANCE_TOLERANCE = 20; // pixels
        if (Math.abs(touchData["dx"] - averageXDelta) > DISTANCE_TOLERANCE ||
            Math.abs(touchData["dy"] - averageYDelta) > DISTANCE_TOLERANCE)
        {
          changesWereMovement = false;
          break;
        }
      }

*/
      if (changesWereMovement)
      {
        // Prevent the default event handling if we've determined that the touch event was in fact
        // for a movement.
        //touchEvent.preventDefault();

        // If there was non-zero movement:
  //      if (averageXDelta != 0 || averageYDelta != 0)
    //    {
          var scaleFactor = 1;//(window.outerWidth / window.innerWidth);
          return {deltaX: averageXDelta * scaleFactor, deltaY: averageYDelta * scaleFactor};
          // Notify the registered function of the deltas:
          //this._handlerCallback(averageXDelta * scaleFactor, averageYDelta * scaleFactor);
      //  }
      }
    }
  return null;
}

/**
 * Given two directions (see _determineTouchDirection) determine if they are moving roughly in
 * the same direction or opposite directions (pinch vs. scroll).
 */
DvtTouchManager.prototype._isSameDirection = function(
  direction1,
  direction2)
{
  if (direction1 == direction2)
  {
    return true;
  }

  // Code below determines that the directions are the same if they are adjacent to each other.
  // Example: treat "ul" as the same direction as "l" and "u".
  if (direction1.length == 2 && direction2.length == 1)
  {
    return direction1.charAt(0) == direction2 || direction1.charAt(1) == direction2;
  }
  else if (direction1.length == 1 && direction2.length == 2)
  {
    return direction1 == direction2.charAt(0) || direction2 == direction1.charAt(1);
  }
  else
  {
    return false;
  }
}

/**
 * Given a touch data object (see _handleTouchMove), determine which direction it is moving.
 * Values are "ul", "u", "ur", "l", "r", "dl", "d" or "dr",
 * where "u" is up, "l" is left, "r" is right and "d" is down.
 * "
 * @return {String} the direction or null if the distance is not significant enough.
 */
DvtTouchManager.prototype._determineTouchDirection = function(touchData)
{
  var origX = touchData["origx"];
  var origY = touchData["origy"];

  if (origX == null || origY == null)
  {
    return null;
  }

  var currentX = touchData["x"];
  var currentY = touchData["y"];

  var MINIMUM_DISTANCE_REQUIRED_RATIO = 0.01; // 1% of zoomed screen

  // Distance formula = sqrt( (x2 - x1)^2 + (y2 - y2)^2 )
  var distanceX = currentX - origX;
  var distanceY = currentY - origY;

  var distance = Math.sqrt( Math.pow(distanceX, 2) + Math.pow(distanceY, 2) );
  var minDistance = window.innerWidth * MINIMUM_DISTANCE_REQUIRED_RATIO;
  if (distance < minDistance)
  {
    // Touch has not moved far enough to determine
    return null;
  }

  // Given a change to both the x and the y coordinates, determine if one is insignificant.
  var INSIGNIFICANT_RATIO = 0.25;
  var directionX = null;
  if (Math.abs(distanceX / distanceY) >= INSIGNIFICANT_RATIO)
  {
    directionX = (distanceX < 0) ? "l" : "r"; // note that we are not considering LTR/RTL here.
      // This is okay as we are not currently concerned with left or right, only if the touches
      // are in the same or different directions.
  }

  var directionY = null;
  if (Math.abs(distanceY / distanceX) >= INSIGNIFICANT_RATIO)
  {
    directionY = (distanceY < 0) ? "u" : "d";
  }

  if (directionX != null && directionY != null)
  {
    return directionY + directionX;
  }
  else if (directionX == null)
  {
    return directionY;
  }
  else if (directionY == null)
  {
    return directionX;
  }

  // Should never reach here
  return null;
}

DvtTouchManager.prototype.calcAveragePosition = function(touchIds) {
    var pointX = 0;
    var pointY = 0;
    var touchCount = touchIds.length;
    for (var i=0;i<touchCount;i++) {
        var touchId = touchIds[i];
        var touchData = this.getTouchInfo(touchId);
        pointX += touchData.pageX;
        pointY += touchData.pageY;
    }
    pointX /= touchCount;
    pointY /= touchCount;
    return new DvtPoint(pointX, pointY);
}

/**
 * Returns an array of start targets for corresponding touch ids
 * @param {array} touchIds An array of touch ids
 * @return {array} An array of touch targets
 */
DvtTouchManager.prototype.getStartTargetsByIds = function(touchIds) {
  var targets = new Array();
  for (var i=0;i<touchIds.length;i++) {
    var touchData = this.getTouchInfo(touchIds[i]);
    targets.push(touchData["startTarget"]);
  }
  return targets;
}
/**
 * @constructor
 * Abstract class for DvtRestoreCollapse Events.  
 * 
 * <p>The supported fields are:
 * <ul>
 * <li>state</li>
 * </ul>
 * <p>
 */
var DvtListItemEvent = function(listItemId, attributeGroupId, showHide, evt)
{   
  this.Init(DvtListItemEvent.TYPE);
  this._listItemId = listItemId;
  this._attrGroupId = attributeGroupId;
  this._showHide = showHide;
  this._evt = evt;
};

DvtListItemEvent.TYPE = 'listItemShowHide';
DvtListItemEvent.SHOW = 'show';
DvtListItemEvent.HIDE = 'hide';

DvtObj.createSubclass(DvtListItemEvent, DvtBaseComponentEvent, "DvtListItemEvent");

DvtListItemEvent.prototype.getNativeEvent = function() {
  return this._evt;
};

DvtListItemEvent.prototype.getListItemId = function () 
{
  return this._listItemId;    
}

DvtListItemEvent.prototype.getShowHide = function () 
{
  return this._showHide;    
}

DvtListItemEvent.prototype.getAttributeGroupId = function () 
{
  return this._attrGroupId;
}
/**
 * @constructor
 * Abstract class for DvtRestoreCollapse Events.  
 * 
 * <p>The supported fields are:
 * <ul>
 * <li>state</li>
 * </ul>
 * <p>
 */
var DvtLegendItemRollOverEvent = function(listItemId, attributeGroupId, hideAttr, mouseState, evt)
{     
  this.Init(DvtLegendItemRollOverEvent.TYPE);
  this._listItemId = listItemId;
  this._attrGroupId = attributeGroupId;
  this._hideAttr = hideAttr;
  this._mouseState = mouseState;
  this._evt = evt;
};

DvtLegendItemRollOverEvent.TYPE = 'legendItemRollOver';
DvtLegendItemRollOverEvent.MOUSEOVER = 'mouseover';
DvtLegendItemRollOverEvent.MOUSEOUT = 'mouseout';

DvtObj.createSubclass(DvtLegendItemRollOverEvent, DvtBaseComponentEvent, "DvtLegendItemRollOverEvent");

DvtLegendItemRollOverEvent.prototype.getNativeEvent = function() {
  return this._evt;
};


DvtLegendItemRollOverEvent.prototype.getHideAttributes = function () 
{
  return this._hideAttr;    
}

DvtLegendItemRollOverEvent.prototype.getListItemId = function () 
{
  return this._listItemId;    
}

DvtLegendItemRollOverEvent.prototype.getMouseState = function () 
{
  return this._mouseState;
}

DvtLegendItemRollOverEvent.prototype.getAttributeGroupId = function () 
{
  return this._attrGroupId;
}
/**
 * @constructor
 */
var ViewportChangeEvent = function (oldDim, newDim, evt) {
  this.Init(ViewportChangeEvent.TYPE);
  this._oldDim = oldDim;
  this._newDim = newDim;
  this._evt = evt;
};

ViewportChangeEvent.TYPE = 'viewportChange';

DvtObj.createSubclass(ViewportChangeEvent, DvtBaseComponentEvent, "ViewportChangeEvent");

ViewportChangeEvent.prototype.getNativeEvent = function () {
  return this._evt;
};

ViewportChangeEvent.prototype.getOldDimensions = function () {
  return this._oldDim;
}

ViewportChangeEvent.prototype.getNewDimensions = function () {
  return this._newDim;
}
// Events when a custom tooltip action menu is interacted with
/**
 * @constructor
 */
var DvtActionTooltipEvent = function(type, target) {
    this.Init(type);
    this.target = target;
}

DvtActionTooltipEvent.TOOLTIP_CLOSED_TYPE = "actiontooltipclosed";
DvtActionTooltipEvent.TOOLTIP_STARTED_TYPE = "actiontooltipstarted";

DvtObj.createSubclass(DvtActionTooltipEvent, DvtBaseComponentEvent, "DvtActionTooltipEvent");

DvtActionTooltipEvent.prototype.Init = function(type) {
  DvtActionTooltipEvent.superclass.Init.call(this, type);
}
/**
 * @constructor
 * A higher-level class that represents a single touch event. 
 * The target and the relatedTarget simulate target and relatedTarget of the MouseEvent 
 * and the target does not match target on the native TouchEvent.
 * @param {string} type One of the DvtComponentTouchEvent event types.
 * @param {DvtTouch} touch A single point of contact with the surface
 * @param {object} target An element that triggered the event
 * @param {object} relatedTarget An element related to the element that triggered the event
 * @extends DvtBaseComponentEvent
 * @class DvtComponentTouchEvent
 */
var DvtComponentTouchEvent = function(type, touch, target, relatedTarget) {
    this.Init(type, touch, target, relatedTarget);
}

/**
 * Touch hold start event
 * @const
 */
DvtComponentTouchEvent.TOUCH_HOLD_START_TYPE = "touchholdstart";
/**
 * Touch hold move event
 * @const
 */
DvtComponentTouchEvent.TOUCH_HOLD_MOVE_TYPE = "touchholdmove";
/**
 * Touch hold end event
 * @const
 */
DvtComponentTouchEvent.TOUCH_HOLD_END_TYPE = "touchholdend";

/**
 * Touch hover start event
 * @const
 */
DvtComponentTouchEvent.TOUCH_HOVER_START_TYPE = "touchhoverstart";
/**
 * Touch hover move event
 * @const
 */
DvtComponentTouchEvent.TOUCH_HOVER_MOVE_TYPE = "touchhovermove";
/**
 * Touch hover end event
 * @const
 */
DvtComponentTouchEvent.TOUCH_HOVER_END_TYPE = "touchhoverend";
/**
 * Touch hover over event
 * @const
 */
DvtComponentTouchEvent.TOUCH_HOVER_OVER_TYPE = "touchhoverover";
/**
 * Touch hover out event
 * @const
 */
DvtComponentTouchEvent.TOUCH_HOVER_OUT_TYPE = "touchhoverout";

/**
 * Touch click event
 * @const
 */
DvtComponentTouchEvent.TOUCH_CLICK_TYPE = "touchclick";
/**
 * Touch double click event
 * @const
 */
DvtComponentTouchEvent.TOUCH_DOUBLE_CLICK_TYPE = "touchdblclick";

DvtObj.createSubclass(DvtComponentTouchEvent, DvtBaseComponentEvent, "DvtComponentTouchEvent");

/**
 * Helper method called by the constructor to initialize this object.
 * @param {string} type One of the DvtComponentTouchEvent event types
 * @param {DvtTouch} touch A single point of contact with the surface
 * @param {object} target An element that triggered the event
 * @param {object} relatedTarget An element related to the element that triggered the event
 */
DvtComponentTouchEvent.prototype.Init = function(type, touch, target, relatedTarget) {
  DvtComponentTouchEvent.superclass.Init.call(this, type);
  this.target = target;
  this.touch = touch;
  this.relatedTarget = relatedTarget;
  this._isPropagationStopped = false;
}

// Stub methods so that mouse click handlers don't break
DvtComponentTouchEvent.prototype.preventDefault = function() {
}

DvtComponentTouchEvent.prototype.stopPropagation = function() {
  this._isPropagationStopped = true;
}

DvtComponentTouchEvent.prototype.isPropagationStopped = function() {
  return this._isPropagationStopped;
}
/**
 * @constructor
 * @extends DvtObj
 * @class DvtScrollbarEvent
 * <p>
 */
var DvtScrollbarEvent = function(type, scrollbar, startCoord, endCoord,
                                valueDelta, scaledDelta) {
    this.Init(type, scrollbar, startCoord, endCoord, valueDelta, scaledDelta);
}


DvtObj.createSubclass(DvtScrollbarEvent, DvtBaseComponentEvent, "DvtScrollbarEvent");


DvtScrollbarEvent.SB_MOVE            = "scrollbarMove";
DvtScrollbarEvent.SB_MOVE_COMPLETE   = "scrollbarMoveComplete";
DvtScrollbarEvent.SB_RESIZE          = "scrollbarResize";
DvtScrollbarEvent.SB_RESIZE_COMPLETE = "scrollbarResizeComplete";


/**
 * Initializer
 * @protected
 */
DvtScrollbarEvent.prototype.Init = function(type, scrollbar, startCoord, endCoord, valueDelta, scaledDelta) {

    DvtScrollbarEvent.superclass.Init.call(this, type);

    this.type = type;           // TODO: temp workaround until this.type is supported in the base class
    this._sb = scrollbar;
    this._startCoord = startCoord;
    this._endCoord = endCoord;
    this._delta = valueDelta;
    this._scaledDelta = scaledDelta;
}



/**
 * Returns the id of the scrollbar
 */
DvtScrollbarEvent.prototype.getScrollbarId = function() {
    return this._sb.getUIId();
}

/**
 * Returns the start coordinate
 */
DvtScrollbarEvent.prototype.getStartCoord = function() {
    return this._startCoord;
}

/**
 * Returns the end coordinate
 */
DvtScrollbarEvent.prototype.getEndCoord = function() {
    return this._endCoord;
}

/**
 * Returns the signed number of pixels moved
 */
DvtScrollbarEvent.prototype.getMovedDelta = function() {
    return this._delta;
}

/**
 * Returns the signed number of pixels scaled by the size of the scrollbar
 */
DvtScrollbarEvent.prototype.getScaledDelta = function() {
    return this._scaledDelta;
}

/**
 * Returns the {@link DvtScrollbar} component
 */
DvtScrollbarEvent.prototype.getScrollbar = function() {
    return this._sb;
}




// Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved. 
/**
 * @constructor
 */
var DvtResizeEvent = function(ww, hh, xx, yy) {
  this.Init(DvtResizeEvent.RESIZE_EVENT, ww, hh, xx, yy);
};

DvtObj.createSubclass(DvtResizeEvent, DvtBaseEvent, "DvtResizeEvent");

DvtResizeEvent.RESIZE_EVENT = "dvtResizeEvent";

DvtResizeEvent.prototype.Init = function(type, ww, hh, xx, yy) {
  DvtResizeEvent.superclass.Init.call(this, type);
  
  this._ww = ww;
  this._hh = hh;
  this._xx = xx;
  this._yy = yy;
};

DvtResizeEvent.prototype.getWidth = function() {
  return this._ww;
};

DvtResizeEvent.prototype.getHeight = function() {
  return this._hh;
};

DvtResizeEvent.prototype.getX = function() {
  return this._xx;
};

DvtResizeEvent.prototype.getY = function() {
  return this._yy;
};
// Copyright (c) 2012, Oracle and/or its affiliates. All rights reserved. 
/**
 * @constructor
 */
var DvtScrollEvent = function(x, y) {
  this.Init(DvtScrollEvent.SCROLL_EVENT, x, y);
};

DvtObj.createSubclass(DvtScrollEvent, DvtBaseEvent, "DvtScrollEvent");

DvtScrollEvent.SCROLL_EVENT = "dvtScrollEvent";

/**
 * Initializer
 * @protected
 */
DvtScrollEvent.prototype.Init = function(type, x, y) {
  DvtScrollEvent.superclass.Init.call(this, type);

  this._x = x;
  this._y = y;
};

DvtScrollEvent.prototype.getX = function() {
  return this._x;
};

DvtScrollEvent.prototype.getY = function() {
  return this._y;
};




/**
 * @constructor
 * @param {string} type Event type.
 * @param {number} x Marquee x.
 * @param {number} y Marquee y.
 * @param {number} w Marquee w.
 * @param {number} h Marquee h.
 * @param {boolean} ctrlKey Whether the ctrl key is pressed.
 */
var DvtMarqueeEvent = function(subtype, x, y, w, h, ctrlKey) {
  this.Init(DvtMarqueeEvent.TYPE);
  this.subtype = subtype;
  this.x = x;
  this.y = y;
  this.w = w;
  this.h = h;
  this.ctrlKey = ctrlKey;
};

DvtObj.createSubclass(DvtMarqueeEvent, DvtBaseComponentEvent, "DvtMarqueeEvent");

DvtMarqueeEvent.TYPE = "dvtMarquee";

DvtMarqueeEvent.SUBTYPE_START = "dvtMarqueeStartEvent";
DvtMarqueeEvent.SUBTYPE_MOVE  = "dvtMarqueeMoveEvent";
DvtMarqueeEvent.SUBTYPE_END   = "dvtMarqueeEndEvent";

/**
 * @return {number} Event subtype.
 */
DvtMarqueeEvent.prototype.getSubtype = function() {
  return this.subtype;
};
/**
 * @constructor
 * @param {string} type Event subtype.
 * @param {number} dxMin The delta of the xMin.
 * @param {number} dxMax The delta of the xMax.
 * @param {number} dyMin The delta of the yMin.
 * @param {number} dyMax The delta of the yMax.
 * @param {number} [dxMinTotal] The total delta of the xMin (relative to the beginning of action).
 * @param {number} [dxMaxTotal] The total delta of the xMax (relative to the beginning of action).
 * @param {number} [dyMinTotal] The total delta of the yMin (relative to the beginning of action).
 * @param {number} [dyMaxTotal] The total delta of the yMax (relative to the beginning of action).
 */
var DvtPanZoomEvent = function(subtype, dxMin, dxMax, dyMin, dyMax, dxMinTotal, dxMaxTotal, dyMinTotal, dyMaxTotal) {
  this.Init(DvtPanZoomEvent.TYPE);
  this.subtype = subtype;
  this.dxMin = dxMin;
  this.dxMax = dxMax;
  this.dyMin = dyMin;
  this.dyMax = dyMax;
  this.dxMinTotal = dxMinTotal;
  this.dxMaxTotal = dxMaxTotal;
  this.dyMinTotal = dyMinTotal;
  this.dyMaxTotal = dyMaxTotal;
};

DvtObj.createSubclass(DvtPanZoomEvent, DvtBaseComponentEvent, "DvtPanZoomEvent");

DvtPanZoomEvent.TYPE = "dvtPanZoom";

DvtPanZoomEvent.SUBTYPE_PAN_START   = "dvtPanStartEvent";
DvtPanZoomEvent.SUBTYPE_PAN_MOVE    = "dvtPanMoveEvent";
DvtPanZoomEvent.SUBTYPE_PAN_END     = "dvtPanEndEvent";
DvtPanZoomEvent.SUBTYPE_ZOOM        = "dvtZoomEvent";
DvtPanZoomEvent.SUBTYPE_PINCH_START = "dvtPinchStartEvent";
DvtPanZoomEvent.SUBTYPE_PINCH_MOVE  = "dvtPinchMoveEvent";
DvtPanZoomEvent.SUBTYPE_PINCH_END   = "dvtPinchEndEvent";

/**
 * @return {string} Event subtype.
 */
DvtPanZoomEvent.prototype.getSubtype = function() {
  return this.subtype;
};
/*---------------------------------------------------------------------*/
/*   DvtDisplayableUtils          Static Utility Functions             */
/*---------------------------------------------------------------------*/

/**
 *   Static Utility Functions for DvtDisplayable
 *   @class DvtDisplayableUtils
 *   @constructor
 */
var  DvtDisplayableUtils = function()
{} ;

DvtObj.createSubclass(DvtDisplayableUtils, DvtObj, "DvtDisplayableUtils");

/*
 * Temporarily add the display object to the stage to get dimensions.
 * Remove it from stage after done
 */
DvtDisplayableUtils.getDimensionsForced = function(context, obj) {
  //save original parent and index
  var oParent = obj.getParent();
  var oIndex;
  if (oParent)
    oIndex = oParent.getChildIndex(obj);

  var stage = context.getStage();
  stage.addChild(obj);

  var dim = obj.getDimensions();
  stage.removeChild(obj);

  //restore original parent
  if (oParent) {
    oParent.addChildAt(obj, oIndex);
  }

  return dim;
}


/*
 * Temporarily add the display object to the stage to get dimensions.
 * Remove it from stage after done
 * cached dimensions in obj._dim
 */
DvtDisplayableUtils._getDimForced = function(context, obj) {
  //if there is a cache or context is null, return it.
  if (obj._dim || ! context) {
    return obj._dim;
  }

  var dim = DvtDisplayableUtils.getDimensionsForced(context, obj);

  //cached the dimensions
  DvtDisplayableUtils._setDimForced(obj, dim);
  return dim;
}


/*
 * cached dimensions in obj._dim
 */
DvtDisplayableUtils._setDimForced = function(obj, dim) {
  //cached the dimensions
  obj._dim = dim;
}

/**
 * Determine if a displayable is an ancestor of another displayable.
 * 
 * @param {DvtDisplayable} ancestor  The potential ancestor displayable.
 * @param {DvtDisplayable} descendant  The potential descendant displayable.
 * @type Boolean
 */
DvtDisplayableUtils.isAncestor = function(ancestor, descendant) {
  var disp = descendant;
  while (disp) {
    if (disp == ancestor) {
      return true;
    }
    if (disp instanceof DvtContainer) {
      disp = disp.getParent();
    }
  }
  return false;
}


// Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
/*---------------------------------------------------------------------*/
/*  DvtPathUtils()       Utility functions for SVG paths               */
/*---------------------------------------------------------------------*/

var DvtPathUtils = {} ;

DvtObj.createSubclass(DvtPathUtils, DvtObj, "DvtPathUtils");

/**
 * Returns a path command for a move to the specified coordinates
 * @param x the destination x coordinate
 * @param y the destination y coordinate
 * @return the moveTo path command
 */
DvtPathUtils.moveTo = function(x,y) {
  return "M" + x + "," + y;
};

/**
 * Returns a path command for a line to the specified coordinates
 * @param x the destination x coordinate
 * @param y the destination y coordinate
 * @return the lineTo path command
 */
DvtPathUtils.lineTo = function(x,y) {
  return "L" + x + "," + y;
};

DvtPathUtils.quadTo = function(x1,y1,x,y) {
  return "Q" + x1 + "," + y1 + "," + x + "," + y;
};

DvtPathUtils.cubicTo = function(x1,y1,x2,y2,x,y) {
  return "C" + x1 + "," + y1 + "," + x2 + "," + y2 + "," + x + "," + y;
};

/**
 * Returns a path command for an arc to the specified coordinates
 * @param rx the x radius of the ellipse whose arc will be drawn
 * @param ry the y radius of the ellipse whose arc will be drawn
 * @param angleExtent the sweep of the arc to be drawn
 * @param direction 1 for clockwise, 0 for counter-clockwise 
 * @param x the ending x coordinate
 * @param y the ending y coordinate
 */
DvtPathUtils.arcTo = function(rx, ry, angleExtent, direction, x, y) {
  var cmd = "A" + rx + "," + ry + ",0,";
  if(angleExtent > Math.PI) {
    cmd += "1,";
  }
  else {
    cmd += "0,";
  }
  cmd += (direction + "," + x + "," + y);
  return cmd;
};

/**
 * Returns a path command that closes the path.
 */
DvtPathUtils.closePath = function() {
  return "Z";
};

/**
 * Returns a path command for a rounded rectangle.
 * @param {number} x Rectangle x.
 * @param {number} y Rectangle y.
 * @param {number} w Rectangle width.
 * @param {number} h Rectangle height.
 * @param {number} tlcr Top left corner radius.
 * @param {number} trcr Top right corner radius.
 * @param {number} brcr Bottom right corner radius.
 * @param {number} blcr Bottom left corner radius.
 * @return {string} Path command.
 */
DvtPathUtils.roundedRectangle = function(x, y, w, h, tlcr, trcr, brcr, blcr) {
  var cmd = DvtPathUtils.moveTo(x+tlcr, y) +
            DvtPathUtils.lineTo(x+w-trcr, y) +
            DvtPathUtils.arcTo(trcr, trcr, Math.PI/2, 1, x+w, y+trcr) +
            DvtPathUtils.lineTo(x+w, y+h-brcr) +
            DvtPathUtils.arcTo(brcr, brcr, Math.PI/2, 1, x+w-brcr, y+h) +
            DvtPathUtils.lineTo(x+blcr, y+h) +
            DvtPathUtils.arcTo(blcr, blcr, Math.PI/2, 1, x, y+h-blcr) +
            DvtPathUtils.lineTo(x, y+tlcr) +
            DvtPathUtils.arcTo(tlcr, tlcr, Math.PI/2, 1, x+tlcr, y) +
            DvtPathUtils.closePath();
  
  return cmd;
}

/**
  *  Creates an array of path/coords from an Svg path string.
  *  @param {String} cmds A string containing SVG path command sequences.
  *  @returns {Array}  an array of consecutive path command/coords, or null
  *                    if no command string supplied.
  */
DvtPathUtils.createPathArray = function(sCmds)
{
  if (! sCmds)
     return null ;

  //  Unpack into an array of commands and coords.
   var cmds = sCmds.replace(/([mlqhvzca])/gi, ',$1,'); // create array of coords from the string
   var ar   = cmds.split(/[ ,]/g) ;
   var len  = ar.length;
   var i ;
   //  Convert coordinates in command array to floats.
   for (i = 0; i < len;  i++) {
      var s = ar[i] ;
      if (!s) {
        ar.splice(i, 1);
        i--;
        len--;
      }
      else if (!isNaN(s)) {
        ar[i] = parseFloat(s) ;
      }
   }

   return ar ;
} ;

/**
 * Returns the bounding box of the supplied path commands.
 * @param {Array} arCmds the path commands.
 * @returns {DvtRectangle} the bounding box of the supplied path commands.
 */
DvtPathUtils.getDimensions = function(aCmds)
{
  if (! (aCmds && aCmds.length)) {
    return new DvtRectangle() ;
  }

  var  len = aCmds.length ;
  var  c ;
  var  xSubPath, ySubPath ;
  var  bFirst = true ;           // false after first command
  var  bRel ;                    // true if relative command
  var  x, y, x2, y2, x3, y3 ;

  var minX = Number.MAX_VALUE ;
  var maxX = Number.MIN_VALUE ;
  var minY = Number.MAX_VALUE ;
  var maxY = Number.MIN_VALUE ;
  var  aPos = [] ;
  var  i, j, k ;
  
  for (i = 0; i < len;  i++)  {
     bRel = false ;
     var iMulti = 0 ;
     j = 0 ;

     c = aCmds[i] ;

     switch (c)
     {
        case 'm' :  bRel = true ;
        case 'M' :  do {
                      x = aCmds[i+1] ;
                      y = aCmds[i+2] ;

                      if (bFirst) {        // note if first is 'm', it is treated as absolute.
                        bFirst = false ;
                      }
                      else if (bRel) {
                        x += xSubPath ;
                        y += ySubPath ;
                      }
                      xSubPath = x ;
                      ySubPath = y ;

                      aPos[j++] = x ;
                      aPos[j++] = y ;
                      iMulti++ ;
                      i += 2 ;
                    } while (! isNaN(aCmds[i +1])) ;
                    break ;

        case 'c' :  bRel = true ;
        case 'C' :  do {
                      x  = aCmds[i+1] ;
                      y  = aCmds[i+2] ;
                      x2 = aCmds[i+3] ;
                      y2 = aCmds[i+4] ;
                      x3 = aCmds[i+5] ;
                      y3 = aCmds[i+6] ;

                      if (bRel) {
                        x  += xSubPath ;
                        y  += ySubPath ;
                        x2 += xSubPath ;
                        y2 += ySubPath ;
                        x3 += xSubPath ;
                        y3 += ySubPath ;
                      }
                      xSubPath = x3 ;
                      ySubPath = y3 ;

                      aPos[j++] = x3 ;
                      aPos[j++] = y3 ;
                      iMulti++ ;
                      i += 6 ;
                    } while (! isNaN(aCmds[i +1])) ;
                    break ;

        case 'q' :  bRel = true ;
        case 'Q' :  do {
                      x  = aCmds[i+1] ;
                      y  = aCmds[i+2] ;
                      x2 = aCmds[i+3] ;
                      y2 = aCmds[i+4] ;
                      if (bRel) {
                        x  += xSubPath ;
                        y  += ySubPath ;
                        x2 += xSubPath ;
                        y2 += ySubPath ;
                      }
                      xSubPath = x2 ;
                      ySubPath = y2 ;

                      aPos[j++] = x2 ;
                      aPos[j++] = y2 ;
                      iMulti++ ;
                      i += 4 ;
                    } while (! isNaN(aCmds[i +1])) ;
                    break ;

        case 'l' :  bRel = true ;
        case 'L' :
                    do {
                      x = aCmds[i+1] ;
                      y = aCmds[i+2] ;
                      if (bRel) {
                        x += xSubPath ;
                        y += ySubPath ;
                      }
                      xSubPath = x ;
                      ySubPath = y ;

                      aPos[j++] = x ;
                      aPos[j++] = y ;
                      iMulti++ ;
                      i += 2 ;
                    } while (! isNaN(aCmds[i+1])) ;
                    break ;

        case 'h' :  bRel = true ;
        case 'H' :
                    do {
                      x = aCmds[i+1] ;
                      if (bRel) {
                        x += xSubPath ;
                      }
                      xSubPath = x ;

                      aPos[j++] = x ;
                      aPos[j++] = ySubPath ;
                      iMulti++ ;
                      i += 1 ;
                    } while (! isNaN(aCmds[i+1])) ;
                    break ;

        case 'v' :  bRel = true ;
        case 'V' :
                    do {
                      y = aCmds[i+1] ;
                      if (bRel) {
                        y += ySubPath ;
                      }
                      ySubPath = y ;

                      aPos[j++] = xSubPath ;
                      aPos[j++] = y ;
                      iMulti++ ;
                      i += 1 ;
                    } while (! isNaN(aCmds[i+1])) ;
                    break ;

        case 'z' :
        case 'Z' :  break ;

        default :   break ;
     }                                    // end switch

     j = 0 ;
     for (k = 0 ; k < iMulti; k++) {
        x = aPos[j++] ;
        y = aPos[j++] ;
        minX = Math.min(minX, x) ;
        maxX = Math.max(maxX, x) ;
        minY = Math.min(minY, y) ;
        maxY = Math.max(maxY, y) ;
     }
  }

  return new DvtRectangle(minX, minY, Math.abs(maxX - minX), Math.abs(maxY - minY)) ;
};


/**
 *  Converts a platform independent array of consecutive commands and coords
 *  to an SVG path string.
 *  @param {Array} ar  The array of commands and coordinates to be converted.
 *  @type String
 */
DvtPathUtils.getPathString = function(ar)
{
   var sOut = '' ;
   var len = ar.length ;
   var s ;

   for (var i = 0; i < len;  i++) {
      s = ar[i] ;
      if (s !== undefined && s !== null)
        sOut += (((i > 0)? ' ' : '') + ar[i]) ;
   }

   return sOut ;
};



/**
  *  Initializes the shape to the specified coordinates.
  *  @private
  */
DvtPathUtils.transformPath = function(sCmds, x, y, sx, sy)
{
   var scaledPath = "" ;                   // return string
   if (! sCmds)
      return ;

  // Split the commands (command is recognized as a single letter followed
  // by any number of non-letter characters)

  var commands = sCmds.match(/[a-z][^a-z]*/ig);

  for (var i = 0; i < commands.length; i++)
  {
     var command = commands[i];
     var cmdType = command.charAt(0);
     var absCmd  = cmdType === cmdType.toUpperCase();

     scaledPath += (cmdType + " ");
     var strArgs = command.substring(1);

     strArgs = strArgs.replace(/,/g, ' ');         // replace all commas with spaces
     strArgs = strArgs.replace(/^\s+|\s+$/g, '');  // trim leading and trailing whitespace

     if (strArgs.length > 0)
     {
        var args = strArgs.split(/\s+/g); // split on whitespace
        if (cmdType.toUpperCase() === 'A')
        {
          // (rx ry x-axis-rotation large-arc-flag sweep-flag x y)  only rx, ry, x, y should be scaled
          // only x,y should be translated for 'A', no translation for 'a'
 
          for (var j = 0; j < args.length; j += 7)            // loop to support multi-arc
          {
            scaledPath += (parseFloat(args[j]) * sx + " ");                      // rx
            scaledPath += (parseFloat(args[j+1]) * sy + " ");                    // ry
            scaledPath += (args[j+2] + " ");                                     // x-axis-rotation
            scaledPath += (args[j+3] + " ");                                     // large-arc-flag
            scaledPath += (args[j+4] + " ");                                     // sweep-flag
            scaledPath += (parseFloat(args[j+5])* sx +(absCmd ? x : 0) + " ");   // x
            scaledPath += (parseFloat(args[j+6])* sy +(absCmd ? y : 0) + " ");   // y
          }
        }
        else
        {
          // For all other cmdTypes, all numbers should be scaled
          // For all absolute cmdTypes, all numbers should be translated
     
          var scales     = [];
          var translates = [];
          if (cmdType.toUpperCase() === 'H')
          {
            scales.push(sx); // All numbers should be scaled by sx
            translates.push(absCmd ? x : 0); // All numbers should be translated by x
          }
          else if (cmdType.toUpperCase() === 'V')
          {
            scales.push(sy); // All numbers should be scaled by sy
            translates.push(absCmd ? y : 0); // All numbers should be translated by y
          }
          else
          {
            // All other commands take a set of points, so even indices should be scaled
            //  by sx, odd indices by sy
            scales.push(sx);
            scales.push(sy);
            // For absolute commands, even indices should be translated by x, odd indices by y
            translates.push(absCmd ? x : 0);
            translates.push(absCmd ? y : 0);
          }

          for (var j = 0; j < args.length; j++)
          {
            var s = scales[j % scales.length];
            var t = translates[j % translates.length];

            scaledPath += ((parseFloat(args[j])*s+t) + " ");  // scale and translate
          }
        }
     }
  }         // end for

  return scaledPath ;
};

/**
 * Helper function for path simplification
 * @param {number} xMove The number of pixels that will be moved in the horizontal coordinate space.
 * @param {number} yMove The number of pixels that will be moved in the vertical coordinate space.
 * @param {number} scale The scale to test if the the x/y movement will show
 * @return {boolean} Whether or not the x/y movement will show in the given scale.
 */
DvtPathUtils._fitsInScale = function(xMove, yMove, scale) {
  return (Math.abs(xMove) > scale || Math.abs(yMove) > scale);
}

/**
 * Simplifies a given path by scaling it down and discarding pixel movements that are too small to be seen in the 
 * given scale.
 * @param {array} cmdAr The array of commands and coordinates to be converted.
 * @param {number} scale The scale to simplify the path to.
 * @return {string} The simplified string of path commands and coordinates.
 */
DvtPathUtils.simplifyPath = function(cmdAr, scale) {
  var cmd;
  var simplifiedCmdStr = '';
  var tempSimplifiedStr = '';
  var partialX = 0;
  var partialY = 0;
  var simplifiedCmd;
  var mx = 0;
  var my = 0;
  // we expect all path commands to start with an m and end with a z
  var numCmds = 0;
  for (var i=0; i<cmdAr.length; i++) {
    if (isNaN(cmdAr[i])) {
      cmd = cmdAr[i];
      if (cmd == 'Z' || cmd=='z') {
        simplifiedCmd = cmd;
        tempSimplifiedStr += cmd;
        // if a command only contains move commands i.e. m[x] [y]z, do not add it but keep track of the relative position
        if (numCmds > 0) {
          simplifiedCmdStr += tempSimplifiedStr;
          mx = 0;
          my = 0;
        }
        tempSimplifiedStr = '';
        numCmds = 0;
        partialX = 0;
        partialY = 0;
      }
      continue;
    }
      
    switch (cmd) {
      case 'M':
        mx = 0;
        my = 0;
      case 'm':
        mx += cmdAr[i];
        my += cmdAr[i+1];
        tempSimplifiedStr = tempSimplifiedStr + cmd + mx+ " " +my;
        simplifiedCmd = cmd;
        i++;
        break;
      case 'l':
        partialX += cmdAr[i];
        partialY += cmdAr[i+1];
        if (DvtPathUtils._fitsInScale (partialX, partialY, scale)) {
          if (simplifiedCmd != cmd) {
            simplifiedCmd = cmd;
            tempSimplifiedStr += cmd;
          } else {
            tempSimplifiedStr += ' ';
          }
          tempSimplifiedStr = tempSimplifiedStr + partialX + " " + partialY;
          partialX = 0;
          partialY = 0;
          numCmds++;
        }
        i++;
        break;
      case 'h':
      case 'v':
        if (cmd == 'h')
          partialX += cmdAr[i];
        else
          partialY += cmdAr[i];
        if (DvtPathUtils._fitsInScale (partialX, partialY, scale)) {
          if (partialX != 0 && partialY != 0) {
            if (simplifiedCmd != 'l') {
              simplifiedCmd = 'l';
              tempSimplifiedStr += 'l';
            } else {
              tempSimplifiedStr += ' ';
            }
            tempSimplifiedStr = tempSimplifiedStr + partialX + " " + partialY;
          } else {
            simplifiedCmd = cmd;
            tempSimplifiedStr = tempSimplifiedStr + cmd + (cmd == 'h' ? partialX : partialY);
          }
          partialX = 0;
          partialY = 0;
          numCmds++;
        }
        break;
      default:
    }
  }
  return simplifiedCmdStr;
}
/**
 * @constructor
 * DvtMarkerDefElem 
 */
var DvtMarkerDefElem = function() {
  this.Init();
}

/*
 * make DvtMarkerDefElem a subclass of DvtObj
 */
DvtObj.createSubclass(DvtMarkerDefElem, DvtPropMap, "DvtMarkerDefElem");

// DvtMarkerDef Attributes
DvtMarkerDefElem.ATTR_ELEMENTS = "elements";
DvtMarkerDefElem.ATTR_SHAPE = "shape";
DvtMarkerDefElem.ATTR_BORDER_COLOR = "bc";
DvtMarkerDefElem.ATTR_FILL_COLOR = "fc";
DvtMarkerDefElem.ATTR_FILL_PATTERN = "fp";
DvtMarkerDefElem.ATTR_FILL_GRADIENT = "fg";
DvtMarkerDefElem.ATTR_DATA = "d";
DvtMarkerDefElem.ATTR_POINTS = "p";
DvtMarkerDefElem.ATTR_LINE_WIDTH = "lw";

DvtMarkerDefElem.ATTR_FILL_GRAD_COLORS = "c";
DvtMarkerDefElem.ATTR_FILL_GRAD_STOPS = "p";
DvtMarkerDefElem.ATTR_FILL_GRAD_BOUNDS = "b";
DvtMarkerDefElem.ATTR_FILL_GRAD_DIR = "dir";
DvtMarkerDefElem.ATTR_FILL_GRAD_DIR_RADIAL = "gdR";
DvtMarkerDefElem.ATTR_FILL_GRAD_DIR_RIGHT = "gdRi" ;
DvtMarkerDefElem.ATTR_FILL_GRAD_DIR_DOWN = "gdD" ;
DvtMarkerDefElem.ATTR_FILL_GRAD_DIR_45 = "gdD45" ;
DvtMarkerDefElem.ATTR_FILL_GRAD_DIR_135 = "gdD135" ;
DvtMarkerDefElem.ATTR_FILL_GRAD_CX = "cx";
DvtMarkerDefElem.ATTR_FILL_GRAD_CY = "cy";
DvtMarkerDefElem.ATTR_FILL_GRAD_RADIUS = "r";
DvtMarkerDefElem.ATTR_FILL_GRAD_RADIUSX = "rx";
DvtMarkerDefElem.ATTR_FILL_GRAD_RADIUSY = "ry";

DvtMarkerDefElem.ATTR_ANGLES = "ang";
DvtMarkerDefElem.ATTR_CLOSURE_TYPE = "ct";

DvtMarkerDefElem.ATTR_TRANSFORM = "transform";


/*
 * Initializes the instance. 
 */
DvtMarkerDefElem.prototype.Init = function() {
  DvtMarkerDefElem.superclass.Init.call(this);
};


/*-------------------------------------------------------------------------*/
/*   DvtMarkerDef attributes                                                */
/*-------------------------------------------------------------------------*/

/**
 * Gets the shape of the marker. The list of shapes are :
 * "circle"
 * "ellipse"
 * "line"
 * "path"
 * "polygone"
 * "polyline"
 * "rectangle"
 *
 * @return the shape of the marker
 */
DvtMarkerDefElem.prototype.getShape = function() {
  return this.getProperty(DvtMarkerDefElem.ATTR_SHAPE);
};


/**
 * Specifies the shape of the marker. The list of shapes are :
 * "circle"
 * "ellipse"
 * "line"
 * "path"
 * "polygone"
 * "polyline"
 * "rectangle"
 *
 * @param shape the shape of the marker
 */
DvtMarkerDefElem.prototype.setShape = function(shape) {
  this.setProperty(DvtMarkerDefElem.ATTR_SHAPE, shape);
};



/**
 * Gets the data of the component. 
 * @return data of the component
 */
DvtMarkerDefElem.prototype.getData = function() {
  return this.getProperty(DvtMarkerDefElem.ATTR_DATA);
};

/**
 * Sets the data of the component. 
 * @param data data of the component
 */
DvtMarkerDefElem.prototype.setData = function(data) {
  return this.setProperty(DvtMarkerDefElem.ATTR_DATA, data);
};

/**
 * Gets the points of the component. 
 * @return points of the component
 */
DvtMarkerDefElem.prototype.getPoints = function() {
  return this.getProperty(DvtMarkerDefElem.ATTR_POINTS);
};

/**
 * Sets the points of the component. 
 * @param points points of the component
 */
DvtMarkerDefElem.prototype.setPoints = function(points) {
  this.setProperty(DvtMarkerDefElem.ATTR_POINTS, points);
};

/**
 * Gets the closure type of the component. 
 * @return closure type of the component
 */
DvtMarkerDefElem.prototype.getClosureType = function() {
  return this.getProperty(DvtMarkerDefElem.ATTR_CLOSURE_TYPE);
};

/**
 * Sets the closure type of the component. 
 * @param closureType closure type of the component
 */
DvtMarkerDefElem.prototype.setClosureType = function(closureType) {
  this.setProperty(DvtMarkerDefElem.ATTR_CLOSURE_TYPE, closureType);
};


/**
 * Gets the angles of the component. 
 * @return angles of the component
 */
DvtMarkerDefElem.prototype.getAngles = function() {
  return this.getProperty(DvtMarkerDefElem.ATTR_ANGLES);
};

/**
 * Sets the angles of the component. 
 * @param angles angles of the component
 */
DvtMarkerDefElem.prototype.setAngles = function(angles) {
  return this.setProperty(DvtMarkerDefElem.ATTR_ANGLES, angles);
};

/**
 * Gets the border color of the component. 
 * @return border color of the component
 */
DvtMarkerDefElem.prototype.getBorderColor = function() {
  return this.getProperty(DvtMarkerDefElem.ATTR_BORDER_COLOR);
};

/**
 * Sets the border color of the component. 
 * @param borderColor border color of the component
 */
DvtMarkerDefElem.prototype.setBorderColor = function(borderColor) {
  this.setProperty(DvtMarkerDefElem.ATTR_BORDER_COLOR, borderColor);
};


/**
 * Gets the line width of the component. 
 * @return line width of the component
 */
DvtMarkerDefElem.prototype.getLineWidth = function() {
  return this.getProperty(DvtMarkerDefElem.ATTR_LINE_WIDTH);
};

/**
 * Sets the line width of the component. 
 * @param lineWidth line width of the component
 */
DvtMarkerDefElem.prototype.setLineWidth = function(lineWidth) {
  this.setProperty(DvtMarkerDefElem.ATTR_LINE_WIDTH, lineWidth);
};


/**
 * Gets the fill color of the component. 
 * @return fill color of the component
 */
DvtMarkerDefElem.prototype.getFillColor = function() {
  return this.getProperty(DvtMarkerDefElem.ATTR_FILL_COLOR);
};

/**
 * Sets the fill color of the component. 
 * @param fillColor fill color of the component
 */
DvtMarkerDefElem.prototype.setFillColor = function(fillColor) {
  this.setProperty(DvtMarkerDefElem.ATTR_FILL_COLOR, fillColor);
};


/**
 * Gets the fill pattern of the component. 
 * @return fill pattern of the component
 */
DvtMarkerDefElem.prototype.getFillPattern = function() {
  return this.getProperty(DvtMarkerDefElem.ATTR_FILL_PATTERN);
};

/**
 * Sets the fill pattern of the component. 
 * @param fillPattern fill pattern of the component
 */
DvtMarkerDefElem.prototype.setFillPattern = function(fillPattern) {
  this.setProperty(DvtMarkerDefElem.ATTR_FILL_PATTERN, fillPattern);
};


/**
 * Gets the fill gradient of the component. 
 * @return fill gradient of the component
 */
DvtMarkerDefElem.prototype.getFillGradient = function() {
  return this.getProperty(DvtMarkerDefElem.ATTR_FILL_GRADIENT);
};

/**
 * Sets the fill gradient of the component. 
 * @param fillGradient fill gradient of the component
 */
DvtMarkerDefElem.prototype.setFillGradient = function(fillGradient) {
  this.setProperty(DvtMarkerDefElem.ATTR_FILL_GRADIENT, fillGradient);
};


/**
 *   Gets the gradient color array of the component.
 */

DvtMarkerDefElem.prototype.getGradColors = function() {
  var s = this.getProperty(DvtMarkerDefElem.ATTR_FILL_GRAD_COLORS) ;  
  var a = s.split(',') ;
  return a ;
}

/**
 *   Gets the gradient stops of the component.
 */

DvtMarkerDefElem.prototype.getGradStops = function() {
  var s = this.getProperty(DvtMarkerDefElem.ATTR_FILL_GRAD_STOPS) ;  
  var a = s.split(',') ;
  DvtArrayUtils.toFloat(a) ;
 
  return a ;
}

/**
 *   Gets the gradient bounds of the component.
 */

DvtMarkerDefElem.prototype.getGradBounds = function() {
  var s = this.getProperty(DvtMarkerDefElem.ATTR_FILL_GRAD_BOUNDS) ;  
  var a = s.split(',') ;
  DvtArrayUtils.toFloat(a) ;  
  return a ;
} 


/**
 *   Gets the gradient direction.
 */

DvtMarkerDefElem.prototype.getGradDir = function() {
  return  this.getProperty(DvtMarkerDefElem.ATTR_FILL_GRAD_DIR) ;  
} 



/**
 *   Gets the radial gradient radius
 */

DvtMarkerDefElem.prototype.getGradRadius = function() {
  return  this.getProperty(DvtMarkerDefElem.ATTR_FILL_GRAD_RADIUS) ;  
} 


/**
 *   Gets the radial gradient x-radius
 */

DvtMarkerDefElem.prototype.getGradRadiusX = function() {
  return  this.getProperty(DvtMarkerDefElem.ATTR_FILL_GRAD_RADIUSX) ;  
}


/**
 *   Gets the radial gradient y-radius
 */

DvtMarkerDefElem.prototype.getGradRadiusY = function() {
  return  this.getProperty(DvtMarkerDefElem.ATTR_FILL_GRAD_RADIUSY) ;  
}

/**
 *   Gets the radial gradient cx.
 */

DvtMarkerDefElem.prototype.getGradCx = function() {
  return  this.getProperty(DvtMarkerDefElem.ATTR_FILL_GRAD_CX) ;  
} 


/**
 *   Gets the radial gradient cxy
 */

DvtMarkerDefElem.prototype.getGradCy = function() {
  return  this.getProperty(DvtMarkerDefElem.ATTR_FILL_GRAD_CY) ;  
} 


/**
 * Gets the transform of the component. 
 * @return transform of the component
 */
DvtMarkerDefElem.prototype.getTransform = function() {
  return this.getProperty(DvtMarkerDefElem.ATTR_TRANSFORM);
};

/**
 * Sets the transform of the component. 
 * @param transform transform of the component
 */
DvtMarkerDefElem.prototype.setTransform = function(transform) {
  return this.setProperty(DvtMarkerDefElem.ATTR_TRANSFORM, transform);
};

/**
 * @constructor
 * DvtMarkerDef
 */
var DvtMarkerDef = function() {
  this.Init();
}

/*
 * make DvtMarkerDef a subclass of DvtObj
 */
DvtObj.createSubclass(DvtMarkerDef, DvtPropMap, "DvtMarkerDef");

DvtMarkerDef.MARKER_DEF = "markerDef";

// List of marker shapes
DvtMarkerDef.MARKER_DEF_CIRCLE = "c";
DvtMarkerDef.MARKER_DEF_ELLIPSE = "o";
DvtMarkerDef.MARKER_DEF_LINE = "l";
DvtMarkerDef.MARKER_DEF_PATH = "p";
DvtMarkerDef.MARKER_DEF_POLYGON = "pg";
DvtMarkerDef.MARKER_DEF_POLYLINE = "pl";
DvtMarkerDef.MARKER_DEF_RECT = "r";


// DvtMarkerDef Attributes
DvtMarkerDef.ATTR_ELEMENTS = "elements";
DvtMarkerDef.ATTR_BORDER_COLOR = "bc";
DvtMarkerDef.ATTR_LINE_WIDTH = "lw";
DvtMarkerDef.ATTR_FILL_COLOR = "fc";
DvtMarkerDef.ATTR_FILL_PATTERN = "fp";
DvtMarkerDef.ATTR_FILL_GRADIENT = "fg";



DvtMarkerDef.BI_DEFAULT_MARKER_SIZE = 9;

DvtMarkerDef.HUMAN_CMDS = "M 38.07,36.467856 q 13.414,0 13.414,-13.406 l 0,-9.258 q 0,-13.4039999 -13.414," +
"-13.4039999 -13.414,0 -13.414,13.4039999 l 0,9.258 q 0,13.406 13.414,13.406 l 0,0 z m 16.219,7.275 -32.435999," +
"0 q -10.139552,0 -15.9400009,7.443875 Q 0.5,58.133383 0.5,69.156856 l 0,54.396004 12.746001,0 0,-51.609004 q 0," +
"-2.824 0.793,-2.824 0.742,0 0.742,2.709 l 0,124.267994 q 0,2.82401 2.823999,2.82401 l 12.531,0 q 2.824,0 2.824," +
"-2.824 l 0,-66.25 10.219,0 0,66.25 q 0,2.824 2.824,2.824 l 12.528,0 q 2.825,0 2.825,-2.824 l 0,-124.268004 q 0," +
"-2.709 0.839,-2.709 0.792,0 0.792,2.824 l 0,51.609004 12.65,0 0,-54.396004 Q 75.6386,58.132927 70.227626," +
"51.186731 64.428999,43.742856 54.289,43.742856 l 0,0 z";

DvtMarkerDef.HUMAN2_CMDS = "M 306.40625 386.78125 C 304.19988 386.78125 302.40625 389.07579 302.40625 391.90625 " +
"C 302.40625 394.73671 304.19988 397.03125 306.40625 397.03125 C 308.61263 397.03125 310.40625 394.73671 310.40625 " +
"391.90625 C 310.40625 389.07579 308.61263 386.78125 306.40625 386.78125 z M 301.78125 396.0625 C 300.43025 397.2945 " +
"298.28125 400.28125 298.90625 403.15625 C 302.41725 405.79925 309.20225 406.154 314.03125 403 C 314.21825 399.828 " +
"312.68325 397.5635 310.90625 396.0625 C 308.65625 400.7185 304.28125 399.7815 301.78125 396.0625 z ";



/*
 * Initializes the instance. 
 */
DvtMarkerDef.prototype.Init = function() {
  DvtMarkerDef.superclass.Init.call(this);
};



/*-------------------------------------------------------------------------*/
/*   DvtMarkerDef attributes                                                */
/*-------------------------------------------------------------------------*/

/**
 * Gets the border color of the component. 
 * @return border color of the component
 */
DvtMarkerDef.prototype.getBorderColor = function() {
  return this.getProperty(DvtMarkerDef.ATTR_BORDER_COLOR);
};

/**
 * Sets the border color of the component. 
 * @param borderColor border color of the component
 */
DvtMarkerDef.prototype.setBorderColor = function(borderColor) {
  this.setProperty(DvtMarkerDef.ATTR_BORDER_COLOR, borderColor);
};


/**
 * Gets the line width of the component. 
 * @return line width of the component
 */
DvtMarkerDef.prototype.getLineWidth = function() {
  return this.getProperty(DvtMarkerDef.ATTR_LINE_WIDTH);
};

/**
 * Sets the line width of the component. 
 * @param lineWidth line width of the component
 */
DvtMarkerDef.prototype.setLineWidth = function(lineWidth) {
  this.setProperty(DvtMarkerDef.ATTR_LINE_WIDTH, lineWidth);
};


/**
 * Gets the fill color of the component. 
 * @return fill color of the component
 */
DvtMarkerDef.prototype.getFillColor = function() {
  return this.getProperty(DvtMarkerDef.ATTR_FILL_COLOR);
};

/**
 * Sets the fill color of the component. 
 * @param fillColor fill color of the component
 */
DvtMarkerDef.prototype.setFillColor = function(fillColor) {
  this.setProperty(DvtMarkerDef.ATTR_FILL_COLOR, fillColor);
};


/**
 * Gets the fill pattern of the component. 
 * @return fill pattern of the component
 */
DvtMarkerDef.prototype.getFillPattern = function() {
  return this.getProperty(DvtMarkerDef.ATTR_FILL_PATTERN);
};

/**
 * Sets the fill pattern of the component. 
 * @param fillPattern fill pattern of the component
 */
DvtMarkerDef.prototype.setFillPattern = function(fillPattern) {
  this.setProperty(DvtMarkerDef.ATTR_FILL_PATTERN, fillPattern);
};


/**
 * Gets the fill gradient of the component. 
 * @return fill gradient of the component
 */
DvtMarkerDef.prototype.getFillGradient = function() {
  return this.getProperty(DvtMarkerDef.ATTR_FILL_GRADIENT);
};

/**
 * Sets the fill gradient of the component. 
 * @param fillGradient fill gradient of the component
 */
DvtMarkerDef.prototype.setFillGradient = function(fillGradient) {
  this.setProperty(DvtMarkerDef.ATTR_FILL_GRADIENT, fillGradient);
};


/**
 * Gets the dimensions of the component. 
 * @return dimensions of the component
 */
DvtMarkerDef.prototype.getDimensions = function() {
  var x = this.getProperty("dx");
  var y = this.getProperty("dy");
  var w = this.getProperty("dw");
  var h = this.getProperty("dh");

  if (w && h) {
    return new DvtRectangle(x, y, w, h);
  }
  return null;
};


/**
 * Gets the elements of the marker. The list of elementss are :
 *
 * @return the elements of the marker
 */
DvtMarkerDef.prototype.getElements = function() {
  return this.getProperty(DvtMarkerDef.ATTR_ELEMENTS);
};


/**
 * Add an element to the marker.
 *
 * @param {DvtMarkerDefElem} element to be added
 */
DvtMarkerDef.prototype.addElement = function(element) {
  var elems = this.getElements();
  if (! elems) {
    elems = [];
    this.setProperty(DvtMarkerDef.ATTR_ELEMENTS, elems);
  }
  elems.push(element);
};


var DvtMarkerGradient = function (){}

DvtObj.createSubclass(DvtMarkerGradient, DvtObj, "DvtMarkerGradient");

DvtMarkerGradient.createMarkerGradient = function (color, marker, opacity)
{
  var arColors = [];
  var arRatios = [];
  var arAlphas = [opacity, opacity, opacity, opacity];
  var gfs = null;

  var shapeType = marker.getType();
  var dim = DvtDisplayableUtils._getDimForced (marker.getCtx(), marker);
  var center = dim.getCenter();
  var size = Math.min (dim.w, dim.h);

  if (shapeType != DvtMarker.HUMAN)
  {
     arRatios = [0.0, 0.5, 0.75, 1];
     var c0 = DvtColorUtils.getPastel(color, 0.20);
     var c1 = DvtColorUtils.getPastel(color, 0.10);
     var c2 = DvtColorUtils.getDarker(color, 0.8);
     
     var radius = size / 2.0;
     var cx = center.x;
     var cy = center.y;
     var arColors = [DvtColorUtils.getPound(c0), DvtColorUtils.getPound(c1), color, DvtColorUtils.getPound(c2)];    
     var bound = new DvtRectangle(-radius, -radius, radius * 2.0, radius* 2.0);
     var arBound = [bound.x, bound.y, bound.w, bound.h];
     gfs = new DvtRadialGradientFill(arColors, arAlphas, arRatios, cx, cy, radius, arBound);
  } else
  {
     arRatios = [0.0, 0.3, 0.7, 1];
     var c0 = DvtColorUtils.getPastel(color, 0.20);
     var c1 = DvtColorUtils.getDarker(color, 0.9);
     var c2 = DvtColorUtils.getDarker(color, 0.8);
     var arColors = [DvtColorUtils.getPound(c0), DvtColorUtils.getPound(c1), color, DvtColorUtils.getPound(c2)];    
     var bound = new DvtRectangle(-size/ 2.0, -size /2.0, size, size);
     var arBound = [bound.x, bound.y, bound.w, bound.h];
     gfs = new DvtLinearGradientFill(135, arColors, arAlphas, arRatios, arBound);
  }

  return gfs ;
}
/**
 * DvtMarkerUtils
 */
var DvtMarkerUtils = {_cache:{}};

DvtObj.createSubclass(DvtMarkerUtils, DvtObj, "DvtMarkerUtils");

/**
 * @this {DvtMarkerUtils}
 * parse markerDefXmlString and return a markerDef object
 */
DvtMarkerUtils.createMarkerDef = function(context, markerDefNode) {
  
  var markerDef = new DvtMarkerDef();
  markerDef.setProperties(markerDefNode.getAttributes());

  var childNodes = markerDefNode.getChildNodes();
  var childElems;

  for (var i = 0; i < childNodes.length; i++) {
    var child = childNodes[i];
    if (child) {
      childElems = new DvtMarkerDefElem();
      
      if (child.getName() == 'fillDef') {
        if (child.getChildNodes()) {
          child = child.getChildNodes()[0] ;    // want the child ( e.g. <g> )
        }
      }

      childElems.setProperties(child.getAttributes());
      childElems.setShape(child.getName());
      markerDef.addElement(childElems);
    }
  }

  if (markerDef) {
    this._addMarkerDef(context, markerDef);
  }
  return markerDef;
};



/**
 * @this {DvtMarkerUtils}
 * add a markerDef object to the marker list
 */
DvtMarkerUtils._addMarkerDef = function(context, markerDef) {
  var stageId = context.getStage().getId();
  var markerId = markerDef.getId();
  var markerList = DvtMarkerUtils.getMarkerList(stageId);

  //first look for a cached copy of the custom marker 
  //if not found, add to the custom marker list
  if (! markerList[markerId]) {
    var marker = this.createMultiPaths(context, markerDef, markerId);
    if (marker) {
      // set id on the root 
      marker.setId("custom" + markerId);
      markerList[markerId] = marker;

      // get custom dimensions and cache it in the shape object
      var dim = markerDef.getDimensions();
      if (dim) {
        DvtDisplayableUtils._setDimForced(marker, dim);
      }
    }
  }
};


/**
 * @this {DvtMarkerUtils}
 * Get Custom Marker List
 */
DvtMarkerUtils.getMarkerList = function(stageId)
{
  if (!this._cache[stageId]) {
    this._cache[stageId] = {};
  }
  return this._cache[stageId];
};


/**
 * @this {DvtMarkerUtils}
 * Returns a DvtPath
 * 
 * @param context  the context
 * @param markerDef the custom marker definition
 */
DvtMarkerUtils.createMarkerShape = function(context, markerDefElem, markerDef, markerId) {

  var marker;
  var type = markerDefElem.getShape();

  if (type == DvtMarkerDef.MARKER_DEF_PATH) {
    marker = this.createPathMarker(context, markerDefElem, markerId);
  }
  /*
  else if (type == DvtMarkerDef.MARKER_DEF_CIRCLE ||
      type == DvtMarkerDef.MARKER_DEF_ELLIPSE) {
    marker = this.createCircleMarker(context, markerDef, markerId, type);
  }
  else if (type == DvtMarkerDef.MARKER_DEF_LINE) {
    marker = this.createLineMarker(context, markerDef, markerId);
  }
  else if (type == DvtMarkerDef.MARKER_DEF_POLYGON) {
    marker = this.createPolygoneMarker(context, markerDef, markerId);
  }
  else if (type == DvtMarkerDef.MARKER_DEF_POLYLINE) {
    marker = this.createPolylineMarker(context, markerDef, markerId);
  }
  else if (type == DvtMarkerDef.MARKER_DEF_RECT_TYPE) {
    marker = this.createRectMarker(context, markerDef, markerId);
  }
  */

  //set common attributes
  if (marker) {
    DvtMarkerUtils.setCommonAttrs(markerDefElem, markerDef, marker);
  }

  return marker;
};


/**
 * @type DvtPath or DvtContainer (contains a list of DvtPaths)
 */
DvtMarkerUtils.createMultiPaths = function(context, markerDef, markerId) {
  var shapes = markerDef.getElements();
  if (! shapes || shapes.length == 0)
    return null;

  var root;
  if (shapes.length == 1) {
    root = DvtMarkerUtils.createMarkerShape(context, shapes[0], markerDef, markerId);
  }
  else {
    root = new DvtContainer(context, markerId);
    var child;
    var childElem;
    for (var i = 0; i < shapes.length; i++) {
      child = shapes[i];
      childElem = DvtMarkerUtils.createMarkerShape(context, child, markerDef, markerId + "_" + i);
      if (childElem)
         root.addChild(childElem);
    }
  }
  return root;

};

// type: circle or ellipse
DvtMarkerUtils.createCircleMarker = function(context, markerDef, markerId, type) {
  var points = markerDef.getPoints();
  var cx = points[0];
  var cy = points[1];
  var rx = points[2];
  var ry;
  if (type == DvtMarkerDef.MARKER_DEF_ELLIPSE) {
    ry = points[3];
  }
  var marker ;
  var closureType = markerDef.getClosureType();
  if (closureType) {
    var angles = markerDef.getAngles();
    var anglesStart;
    var anglesExtent;
    if (angles) {
      anglesStart = angles[0];
      anglesExtent = angles[1];
    }
    marker = new DvtArc(context, cx, cy, rx, ry, 
                        anglesStart, anglesExtent, closureType, markerId);
  }
  else {
    marker = new DvtCircle(context, cx, cy, rx, markerId);
  }

  return marker;
};


DvtMarkerUtils.createRectMarker = function(context, markerDef, markerId) {
  var points = markerDef.getPoints();
  var x = points[0];
  var y = points[1];
  var w = points[2];
  var h = points[3];

  return new DvtRect(context, x, y, w, h, markerId);
};


DvtMarkerUtils.createLineMarker = function(context, markerDef, markerId) {
  var points = markerDef.getPoints();
  var x1 = points[0];
  var y1 = points[1];
  var x2 = points[2];
  var y2 = points[3];

  return new DvtLine(context, x1, y1, x2, y2, markerId);
};

DvtMarkerUtils.createPathMarker = function(context, markerDefElem, markerId) {
  var data = markerDefElem.getData();

  return new DvtPath(context, data, markerId);
};


DvtMarkerUtils.createPolygoneMarker = function(context, markerDef, markerId) {
  var points = markerDef.getPoints();

  return new DvtPolygon(context, points, markerId);
};


DvtMarkerUtils.createPolylineMarker = function(context, markerDef, markerId) {
  var points = markerDef.getPoints();

  return new DvtPolyline(context, points, markerId);
};


DvtMarkerUtils.setCommonAttrs = function(markerDefElem, markerDef, marker) {
  // solid, gradient, pattern fill?
  var fc = markerDefElem.getFillColor();
  var fa = null; //TODO getAlpha
  var fg = markerDefElem.getFillGradient();
  var fp = markerDefElem.getFillPattern();

  if (fp) {
    marker.setFill(new DvtPatternFill(fp, fc));
  }
  else if (fg) {                           // look for matching fillDef gradient id
    var elems = markerDef.getElements() ;
    var fd ;
    var len = elems.length ;
    for (var i = 0; i < len; i++) {
       var fillDef = elems[i] ;
       if (fillDef.getShape() == 'g' && fillDef.getId() == fg) {
         fd = fillDef ;
         break ;
       } 
    }   
    
    var stops ;
    var bounds ;
    var dir ;
    var gradCx ;
    var gradCy ;
    var rad ;
    if (fd) {
      fc     = fd.getGradColors() ;
      stops  = fd.getGradStops() ;
      bounds = fd.getGradBounds() ;
      dir    = fd.getGradDir() ;
      if (dir == DvtMarkerDefElem.ATTR_FILL_GRAD_DIR_RADIAL) {
        gradCx =  parseFloat(fd.getGradCx()) ;
        gradCy =  parseFloat(fd.getGradCy()) ;
        rad    =  parseFloat(fd.getGradRadius()) ;
        if (! rad) {
          var radX = parseFloat(fd.getGradRadiusX()) ;    // svg doesn't support rx, ry
          var radY = parseFloat(fd.getGradRadiusY()) ;          
          rad = Math.max(radX, radY) ;           
        }
        marker.setFill(new DvtRadialGradientFill(fc, fa , stops, gradCx, gradCy, rad, bounds));
       }
       else  {
          var angle = 0 ;
          if (dir == DvtMarkerDefElem.ATTR_FILL_GRAD_DIR_45)
            angle = -135 ;
          else if (dir == DvtMarkerDefElem.ATTR_FILL_GRAD_DIR_135)
            angle = -45 ;
          else if (dir == DvtMarkerDefElem.ATTR_FILL_GRAD_DIR_DOWN)
            angle = -90 ;
          marker.setFill(new DvtLinearGradientFill(angle, fc, fa, stops, bounds)); 
       }
    }   
    else { 
      marker.setFill(new DvtLinearGradientFill(0, ["#000", "#fff"])); 
    }
  }
  else if (fc || fa) {
    marker.setSolidFill(fc, fa);
  }

  var lw = parseFloat(markerDefElem.getLineWidth());
  var bc = markerDefElem.getBorderColor();

  if (lw || bc) {
    if (! lw)
      lw = 1 ;       
    if (! bc)
      bc = "black";
    
    var stroke = new DvtSolidStroke(bc, 1, lw);
    marker.setStroke(stroke);    
  }

};


/**
 * get a markerDef from the marker list
 * @type DvtPath or DvtContainer (contains a list of DvtPaths)
 */
DvtMarkerUtils.getCustomMarkerInfo = function(context, markerId) {
  var stageId = context.getStage().getId();
  var markerList = DvtMarkerUtils.getMarkerList(stageId);

  if (markerList) {
    return markerList[markerId];
  }
  else {
    return undefined;
  }
};


/**
 * Returns the built in marker shape given the marker type and skin
 * @param {DvtContext} The platform specific context object
 * @param {String} markerType The marker type
 * @param {String} skin The skin name
 * @return {DvtShape} The built in marker shape
 */
DvtMarkerUtils.getBuiltinMarkerInfo = function(context, markerType, skin) {
  var stageId = context.getStage().getId();
  var markerList = DvtMarkerUtils.getMarkerList(stageId);
  var markerId = skin ? markerType + '_' + skin : markerType;
  var defId = markerList[markerId];
  // if the marker is not in cache, add it to markerList
  if (! defId) {
    if (markerType) {
      var tmarker = new DvtPath(context, skin == DvtCSSStyle.SKIN_ALTA ? DvtMarkerDef.HUMAN2_CMDS : DvtMarkerDef.HUMAN_CMDS, "dvtHuman");
      // cache the dimensions in the shape object
      DvtDisplayableUtils._getDimForced(context, tmarker);
      markerList[markerId] = tmarker;
    }
  }
  return markerList[markerId];
};


/**
 * @this {DvtMarkerUtils}
 * For internal use only
 */
DvtMarkerUtils.clearCached = function(context) {
  var stageId = context.getStage().getId();
  this._cache[stageId] = undefined;
}


// Copyright (c) 2008, 2012, Oracle and/or its affiliates. 
// All rights reserved. 
/*---------------------------------------------------------------------*/
/*  DvtPolygonUtils()       Utility functions for Polygons             */
/*---------------------------------------------------------------------*/

var DvtPolygonUtils = {} ;

DvtObj.createSubclass(DvtPolygonUtils, DvtObj, "DvtPolygonUtils");

/**
 * Returns the bounding box of the supplied polygon coords.
 * @param {Array} aPts an array of consecutive x,y coordinate pairs.
 * @returns {DvtRectangle} the bounding box of the supplied polygon.
 */
DvtPolygonUtils.getDimensions = function(aPts)
{
  if ((! aPts) || (aPts.length=== 0)) {
    return new DvtRectangle() ;
  }

  var minX = Number.MAX_VALUE ;
  var maxX = Number.MIN_VALUE ;
  var minY = Number.MAX_VALUE ;
  var maxY = Number.MIN_VALUE ;

  var len = aPts.length ;
  var x, y ;
  for (var i = 0; i < len; i++) {

     x = aPts[i++];
     y = aPts[i];
     minX = Math.min(minX, x) ;
     maxX = Math.max(maxX, x) ;
     minY = Math.min(minY, y) ;
     maxY = Math.max(maxY, y) ;
  }

  return new DvtRectangle(minX, minY, Math.abs(maxX - minX), Math.abs(maxY - minY)) ;
};


// Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.
/*---------------------------------------------------------------------*/
/*  DvtTextUtils()       Utility functions for text                    */
/*---------------------------------------------------------------------*/

var DvtTextUtils = {} ;

DvtObj.createSubclass(DvtTextUtils, DvtObj, "DvtTextUtils");

/** private **/
DvtTextUtils._cachedTextDimensions = {};

DvtTextUtils.formatTextString = function(tooltip)
{
    var fullText = "";
    if (!tooltip)
        return fullText;

    tooltip = tooltip.replace(/\n/g, '<br>'); // replace logical newlines sequences
    var tooltipTextArray = tooltip.split("<br>");        
    if (tooltipTextArray) {
        var shortArray = new Array();
        for (var i=0; i< tooltipTextArray.length; i++) {
            var txt = tooltipTextArray[i];
            if (txt != null && txt != "") {
                shortArray.push(txt);
            }
        }
        for (var i=0; i< shortArray.length; i++) {
            fullText += shortArray[i];
            if (i < shortArray.length - 1) {
                fullText += DvtTextArea.NEW_LINE;
            }
        }
    }
    return fullText;
}

/**
 * Conservatively estimates the width and height of the specified text object.  This function uses a cache to 
 * guess the width and height of the specified text string.  This function relies on the fact that
 * all text strings with the same CSS style return the same height from getDimensions.  Users of 
 * this function can avoid expensive getDimensions calls when checking to see if a text string 
 * would fit in a certain size.
 * @param {DvtOutputText} text
 * @param {number} [minChars] The minimum number of characters that should be displayed before ellipsis if 
 *                            truncation occurs. If this argument is skipped, the default is 1 character.
 * @return {Object} An object with fields w, h, and wMin.  w and h correspond to the conservative estimate of the
 *                  text size, while wMin corresponds to the minimum width necessary to show truncated text with the
 *                  specified minimum number of characters.
 */
DvtTextUtils.guessTextDimensions = function(text, minChars) {
  var textString = text.getTextString();
  var cssStyle = text.getCSSStyle();
  var cssStyleStr =  cssStyle ? cssStyle.toString() : "";
  
  // Check whether a cached size is already available
  var cachedDims = DvtTextUtils._cachedTextDimensions[cssStyleStr];
  
  // Compute the dimensions of a representative character and add to the cache
  if(cachedDims == null) {    
    // Measure M and W, which are usually the longest characters. Also safe for CJK, which is always monospace.
    text.setTextString("MW");
    var dims = text.measureDimensions();
    
    // Cache the dims of a single character. Conservative because real strings are not solely longest characters.
    cachedDims = {w: 0.50 * dims.w, h: dims.h};
    DvtTextUtils._cachedTextDimensions[cssStyleStr] = cachedDims;
    
    // Restore the textString
    text.setTextString(textString);
  }
  
  // Use the cached size to guess at the string length
  var w = cachedDims.w * textString.length;
  
  // Esimate the minimum truncated length using fudge factor and by estimating the ellipsis as 1 character
  minChars = (isNaN(minChars) || minChars == null) ? 1 : minChars;
  var wMin = Math.min(0.5 * w, cachedDims.w * ((0.5 * minChars) + 1));
  
  return {w: w, h: cachedDims.h, wMin: wMin};
}

/**
 * Fits text in the provided space. This function uses DvtTextUtils.guessTextDimensions before calling setMaxWidth
 * in order to avoid expensive getDimensions calls. It adds the text to the container, and removes it if the text cannot
 * fit at all in the container.
 * @param {DvtOutputText} text
 * @param {number} maxWidth The maximum width of the text
 * @param {number} maxHeight The maximum height of the text
 * @param {DvtContainer} container The parent of the text
 * @param {number} [minChars] The minimum number of characters that should be displayed before ellipsis if 
 *                            truncation occurs. If this argument is skipped, the default is 1 character.
 * @return {boolean} false if the text cannot fit at all, true otherwise.
 */
DvtTextUtils.fitText = function(text, maxWidth, maxHeight, container, minChars) {
  minChars = (isNaN(minChars) || minChars == null) ? 1 : minChars;
  var untruncatedTextString = text.getTextString();
  
  var guess = DvtTextUtils._guessFit(text, maxWidth, maxHeight, container, minChars);
  if(guess == true) {
    container.addChild(text);
    return true;
  }
  else if(guess == false) {
    // Remove from parent in this case to be consistent
    var parent = text.getParent();
    if(parent)
      parent.removeChild(text);
      
    return false;
  }
  
  // At this point, truncation may be needed.  Try to truncate the text.
  container.addChild(text);
  
  if(text instanceof DvtOutputText) 
    DvtTextUtils._truncateOutputText(text, maxWidth, minChars);
  else if(text instanceof DvtMultilineText) {
    // DvtOutputText will manage removal from container and setting of untruncated text string
    return text.__fitText(maxWidth, maxHeight, minChars);
  }
  else
    text.setMaxWidth(maxWidth, minChars);
  
  // Check if the truncated text can fit
  if (text.getTextString() == "") {
    container.removeChild(text);
    return false;
  } 
  else {
    if (text.getTextString() != untruncatedTextString) 
      text.setUntruncatedTextString(untruncatedTextString);
    
    return true;
  }
}

/**
 * Uses estimates to quickly determine whether the text can fit in the specified area.  Returns true if the text will
 * definitely fit, false if the text will definitely not fit, and null if further calculation is needed.
 * @param {DvtOutputText} text
 * @param {number} maxWidth The maximum width of the text
 * @param {number} maxHeight The maximum height of the text
 * @param {DvtContainer} container The parent of the text
 * @param {number} minChars The minimum number of characters that should be displayed before ellipsis
 * @return {object} false if the text won't fit, true if it will, null if further calculation needed
 */
DvtTextUtils._guessFit = function(text, maxWidth, maxHeight, container, minChars) {
  if(text instanceof DvtMultilineText) {
    // Can optimize in the future if needed
    return null;
  }
  else {
    // Estimate the dims conservatively
    var estimatedDims = DvtTextUtils.guessTextDimensions(text, minChars);
    
    // The "estimated" height is always accurate and estimated min width is conservative. Safe to quit if it doesn't fit.
    if(estimatedDims.h > maxHeight || estimatedDims.wMin > maxWidth) 
      return false;
      
    // The estimated width is conservative, ensuring that truncation is not necessary if the estimate < maxWidth.
    if(estimatedDims.w < maxWidth)
      return true;
      
    // No determination could be made
    return null;
  }
}

/**
 * Truncates the text instance to fit within the given width.  Sets the text string of the text to an empty string if
 * truncated text does not fit.
 * @param {DvtOutputText} text The text instance to be truncated.
 * @param {number} maxWidth The maximum width of the text.
 * @param {number} minChars The minimum number of characters that should be displayed before ellipsis after truncation.
 * @private
 */
DvtTextUtils._truncateOutputText = function(text, maxWidth, minChars) {
  // Initial check using accurate dimensions
  var dims = text.measureDimensions();
  if(dims.w <= maxWidth)
    return;
    
  // Determine avg pixels per char and make an initial guess at the truncation
  var textString = text.getTextString();
  var textLength = textString.length;
  var avgPixelsPerChar = dims.w/textString.length;
  var maxNumChars = Math.max(Math.floor(maxWidth/avgPixelsPerChar)-2, minChars); // Subtract 2 for the ellipsis
  
  // Determine whether we can use context to measure text.
  // If so, don't need to call getDimensions() at all, and only need to setTextString() at the very end.
  var truncatedTextString = textString.substring(0, maxNumChars) + DvtOutputText.ELLIPSIS;
  text.setTextString(truncatedTextString);
  dims = text.measureDimensions();
  
  // Add characters if initial guess is too short.  Keep track of the previous string and dims in case we overshoot
  var prevTextString = truncatedTextString;
  var prevDims = dims;
  while (dims.w < maxWidth) {
    if (maxNumChars >= textString.length)
      break;

    // Calculate the availWidth and use that to estimate the number of characters to increment
    var availWidth = maxWidth - dims.w;
    
    // estimatedIncrement: The smaller of the chars remaining and the estimate of characters than can fit
    var estimatedIncrement = Math.min(textLength - maxNumChars, Math.max(Math.floor(availWidth/avgPixelsPerChar), 1));

    // Add chars and measure again
    maxNumChars += estimatedIncrement;
    truncatedTextString = textString.substring(0, maxNumChars) + DvtOutputText.ELLIPSIS;
    text.setTextString(truncatedTextString);
    dims = text.measureDimensions();
    
    // If we overshot and the increment was only 1, then restore the old string
    if(estimatedIncrement == 1 && dims.w > maxWidth) {
      text.setTextString(prevTextString);
      dims = prevDims;
      break;
    }
    
    // Otherwise update the previous string and dims
    prevTextString = truncatedTextString;
    prevDims = dims;
  }

  // Remove characters if initial guess is too long
  while (dims.w > maxWidth) {
    if (maxNumChars <= minChars) {
      // minChars doesn't fit, return ""
      text.setTextString("");
      break;
    }
    
    // Truncate 1 char at a time
    maxNumChars -= 1;
    truncatedTextString = textString.substring(0, maxNumChars) + DvtOutputText.ELLIPSIS;
    text.setTextString(truncatedTextString);
    dims = text.measureDimensions();
  }
}
// Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.
/**
 *   Static Shape Utility Functions
 *   @class DvtSvgShapeUtils
 *   @constructor
 */
var  DvtSvgShapeUtils = function()
{} ;

DvtObj.createSubclass(DvtSvgShapeUtils, DvtObj, "DvtSvgShapeUtils");

DvtSvgShapeUtils._uniqueSeed = 0 ;  // for unique Id creation

/**
 * Adds a clipping region to the global defs element.
 * @param {DvtClipPath}  cp  the DvtClipPath object specifying the clipping region(s).
 * @returns {boolean}    true if the clipping paths was successfully or already added, else false.
 */
DvtSvgShapeUtils.addClipPath = function(cp, context) {
  var id = cp.getId() ;
  if (! id) {
    return  false;    // essential to have an id to reference
  }

  var elemDefs = context.getDefs() ; 
  if (! elemDefs) {
    return false;
  }

  // Check if clipping path for this id is already defined.
  var defsChildren = elemDefs.childNodes ;
  var len          = defsChildren.length ;
  for (var i = 0; i < len; i++) {
    var el = defsChildren[i] ;
    if (el.id === id)
      return true;
  }
  
  var elemClip  = DvtSvgShapeUtils.createElement('clipPath', id) ;
  context.appendDefs(elemClip) ;
  
  var regions = cp.getRegions() ;
  for (var i = 0; i < regions.length; i++) {
     var region = regions[i] ;
     if (region) {
       var  elem = null ;
       if (region.type === DvtClipPath.RECT) {
          elem = DvtSvgShapeUtils.createElement('rect') ;
          DvtToolkitUtils.setAttrNullNS(elem, 'x',      region.x) ;
          DvtToolkitUtils.setAttrNullNS(elem, 'y',      region.y) ;
          DvtToolkitUtils.setAttrNullNS(elem, 'width',  region.w) ;
          DvtToolkitUtils.setAttrNullNS(elem, 'height', region.h) ;
          if (region.rx)
            DvtToolkitUtils.setAttrNullNS(elem, 'rx', region.rx) ;
          if (region.ry)
            DvtToolkitUtils.setAttrNullNS(elem, 'ry', region.ry) ;
       }
       else if (region.type === DvtClipPath.PATH) {
          elem = DvtSvgShapeUtils.createElement('path') ;
          DvtToolkitUtils.setAttrNullNS(elem, 'd', region.d) ;
       }
       else if (region.type === DvtClipPath.POLYGON) {
          elem = DvtSvgShapeUtils.createElement('polygon') ;
          DvtToolkitUtils.setAttrNullNS(elem, 'points', region.points) ;
       }
       else if (region.type === DvtClipPath.ELLIPSE) {
          elem = DvtSvgShapeUtils.createElement('ellipse') ;
          DvtToolkitUtils.setAttrNullNS(elem, 'cx', region.cx) ;
          DvtToolkitUtils.setAttrNullNS(elem, 'cy', region.cy) ;
          DvtToolkitUtils.setAttrNullNS(elem, 'rx', region.rx) ;
          DvtToolkitUtils.setAttrNullNS(elem, 'ry', region.ry) ;
       }
       else if (region.type === DvtClipPath.CIRCLE) {
          elem = DvtSvgShapeUtils.createElement('circle') ;
          DvtToolkitUtils.setAttrNullNS(elem, 'cx', region.cx) ;
          DvtToolkitUtils.setAttrNullNS(elem, 'cy', region.cy) ;
          DvtToolkitUtils.setAttrNullNS(elem, 'r', region.r) ;
       }

       if (elem)
         DvtToolkitUtils.appendChildElem(elemClip, elem) ;
     }
  }

  return true ;
}

/**
 * Creates an SVG DOM element.  
 * @param {String} name 
 * @param {String} id  Optional ID to be applied to the created DOM element.
 * @return {Element} the DOM element
 */
DvtSvgShapeUtils.createElement = function(name, id)
{
   var elem = document.createElementNS(DvtToolkitUtils.SVG_NS, name) ;

   if (id) {
     DvtToolkitUtils.setAttrNullNS(elem, 'id', id) ;
   }
     
   return elem ;
}

/**
 * Creates a unique ID string
 * @param {DvtContext} context The rendering context
 * @param {String} sPrefix  Optional string used as a prefix for the generated ID. If 
 *                          omitted, the ID generated will be prefixed with '$'.
 * @return {String}        A unique ID string
 */
DvtSvgShapeUtils.getUniqueId = function(context, sPrefix)
{
  var uniqueId = (sPrefix? sPrefix : '$') + DvtSvgShapeUtils._uniqueSeed++ ;
  if (DvtAgent.isEnvironmentTest())
    return (context ? context.getStage().getId() + '_' : '') + uniqueId;
  else
    return uniqueId;
}

/**
 * Converts an array of x,y coordinate pairs into an SVG style string.
 * @param {array} arPoints the array of points
 * @return {Array}  the string usable by SVG polygons and polylines
 */
DvtSvgShapeUtils.convertPointsArray = function(arPoints) {
  var len = arPoints.length ;   // convert to svg space separated list
  var s = '' ;

  for (var i = 0; i < len; i++) {
    if (i > 0) {
      s += ' ' ;
    }
    s += arPoints[i] ;
  }
  return s;
}
// Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.
/**
 *  Abstract base class for displayable objects.
 *  @extends DvtObj
 *  @class
 *  @constructor
 */
var DvtDisplayable = function () {
  // This class should never be instantiated directly
}

DvtObj.createSubclass(DvtDisplayable, DvtObj, "DvtDisplayable");

/**
 * Array of SVG attributes that should be transferred to the outer element.
 * @private
 */
DvtDisplayable._ATTRS_TRANSFERABLE_TO_OUTER = [/*'filter',*/'clip-path']

/**
 * A mapping between event types and the string needed to create a new event for dispatch
 * @private
 */
DvtDisplayable._CREATE_EVENT_TYPE_MAP = {
  click : DvtMouseEvent.CLICK, mouseover : DvtMouseEvent.MOUSEOVER, mouseout : DvtMouseEvent.MOUSEOUT, mousemove : DvtMouseEvent.MOUSEMOVE, keydown : DvtKeyboardEvent.KEYDOWN, keyup : DvtKeyboardEvent.KEYUP
};

/**
 * @param {DvtContext} context
 * @param {string} type The type of SVG element to be created.
 * @param {string} [id] The optional id for the corresponding DOM element.
 * @protected
 */
DvtDisplayable.prototype.Init = function (context, type, id) {
  if (id)
    this._id = id;

  this._context = context;
  this._elem = DvtSvgShapeUtils.createElement(type, this._id);
  this._elem._obj = this;//  pointer back to this object
  // TODO HZHANG Removal of null initialization routines
  this._bVisible = true;
  this._filter = null;
  this._pixelHinting = false;
  this._cursor = null;
  this._bMouseEnabled = true;
  this._alpha = 1;
  this._matrix = null;

  this._bubbleClosure = null;
  this._captureClosure = null;
  this._desc = null;

  this._ariaProperties = {
  };
  
  /**
   * Property map used to cache SVG property values to avoid DOM access.
   * @private
   */
  this._properties = {};

  // TODO REMOVE
  this._impl = this;
  this._obj = this;
}

/**
 * Returns the application context.
 * @return {DvtContext}
 */
DvtDisplayable.prototype.getCtx = function () {
  return this._context;
};

/**
 * Internal DVT toolkit framework use only. Returns the platform specific
 * implementation for this object (such as {@link DvtSvgRect}).
 * @protected
 * @type Object
 */
DvtDisplayable.prototype.getImpl = function () { 
  // TODO HZHANG Deprecated.  Will start removing usages outside of the shapes layer once the new toolkit is merged.
  return this;
}

/**
 *  @returns {Object}  the controlling (js) object.
 */
DvtDisplayable.prototype.getObj = function ()// TODO HZHANG REMOVE
{
  // TODO HZHANG Deprecated.  Will start removing usages outside of the shapes layer once the new toolkit is merged.
  return this;
}

/**
 *  Returns the SVG DOM element representing this displayable object.
 *  @returns {DOM_element}  An SVG DOM element representing this displayable object.
 */
DvtDisplayable.prototype.getElem = function () {
  return this._elem;
}

/**
 * Returns the outermost SVG DOM element of this displayable.  This should be used when
 * removing this displayable from the DOM.
 * @return {DvtDisplayable}
 */
DvtDisplayable.prototype.getOuterElem = function () {
  return this._outerElem ? this._outerElem : this.getElem();
}

/**
 * Returns the id of this displayable.
 * @return {string}
 */
DvtDisplayable.prototype.getId = function () {
  return this._id;
}

/**
 * Specifies the id of this displayable.
 * @param {string} id
 */
DvtDisplayable.prototype.setId = function (id) {
  if (this._id !== id) {
    if (id && id.length === 0) {
      id = null;
    }
    this._id = id;

    if (id)
      DvtToolkitUtils.setAttrNullNS(this._elem, 'id', id);
    else 
      DvtToolkitUtils.removeAttrNullNS(this._elem, 'id');
  }
}

/**
 * Returns the parent of this object.
 * @type DvtDisplayable
 */
DvtDisplayable.prototype.getParent = function () {
  return this._parent;
}

/**
 * Sets the parent of this object.
 * @param {DvtDisplayable} parent
 */
DvtDisplayable.prototype.setParent = function (parent) {
  this._parent = parent;
};

/**
 * Returns true if pixel hinting is enabled.
 * @return {boolean}
 */
DvtDisplayable.prototype.getPixelHinting = function () {
  return this._pixelHinting;
}

/**
 * Specifies whether pixel hinting is enabled.
 * @param {boolean} bHint
 */
DvtDisplayable.prototype.setPixelHinting = function (bHint) {
  this._pixelHinting = bHint;
  if (bHint)
    DvtToolkitUtils.setAttrNullNS(this._elem, 'shape-rendering', 'crispEdges');
  else 
    DvtToolkitUtils.removeAttrNullNS(this._elem, 'shape-rendering');
}

/**
 *  Gets the visibility of this object.
 *  @returns {boolean}  True if the object is visible, else false.
 */
DvtDisplayable.prototype.getVisible = function () {
  return this._bVisible;
}

/**
 *  Enables/disables the visibility of this object.
 *  @param {boolean}  bVis  True if the object is to be visible, else false if
 *  it is to be hidden.
 */
DvtDisplayable.prototype.setVisible = function (bVis) {
  if (this._bVisible !== bVis) {
    this._bVisible = bVis;
    var elem = (this instanceof DvtMarker) ? this._elem : this.getElem();

    //Bug 16005714 - HTML5: VISIBILITY="VISIBLE" LEFT ON ELEMENT AFTER ANIMATION
    //Since the default value for visibility is true, just remove the 'visibility' attribute.
    //This change is needed to avoid the attribute visibility="visible" left on
    //this element after animation.
    //Note: in SVG, the visibility attribute doesn't behave like Flash, 
    //Ex: if a child has visibility="visible" and its container has visibility=hidden
    //the child is still visible
    if (bVis) {
      DvtToolkitUtils.removeAttrNullNS(elem, 'visibility');
    }
    else {
      DvtToolkitUtils.setAttrNullNS(elem, 'visibility', 'hidden');
    }
  }
}


/**
 *  Sets a clipping region for this object.
 *  @param {DvtClipPath}  cp  the DvtClipPath object specifying the clipping region.
 */
DvtDisplayable.prototype.setClipPath = function (cp) {
  // Update clip path reference count on the context
  if (cp && this.ClipPathId != cp.getId()) {
    if(this.ClipPathId)
      this._context.removeClipPath(this.ClipPathId);
    
    this.ClipPathId = cp.getId();
    this._context.addClipPath(this.ClipPathId);
  }
  else if(this.ClipPathId) {
    this._context.removeClipPath(this.ClipPathId);
    this.ClipPathId = null;
  }
  
  // Bug 14764452 - PANELCARDS NOT CLIPPING IN DIAGRAM
  // if cp is null, clear the clip-path property, 
  // ideally the clipPath should also be removed from the global defs
  // if it's not used.
  if (!cp) {
    DvtToolkitUtils.removeAttrNullNS(this.getOuterElem(), 'clip-path');
    return;
  }

  // Create an outer group if there is a matrix defined, since SVG applies transforms before clip paths.
  if (!this._outerElem && this._matrix)
    this._createOuterGroupElem();
  
  var id = cp.getId();
  if (id) {  
    // essential to have an id to reference
    var context = this.getCtx();

    if (DvtSvgShapeUtils.addClipPath(cp, context)) {
      // add to global defs
      // Set the clip path on the outer element of the shape
      DvtToolkitUtils.setAttrNullNS(this.getOuterElem(), 'clip-path', 'url(#' + id + ')');
    }
  }
}

DvtDisplayable.prototype.addClipPath = function (cp, context) {
  return DvtSvgShapeUtils.addClipPath(cp, context);
}

/**
 * Converts the DvtRectangle in the local coordinate system to the target displayable's coordinate system.
 * @param {DvtRectangle} rect
 * @param {DvtDisplayable} targetCoordinateSpace
 */
DvtDisplayable.prototype.ConvertCoordSpaceRect = function (rect, targetCoordinateSpace) {
  if (!targetCoordinateSpace || targetCoordinateSpace === this)
    return rect;

  // First calculate relative to the stage
  var stageP1 = this.localToStage(new DvtPoint(rect.x, rect.y));
  var stageP2 = this.localToStage(new DvtPoint(rect.x + rect.w, rect.y + rect.h));

  // Then convert relative to target
  var targetP1 = targetCoordinateSpace.stageToLocal(stageP1);
  var targetP2 = targetCoordinateSpace.stageToLocal(stageP2);

  return new DvtRectangle(targetP1.x, targetP1.y, targetP2.x - targetP1.x, targetP2.y - targetP1.y);
}

/**
 * Returns the dimensions of the displayable by calling getBBox.
 * @return {DvtRectangle}
 */
DvtDisplayable.prototype.GetSvgDimensions = function() {
  try {
    var bbox = this.getElem().getBBox();
  }
  catch (e) {
    if(DvtAgent.isEnvironmentTest())
      out.println("Error in DvtDisplayable.prototype.GetSvgDimensions: " + e);
    
    return null;
  }
  //don't return bbox directly because we don't want calling code
  //to depend on platform-specific API, so instead turn it into 
  //a DvtRectangle
  return new DvtRectangle(bbox.x, bbox.y, bbox.width, bbox.height);
}

/**
 * Returns the bounds of the displayable relative to the target coordinate space.  If the target
 * coordinate space is not specified, returns the bounds relative to this displayable.
 * @param {DvtDisplayable} targetCoordinateSpace The displayable defining the target coordinate space.
 * @return {DvtRectangle} The bounds of the displayable relative to the target coordinate space.
 */
DvtDisplayable.prototype.getDimensions = function (targetCoordinateSpace) {
  var bounds = this.GetSvgDimensions();
  return this.ConvertCoordSpaceRect(bounds, targetCoordinateSpace);
}

//BUG FIX 13842194:
/**
 * Returns the bounds of the displayable relative to the target coordinate space, including stroke width.  If the target
 * coordinate space is not specified, returns the bounds relative to this displayable.
 * @param {DvtDisplayable} targetCoordinateSpace The displayable defining the target coordinate space.
 * @return {DvtRectangle} The bounds of the displayable relative to the target coordinate space.
 */
DvtDisplayable.prototype.getDimensionsWithStroke = function (targetCoordinateSpace) {
  var bounds = this.GetDimensionsWithStroke();
  return this.ConvertCoordSpaceRect(bounds, targetCoordinateSpace);
}

//BUG FIX 13842194:
DvtDisplayable.prototype.GetDimensionsWithStroke = function (targetCoordinateSpace) {
  //get dims for the shape elem, and change coord space if necessary
  var dims = this.GetElemDimensionsWithStroke();
  if (!targetCoordinateSpace || targetCoordinateSpace === this)
    return dims;
  else {
    // Calculate the bounds relative to the target space
    return this.ConvertCoordSpaceRect(dims, targetCoordinateSpace);
  }
}

//BUG FIX 13842194:
DvtDisplayable.prototype.GetElemDimensionsWithStroke = function () {
  // TODO HZHANG CLEANUP This doesn't look correct
  var bbox = null;
  try {
    //always use this._elem, which should point to a concrete shape element
    bbox = this._elem.getBBox();
  }
  catch (e) {
    return null;
  }
  //don't return bbox directly because we don't want calling code
  //to depend on platform-specific API, so instead turn it into 
  //a DvtRectangle
  return new DvtRectangle(bbox.x, bbox.y, bbox.width, bbox.height);
}

/**
 * Returns true if any of the specified attribute names are present on the element.
 * @param {object} elem  The SVG DOM element.
 * @param {array} attrNames The array of attribute names to look for.
 * @protected
 */
DvtDisplayable.HasAttributes = function (elem, attrNames) {
  if (attrNames) {
    var numAttrs = attrNames.length;
    for (var i = 0;i < numAttrs;i++) {
      if (DvtToolkitUtils.getAttrNullNS(elem, attrNames[i]))// TODO HZHANG This should be hasAttrNullNS
        return true;
    }
  }
  return false;
}

/**
 * Transfer relevant attributes from the original SVG DOM element to the new SVG DOM element.
 * @param {object} fromElem  The SVG DOM element.
 * @param {object} toElem  The new SVG DOM element.
 * @param {array} attrNames The array of attribute names to transfer.
 * @protected
 */
DvtDisplayable.TransferAttributes = function (fromElem, toElem, attrNames) {
  if (attrNames) {
    var attrName;
    var attrValue;
    var numAttrs = attrNames.length;
    for (var i = 0;i < numAttrs;i++) {
      attrName = attrNames[i];
      attrValue = DvtToolkitUtils.getAttrNullNS(fromElem, attrName);
      if (attrValue) {
        DvtToolkitUtils.removeAttrNullNS(fromElem, attrName);
        DvtToolkitUtils.setAttrNullNS(toElem, attrName, attrValue);
        if (DvtAgent.isPlatformIE()) {
          // bug 14605036, prev removeAttributeNS()
          DvtToolkitUtils.setAttrNullNS(fromElem, attrName, null);// fails for IE9 (9.0.8112.16421)
        }
      }
    }
  }
};

/**
 * Creates an outer group element to workaround issues with filters and clip paths.
 * @private
 */
DvtDisplayable.prototype._createOuterGroupElem = function () {
  if (this._outerElem)
    return;

  var outerId = this._id ? this._id + '_outer' : null;
  this._outerElem = DvtSvgShapeUtils.createElement('g', outerId);

  // Reparent the DOM elements
  var parent = this.getParent();
  if (parent) {
    var parentElem = parent.getElem();
    parentElem.replaceChild(this._outerElem, this.getElem());
  }
  DvtToolkitUtils.appendChildElem(this._outerElem, this.getElem());

  // Transfer attributes from the old outermost SVG element to the new outer element
  DvtDisplayable.TransferAttributes(this.getElem(), this._outerElem, DvtDisplayable._ATTRS_TRANSFERABLE_TO_OUTER)
}

/**
 * @returns {DvtCssStyle} the DvtCSSStyle of this object.
 */
DvtDisplayable.prototype.getCSSStyle = function () {
  return this._cssStyle;
}

/**
 * Sets the DvtCSSStyle of this object.
 * @param {DvtCssStyle} style The DvtCSSStyle of this object.
 */
DvtDisplayable.prototype.setCSSStyle = function (style) {
  this._cssStyle = style;// TODO HZHANG Should we have this on non-text-objects?
}

/**
 * Sets the cursor on this object.
 * @param {String} cursor type
 */
DvtDisplayable.prototype.setCursor = function (cursorType) {
  this._cursor = cursorType;
  if (cursorType)
    DvtToolkitUtils.setAttrNullNS(this.getElem(), "cursor", cursorType);
  else 
    DvtToolkitUtils.removeAttrNullNS(this.getElem(), "cursor");
}

/**
 * Gets the cursor used on this object.
 * @type {String}
 */
DvtDisplayable.prototype.getCursor = function () {
  return this._cursor;
}

/**
 * Sets whether mouse events are enabled on this object.
 * @param {boolean} whether mouse events are enabled
 */
DvtDisplayable.prototype.setMouseEnabled = function (bEnabled) {
  this._bMouseEnabled = bEnabled;
  var val = bEnabled ? "visiblePainted" : "none";
  DvtToolkitUtils.setAttrNullNS(this.getElem(), "pointer-events", val);
}

/**
 * Gets whether mouse events are enabled on this object.
 * @type {boolean}
 */
DvtDisplayable.prototype.isMouseEnabled = function () {
  return this._bMouseEnabled;
}

/**
 *  Returns the alpha channel value.
 *  @type number
 *  @returns A value between 0 (invisible) and 1 (opaque).
 */
DvtDisplayable.prototype.getAlpha = function () {
  return this._alpha;
}

/**
 *  Sets the alpha.
 *  @param {number} alpha  A value between 0 (invisible) and 1 (opaque).
 *  @returns nothing
 */
DvtDisplayable.prototype.setAlpha = function (alpha) {
  //when animating alpha, small values are turned into strings like
  //"3.145e-8", which SVG incorrectly clamps to 1, so just cut off
  //small values here and make them 0
  if (alpha < 0.00001)
    alpha = 0;

  if (alpha !== this._alpha) {
    this._alpha = alpha;
    DvtToolkitUtils.setAttrNullNS(this.getElem(), 'opacity', this._alpha);
  }
}

/**
 * Applies deferred aria role and properties to the DOM.
 */
DvtDisplayable.prototype.applyAriaProperties = function() {
  if(DvtAgent.deferAriaCreation()) {
    // Apply Aria Role
    if(this._ariaRole)
      this.setAriaRole(this._ariaRole);      

    // Apply Aria Properties
    for(var property in this._ariaProperties) {
      this.setAriaProperty(property, this._ariaProperties[property]);
    }
  }
}

/**
 * Sets the WAI-ARIA role.
 * @param {String} role The role attribute value.
 */
DvtDisplayable.prototype.setAriaRole = function (role) {
  if(!DvtAgent.deferAriaCreation()) {
    if (role)
      DvtToolkitUtils.setAttrNullNS(this._elem, 'role', role);
    else 
      DvtToolkitUtils.removeAttrNullNS(this._elem, 'role');
  }
  
  this._ariaRole = role;
}

/**
 * Gets the WAI-ARIA role.
 * @return {String} The role attribute value.
 */
DvtDisplayable.prototype.getAriaRole = function () {
  return this._ariaRole;
}

/**
 * Sets the WAI-ARIA property/state.
 * @param {String} property The property/state attribute name. The prefix "aria-" should be skipped.
 * @param {String} value The property/state attribute value.
 */
DvtDisplayable.prototype.setAriaProperty = function (property, value) {
  if (!property)
    return;

  if (!DvtAgent.deferAriaCreation()) {
    if (value) {
      if (property == 'label' && value) {
        // replace line break characters (\n and <br/>) with semicolons
        value = value.replace(/\n/g, "; ");
        value = value.replace(/\<br\/\>/gi, "; ");
      }
  
      DvtToolkitUtils.setAttrNullNS(this._elem, 'aria-' + property, value);
    }
    else 
      DvtToolkitUtils.removeAttrNullNS(this._elem, 'aria-' + property);
  }
  
  this._ariaProperties[property] = value;

  if (property != 'hidden')
    this.setAriaProperty('hidden', null);
}

/**
 * Gets the WAI-ARIA property/state.
 * @param {String} property The property/state attribute name. The prefix "aria-" should be skipped.
 * @return {String} The property/state attribute value.
 */
DvtDisplayable.prototype.getAriaProperty = function (property) {
  if (property) {
    return this._ariaProperties[property];
  } else {
    return null;
  }
}


/**
 * Convert a point from stage coords to local coords.
 * @param {DvtPoint}  point  point in stage coords
 * @type DvtPoint
 */
DvtDisplayable.prototype.stageToLocal = function (point) {
  var pathToStage = this.getPathToStage();
  var mat;
  var retPoint = point;
  for (var i = pathToStage.length - 1;i >= 0;i--) {
    mat = pathToStage[i].getMatrix().clone();
    mat.invert();
    retPoint = mat.transformPoint(retPoint);
  }
  return retPoint;
}

/**
 * Convert a point from local coords to stage coords.
 * @param {DvtPoint}  point  point in local coords
 * @type DvtPoint
 */
DvtDisplayable.prototype.localToStage = function (point) {
  var pathToStage = this.getPathToStage();
  var mat;
  var retPoint = point;
  for (var i = 0;i < pathToStage.length;i++) {
    mat = pathToStage[i].getMatrix();
    retPoint = mat.transformPoint(retPoint);
  }
  return retPoint;
}

/**
 * Get an array of objects in the tree from this displayable to the stage.
 * The returned array is ordered with this displayable first and the stage
 * last, like [this, this.getParent(), ... , stage].
 * @type array
 */
DvtDisplayable.prototype.getPathToStage = function()
{
  var displayable = this;
  var array = [];
   while (displayable)
   {
    array.push(displayable);
    displayable = displayable.getParent();
  }
  return array;
};

/**
 *    Destroy the displayable.  It should no longer be used or displayed
 */
DvtDisplayable.prototype.destroy = function()
{
  //FIX BUG 12875374: Remove all draw effects at once, because removing
  //them one by one results in the remaining ones being reapplied at each
  //iteration.  Since this object is being destroyed, it is most likely 
  //disconnected from the display list.  When the draw effects are applied,
  //they may call getBBox() on the element, which can result in errors in
  //Firefox when the object is disconnected, and the view not being rendered.
  this.removeAllDrawEffects();
  if (this.ClipPathId)
    this.setClipPath(null);
};


/**
 * Creates a copy of this displayable wrapped by a new container
 * @return {DvtContainer} a copy of this displayable
 */
DvtDisplayable.prototype.createCopy = function() {
  var container = new DvtContainer(this.getCtx(), "clonedContainer");
  var clonedSvg = this.getElem().cloneNode(true);
  DvtToolkitUtils.appendChildElem(container.getElem(), clonedSvg);
  this._disableEvents(clonedSvg);
  return container;
}

DvtDisplayable.prototype._disableEvents = function (svgElem) {
  var child = svgElem.firstChild;
  //loop over all children
  while (child != null) {
    if (child.setAttributeNS) {
      DvtToolkitUtils.setAttrNullNS(child, "pointer-events", "none");
      DvtToolkitUtils.setAttrNullNS(child, "id", null);
    }
    this._disableEvents(child);
    child = child.nextSibling;
  }
}

/**
 * Sets/adds desc element to the SVG node.
 * @param {String} descTxt The description value.
 */
DvtDisplayable.prototype.setDesc = function (descTxt) {
  if (!descTxt || this._desc == descTxt)
    return;

  if (!this._desc)// new element
    this._createDesc(descTxt);
  else if (this._desc != descTxt) {
    // replace existing
    var isFound = false;
    // loop over all children
    var child = this.getElem().firstChild;
    while (child != null) {
      if (child.tagName == 'desc') {
        var textNode = child.firstChild;
        if (textNode)
          textNode.nodeValue = descTxt;

        this._desc = descTxt;
        isFound = true;
        break;
      }
      child = child.nextSibling;
    }
    if (!isFound)
      this._createDesc(descTxt);
  }
}

/**
 * Adds desc element to the SVG node.
 * @param {String} descTxt The description value.
 */
DvtDisplayable.prototype._createDesc = function (descTxt) {
  if (!descTxt)
    return;

  var descElem = DvtSvgShapeUtils.createElement("desc", null);
  var textNode = document.createTextNode(descTxt);
  DvtToolkitUtils.appendChildElem(descElem, textNode);
  DvtToolkitUtils.appendChildElem(this.getElem(), descElem);
  this._desc = descTxt;
}

/**
 * Dispatches the native event to the internal dom element
 * Note: Use with caution
 * @param {Object} event
 * @override
 */
DvtDisplayable.prototype.dispatchNativeEvent = function (event) {
}


/**
 * Helper function to access the value of a property that was set using SetProperty.
 * @param {string} name the name of the attribute.
 * @return {object}
 * @protected
 */
DvtDisplayable.prototype.GetProperty = function(name) {
  return this._properties[name];
}

/**
 * Helper function to store the value of a property. Protects against attribute name collision with subclasses by 
 * storing the value on a child object.
 * @param {string} name The name of the attribute.
 * @param {string} value The value of the attribute.
 * @return {DvtDisplayable} Returns this instance to support chaining.
 * @protected
 */
DvtDisplayable.prototype.SetProperty = function(name, value) {
  if(value !== this._properties[name]) {
    this._properties[name] = value;
  }
  return this;
}

/**
 * Helper function to set the specified SVG attribute on the DOM element.  Optimizes getters by storing a copy of the 
 * value using SetAttr so that DOM access isn't required. If the property value has been updated in the DOM, then 
 * SvgPropertyChanged will be called to allow for additional processing if needed.
 * @param {string} name The name of the attribute.
 * @param {string} value The value of the attribute.
 * @param {string} [defaultValue] The default value of the attribute, which can be provided to optimize performance.
 * @return {DvtDisplayable} Returns this instance to support chaining.
 * @protected
 */
DvtDisplayable.prototype.SetSvgProperty = function(name, value, defaultValue) {
  if(value !== this._properties[name]) {
    this._properties[name] = value;
    DvtToolkitUtils.setAttrNullNS(this._elem, name, value, defaultValue);
    this.SvgPropertyChanged(name);
  }
  return this;
}

/**
 * Callback that is notified whenever an SVG DOM property is changed by SetSvgProperty. Subclasses can override to 
 * perform additional processing, such as updating the selection feedback, when properties are changed.
 * @param {string} name The name of the attribute.
 * @protected
 */
DvtDisplayable.prototype.SvgPropertyChanged = function(name) {
  // subclasses can override
}
// File containing all draw effect (filter) related functions defined on DvtDisplayable.

DvtDisplayable.prototype.getNumDrawEffects = function()
{
  if (!this._drawEffects)
  {
    return 0;
  }

  return this._drawEffects.length;
}

DvtDisplayable.prototype.addDrawEffect = function (effect) 
{
  if (!this._drawEffects) 
  {
    this._drawEffects = [];
  }

  //lock the effect
  effect.__lock();

  this._drawEffects.push(effect);

  this._applyDrawEffects(this._drawEffects);
};

DvtDisplayable.prototype.addDrawEffectAt = function (effect, index) 
{
  if (!this._drawEffects) 
  {
    this._drawEffects = [];
  }

  //lock the effect
  effect.__lock();

  if (index >= this._drawEffects.length)
  {
    this._drawEffects.push(effect);
  }
  else
  {
    this._drawEffects.splice(index, 0, effect);
  }

  this._applyDrawEffects(this._drawEffects);
};

DvtDisplayable.prototype.removeDrawEffect = function(effect)
{
  var index = this.getDrawEffectIndex(effect);
  if (index >  - 1) 
  {
    this._drawEffects.splice(index, 1);
    this._applyDrawEffects(this._drawEffects);
  }
};

DvtDisplayable.prototype.removeDrawEffectAt = function(index)
{
  if (this._drawEffects)
  {
    var numEffects = this._drawEffects.length;
    if (index >= 0 && index < numEffects) 
    {
      this._drawEffects.splice(index, 1);
      this._applyDrawEffects(this._drawEffects);
    }
  }
};

DvtDisplayable.prototype.removeAllDrawEffects = function () 
{
  if (this._drawEffects) 
  {
    this._drawEffects = null;
    this._applyDrawEffects(this._drawEffects);
  }
}

DvtDisplayable.prototype.getDrawEffectIndex = function(effect)
{
  if (this._drawEffects)
  {
    var numEffects = this._drawEffects.length;
    for (var i = 0; i < numEffects; i++)
    {
      if (effect === this._drawEffects[i])
      {
        return i;
      }
    }
  }
  return  - 1;
}

DvtDisplayable.prototype._applyDrawEffects = function () {
  var effects = this._drawEffects;
  
  // Create an outer group if there is a matrix defined, since SVG applies transforms before filters.
  if (!this._outerElem && this._matrix)
    this._createOuterGroupElem();

  //remove current filter
  if (this._filter) {
    DvtToolkitUtils.removeAttrNullNS(this.getOuterElem(), 'filter');
    this.getCtx().removeDefs(this._filter);
    this._filter = null;
  }

  //add new filter if necessary
  if (effects && effects.length > 0) {
    //Bug 12394679: Repaint bug in Firefox requires us to force a repaint after removing filter
    //At worst we will create n empty filters where n=# markers
    this._filter = DvtSvgFilterUtils.createFilter(effects, this);
    if (this._filter) {
      this.getCtx().appendDefs(this._filter);
      var filterId = DvtToolkitUtils.getAttrNullNS(this._filter, 'id');
      DvtToolkitUtils.setAttrNullNS(this.getOuterElem(), 'filter', 'url(#' + filterId + ')');
    }
  }
}
// File containing all event listener related functions defined on DvtDisplayable.

/**
 * Adds an event listener.
 * @param {string} type the event type
 * @param {function} listener the function to call
 * @param {string} useCapture whether the listener operates in the capture phase
 * @param {object} obj instance of the object the listener is defined on
 */
DvtDisplayable.prototype.addEvtListener = function (type, listener, useCapture, obj) {
  // Store a reference to the listener
  var listenersArray = this._getListeners(type, useCapture, true);
  listenersArray.push(listener);
  listenersArray.push(obj);

  // Call the impl so that it can add the actual listener
  this._addListener(type, useCapture);
}

/**
 * Removes an event listener.
 * @param {string} type the event type
 * @param {function} listener the function to call
 * @param {string} useCapture whether the listener operates in the capture phase
 * @param {object} obj instance of the object the listener is defined on
 */
DvtDisplayable.prototype.removeEvtListener = function (type, listener, useCapture, obj) {
  // Remove the listener
  var listenersArray = this._getListeners(type, useCapture, false);
  if (listenersArray) {
    for (var i = 0;i < listenersArray.length;i += 2) {
      if (listenersArray[i] === listener && listenersArray[i + 1] === obj) {
        listenersArray.splice(i, 2);
        break;
      }
    }
  }

  // Call the impl so that it can remove the actual listener.
  // Note that the array itself is intentionally not removed.
  if (listenersArray && listenersArray.length <= 0)
    this._removeListener(type, useCapture);
}

/**
 * Dispatch event
 * @param {String} eventType
 * @param {String} params An optional parameter to specify other parameters for the event
 */
DvtDisplayable.prototype.dispatchDisplayableEvent = function (eventType, params) {
  var createEventType = DvtDisplayable._CREATE_EVENT_TYPE_MAP[eventType];
  var context;
  if (DvtMouseEvent.CLICK == createEventType || DvtMouseEvent.MOUSEOVER == createEventType || DvtMouseEvent.MOUSEOUT == createEventType || DvtMouseEvent.MOUSEMOVE == createEventType) {
    if (document.createEvent) {
      context = this.getCtx();
      var dim = this.getDimensions();
      var elementPosition = this.localToStage(new DvtPoint(dim.x, dim.y));
      var absoluteStagePos = context.getStageAbsolutePosition();
      var absoluteElementPosition = new DvtPoint(absoluteStagePos.x + elementPosition.x, absoluteStagePos.y + elementPosition.y);
      var event = document.createEvent("MouseEvents");
      event.initMouseEvent(createEventType, true, true, window, 1, absoluteElementPosition.x, absoluteElementPosition.y, absoluteElementPosition.x, absoluteElementPosition.y, false, false, false, false, 0, null);
      this.getElem().dispatchEvent(event);
    }
  }
  else if (DvtKeyboardEvent.KEYDOWN == createEventType || DvtKeyboardEvent.KEYUP == createEventType) {
    if (document.createEvent) {
      var keyboardEvent = document.createEvent("KeyboardEvent");
      var keycode = parseInt(params);

      if (this._ctrlKeyPressed === undefined)
        this._ctrlKeyPressed = false;

      if (this._shiftKeyPressed === undefined)
        this._shiftKeyPressed = false;

      if (keycode == DvtKeyboardEvent.CONTROL) {
        if (this._ctrlKeyPressed && createEventType == DvtKeyboardEvent.KEYUP)
          this._ctrlKeyPressed = false;
        else if (!this._ctrlKeyPressed && createEventType == DvtKeyboardEvent.KEYDOWN)
          this._ctrlKeyPressed = true;
      }
      else if (keycode == DvtKeyboardEvent.SHIFT) {
        if (this._shiftKeyPressed && createEventType == DvtKeyboardEvent.KEYUP)
          this._shiftKeyPressed = false;
        else if (!this._shiftKeyPressed && createEventType == DvtKeyboardEvent.KEYDOWN)
          this._shiftKeyPressed = true;
      }

      if (typeof (keyboardEvent.initKeyboardEvent) != 'undefined') {
        keyboardEvent.initKeyboardEvent(createEventType, true, true, window, this._ctrlKeyPressed, false, this._shiftKeyPressed, false, keycode, keycode);
      }
      else {
        keyboardEvent.initKeyEvent(createEventType, true, true, window, this._ctrlKeyPressed, false, false, this._shiftKeyPressed, keycode, keycode);
      }

      /*      
        ideally, we would just create the native keyboard event and disptach it to the wrapping div, but we
        can't for two reasons
        1. when the keyboardEvent is initialized above, the initKeyboardEvent method used by Webkit doesn't initialize
           the event with the right keycode; it is always 0.  This is a known bug tracked in Chromium and at Webkit
           see http://code.google.com/p/chromium/issues/detail?id=27048 (Chromium) and
           https://bugs.webkit.org/show_bug.cgi?id=16735 (Webkit)
        2. since the native event doesn't work, I tried dispatching a DvtSvgKeyboardEvent to the wrapping div.
           however, this generates a DOM EventException of type UNSPECIFIED_EVENT_TYPE_ERR, even though the
           type of the DvtSvgKeyboardEvent was specified.
        
        So, instead, we will directly call the bubble listener that we attach to the wrapping div 
        */

      var svgKeyboardEvent = DvtSvgEventFactory.newEvent(keyboardEvent);
      svgKeyboardEvent.keyCode = keycode;
      svgKeyboardEvent.ctrlKey = this._ctrlKeyPressed;
      svgKeyboardEvent.shiftKey = this._shiftKeyPressed;

      context = this.getCtx();
      var stage = context.getStage();
      var wrappingDiv = stage.getSVGRoot().parentNode;
      DvtHtmlKeyboardListenerUtils._bubbleListener.call(wrappingDiv, svgKeyboardEvent);
    }
  }
}

/**
 * TODO JSDOC
 * @protected
 */
DvtDisplayable.prototype.AddElemListener = function (type, listener, useCapture) {
  DvtToolkitUtils.addDomEventListener(this.getElem(), type, listener, useCapture);
  if (type == DvtTouchEvent.TOUCHEND) {
    DvtToolkitUtils.addDomEventListener(this.getElem(), DvtTouchEvent.TOUCHCANCEL, listener, useCapture);
  }
}

/**
 * Notifies all applicable event listeners of the given event.
 * @param {DvtMouseEvent} event
 * @param {boolean} useCapture whether the listener operates in capture phase
 * @protected
 */
DvtDisplayable.prototype.FireListener = function (event, useCapture) {
  // workaround for bug 15880934
  var type = event.getType ? event.getType() : event.type;
  var listenersArray = this._getListeners(type, useCapture, false);
  if (listenersArray) {
    for (var i = 0;i < listenersArray.length;i += 2) {
      var obj = listenersArray[i + 1];
      if (listenersArray[i]) {
        listenersArray[i].call(obj, event);
      }
    }
  }
}

/**
 * Returns the listeners of the given event type and capture mode.
 * @param {string} type the event type
 * @param {string} useCapture whether the listener operates in the capture phase
 * @param {boolean} createNew whether the array should be created if it doesn't exist
 * @return {array} the mutable Array of listeners
 * @private
 */
DvtDisplayable.prototype._getListeners = function (type, useCapture, createNew) {
  // First find the object where the listener arrays are stored
  if (!this._listenerObj) {
    if (createNew) {
      this._listenerObj = {
      };
    }
    else {
      return null;
    }
  }

  // Then find the array for this event type, creating if necessary 
  var eventKey = type + "_" + (useCapture ? true : false);// for example: "click_true"  
  var listenersArray = this._listenerObj[eventKey];
  if (!listenersArray && createNew) {
    listenersArray = [];
    this._listenerObj[eventKey] = listenersArray;
  }

  return listenersArray;
}

/**
 * Adds an event listener.
 * @param {String} type the event type
 * @param {String} useCapture whether the listener operates in the capture phase
 * @private
 */
DvtDisplayable.prototype._addListener = function (type, useCapture) {
  var listener = this._getListener(useCapture);
  // on keyboard events, add the listener to the component's wrapping div, since SVG 
  // DOM elements don't support keystrokes. 
  if (type == DvtKeyboardEvent.KEYUP || type == DvtKeyboardEvent.KEYDOWN) {
    var context = this.getCtx();
    var stage = context.getStage();
    var wrappingDiv = stage.getSVGRoot().parentNode;
    if(!wrappingDiv)
      return;
    
    // allow support for multiple displayables to receive keyboard events
    // TODO: replace this with a singular compound event manager that
    //       will dispatch keyboard events to individual event managers
    if (!wrappingDiv._obj) {
      wrappingDiv._obj = []
    }
    if (DvtArrayUtils.getIndex(wrappingDiv._obj, this) ==  - 1) {
      wrappingDiv._obj.push(this);
    }
    listener = DvtHtmlKeyboardListenerUtils.getListener(useCapture);
    DvtToolkitUtils.addDomEventListener(wrappingDiv, type, listener, useCapture);
  }
  else {
    this.AddElemListener(type, listener, useCapture);
  }
}

/**
 * Removes an event listener.
 * @param {string} type the event type
 * @param {function} listener the function to call
 * @param {String} useCapture whether the listener operates in the capture phase
 * @private
 */
DvtDisplayable.prototype._removeListener = function (type, useCapture) {
  var listener = this._getListener(useCapture);
  DvtToolkitUtils.removeDomEventListener(this.getElem(), type, listener, useCapture);
}

// TODO JSdoc
DvtDisplayable.prototype._getListener = function (useCapture) {
  var thisRef = this;
  if (useCapture) {
    if (!this._captureClosure) {
      this._captureClosure = function (event) {
        thisRef._captureListener(event);
      };
    }
    return this._captureClosure;
  }
  else {
    if (!this._bubbleClosure) {
      this._bubbleClosure = function (event) {
        thisRef._bubbleListener(event);
      };
    }
    return this._bubbleClosure;
  }
}

/**
 * The event listener that is called by the implementation object's bubble phase listeners.
 * This function will wrap the event and delegate to the real event listeners.
 * @param {object} event the DOM event object
 * @this {object} the platform object actively processing the event object with an event listener
 * @private
 */
DvtDisplayable.prototype._bubbleListener = function (event) {
  if (DvtAgent.isPlatformIE()) {
    // Moving an object in the dom for IE causes mouse over events to fire if the moved item is under the mouse
    // Ensure mouse over is not repeatedly called in such a case
    if (event.type == DvtMouseEvent.MOUSEOVER) {
      if (this._bubbleHoverItem) {
        if (this._bubbleHoverItem == event.target) {
          // Prevent infinite loop
          return;
        }
        else {
          //MOUSEOVER event on a DOM element stores the element in _bubbleHoverItem and MOUSEOUT event clears _bubbleHoverItem.
          //If a MOUSEOVER event is not followed by MOUSEOUT event, _bubbleHoverItem won't be cleared.
          //During the subsequent MOUSEOVER event if the event target is different than _bubbleHoverItem, 
          //that indicates the browser have missed to fire MOUSEOUT event for previous DOM element stored in _bubbleHoverItem.
          //So building a new MOUSEOUT event for _bubbleHoverItem.
          var dvtEvent = DvtSvgEventFactory.newEvent(event, this.getCtx());
          //Bug 17369581: Set the event as MOUSEOUT event, target as _bubbleHoverItem, relatedTarget as event.target
          //This is equivalent to firing new MOUSEOUT event for _bubbleHoverItem
          dvtEvent.modifyEventForIE(DvtMouseEvent.MOUSEOUT, this._bubbleHoverItem);
          this.FireListener(dvtEvent, false);
        }
      }
      this._bubbleHoverItem = event.target;
    }
    else if (event.type == DvtMouseEvent.MOUSEOUT) {
      this._bubbleHoverItem = null;
    }
  }

  var dvtEvent = DvtSvgEventFactory.newEvent(event, this.getCtx());
  this.FireListener(dvtEvent, false);
}

/**
 * The event listener that is called by the implementation object's capture phase listeners.
 * This function will wrap the event and delegate to the real event listeners.
 * @param {object} event the DOM event object
 * @this {object} the platform object actively processing the event object with an event listener
 * @private
 */
DvtDisplayable.prototype._captureListener = function (event) {
  if (DvtAgent.isPlatformIE()) {
    // Moving an object in the dom for IE causes mouse over events to fire if the moved item is under the mouse
    // Ensure mouse over is not repeatedly called in such a case
    if (event.type == DvtMouseEvent.MOUSEOVER) {
      if (this._captureHoverItem) {
        if (this._captureHoverItem == event.target) {
          // Prevent infinite loop
          return;
        }
        else {
          //MOUSEOVER event on a DOM element stores the element in _captureHoverItem and MOUSEOUT event clears _captureHoverItem.
          //If a MOUSEOVER event is not followed by MOUSEOUT event, _captureHoverItem won't be cleared.
          //During the subsequent MOUSEOVER event if the event target is different than _captureHoverItem, 
          //that indicates the browser have missed to fire MOUSEOUT event for previous DOM element stored in _captureHoverItem.
          //So building a new MOUSEOUT event for _captureHoverItem.
          var dvtEvent = DvtSvgEventFactory.newEvent(event, this.getCtx());
          //Bug 17369581: Set the event as MOUSEOUT event, target as _captureHoverItem, relatedTarget as event.target
          //This is equivalent to firing new MOUSEOUT event for _captureHoverItem
          dvtEvent.modifyEventForIE(DvtMouseEvent.MOUSEOUT, this._captureHoverItem);
          this.FireListener(dvtEvent, true);
        }
      }
      this._captureHoverItem = event.target;
    }
    else if (event.type == DvtMouseEvent.MOUSEOUT) {
      this._captureHoverItem = null;
    }
  }
  var dvtEvent = DvtSvgEventFactory.newEvent(event, this.getCtx());
  this.FireListener(dvtEvent, true);
}
// File containing all transformation related functions defined on DvtDisplayable.

/**
 * Sets the horizontal and vertical translation to apply to this container.
 * @param {Number} tx   The horizontal translation to apply, in pixels.
 * @param {Number} ty   The vertical translation to apply, in pixels.
 */
DvtDisplayable.prototype.setTranslate = function (tx, ty) {
  //the matrix is the ultimate source of truth, because
  //it contains all the transform information
  var mat = this.getMatrix().clone();
  var decomp = mat._decompose();
  if (tx != null)
    decomp[DvtMatrix._DECOMP_TX] = tx;
  if (ty != null)
    decomp[DvtMatrix._DECOMP_TY] = ty;
  mat._recompose(decomp);
  this.setMatrix(mat);
}

/**  Returns the horizontal translation applied to this container.
 *  @type Number
 *  @returns horizontal translation, in pixels
 */
DvtDisplayable.prototype.getTranslateX = function () {
  //if (this._translateX)
  if (this._matrix) {
    //return this._translateX ;
    //get the value from the matrix because other 
    //transformations may have changed it
    return this._matrix._decompose()[DvtMatrix._DECOMP_TX];
  }

  return 0;
}

/**  Set the horizontal translation to apply to this container.
 *  @param {Number} tx   The horizontal translation to apply, in pixels.
 */
DvtDisplayable.prototype.setTranslateX = function (tx) {
  //the matrix is the ultimate source of truth, because
  //it contains all the transform information
  var mat = this.getMatrix().clone();
  var decomp = mat._decompose();
  decomp[DvtMatrix._DECOMP_TX] = tx;
  mat._recompose(decomp);
  this.setMatrix(mat);
}

/**  Return the vertical translation applied to this container.
 *  @type Number
 *  @returns vertical translation, in pixels
 */
DvtDisplayable.prototype.getTranslateY = function () {
  //if (this._translateY)
  if (this._matrix) {
    //return this._translateY ;
    //get the value from the matrix, because other 
    //transformations may have changed it
    return this._matrix._decompose()[DvtMatrix._DECOMP_TY];
  }

  return 0;
}

/**  Set the vertical translation to apply to this container.
 *  @param {Number} ty   The vertical translation to apply, in pixels.
 */
DvtDisplayable.prototype.setTranslateY = function (ty) {
  //the matrix is the ultimate source of truth, because
  //it contains all the transform information
  var mat = this.getMatrix().clone();
  var decomp = mat._decompose();
  decomp[DvtMatrix._DECOMP_TY] = ty;
  mat._recompose(decomp);
  this.setMatrix(mat);
}

/**
 * Sets the horizontal and vertical scale to apply to this container.
 * @param {Number} sx   The horizontal scale to apply.
 * @param {Number} sy   The vertical scale to apply.
 */
DvtDisplayable.prototype.setScale = function (sx, sy) {
  //the matrix is the ultimate source of truth, because
  //it contains all the transform information
  var mat = this.getMatrix().clone();
  var decomp = mat._decompose();
  if (sx)
    decomp[DvtMatrix._DECOMP_SX] = sx;
  if (sy)
    decomp[DvtMatrix._DECOMP_SY] = sy;
  mat._recompose(decomp);
  this.setMatrix(mat);
}

/**  Return the horizontal scale applied to this container.
 *  @type Number
 *  @returns horizontal scale
 */
DvtDisplayable.prototype.getScaleX = function () {
  //if (this._scaleX != null)
  if (this._matrix) {
    //return this._scaleX ;
    //get the value from the matrix, because other 
    //transformations may have changed it
    return this._matrix._decompose()[DvtMatrix._DECOMP_SX];
  }

  return 1;
}

/**  Set the horizontal scale to apply to this container.
 *  @param {Number} sx   The horizontal scale to apply.
 */
DvtDisplayable.prototype.setScaleX = function (sx) {
  //the matrix is the ultimate source of truth, because
  //it contains all the transform information
  var mat = this.getMatrix().clone();
  var decomp = mat._decompose();
  decomp[DvtMatrix._DECOMP_SX] = sx;
  mat._recompose(decomp);
  this.setMatrix(mat);
}

/**  Return the vertical scale applied to this container.
 *  @type Number
 *  @returns vertical scale
 */
DvtDisplayable.prototype.getScaleY = function () {
  //if (this._scaleY != null)
  if (this._matrix) {
    //return this._scaleY ;
    //get the value from the matrix, because other 
    //transformations may have changed it
    return this._matrix._decompose()[DvtMatrix._DECOMP_SY];
  }

  return 1;
}

/**  Set the vertical scale to apply to this container.
 *  @param {Number} sy   The horizontal scale to apply.
 */
DvtDisplayable.prototype.setScaleY = function (sy) {
  //the matrix is the ultimate source of truth, because
  //it contains all the transform information
  var mat = this.getMatrix().clone();
  var decomp = mat._decompose();
  decomp[DvtMatrix._DECOMP_SY] = sy;
  mat._recompose(decomp);
  this.setMatrix(mat);
}

/**  Return the rotation applied to this container.
 *  @type Number
 *  @returns rotation, in radians
 */
DvtDisplayable.prototype.getRotation = function () {
  //if (this._rotation != null)
  if (this._matrix) {
    //return this._rotation ;
    //get the value from the matrix, because other 
    //transformations may have changed it
    return this._matrix._decompose()[DvtMatrix._DECOMP_R];
  }

  return 0;
}

/**  Set the rotation to apply to this container.
 *  @param {Number} angleRads   The rotation to apply, in radians.
 */
DvtDisplayable.prototype.setRotation = function (angleRads) {
  //the matrix is the ultimate source of truth, because
  //it contains all the transform information
  var mat = this.getMatrix().clone();
  var decomp = mat._decompose();
  decomp[DvtMatrix._DECOMP_R] = angleRads;
  mat._recompose(decomp);
  this.setMatrix(mat);
}

/**  Return the transformation matrix applied to this container.
 *  @type DvtMatrix
 *  @returns transformation matrix
 */
DvtDisplayable.prototype.getMatrix = function () {
  if (this._matrix) {
    return this._matrix;
  }

  return new DvtMatrix();
}

/**
 * Set the transformation matrix to apply to this container.
 * When set, the matrix becomes permanently locked so that it becomes immutable.
 * A clone must be created if any updates to the matrix need to be made.
 * The same matrix can be set on more than one displayable irregardless of locking.
 * @param {DvtMatrix} mat   The transformation matrix to apply.
 */
DvtDisplayable.prototype.setMatrix = function (mat) {
  // treat setting identity matrix same as setting null matrix
  if (mat && mat.isIdentity())
    mat = null;

  if (this._matrix != mat) {
    this._matrix = mat;

    // Lock the new matrix if it isn't already locked, before setting it on this displayable.  
    // The same matrix can be set on more than one displayable irregardless of locking.
    if (this._matrix && !this._matrix.isLocked())
      this._matrix.__lock();

    // Create an outer elem if needed
    if (!this._outerElem && DvtDisplayable.HasAttributes(this.getElem(), DvtDisplayable._ATTRS_TRANSFERABLE_TO_OUTER))
      this._createOuterGroupElem();

    this._matrix = mat;
    //apply the new matrix if it's non-null
    if (mat) {
      var sMat = 'matrix(' + mat.getA() + ',' + mat.getC() + ',' + mat.getB() + ',' + mat.getD() + ',' + mat.getTx() + ',' + mat.getTy() + ')';

      //set the transform attribute on the outer SVG element of this shape
      DvtToolkitUtils.setAttrNullNS(this.getElem(), 'transform', sMat, "matrix(1,0,0,1,0,0)");
      
      //set the vector-effect attribute to prevent the stroke-width
      //from scaling with the transform
      //NOTE: this is commented out for now because it causes strange rendering
      //artifacts when scaling to a small value
      //DvtToolkitUtils.setAttrNullNS(this.getElem(), 'vector-effect', 'non-scaling-stroke') ;
    }
    //if clearing the existing matrix by setting a null or undefined mat,
    //then remove the existing attribute from the DOM
    else {
      var transformAttr = DvtToolkitUtils.getAttrNullNS(this.getElem(), 'transform');
      if (transformAttr) {
        DvtToolkitUtils.removeAttrNullNS(this.getElem(), 'transform');
        if (DvtAgent.isPlatformIE()) {
          // bug 14617946, prev removeAttributeNS()
          DvtToolkitUtils.setAttrNullNS(this.getElem(), 'transform', null);// fails for IE9 (9.0.8112.16421)
        }

      }
      //NOTE: this is commented out for now because it causes strange rendering
      //artifacts when scaling to a small value
      var vectorEffectAttr;// = DvtToolkitUtils.getAttrNullNS(this.getElem(), 'vector-effect');
      if (vectorEffectAttr) {
        DvtToolkitUtils.removeAttrNullNS(this.getElem(), 'vector-effect');
      }
    }
  }
}
// Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.
/**
 * Container for displayable objects.
 * @extends DvtDisplayable
 * @param {DvtContext} context
 * @param {string} [id] The optional id for the corresponding DOM element.
 * @class
 * @constructor
 */
var DvtContainer = function (context, id) {
  this.Init(context, 'g', id);
}

DvtObj.createSubclass(DvtContainer, DvtDisplayable, "DvtContainer");

/**
 * @override
 */
DvtContainer.prototype.Init = function (context, type, id) {
  // For the SVG implementation, we need to know whether this is a standard
  // non-shape container, or a shape "container".  Since elementary objects
  // may not be nested, e.g. a rect containing another rect, an artificial 
  // group must be constructed to group the parent and the children.  That
  // is they actually become grouped siblings.
  this._bShapeContainer = (this instanceof DvtShape);// if shape "container"
  DvtContainer.superclass.Init.call(this, context, type != null ? type : 'g', id);
  this._childGroupElem = null;// child surround group
}

/**
 * @protected
 * Array of SVG attributes that should be transferred from the shape
 * tag to the group when this shape becomes a group (when children
 * are added to it).
 */
DvtContainer.AttributesTransferableToGroup = ['transform', 'opacity', 'style', 'visibility', 'pointer-events', 'clip-path'];

/**
 *  Adds the specified object as a child of this container. The object is
 *  added to the end of the child list.  If the object is already a child,
 *  it will be moved to the end of the child list.
 *   @param {DvtDisplayable} obj The object to be added.
 */
DvtContainer.prototype.addChild = function (obj) {

  if (obj) {
    // Remove the object from its current parent
    var oldParent = obj.getParent();
    if (oldParent)
      oldParent.removeChild(obj);

    //initialize _arList after removing child from parent in case
    //this container was the parent, which could result in removeChild()
    //setting _arList to null if the last child was removed
    if (!this._arList) {
      this._arList = [];
    }

    // Add the object to this container
    obj.setParent(this);

    if (this._bShapeContainer) {
      //  This is a shape "container".
      //  If no previous children, will create a group DOM element for the this
      //  (parent) object and add the new child to the child group DOM element.
      //  else will add the object directly to the shape group container element.
      this.CreateChildGroupElem(false);
    }

    //  Bug 15865017 - GET RID OF DVTGOLINK AND IMPLS
    //  if there is an anchor elem <a> for this container
    //  append child to the <a> element 
    //  otherwise append child directly to this container group element
    var containerElem = this.getContainerElem();
    DvtToolkitUtils.appendChildElem(containerElem, obj.getOuterElem());

    this._arList.push(obj);
  }
}

/**
 *  Adds the specified object as a child of this container at the specified index. Returns
 *  immediately if the index position doesn't already exist in the child list (unless the
 *  index equals the number of children).  If a currently occupied index is specified, the
 *  current child at that position and all subsequent children are moved one position
 *  higher in the list.  If the object is a child of another container, it is removed and
 *  reparented in the new container. Note that the action of this method is to remove the
 *  object from the current container (which may also be the container that it will be
 *  added to), so for an object "move" in the same container, all objects with a higher
 *  index will now move one position lower.  The object is now inserted at the supplied
 *  index.
 *  @param {DvtObj} obj  The object to be added (must be a descendent of {@link DvtObj}).
 *  @param {number} index The index at which to add this object
 */
DvtContainer.prototype.addChildAt = function (obj, index) {
  this.AddChildAt(obj, index);
}

// TODO JSDoc, exists so that shapes can call without being confused by the additional shapes for selection
DvtContainer.prototype.AddChildAt = function(obj, index) {
  if ((index >= 0) && (index <= this.getNumChildren()) && obj)// validate index
  {
    var curIndex = this._findChild(obj);// note if obj is child of this container
    if ((curIndex >= 0) && (curIndex == index))// do nothing if child of this container
      return;// and move is to current position
    var oldParent = obj.getParent();// remove object from current parent
    if (oldParent)
      oldParent.removeChild(obj);
    obj.setParent(this);// reparent
  
    // If obj is child of this container and the intent is to place it after the last
    // object (before the above remove was done), decrement the index.
    if (curIndex >= 0) {
      if (index == (this.getNumChildren() + 1))
        index--;
    }
  
    var idx = index;
  
    if (this._bShapeContainer) {
      //  This is a shape "container".
      //  If no previous children, will create a group DOM element for the this
      //  (parent) object and add the new child to the child group DOM element.
      //  else will add the object directly to the shape group container element.
      this.CreateChildGroupElem(false);
  
      //need to increment the index to account for the shape dom element,
      //which should be the first child of the childGroupElem
      idx++;
    }
  
    //  Bug 15865017 - GET RID OF DVTGOLINK AND IMPLS
    //  if there is an anchor elem <a> for this container
    //  append child to the <a> element 
    //  otherwise append child directly to this container group element
    var containerElem = this.getContainerElem();
    var existingNode = containerElem.childNodes[idx];
    // BUG #12661320: IE9 cannot handle a value of undefined in insertBefore.  Set to null in such a case. 
    if (!existingNode)
      existingNode = null;
    containerElem.insertBefore(obj.getOuterElem(), existingNode);
  
    if (!this._arList) {
      this._arList = [];
    }
    this._arList.splice(index, 0, obj);
  }
}

/**  
 * Returns true if the specified displayable is a direct child of this container.
 * @param {DvtDisplayable} obj The object to be searched for.
 * @return {boolean} True if object is contained by this container, else false.
 */
DvtContainer.prototype.contains = function (obj) {
  return (this._findChild(obj) >= 0);
}

/**
 * Returns index of specified child obj in the internal list, or -1 if not
 * found.
 * @type DvtObj
 * @private
 */
DvtContainer.prototype._findChild = function (obj) {
  var idx =  - 1;

  if (this._arList) {
    var len = this._arList.length;
    for (var i = 0;i < len;i++) {
      // find the obj
      if (this._arList[i] === obj) {
        idx = i;
        break;
      }
    }
  }

  return idx;
};

/**
 *   Returns the child after the specified object, or null if it is the last
 *   in the list.
 *   @param {DvtObj} obj  The object whose successor is required.
 *   @type {DvtObj}
 */
DvtContainer.prototype.getChildAfter = function (obj) {
  var o = null;
  var idx = this._findChild(obj);

  if ((idx >= 0) && (++idx < this._arList.length)) {
    o = this._arList[idx];
  }

  return o;
};

/**
 *   Returns the child before the specified object, or null if the is the first
 *   in the list.
 *   @param {DvtObj} obj  The object whose predecessor is required.
 *   @type {DvtObj}
 */
DvtContainer.prototype.getChildBefore = function (obj) {
  var o = null;
  var idx = this._findChild(obj);

  if (idx > 0) {
    o = this._arList[--idx];
  }

  return o;
};

/**
 *   Returns the child at the specified zero-relative position, or null if
 *   there is no child represented by the position.
 *   @param {number} idx  The zero-relative index to the child object.
 *   @type {DvtObj}
 */
DvtContainer.prototype.getChildAt = function (idx) {
  var o = null;

  if (this._arList && (this._arList.length > idx) && (idx >= 0)) {
    o = this._arList[idx];
  }

  return o;
}

/**
 *   Returns the container index of the specified object, or -1 if the object
 *   is not a direct child of the container.
 *   @param {DvtObj} obj  The object whose container index is required.
 *   @type {number}
 */
DvtContainer.prototype.getChildIndex = function (obj) {
  return this._findChild(obj);
}

/**
 *   Returns the number of direct children of this container
 *   @type number
 */
DvtContainer.prototype.getNumChildren = function () {
  return (this._arList ? this._arList.length : 0);
}

/**
 *   Removes the specified child object from this container.
 *   @param {DvtObj} obj  The object to be removed.
 */
DvtContainer.prototype.removeChild = function (obj) {
  var idx = this._findChild(obj);// is child in container
  if (idx !==  - 1) {
    this._removeObj(obj, idx);
  }
}

/**
 *   Removes the specified child object from this container.
 *   @param {DvtDisplayable} obj The object to be removed.
 */
DvtContainer.prototype.removeChildImpl = function (obj) {
  var elemObj = obj.getOuterElem();// obj's outer DOM element
  var parent = obj.getParent();// get parent object (the container or the shape group container)
  
  if (elemObj && parent) {
    // Bug 15865017 - GET RID OF DVTGOLINK AND IMPLS
    var elem = this.getContainerElem();
    elem.removeChild(elemObj);
  }

  //  If no more children, can remove the added group for child containership,
  //  and reparent the containing shape directly back to its parent in the
  //  position that the added child group container occupied.
  // Bug 15865017 - GET RID OF DVTGOLINK AND IMPLS
  // don't remove the childGroupElem because we need it to hold the anchor
  if (!this._anchorElem && this._bShapeContainer && this.getNumChildren() === 1) {
    var childGroupElem = this._childGroupElem;
    var childGroupElemParent = (childGroupElem ? childGroupElem.parentNode : null);

    if (childGroupElemParent) {
      DvtDisplayable.TransferAttributes(childGroupElem, this._elem, this.GetAttributesTransferableToGroup());
      childGroupElemParent.replaceChild(this._elem, childGroupElem);
      this._childGroupElem = null;
    }
  }
};


/**
 *   Removes the specified child object at the index specfied from this container.
 *   @param {number} idx  The index of the object to be removed.
 *   @returns {DvtObj}  The object removed.
 */
DvtContainer.prototype.removeChildAt = function (idx) {
  var obj = this.getChildAt(idx);

  if (obj) {
    this._removeObj(obj, idx);
  }

  return obj;
};

/**
 *   Removes all child object's from this container.
 */
DvtContainer.prototype.removeChildren = function () {
  if (this._arList) {
    var ar = this._arList;

    while (this.getNumChildren() > 0) {
      this._removeObj(ar[0], 0);
    }
  }
};

/**
 *   Removes the specified object from this container.
 *   @param {DvtObj}  obj   The object to be removed.
 *   @param {number}  idx   The index position (zero relative) of the child
 *                          in the container's list of chhildren.
 *    @private
 */
DvtContainer.prototype._removeObj = function (obj, idx) {
  //  obj must be in the container.
  this.removeChildImpl(obj);// perform platform remove
  obj.setParent(null);

  this._arList.splice(idx, 1);// remove from list
  if (this._arList.length === 0) {
    this._arList = null;
  }
}

/**
 *    Destroy the container.  It should no longer be used or displayed
 */
DvtContainer.prototype.destroy = function () {
  DvtContainer.superclass.destroy.call(this);
  var childCount = this.getNumChildren();
  for (var i = 0;i < childCount;i++) {
    var child = this.getChildAt(i);
    child.destroy();
  }
}
/**
 * Gets the hyperlink information for this object
 */
DvtContainer.prototype.getHyperlink = function () {
  return this._linkObj;
}

/**
 * Returns an rray of SVG attributes that should be transferred from the shape
 * tag to the group when this shape becomes a group (when children are added to it).
 * @return {array}
 */
DvtContainer.prototype.GetAttributesTransferableToGroup = function () {
  return DvtContainer.AttributesTransferableToGroup;
}

/**
 * @override
 */
DvtContainer.prototype.getElem = function () {
  return (this._childGroupElem ? this._childGroupElem : this._elem);
}



/**
 *    Exchanges the positions of two objects in the container.
 *    DONT USE YET - IN PROGRESS JRM  TDO
 */
DvtContainer.prototype.swap = function (obj1, obj2) {
  //  Both obj's must be in this same container.
  var idx1 = this.getChildIndex(obj1);
  var idx2 = this.getChildIndex(obj2);

  this._arList[idx1] = obj2;// swap entries in list.
  this._arList[idx2] = obj1;

  //  Update the DOM
  var elem1 = obj1.getElem();// obj's DOM element
  var elem2 = objw.getElem(); // TODO HZHANG this never could have possibly worked, so we should consider removing the entire function
  var parent = obj1.getParent();// get parent object (the container
  // or the shape group container)
  var elem2Next = elem2.nextSibling;

  if (parent && elem1 && elem2) {
    parent.replaceChild(elem1, elem2);
    parent.insertBefore(elem1, elem2Next);

    // Update the array
    var idx1 = obj1.getIndex();
    var idx2 = obj2.getIndex();

    this._arList[idx1] = obj2;
    this._arList[idx2] = obj1;
  }
}

/**
 * Create a group element for adding children.
 * @param {boolean} rmChildren True if all children should be removed
 * @param {boolean} forced True always create a child group element for shape container
 * @protected
 */
DvtContainer.prototype.CreateChildGroupElem = function (rmChildren, forced) {
  //  This is a shape "container".
  //  If no previous children, will create a group DOM element for the this
  //  (parent) object and add the new child to the child group DOM element.
  //  else will add the object directly to the shape group container element.
  if (!this._childGroupElem && (forced || this.getNumChildren() === 0)) {
    var childGroupId = this._id ? this._id + '_g' : null;
    this._childGroupElem = DvtSvgShapeUtils.createElement('g', childGroupId);

    //  Remove this's DOM element from the parent, and append to child group DOM element.
    var parent = this.getParent();
    var elemParent;
    if (parent) {
      elemParent = parent.getElem();
      elemParent.replaceChild(this._childGroupElem, this._elem);
    }
    if (!rmChildren)
      DvtToolkitUtils.appendChildElem(this._childGroupElem, this._elem);// add shape to new group
    //transfer attributes from the old outermost SVG element to the
    //new outer group element
    DvtDisplayable.TransferAttributes(this._elem, this._childGroupElem, this.GetAttributesTransferableToGroup());

    //Note need to copy _obj reference to the new group element so that events can be propagated.
    if (this._elem._obj) {
      this._childGroupElem._obj = this._elem._obj;
    }
    
    // Track the number of child group elements created, so that we can move away from this pattern
    if(DvtAgent.isEnvironmentTest())
      document.shapeContainerCount++;
  }
  else if (rmChildren) {
    this.removeChildren();
  }

}

//BUG FIX 13842194:
/**
 * @override
 */
DvtContainer.prototype.getDimensionsWithStroke = function () {
  //a pure container has no shape of its own, so calculate the
  //dims for all child shapes in the subtree rooted at this container
  //build an initial array of all direct children of this container
  var ar = [];
  var numChildren = this.getNumChildren();
  for (var i = 0;i < numChildren;i++) {
    ar.push(this.getChildAt(i));
  }

  //loop over the array of children until it's empty
  var totalDims = null;
  while (ar.length > 0) {
    //remove the first object from the array
    var child = ar.shift();
    //get dims in coordinate space of this container, because we're 
    //processing whole subtree of children under this container
    var dims = child.GetDimensionsWithStroke(this);
    if (dims) {
      if (!totalDims) {
        totalDims = dims;
      }
      else {
        totalDims = totalDims.getUnion(dims);
      }
    }

    //add any children of current object to end of array
    numChildren = child.getNumChildren();
    for (var i = 0;i < numChildren;i++) {
      ar.push(child.getChildAt(i));
    }
  }
  return totalDims;
};

//BUG FIX 13842194:
DvtContainer.prototype.GetDimensionsWithStroke = function (targetCoordinateSpace) {
  //pure container doesn't have its own dimensions
  return null;
}

/**
 * Adds a hyperlink to this object, remove the old hyperlink if exists.
 * @param {DvtObj} linkObj contains destination (url) and targetFrame properties
 */
DvtContainer.prototype.setHyperlink = function (linkObj) {
  //Bug 15865017 - GET RID OF DVTGOLINK AND IMPLS
  this._linkObj = linkObj;
  
  var destination;
  var frame;
  var focusable;

  if (linkObj) {
    destination = linkObj["destination"];
    frame = linkObj["targetFrame"];
    focusable = linkObj["focusable"];
  }

  var gElem = this.getElem();
  var aElem;
  var elem = this._elem;

  //if an "a" element already exists, 
  if (this._anchorElem) {
    aElem = this._anchorElem;

    // replace destination and targetFrame
    if (destination) {
      DvtToolkitUtils.setAttrNS(aElem, DvtImage.XLINK_NS, 'xlink:href', destination);
      if (frame) {
        DvtToolkitUtils.setAttrNullNS(aElem, 'target', frame);
      }
      else {
        DvtToolkitUtils.removeAttrNullNS(aElem, 'target');
      }

      if (focusable)
        DvtToolkitUtils.setAttrNullNS(aElem, 'focusable', focusable);
    }

    // no destination, remove "a" element
    else {
      if (gElem && aElem.parentNode == gElem) {
        gElem.removeChild(aElem);
        DvtContainer._reparentChildren(gElem, aElem);
      }
      this.setCursor("default");
      this._anchorElem = null;
    }
  }

  // create an "a" element
  else {
    aElem = DvtSvgShapeUtils.createElement('a');
    if (destination)
      DvtToolkitUtils.setAttrNS(aElem, DvtImage.XLINK_NS, 'xlink:href', destination);

    if (frame)
      DvtToolkitUtils.setAttrNullNS(aElem, 'target', frame);

    if (focusable)
      DvtToolkitUtils.setAttrNullNS(aElem, 'focusable', focusable);

    // need to wrap around shape element (<a><text></a>) with a <g> to avoid
    // dom element replacement error.
    // Bug 15865017 - GET RID OF DVTGOLINK AND IMPLS
    if (this._bShapeContainer) {
      this.CreateChildGroupElem(false, true);
    }

    gElem = this.getElem();
    DvtContainer._reparentChildren(aElem, gElem);

    DvtToolkitUtils.appendChildElem(gElem, aElem);

    this.setCursor(DvtSelectionEffectUtils.getSelectingCursor());
    this._anchorElem = aElem;
  }
}

/*
 * move children from source to target element
 */
DvtContainer._reparentChildren = function (target, source) {
  var childNodes = source.childNodes;

  if (childNodes) {
    var node;
    var lastNode;

    for (var i = childNodes.length - 1;i >= 0;i--) {
      node = childNodes[i];
      if (lastNode) {
        target.insertBefore(node, lastNode);
      }
      else {
        DvtToolkitUtils.appendChildElem(target, node);
      }
      lastNode = node;
    }
  }
}

/**
 * Returns the anchor element if exists.
 */
DvtContainer.prototype.getContainerElem = function () {
  return this._anchorElem ? this._anchorElem : this.getElem();
}

/**
 * Dispatches the native event to the internal dom element
 * Note: Use with caution
 * @param {Object} event
 */
DvtContainer.prototype.dispatchNativeEvent = function (event) {
  var nativeEvent = event.getNativeEvent();
  var target = null;

  if (this._bShapeContainer)
    target = this._childGroupElem;
  else if (this._anchorElem)
    target = this._anchorElem;
  else 
    target = this._elem;

  if (target.dispatchEvent)
    target.dispatchEvent(nativeEvent);
}
// Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.
/**
 * Top level container for all displayables contained within the SVG document.  This class should not be extended.
 * @extends DvtContainer
 * @param {DvtContext} context
 * @param {SVGElement} svgRoot The containing SVG document.
 * @param {string} [id] The optional id for the corresponding DOM element.
 * @class
 * @constructor
 * @export
 */
var DvtStage = function (context, svgRoot, id) {
  // Note: Initialization code in constructor to prevent subclassing.
  this.Init(context, 'g', id);

  this._SVGRoot = svgRoot;// containing SVG DOM element
  
  //to disable ability to select text, bug 13453406
  this.disableSelection(this._elem);

  //set cursor to default to avoid text cursors on text objects
  this.setCursor("default");
}

DvtObj.createSubclass(DvtStage, DvtContainer, "DvtStage");

/**
 * @override
 * @export
 */
DvtStage.prototype.addChild = function (obj) {
  // Note: This function exists to ensure that applications can add children to the stage.  Do not remove.
  DvtStage.superclass.addChild.call(this, obj);
}

/**
 * Appends the specified element to the defs element for this stage.
 * @param {object} elem
 */
DvtStage.prototype.appendDefs = function (elem) {
  DvtToolkitUtils.appendChildElem(this._elemDefs, elem);
}

/**
 * Returns the defs element for this stage.
 * @return {object}
 */
DvtStage.prototype.getDefs = function () {
  return this._elemDefs;
}

/**
 * Returns the root SVG document.
 * @return {object}
 */
DvtStage.prototype.getSVGRoot = function () {
  return this._SVGRoot;
}

// TODO HZHANG CLEANUP
DvtStage.prototype.disableSelection = function (target) {
  target.onselectstart = function () {
    return false
  };
  target.onselect = function () {
    return false
  };
}
// Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.
/**
 *  Abstract base class for shape displayables.
 *  @extends DvtContainer
 *  @class
 *  @constructor
 */
var DvtShape = function () {
  // This class should never be instantiated directly
}

//  Allow shapes to become 'containers' themselves.  Note: this does not
//  provide a true parent/child relationship since this not available in SVG. TODO HZHANG reconsider this decision
DvtObj.createSubclass(DvtShape, DvtContainer, "DvtShape");

/**
 * @override
 */
DvtShape.prototype.Init = function (context, type, id) {
  DvtShape.superclass.Init.call(this, context, type, id);

  // TODO HZHANG: For all properties that default to null or false, remove from constructor
  this._bSelectable = false;
  this.IsSelected = false;
  this.InnerShape = null;
  this.HoverInnerStroke = null;
  this.HoverOuterStroke = null;
  this.SelectedInnerStroke = null;
  this.SelectedOuterStroke = null;
  this.SelectedHoverInnerStroke = null;
  this.SelectedHoverOuterStroke = null;
  this.OriginalStroke = null;
  this._isOriginalStrokeSet = false;
  this.IsShowingHoverEffect = false;
  this.setAriaProperty('hidden', 'true');
}

/**
 * Returns the fill for this shape.
 * @return {DvtFill}
 */
DvtShape.prototype.getFill = function () {
  return this.GetProperty('fill');
}

/**
 * Specifies a fill to be applied to the shape.
 * @param {DvtFill} fill
 */
DvtShape.prototype.setFill = function (fill) {
  this._manageDefinitions(this.GetProperty('fill'), fill);

  if (!fill) {
    DvtToolkitUtils.setAttrNullNS(this._elem, 'fill', 'none');
    DvtToolkitUtils.removeAttrNullNS(this._elem, 'fill-opacity');
    this.SetProperty('fill', null);
    return;
  }
  else {
    if (this.GetProperty('fill') === fill) {
      return;
    }
  }
  
  this.SetProperty('fill', fill);

  if (fill instanceof DvtGradientFill || fill instanceof DvtImageFill || fill instanceof DvtPatternFill)
    this._setSpecFill(fill);
  else {
    //  Basic fill
    var color = fill.getColor();
    if (color) {
      if (color.charAt(0) == '#' && color.length > 7) {
        // #aarrggbb values shouldn't get sent to the DOM
        color = DvtColorUtils.getRGBA(color);
      }
      var alpha = fill.getAlpha();
      // Workaround for Safari where versions < 5.1 draw rgba values as black
      if ((DvtAgent.isEnvironmentBatik() || DvtAgent.isBrowserSafari()) && color.indexOf("rgba") !==  - 1) {
        DvtToolkitUtils.setAttrNullNS(this._elem, 'fill', DvtColorUtils.getRGB(color));

        // Apply alpha in rgba value as a multiplier to the alpha set on the object as this is what svg does.
        if (alpha != null)
          DvtToolkitUtils.setAttrNullNS(this._elem, 'fill-opacity', DvtColorUtils.getAlpha(color) * alpha, 1);
        else 
          DvtToolkitUtils.setAttrNullNS(this._elem, 'fill-opacity', DvtColorUtils.getAlpha(color), 1);
      }
      else {
        DvtToolkitUtils.setAttrNullNS(this._elem, 'fill', color);
        if (alpha != null)
          DvtToolkitUtils.setAttrNullNS(this._elem, 'fill-opacity', alpha, 1);
      }
    }
  }

  // Make the fill immutable now that it has been applied.
  fill.__lock();

  this.UpdateSelectionEffect();
}

/**
 *  Sets a solid fill on this shape.
 *  @param {String}  color  The hex or RGB representation of the solid fill
 *  @param {number}  alpha  The fill opacity. Defaults to 1 if none specified.
 *  If null is specified, a transparent fill is applied.
 */
DvtShape.prototype.setSolidFill = function (color, alpha) {
  this.setFill(new DvtSolidFill(color, alpha));
};

/**
 *  Sets an invisible fill on this shape.
 */
DvtShape.prototype.setInvisibleFill = function () {
  this.setFill(DvtSolidFill.invisibleFill());
}

DvtShape.prototype._setSpecFill = function (obj, func) {
  var id;
  if (!obj.isLocked()) {
    id = obj.getId();
    if (!id) {
      if (obj instanceof DvtPatternFill) {
        id = DvtSvgShapeUtils.getUniqueId(this.getCtx(), "pat");// no id - create unique internal id
      }
      else {
        id = DvtSvgShapeUtils.getUniqueId(this.getCtx(), 'Gr');// no id - create unique internal id
      }
      obj.setId(id);
    }
  }
  else {
    id = obj.getId();
  }
  if (!obj._defPresent) {
    var elem = obj._defElem;
    if (!elem) {
      if (obj instanceof DvtGradientFill)
        elem = DvtSvgGradientUtils.createElem(obj, id);
      else if (obj instanceof DvtImageFill)
        elem = DvtSvgImageFillUtils.createElem(obj, id);
      else if (obj instanceof DvtPatternFill)
        elem = DvtSvgPatternFillUtils.createElem(obj, id);
    }
    obj._defElem = elem;
    this.getCtx().appendDefs(elem);
    obj._defPresent = true;
  }

  DvtToolkitUtils.setAttrNullNS(this._elem, 'fill', 'url(#' + id + ')');
  DvtToolkitUtils.setAttrNullNS(this._elem, 'fill-opacity', '1');
};

/**
 * Returns the stroke for this shape.
 * @return {DvtStroke}
 */
DvtShape.prototype.getStroke = function () {
  return this._stroke;
};

/**
 *  Sets the stroke properties on this shape from the supplied stroke object.
 *  If the stroke object is null, any existing stroke is removed.
 *  @param {DvtStroke}  obj  A stroke object.
 */
DvtShape.prototype.setStroke = function (stroke) {
  this._manageDefinitions(this._stroke, stroke);

  this._stroke = stroke;

  if (!stroke) {
    DvtToolkitUtils.removeAttrNullNS(this._elem, 'stroke');
    DvtToolkitUtils.removeAttrNullNS(this._elem, 'stroke-opacity');
    DvtToolkitUtils.removeAttrNullNS(this._elem, 'stroke-width');
    DvtToolkitUtils.removeAttrNullNS(this._elem, 'stroke-dasharray');
    DvtToolkitUtils.removeAttrNullNS(this._elem, 'stroke-dashoffset');
    DvtToolkitUtils.removeAttrNullNS(this._elem, 'stroke-linejoin');
    DvtToolkitUtils.removeAttrNullNS(this._elem, 'stroke-linecap');
    DvtToolkitUtils.removeAttrNullNS(this._elem, 'stroke-miterlimit');
    return;
  }

  //  Stroke color/alpha
  // gradient
  if (stroke instanceof DvtGradientStroke) {
    this._setSpecStroke(stroke);
  }
  else {
    var color = stroke.getColor();
    if (color) {
      if (color.charAt(0) == '#' && color.length > 7) {
        // #aarrggbb values shouldn't get sent to the DOM
        color = DvtColorUtils.getRGBA(color);
      }
      var alpha = stroke.getAlpha();
      // Workaround for Safari where versions < 5.1 draw rgba values as black
      if ((DvtAgent.isEnvironmentBatik() || DvtAgent.isBrowserSafari()) && color.indexOf("rgba") !==  - 1) {
        DvtToolkitUtils.setAttrNullNS(this._elem, 'stroke', DvtColorUtils.getRGB(color));
        // Use alpa in rgba value as a multiplier to the alpha set on the object as this is what svg does.
        if (alpha != null)
          DvtToolkitUtils.setAttrNullNS(this._elem, 'stroke-opacity', DvtColorUtils.getAlpha(color) * alpha, 1);
        else 
          DvtToolkitUtils.setAttrNullNS(this._elem, 'stroke-opacity', DvtColorUtils.getAlpha(color), 1);
      }
      else {
        DvtToolkitUtils.setAttrNullNS(this._elem, 'stroke', color);
        if (alpha != null)
          DvtToolkitUtils.setAttrNullNS(this._elem, 'stroke-opacity', alpha, 1);
      }
    }
  }

  //  Stroke width
  DvtToolkitUtils.setAttrNullNS(this._elem, 'stroke-width', stroke.getWidth(), 1);

  if (stroke.isFixedWidth())
    DvtToolkitUtils.setAttrNullNS(this._elem, 'vector-effect', 'non-scaling-stroke');

  //  Stroke type/style
  var st = stroke.getType();
  if (st !== DvtStroke.SOLID) {
    DvtToolkitUtils.setAttrNullNS(this._elem, 'stroke-dasharray', stroke.getDash());
    if (stroke.getDashOffset()) {
      DvtToolkitUtils.setAttrNullNS(this._elem, 'stroke-dashoffset', stroke.getDashOffset());
    }
  }
  else {
    DvtToolkitUtils.removeAttrNullNS(this._elem, 'stroke-dasharray');
    DvtToolkitUtils.removeAttrNullNS(this._elem, 'stroke-dashoffset');
  }

  //  Line-joining attribute
  attrib = stroke.getLineJoin();
  if (attrib) {
    DvtToolkitUtils.setAttrNullNS(this._elem, 'stroke-linejoin', attrib);
  }

  //  Line-ending attribute
  attrib = stroke.getLineEnd();
  if (attrib) {
    DvtToolkitUtils.setAttrNullNS(this._elem, 'stroke-linecap', attrib);
  }

  //  miter limit attribute
  attrib = stroke.getMiterLimit();
  if (attrib) {
    DvtToolkitUtils.setAttrNullNS(this._elem, 'stroke-miterlimit', attrib);
  }

  // Make the stroke immutable now that it has been applied.
  stroke.__lock();
}

/**
 *  Sets a solid stroke on this shape.
 *  @param {String}  color  The hex or RGB representation of the solid fill
 *  @param {number}  alpha  The fill opacity. Defaults to 1 if none specified.
 *  @param {number}  strokeWidth  The stroke width. Defaults to 1 if none specified.
 *  If null is specified, a transparent fill is applied.
 */
DvtShape.prototype.setSolidStroke = function (color, alpha, strokeWidth) {
  this.setStroke(new DvtSolidStroke(color, alpha, strokeWidth));
}

/**
 * Private helper function to create gradient, add it to def section of the SVG DOM,
 * and set the stroke to point to the gradient def
 * @private
 */
DvtShape.prototype._setSpecStroke = function (obj, func) {
  var id;
  if (!obj.isLocked()) {
    id = obj.getId();
    if (!id) {
      id = DvtSvgShapeUtils.getUniqueId(this.getCtx(), 'Gr');// no id - create unique internal id
      obj.setId(id);
    }
  }
  else {
    id = obj.getId();
  }

  if (!obj._defPresent) {
    var elem = obj._defElem;
    if (!elem)
      elem = DvtSvgGradientUtils.createElem(obj, id);// create SVG DOM elem
    obj._defElem = elem;
    this.getCtx().appendDefs(elem);
    obj._defPresent = true;
  }

  DvtToolkitUtils.setAttrNullNS(this._elem, 'stroke', 'url(#' + id + ')');
  var alpha = obj.getAlpha();
  if (alpha != null) {
    DvtToolkitUtils.setAttrNullNS(this._elem, 'stroke-opacity', alpha);
  }
};

/**  Changes the shape to an outline shape format.  Used for legends
 *  markers that represent a hidden state for the associated series risers.
 *  @param {String} fc Border color for hollow shape in format of #aarrggbb
 *  @param {number} strokeWidth Stroke width used for shapes that were transofrmed (optional)
 */
DvtShape.prototype.setHollow = function (fc, strokeWidth) {
  if (!this._bHollow) {
    // Save original fill and stroke to restore 
    this._origFill = this.GetProperty('fill');
    this._origStroke = this._stroke;
    // Set hollow shape fill and stroke based on shape fill
    var hollowFill = DvtSolidFill.invisibleFill();
    var hollowStroke;
    if (fc) {
      hollowStroke = new DvtSolidStroke(DvtColorUtils.getRGB(fc), DvtColorUtils.getAlpha(fc), strokeWidth);
    }
    else {
      hollowStroke = new DvtSolidStroke(this.GetProperty('fill').getColor(), this.GetProperty('fill').getAlpha(), strokeWidth);
    }
    this.setFill(hollowFill);
    this.setStroke(hollowStroke);
    this._bHollow = true;
  }
  else {
    this.setFill(this._origFill);
    this.setStroke(this._origStroke);
    this._bHollow = false;
  }
};

/**  Returns whether a shape is hollow.
 *  @returns {boolean} True if the shape is hollow
 */
DvtShape.prototype.isHollow = function () {
  return this._bHollow;
}

/**
 *    Destroy the shape.  It should no longer be used or displayed
 */
DvtShape.prototype.destroy = function () {
  DvtShape.superclass.destroy.call(this);
  this.setFill(null);
  this.setStroke(null);
}

/*
 * Manage the gradient/filter definitions for svg by keeping a reference count and removing unreferenced defs
 */
DvtShape.prototype._manageDefinitions = function (oldObj, newObj) {
  // If a new obj is specified, adjust reference counts and remove def if 0 references
  if (oldObj != newObj) {
    // Decrease count on existing obj
    if (oldObj) {
      oldObj._referenceCount--;
      if (oldObj._referenceCount == 0) {
        if (oldObj._defElem) {
          this.getCtx().removeDefs(oldObj._defElem);
          oldObj._defPresent = false;
        }
      }

    }
    if (newObj) {
      if (!newObj._referenceCount)
        newObj._referenceCount = 0;
      newObj._referenceCount++;
    }
  }
}

//BUG FIX 13842194:
/**
 * @override
 */
DvtShape.prototype.getDimensionsWithStroke = function () {
  //get the dims for this shape by itself
  var dims = this.GetElemDimensionsWithStroke();
  //get the dims for any children of this container
  var containerDims = DvtShape.superclass.getDimensionsWithStroke.call(this);
  //create union of shape and container dims
  if (dims && containerDims) {
    dims = dims.getUnion(containerDims);
  }
  else if (containerDims) {
    dims = containerDims;
  }

  return dims;
};

//BUG FIX 13842194:
DvtShape.prototype.GetDimensionsWithStroke = function (targetCoordinateSpace) {
  //get the dims for this shape by itself
  var dims = this.GetElemDimensionsWithStroke();
  if (!targetCoordinateSpace || targetCoordinateSpace === this)
    return dims;
  else {
    // Calculate the bounds relative to the target space
    return this.ConvertCoordSpaceRect(dims, targetCoordinateSpace);
  }
};

//BUG FIX 13842194:
DvtShape.prototype.GetElemDimensionsWithStroke = function () {
  //get the dims for this shape by itself
  var dims = DvtShape.superclass.GetElemDimensionsWithStroke.call(this);
  //assume that stroke touches every edge of bounding box, so push out
  //every edge by half the stroke width
  var stroke = this.getStroke();
  if (dims && stroke) {
    var sw = stroke.getWidth();
    if (sw) {
      var halfSw = .5 * sw;
      dims.x -= halfSw;
      dims.y -= halfSw;
      dims.w += sw;
      dims.h += sw;
    }
  }
  return dims;
};

/**
 * Updates the geometries of the DvtShape used for the selection effects.
 * @protected
 */
DvtShape.prototype.UpdateSelectionEffect = function () {
  if (this.isSelected() || this.isHoverEffectShown()) {
    var stroke;
    if (this.InnerShape) {
      stroke = this.InnerShape.getStroke();
      this.removeChild(this.InnerShape);
    }
    this.InnerShape = this.copyShape();
    this.InnerShape.setMouseEnabled(false);
    this.InnerShape.setFill(this.getFill());
    if (stroke)
      this.InnerShape.setStroke(stroke);
    this.InnerShape.setMouseEnabled(false);
    this.InnerShape.setCursor(DvtSelectionEffectUtils.getSelectingCursor());
    this.AddChildAt(this.InnerShape, 0);
  }
}

/**
 * Sets the hover inner and outer strokes for this shape.
 * If there is only one stroke color for this effect, only innerStroke needs to be set.
 * @param {DvtStroke} innerStroke The inner stroke color for this effect
 * @param {DvtStroke} outerStroke The outer stroke color for this effect
 * @return {DvtShape} To be used for chaining
 */
DvtShape.prototype.setHoverStroke = function (innerStroke, outerStroke) {
  this.HoverInnerStroke = innerStroke;
  this.HoverOuterStroke = outerStroke;
  return this;
}

/**
 * Sets the selected inner and outer strokes for this shape.
 * If there is only one stroke color for this effect, only innerStroke needs to be set.
 * @param {DvtStroke} innerStroke The inner stroke color for this effect
 * @param {DvtStroke} outerStroke The outer stroke color for this effect
 * @return {DvtShape} To be used for chaining
 */
DvtShape.prototype.setSelectedStroke = function (innerStroke, outerStroke) {
  this.SelectedInnerStroke = innerStroke;
  this.SelectedOuterStroke = outerStroke;
  return this;
}

/**
 * Sets the selected hover inner and outer stroke for this shape.
 * If there is only one stroke color for this effect, only innerStroke needs to be set.
 * If none are given, default will be to use the selected outer and hover inner strokes.
 * @param {DvtStroke} innerStroke The inner stroke color for this effect
 * @param {DvtStroke} outerStroke The outer stroke color for this effect
 * @return {DvtShape} To be used for chaining
 */
DvtShape.prototype.setSelectedHoverStroke = function (innerStroke, outerStroke) {
  this.SelectedHoverInnerStroke = innerStroke;
  this.SelectedHoverOuterStroke = outerStroke;
  return this;
}

/**
 * Implemented for DvtSelectable
 */
DvtShape.prototype.setSelectable = function (bSelectable) {
  this._bSelectable = bSelectable;
  if (this._bSelectable)
    this.setCursor(DvtSelectionEffectUtils.getSelectingCursor());
  else 
    this.setCursor(null);
}

/**
 * Implemented for DvtSelectable
 */
DvtShape.prototype.isSelectable = function () {
  return this._bSelectable;
}

/**
 * Implemented for DvtSelectable
 */
DvtShape.prototype.isSelected = function () {
  return this.IsSelected;
}

/**
 * Implemented for DvtSelectable
 * @override
 */
DvtShape.prototype.setSelected = function (selected) {
  if (this.IsSelected == selected)
    return;

  if (!this._isOriginalStrokeSet) {
    this._isOriginalStrokeSet = true;
    this.OriginalStroke = this.getStroke();
  }

  this.IsSelected = selected;

  if (this.isSelected()) {
    // on selection, set the outer border treatment on the DvtShape and the inner border treatment
    // on its copy which is placed in front of it with the same fill
    this.UpdateSelectionEffect();

    if (this.isHoverEffectShown()) {
      this.CreateSelectedHoverStrokes();
      this.InnerShape.setStroke(this.SelectedHoverInnerStroke);
      this.setStroke(this.SelectedHoverOuterStroke);
    }
    else {
      this.InnerShape.setStroke(this.SelectedInnerStroke);
      this.setStroke(this.SelectedOuterStroke);
    }
  }
  else {
    this.removeChild(this.InnerShape);
    this.setStroke(this.OriginalStroke);
  }
}

/**
 * Implemented for DvtSelectable
 * @override
 */
DvtShape.prototype.showHoverEffect = function () {
  this.IsShowingHoverEffect = true;

  if (!this._isOriginalStrokeSet) {
    this._isOriginalStrokeSet = true;
    this.OriginalStroke = this.getStroke();
  }

  this.UpdateSelectionEffect();

  if (this.isSelected()) {
    this.CreateSelectedHoverStrokes();
    this.InnerShape.setStroke(this.SelectedHoverInnerStroke);
    this.setStroke(this.SelectedHoverOuterStroke);
  }
  else {
    this.InnerShape.setStroke(this.HoverInnerStroke);
    this.setStroke(this.HoverOuterStroke);
  }
}

/**
 * Initializes the selected hover strokes
 * @protected
 */
DvtShape.prototype.CreateSelectedHoverStrokes = function () {
  if (!this.SelectedHoverInnerStroke)
    this.SelectedHoverInnerStroke = this.HoverInnerStroke.clone();
  if (!this.SelectedHoverOuterStroke) {
    this.SelectedHoverOuterStroke = this.SelectedOuterStroke.clone();
    this.SelectedHoverOuterStroke.setWidth(this.SelectedOuterStroke.getWidth() + (this.HoverInnerStroke.getWidth() - this.SelectedInnerStroke.getWidth()));
  }
}

/**
 * Implemented for DvtSelectable
 */
DvtShape.prototype.hideHoverEffect = function () {
  this.IsShowingHoverEffect = false;
  if (this.isSelected()) {
    this.InnerShape.setStroke(this.SelectedInnerStroke);
    this.setStroke(this.SelectedOuterStroke);
  }
  else {
    this.removeChild(this.InnerShape);
    this.setStroke(this.OriginalStroke);
  }
}
/**
 * Determine if the selection hover effect is shown.
 * @type boolean
 */
DvtShape.prototype.isHoverEffectShown = function () {
  return this.IsShowingHoverEffect;
}

/**
 * Override DvtContainer's addChildAt to account for the selection shape
 * @override
 */
DvtShape.prototype.addChildAt = function (obj, idx) {
  DvtShape.superclass.addChildAt.call(this, obj, idx + this._getInnerShapeCount());
}

/**
 * Override DvtContainer's getChildAt to account for the selection shape
 * @override
 */
DvtShape.prototype.getChildAt = function (obj, idx) {
  return DvtShape.superclass.getChildAt.call(this, obj, idx + this._getInnerShapeCount());
}

/**
 * Override DvtContainer's getChildIndex to account for the selection shape
 * @override
 */
DvtShape.prototype.getChildIndex = function (obj) {
  var idx = DvtShape.superclass.getChildIndex.call(this, obj);
  return (this.isSelected() || this.isHoverEffectShown()) ? idx + 1 : idx;
}

/**
 * Override DvtContainer's removeChildAt to account for the selection shape
 * @override
 */
DvtShape.prototype.removeChildAt = function (idx) {
  DvtShape.superclass.removeChildAt.call(this, idx + this._getInnerShapeCount());
}

/**
 * @override
 */
DvtShape.prototype.getDimensions = function (targetCoordinateSpace) {
  // Optimized implementation that allows container geometry to be taken into account to avoid costly DOM calls
  if (this.getDimensionsSelf && (this.getNumChildren() - this._getInnerShapeCount() == 0))
    return this.getDimensionsSelf(targetCoordinateSpace);
  else 
    return DvtShape.superclass.getDimensions.call(this, targetCoordinateSpace);
}

/**
 * Returns the number of inner shapes that are part of the child list.  This value should be used as an offset to find
 * the true child count.
 * @private
 */
DvtShape.prototype._getInnerShapeCount = function () {
  // TODO CLEANUP: HZHANG Technically we should override getNumChildren, but I'm nervous about changing this behavior.
  //               We'll end up fine once shapes can no longer be child containers.
  return (this.isSelected() || this.isHoverEffectShown()) ? 1 : 0;
}

/**
 * @override
 */
DvtShape.prototype.SvgPropertyChanged = function(name) {
  this.UpdateSelectionEffect();
}

/**
 * Makes and returns a copy of the shape with the same geometries. The original shape's fill, stroke, and id will not
 * be copied over.
 * @return {DvtShape} A copy of this shape with the same constructor arguments.
 */
DvtShape.prototype.copyShape = function () {
  // subclasses should implement
  return null;
}
// Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.
/**
 * Abstract base class for circular displayable that is drawn around a point.
 * @extends DvtShape
 * @class
 * @constructor
 */
var DvtCircularShape = function () {
  // This class should never be instantiated directly
}

DvtObj.createSubclass(DvtCircularShape, DvtShape, "DvtCircularShape");

/**
 * @param {DvtContext} context
 * @param {string} type The type of SVG element to be created.
 * @param {number} cx The x coordinate of the center of the shape.
 * @param {number} cy The y coordinate of the center of the shape.
 * @param {string} [id] The optional id for the corresponding DOM element.
 * @protected
 */
DvtCircularShape.prototype.Init = function (context, type, cx, cy, id) {
  DvtCircularShape.superclass.Init.call(this, context, type, id);
  this.setCx(cx).setCy(cy);
}

/**
 * Returns the x coordinate of the center of the shape.
 * @return {number}
 */
DvtCircularShape.prototype.getCx = function () {
  return this.GetProperty('cx');
}

/**
 * Specifies the x coordinate of the center of the shape.
 * @param {number} cx
 * @return {DvtCircularShape}
 */
DvtCircularShape.prototype.setCx = function (cx) {
  return this.SetSvgProperty('cx', cx, 0);
}

/**
 * Returns the y coordinate of the center of the shape.
 * @return {number}
 */
DvtCircularShape.prototype.getCy = function () {
  return this.GetProperty('cy');
}

/**
 * Specifies the y coordinate of the center of the shape.
 * @param {number} cy
 * @return {DvtCircularShape}
 */
DvtCircularShape.prototype.setCy = function (cy) {
  return this.SetSvgProperty('cy', cy, 0);
}
// Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.
/**
 * Abstract base class for polygon displayable that is defined by an array of points.
 * @extends DvtShape
 * @class
 * @constructor
 */
var DvtPolygonalShape = function () {
  // This class should never be instantiated directly
}

DvtObj.createSubclass(DvtPolygonalShape, DvtShape, "DvtPolygonalShape");

/**
 * @param {DvtContext} context
 * @param {string} type The type of SVG element to be created.
 * @param {array} arPoints The array of coordinates for this polygon, in the form [x1,y1,x2,y2...].
 * @param {string} [id] The optional id for the corresponding DOM element.
 * @protected
 */ 
DvtPolygonalShape.prototype.Init = function (context, type, arPoints, id) {
  DvtPolygonalShape.superclass.Init.call(this, context, type, id);
  
  if(arPoints)
    this.setPoints(arPoints);
}

/**
 * Returns the array of coordinates for this shape, in the form [x1,y1,x2,y2...].
 * @return {array}
 */
DvtPolygonalShape.prototype.getPoints = function () {
  return this.GetProperty('arPoints');
}

/**
 * Specifies the array of coordinates for this shape, in the form [x1,y1,x2,y2...].
 * @param {array} arPoints
 * @return {DvtPolygonalShape}
 */
DvtPolygonalShape.prototype.setPoints = function (arPoints) {
  this.SetProperty('arPoints', arPoints);
  return this.SetSvgProperty('points', DvtSvgShapeUtils.convertPointsArray(arPoints));
}

/**
 * Returns the bounds of the displayable relative to the target coordinate space.  If the target
 * coordinate space is not specified, returns the bounds relative to this displayable.  This function does not take
 * into account any child displayables.
 * @param {DvtDisplayable} targetCoordinateSpace The displayable defining the target coordinate space.
 * @return {DvtRectangle} The bounds of the displayable relative to the target coordinate space.
 */
DvtPolygonalShape.prototype.getDimensionsSelf = function (targetCoordinateSpace) {
  // Note: In the near future, we will not support children for shapes, so this routine will be refactored into the
  //       existing getDimensions calls.  For now, components must be aware of the presence of children to use this.
  var bounds = DvtPolygonUtils.getDimensions(this.getPoints());
  return this.ConvertCoordSpaceRect(bounds, targetCoordinateSpace);
}
// Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.
/**
 * Arc displayable.
 * @param {DvtContext} context
 * @param {number} cx The x coordinate of the center of the arc.
 * @param {number} cy The y coordinate of the center of the arc.
 * @param {number} rx The horizontal radius of the arc. 
 * @param {number} ry The vertical radius of the arc. 
 * @param {number} startAngle The starting angle in degrees (following the normal anti-clockwise is positive convention).
 * @param {number} angleExtent The angle extent in degrees (following the normal anti-clockwise is positive convention).
 * @param {String} [closureType] An optional closure type for the arc. Closure types are {@link DvtArc#OPEN} (the default),
 *                              {@link DvtArc#CHORD} and {@link DvtArc#PIE}. TODO HZHANG cleanup types
 * @param {string} [id] The optional id for the corresponding DOM element.
 * @extends DvtShape
 * @class
 * @constructor
 */
var DvtArc = function (context, cx, cy, rx, ry, startAngle, angleExtent, closureType, id)
{
  this.Init(context, cx, cy, rx, ry, startAngle, angleExtent, closureType, id);
}

DvtObj.createSubclass(DvtArc, DvtShape, "DvtArc");

// TODO HZHANG we should find out if this shape is needed at all.  If so, major cleanup needed
// TODO HZHANG this class is setting a bunch of non-path properties on paths
// TODO HZHANG the usage of createArc is inconsistent
// TODO HZHANG add linkages to self on return

/**
 * Closure type - arc is not closed.
 * @type String
 */
DvtArc.OPEN = "OPEN";
/**
 * Closure type - arc is closed to create a segment.
 * @type String
 */
DvtArc.CHORD = "CHORD";
/**
 * Closure type - arc is closed to create a sector.
 * @type String
 */
DvtArc.PIE = "PIE";

/**
 * @param {DvtContext} context
 * @param {number} cx The x coordinate of the center of the arc.
 * @param {number} cy The y coordinate of the center of the arc.
 * @param {number} rx The horizontal radius of the arc. 
 * @param {number} ry The vertical radius of the arc. 
 * @param {number} startAngle The starting angle in degrees (following the normal anti-clockwise is positive convention).
 * @param {number} angleExtent The angle extent in degrees (following the normal anti-clockwise is positive convention).
 * @param {String} [closureType] An optional closure type for the arc. Closure types are {@link DvtArc#OPEN} (the default),
 *                              {@link DvtArc#CHORD} and {@link DvtArc#PIE}. TODO HZHANG cleanup types
 * @param {string} [id] The optional id for the corresponding DOM element.
 * @protected
 */
DvtArc.prototype.Init = function (context, cx, cy, rx, ry, startAngle, angleExtent, closureType, id) {
  DvtArc.superclass.Init.call(this, context, 'path', id);

  this._sa = 0;// TODO hzhang cleanup
  this._ae = 0;

  ry = ((ry === null || isNaN(ry)) ? rx : ry);

  this._bInInit = true;// performance - avoid multiple createArc()'s
  this.setCx(cx);
  this.setCy(cy);
  this.setRx(rx);
  this.setRy(ry);
  this.setAngleStart(startAngle);
  this.setAngleExtent(angleExtent);
  this.setClosure(closureType ? closureType : DvtArc.OPEN);
  this._bInInit = false;// finally allow createArc to work.
  this._createArc();
}

/** @private */
DvtArc.prototype._addClosure = function (p) {
  if (this._ct === DvtArc.CHORD) {
    p += ' z';
  }
  else if (this._ct === DvtArc.PIE) {
    p += ' L ' + this._cx + ',' + this._cy + ' z';
  }
  else if (this._ct === DvtArc.OPEN) {
    this.setFill(null);
  }

  return p;
}

/**
 * @private
 */
DvtArc.prototype._createArc = function () {
  if (this._bInInit) {
    // don't need to do this until end of Init()
    return;
  }

  var sa = (this._sa * DvtMath.RADS_PER_DEGREE);
  var ae = (this._ae * DvtMath.RADS_PER_DEGREE);

  var x1 = this._cx + (this._rx * Math.cos(sa));// get arc
  var y1 = this._cy - (this._ry * Math.sin(sa));// end points
  var x2 = this._cx + (this._rx * Math.cos(sa + ae));
  var y2 = this._cy - (this._ry * Math.sin(sa + ae));

  var nLargeArc = (Math.abs(this._ae) > 180) ? '1' : '0';
  var nSweepFlag = (this._ae > 0) ? '0' : '1';// 0 == svg +ve angle
  var path = "M " + x1 + " " + y1 + " A " + this._rx + "," + this._ry + " " + "0" + " " + nLargeArc + "," + nSweepFlag + " " + x2 + "," + y2;
  path = this._addClosure(path);

  DvtToolkitUtils.setAttrNullNS(this._elem, 'd', path);
  if (this._stroke !== null) {
    this.setStroke(this._stroke);
  }
}

/**
 * Returns the angle subtended by the arc.
 * @returns {number}  The angle subtended by the arc (following the normal anti-clockwise
 * is positive convention).
 */
DvtArc.prototype.getAngleExtent = function () {
  return this._ae;
}

/**
 * Returns the angle subtended by the arc.
 * @returns {number}  The angle subtended by the arc.
 * is positive convention).
 */
DvtArc.prototype.setAngleExtent = function (ae) {
  ae = ((ae === null || isNaN(ae)) ? 0 : ae);
  if (this._ae !== ae) {

    //  From https://developer.mozilla.org/en/SVG/Tutorial/Paths
    //  "Complete circles and ellipses are actually the one object paths have trouble drawing.
    //  Because the start and end points for any path going around a circle are the same, there
    //  are an infinite number of circles that could be chosen, and the actual path is undefined.
    //  It's possible to approximate them by making the start and end points of your path slightly askew"
    if (ae === 360) {
      // bug 12723079
      ae = 359.99;// cannnot use any precision higher than this!
    }

    this._ae = ae;
    this._createArc();
    this.UpdateSelectionEffect();
  }
}

/**
 * Returns the start angle for an arc.
 * @returns {number}  The starting angle (following the normal anti-clockwise
 * is positive convention).
 */
DvtArc.prototype.getAngleStart = function () {
  return this._sa;
}

/**
 * Sets the start angle of the arc.
 * @param {number}  The starting angle (following the normal anti-clockwise
 * is positive convention).
 */
DvtArc.prototype.setAngleStart = function (sa) {
  sa = ((sa === null || isNaN(sa)) ? 0 : sa);
  if (this._sa !== sa) {
    this._sa = sa;
    this._createArc();
    this.UpdateSelectionEffect();
  }
}

/**
 *    Returns the closure type of the arc.
 *    @type String
 *    @returns The closure type,  such as {@link DvtArc#OPEN}
 */
DvtArc.prototype.getClosure = function () {
  return this._ct;
}

/**
 * Sets the closure type of the arc.
 * @param {String} ct   The closure type,  such as {@link DvtArc#OPEN}
 */
DvtArc.prototype.setClosure = function (ct) {
  if (ct !== this._ct) {
    this._ct = ct;
    this._createArc();
    this.UpdateSelectionEffect();
  }
}

/**
 * Returns the x coordinate of the center.
 * @type number
 */
DvtArc.prototype.getCx = function () {
  return this._cx;
}

/**
 * Sets the x coordinate of the center.
 * @param {number} cx  The center x position.
 */
DvtArc.prototype.setCx = function (cx) {  // TODO HZHANG not a valid SVG attribute
  if (cx !== this._cx) {
    this._cx = cx;
    DvtToolkitUtils.setAttrNullNS(this._elem, 'cx', cx);
    this.UpdateSelectionEffect();
  }
}

/**
 * Returns the y coordinate of the center.
 * @type number
 */
DvtArc.prototype.getCy = function () {
  return this._cy;
}

/**
 * Sets the y coordinate of the center.
 * @param {number} cy  The center y position.
 *
 */
DvtArc.prototype.setCy = function (cy) {  // TODO HZHANG not a valid SVG attribute
  if (cy !== this._cy) {
    this._cy = cy;
    DvtToolkitUtils.setAttrNullNS(this._elem, 'cy', cy);
    this.UpdateSelectionEffect();
  }
}

/**
 * Returns the horizontal radius of the ellipse.
 * @type number
 */
DvtArc.prototype.getRx = function () {
  return this._rx;
}

/**
 * Sets the horizontal radii of the ellipse.
 * @param {number} rx  The horizontal radius of the ellipse.
 */
DvtArc.prototype.setRx = function (rx) {  // TODO HZHANG not a valid SVG attribute
  if (rx !== this._rx) {
    this._rx = rx;
    DvtToolkitUtils.setAttrNullNS(this._elem, 'rx', this._rx);
    this.UpdateSelectionEffect();
  }
}

/**
 * Returns the vertical radius of the ellipse.
 * @type number
 */
DvtArc.prototype.getRy = function () {
  return this._ry;
}

/**
 * Sets the vertical radius of the ellipse.
 * @param {number} ry  The vertical radius of the ellipse.
 */
DvtArc.prototype.setRy = function (ry) {  // TODO HZHANG not a valid SVG attribute
  if (ry !== this._ry) {
    this._ry = ry;
    DvtToolkitUtils.setAttrNullNS(this._elem, 'ry', this._ry);
    this.UpdateSelectionEffect();
  }
}

/**
 * Defines the position and extent of the arc.
 * @param {number} sa  The starting angle in degrees (following the normal
 * anti-clockwise is positive convention).
 * @param {number} ae  The angle extent in degrees (following the normal
 * anti-clockwise is positive convention).
 */
DvtArc.prototype.setArc = function (sa, ae) { // TODO HZHANG check usages
  this.setAngleStart(sa);
  this.setAngleExtentStart(ae);
}

/**
 * Sets both the horizontal and vertical radii of the ellipse/circle.
 * @param {number} rx  The horizontal radius of the ellipse.
 * @param {number} ry  The vertical radius of the ellipse.
 */
DvtArc.prototype.setRadius = function (rx, ry) { // TODO HZHANG check usages
  this.setRx(rx);
  this.setRy(ry);
}

/**
 * @override
 */
DvtArc.prototype.copyShape = function () {
  return new DvtArc(this.getCtx(), this.getCx(), this.getCy(), this.getRx(), this.getRy(), this.getAngleStart(), this.getAngleExtent(), this.getClosure());
}
// Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.
/**
 * Circle displayable.
 * @param {DvtContext} context
 * @param {number} cx The x coordinate of the center of the circle.
 * @param {number} cy The y coordinate of the center of the circle.
 * @param {number} r The radius of the circle. 
 * @param {string} [id] The optional id for the corresponding DOM element.
 * @extends DvtCircularShape
 * @class
 * @constructor
 */
var DvtCircle = function (context, cx, cy, r, id) {
  this.Init(context, cx, cy, r, id);
}

DvtObj.createSubclass(DvtCircle, DvtCircularShape, "DvtCircle");

/**
 * @param {DvtContext} context
 * @param {number} cx The x coordinate of the center of the circle.
 * @param {number} cy The y coordinate of the center of the circle.
 * @param {number} r The radius of the circle.
 * @param {string} [id] The optional id for the corresponding DOM element.
 * @protected
 */
DvtCircle.prototype.Init = function (context, cx, cy, r, id) {
  DvtCircle.superclass.Init.call(this, context, 'circle', cx, cy, id);
  this.setRadius(r);
}

/**
 * Returns the radius of the circle.
 * @return {number}
 */
DvtCircle.prototype.getRadius = function () {
  return this.GetProperty('r');
}

/**
 * Specifies the radius of the circle.
 * @param {number} r
 * @return {DvtCircle}
 */
DvtCircle.prototype.setRadius = function (r) {
  return this.SetSvgProperty('r', r);
}

/**
 * @override
 */
DvtCircle.prototype.copyShape = function () {
  return new DvtCircle(this.getCtx(), this.getCx(), this.getCy(), this.getRadius());
}

/**
 * Returns the bounds of the displayable relative to the target coordinate space.  If the target
 * coordinate space is not specified, returns the bounds relative to this displayable.  This function does not take
 * into account any child displayables.
 * @param {DvtDisplayable} targetCoordinateSpace The displayable defining the target coordinate space.
 * @return {DvtRectangle} The bounds of the displayable relative to the target coordinate space.
 */
DvtCircle.prototype.getDimensionsSelf = function (targetCoordinateSpace) {
  // Note: In the near future, we will not support children for shapes, so this routine will be refactored into the
  //       existing getDimensions calls.  For now, components must be aware of the presence of children to use this.
  var bounds = new DvtRectangle(this.getCx() - this.getRadius(), this.getCy() - this.getRadius(), this.getRadius() * 2, this.getRadius() * 2);
  return this.ConvertCoordSpaceRect(bounds, targetCoordinateSpace);
}
// Copyright (c) 2011, 2014, Oracle and/or its affiliates. All rights reserved.
/**
 * Image displayable.
 * @param {DvtContext} context
 * @param {string} src The url for the image
 * @param {number} x The top left x-coordinate of the image
 * @param {number} y The top left y-coordinate of the image
 * @param {number} w The image width
 * @param {number} h The image height
 * @param {string} [id] The optional id for the corresponding DOM element.
 * @extends DvtShape
 * @class
 * @constructor
 */
var DvtImage = function (context, src, x, y, w, h, id) {
  this.Init(context, src, x, y, w, h, id);
}

DvtObj.createSubclass(DvtImage, DvtShape, "DvtImage");// TODO HZHANG this should extend displayable

DvtImage.XLINK_NS = "http://www.w3.org/1999/xlink";

/**
 * Helper method called by the constructor for initializing this object
 * @param {string} src The url for the image
 * @param {number} x The top left x-coordinate of the image
 * @param {number} y The top left y-coordinate of the image
 * @param {number} w The image width
 * @param {number} h The image height
 * @param {string} id The identifier for the image
 * @private
 */
DvtImage.prototype.Init = function (context, src, x, y, w, h, id) {
  DvtImage.superclass.Init.call(this, context, 'image', id);
  // IE doesn't allow interactivity unless there's a fill
  if (DvtAgent.isPlatformIE()) {
    DvtToolkitUtils.setAttrNullNS(this._elem, 'fill', '#FFFFFF');
    DvtToolkitUtils.setAttrNullNS(this._elem, 'fill-opacity', '0');
  }
  this.setImage(src, x, y, w, h);
}

/**
 * Returns the x coordinate of the image.
 * @return {number}
 */
DvtImage.prototype.getX = function () {
  return this.GetProperty('x');
}

/**
 * Specifies the x coordinate of the image.
 * @param {number} x
 * @return {DvtImage}
 */
DvtImage.prototype.setX = function (x) {
  return this.SetSvgProperty('x', x);
}

/**
 * Returns the y coordinate of the image.
 * @return {number}
 */
DvtImage.prototype.getY = function () {
  return this.GetProperty('y');
}

/**
 * Specifies the y coordinate of the image.
 * @param {number} y
 * @return {DvtImage}
 */
DvtImage.prototype.setY = function (y) {
  return this.SetSvgProperty('y', y);
}

/**
 * Returns the width of the image.
 * @return {number}
 */
DvtImage.prototype.getWidth = function () {
  return this.GetProperty('width');
}

/**
 * Specifies the width of the image.
 * @param {number} w The width of the image.
 * @return {DvtImage}
 */
DvtImage.prototype.setWidth = function (w) {
  return this.SetSvgProperty('width', w);
}

/**
 * Returns the height of the image.
 * @return {number}
 */
DvtImage.prototype.getHeight = function () {
  return this.GetProperty('height');
}

/**
 * Specifies the height of the image.
 * @param {number} h The height of the image.
 * @return {DvtImage}
 */
DvtImage.prototype.setHeight = function (h) {
  return this.SetSvgProperty('height', h);
}

/**
 * Returns the src of the image.
 * @returns (String) the src of the image.
 */
DvtImage.prototype.getSrc = function () {
  return this._src;
}

/**
 * Sets the src of the image.
 * @param {number} src  The src of the image.
 * @return {DvtImage}
 */
DvtImage.prototype.setSrc = function (src) {
  if (src !== this._src) {
    this._src = src;
    if (DvtAgent.isEnvironmentBatik()) {
      var imageInfo = DvtJavaImageLoader.getImageInfo(src);
      if (imageInfo)
        this._src = imageInfo.uri;
    }
    
    DvtToolkitUtils.setAttrNS(this._elem, DvtImage.XLINK_NS, 'xlink:href', this._src);
  }
  
  // Return self for linking setters
  return this;
}

DvtImage.prototype.getPos = function () { // TODO HZHANG CLEANUP
  return new DvtPoint(this._x, this._y);
}

DvtImage.prototype.setPos = function (x, y) { // TODO HZHANG CLEANUP
  this.setX(x).setY(y);
}

/**
 *     Sets the position and size and src of the image
 *     Maybe specified as individual values or using a DvtImage object.
 *
 *   e.g. Image = factory.newImage('pic'png', 10, 10, 50, 100);  or
 *
 *        Image = factory.newImage(myImage);   where myImage = new DvtImage('pic.png', 10, 10, 50, 100);
 */
DvtImage.prototype.setImage = function (src, x, y, w, h) { // TODO HZHANG CLEANUP
  if (x instanceof DvtImage) {
    this.setSrc(src.src);
    this.setPos(src.x, src.y);
    this.setWidth(src.w);
    this.setHeight(src.h);
  }
  else {
    this.setSrc(src);
    this.setPos(x, y);
    this.setWidth(w);
    this.setHeight(h);
  }

  //TODO: set preserveAspectRatio="none" for now
  DvtToolkitUtils.setAttrNullNS(this._elem, 'preserveAspectRatio', 'none');
}

/**
 * @override
 */
DvtImage.prototype.getDimensions = function (targetCoordinateSpace) {
  // Optimized implementation that allows container geometry to be taken into account to avoid costly DOM calls
  if (this.getDimensionsSelf && (this.getNumChildren() - this._getInnerShapeCount() == 0))
    return this.getDimensionsSelf(targetCoordinateSpace);
  else {
    var bbox = this.getElem().getBBox();
    if (bbox.width && bbox.height)
      bbox = new DvtRectangle(bbox.x, bbox.y, bbox.width, bbox.height);
    else
      bbox = new DvtRectangle(bbox.x, bbox.y, this.getWidth(), this.getHeight());
    
    return this.ConvertCoordSpaceRect(bbox, targetCoordinateSpace);
  }
}

/**
 * Loads the image and sets the image size if it was loaded
 * Returns the dimension of the image if it was loaded
 */
DvtImage.prototype.loadImage = function () {
  if (this._src) {
    var imageSize = DvtSvgImageLoader.loadImage(this._src);
    if (imageSize) {
      this.setWidth(imageSize.width);
      this.setHeight(imageSize.height);

      //BUG 17601740 - FIREFOX: NODE CONTENT COLLAPSED ON INITIAL RENDERING 
      //      return this.getDimensions();
      return new DvtRectangle(0, 0, this.getWidth(), this.getHeight());
    }
  }
  return null;
}

/**
 * Convenience method for setting the width and height of the image.
 * @param {object} dims An object with width and height properties.
 */
DvtImage.prototype.__setDimensions = function (dims) {
  this.setWidth(dims.width);
  this.setHeight(dims.height);
}

/**
 * @override
 */
DvtImage.prototype.UpdateSelectionEffect = function() {
  // noop: Does not participate in selection effects
}

/**
 * @override
 */
DvtImage.prototype.copyShape = function () {
  return new DvtImage(this.getCtx(), this.getSrc(), this.getX(), this.getY(), this.getWidth(), this.getHeight());
}

/**
 * Returns the bounds of the displayable relative to the target coordinate space.  If the target
 * coordinate space is not specified, returns the bounds relative to this displayable.  This function does not take
 * into account any child displayables.
 * @param {DvtDisplayable} targetCoordinateSpace The displayable defining the target coordinate space.
 * @return {DvtRectangle} The bounds of the displayable relative to the target coordinate space.
 */
DvtImage.prototype.getDimensionsSelf = function (targetCoordinateSpace) {
  // Note: In the near future, we will not support children for shapes, so this routine will be refactored into the
  //       existing getDimensions calls.  For now, components must be aware of the presence of children to use this.
  var bounds = new DvtRectangle(this.getX(), this.getY(), this.getWidth(), this.getHeight());
  return this.ConvertCoordSpaceRect(bounds, targetCoordinateSpace);
}
// Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.
/**
 * Line displayable.
 * @param {DvtContext} context
 * @param {number} x1 The x coordinate of the first point.
 * @param {number} y1 The y coordinate of the first point.
 * @param {number} x2 The x coordinate of the second point.
 * @param {number} y2 The y coordinate of the second point.
 * @param {string} [id] The optional id for the corresponding DOM element.
 * @extends DvtShape
 * @class
 * @constructor
 */
var DvtLine = function (context, x1, y1, x2, y2, id) {
  this.Init(context, x1, y1, x2, y2, id);
}

DvtObj.createSubclass(DvtLine, DvtShape, "DvtLine");

/**
 * @param {DvtContext} context
 * @param {number} x1 The x coordinate of the first point.
 * @param {number} y1 The y coordinate of the first point.
 * @param {number} x2 The x coordinate of the second point.
 * @param {number} y2 The y coordinate of the second point.
 * @param {string} [id] The optional id for the corresponding DOM element.
 * @protected
 */
DvtLine.prototype.Init = function (context, x1, y1, x2, y2, id) {
  DvtLine.superclass.Init.call(this, context, 'line', id);

  // TODO HZHANG: This can be removed
  DvtToolkitUtils.setAttrNullNS(this._elem, 'fill', 'none');
  
  this.setX1(x1).setY1(y1).setX2(x2).setY2(y2);
  this._bHollow = false; // TODO HZHANG CLEANUP: The whole bHollow thing is pretty strange.
}

/**
 * Returns the x coordinate of the first point.
 * @return {number}
 */
DvtLine.prototype.getX1 = function () {
  return this.GetProperty('x1');
}

/**
 * Specifies the x coordinate of the first point.
 * @param {number} x1
 * @return {DvtLine}
 */
DvtLine.prototype.setX1 = function (x1) {
  return this.SetSvgProperty('x1', x1);
}

/**
 * Returns the y coordinate of the first point.
 * @return {number}
 */
DvtLine.prototype.getY1 = function () {
  return this.GetProperty('y1');
}

/**
 * Specifies the y coordinate of the first point.
 * @param {number} y1
 * @return {DvtLine}
 */
DvtLine.prototype.setY1 = function (y1) {
  return this.SetSvgProperty('y1', y1);
}

/**
 * Returns the x coordinate of the second point.
 * @return {number}
 */
DvtLine.prototype.getX2 = function () {
  return this.GetProperty('x2');
}

/**
 * Specifies the x coordinate of the second point.
 * @param {number} x2
 * @return {DvtLine}
 */
DvtLine.prototype.setX2 = function (x2) {
  return this.SetSvgProperty('x2', x2);
}

/**
 * Returns the y coordinate of the second point.
 * @return {number}
 */
DvtLine.prototype.getY2 = function () {
  return this.GetProperty('y2');
}

/**
 * Specifies the y coordinate of the second point.
 * @param {number} y2
 * @return {DvtLine}
 */
DvtLine.prototype.setY2 = function (y2) {
  return this.SetSvgProperty('y2', y2);
}

/**  
 * Changes the shape to an outline shape format.  Used for legend that represent a hidden state.
 * @override
 */
DvtLine.prototype.setHollow = function () {
  var parentElem = this._elem.parentNode;

  if (!this._bHollow) {
    this._origElem = this._elem;
    var hollowMarker;
    var width = this.getX2() - this.getX1();// Legend lines are always horizontal, so take width as height
    var height = width;
    var startY = this.getY1() - width / 2;
    var stroke = this.getStroke();

    hollowMarker = DvtSvgShapeUtils.createElement('rect');
    DvtToolkitUtils.setAttrNullNS(hollowMarker, 'x', this.getX1());
    DvtToolkitUtils.setAttrNullNS(hollowMarker, 'y', startY);
    DvtToolkitUtils.setAttrNullNS(hollowMarker, 'width', this.getX2() - this.getX1());
    DvtToolkitUtils.setAttrNullNS(hollowMarker, 'height', height);
    var color = stroke.getColor();
    if (color) {
      var alpha = stroke.getAlpha();
      // Workaround for Safari where versions < 5.1 draw rgba values as black
      if (DvtAgent.isBrowserSafari() && color.indexOf("rgba") !==  - 1) {
        DvtToolkitUtils.setAttrNullNS(hollowMarker, 'stroke', DvtColorUtils.getRGB(color));
        // Use alpa in rgba value as a multiplier to the alpha set on the object as this is what svg does.
        if (alpha != null)
          DvtToolkitUtils.setAttrNullNS(hollowMarker, 'stroke-opacity', DvtColorUtils.getAlpha(color) * alpha);
        else 
          DvtToolkitUtils.setAttrNullNS(hollowMarker, 'stroke-opacity', DvtColorUtils.getAlpha(color));
      }
      else {
        DvtToolkitUtils.setAttrNullNS(hollowMarker, 'stroke', color);
        if (alpha != null)
          DvtToolkitUtils.setAttrNullNS(hollowMarker, 'stroke-opacity', alpha);
      }
    }
    DvtToolkitUtils.setAttrNullNS(hollowMarker, 'fill', '#ffffff');
    DvtToolkitUtils.setAttrNullNS(hollowMarker, 'fill-opacity', '0.001');// need this or hit detection fails on center
    DvtToolkitUtils.setAttrNullNS(hollowMarker, 'shape-rendering', 'crispEdges');
    hollowMarker._obj = this;// replace the elem's _obj backpointer 
    parentElem.replaceChild(hollowMarker, this._elem);
    this._elem = hollowMarker;
    DvtToolkitUtils.setAttrNullNS(this._elem, 'opacity', this._alpha);
    this._bHollow = true;
  }
  else if (this._origElem) {
    parentElem.replaceChild(this._origElem, this._elem);
    DvtToolkitUtils.setAttrNullNS(this._origElem, 'opacity', this._alpha);
    this._elem = this._origElem;
    this._origElem = null;
    this._bHollow = false;
  }
}

/**
 * @override
 */
DvtLine.prototype.getDimensions = function (targetCoordinateSpace) {
  // TODO HZHANG CLEANUP: It seems like this can just call getDimensionsSelf
  var bounds = DvtLine.superclass.getDimensions.call(this, targetCoordinateSpace);
  // BUG #12806130: Vertical/horizontal lines in svg are ignored when group containers wrap them
  if (this._childGroupElem && this._elem) {
    var groupBox = this._childGroupElem.getBBox();
    // Empty bounding box is an indication of only vertical/horizontal lines present in this group
    // In this case, use the original line itself to get the bounds as an approximation
    if (groupBox.x == 0 && groupBox.y == 0 && groupBox.width == 0 && groupBox.height == 0) {
      var lineBounds = this._elem.getBBox();
      bounds = new DvtRectangle(lineBounds.x, lineBounds.y, lineBounds.width, lineBounds.height);
    }
  }
  return bounds;
}

/**
 * @override
 */
DvtLine.prototype.copyShape = function () {
  return new DvtLine(this.getCtx(), this.getX1(), this.getY1(), this.getX2(), this.getY2());
}

/**
 * Returns the bounds of the displayable relative to the target coordinate space.  If the target
 * coordinate space is not specified, returns the bounds relative to this displayable.  This function does not take
 * into account any child displayables.
 * @param {DvtDisplayable} targetCoordinateSpace The displayable defining the target coordinate space.
 * @return {DvtRectangle} The bounds of the displayable relative to the target coordinate space.
 */
DvtLine.prototype.getDimensionsSelf = function (targetCoordinateSpace) {
  // Note: In the near future, we will not support children for shapes, so this routine will be refactored into the
  //       existing getDimensions calls.  For now, components must be aware of the presence of children to use this.
  var x = Math.min(this.getX1(), this.getX2());
  var y = Math.min(this.getY1(), this.getY2());
  var w = Math.abs(this.getX1() - this.getX2());
  var h = Math.abs(this.getY1() - this.getY2());

  var bounds = new DvtRectangle(x, y, w, h);
  return this.ConvertCoordSpaceRect(bounds, targetCoordinateSpace);
}
// Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.
/** 
  *  A marker object for lines, scatter and bubble charts and legend areas.
  *  @param {DvtContext} context 
  *  @param {Object} type An string representing the type of the marker (see {@link DvtMarker}), 
  *                       a string URI for the shape path for a custom svg marker, 
  *                       or an array of image URIs for each of the 4 marker states (active, hover, selected, hoverSelected).
  *  @param {number} x  The x position of the top left corner of the marker.
  *  @param {number} y  The y position of the top left corner of the marker.
  *  @param {number} w  The width of the marker.
  *  @param {number} h  The height of the marker.
  *  @param {number} sx  Optional The horizontal scale factor of the marker.
  *  @param {number} sy  Optional The vertical scale factor of the marker.
  *  @param {String} id  Optional ID for the shape (see {@link  DvtDisplayable#setId}).
  *  @param {boolean} maintainAspect Optional Indicates whether aspect ratio should be maintained (false is not specified)
  *  @class DvtMarker A marker object for lines, scatter and bubble charts and legend areas.
  *  @extends DvtShape
  *  @constructor
  */
var DvtMarker = function (context, type, skin, x, y, w, h, id, sx, sy, maintainAspect) {
  this.Init(context, type, skin, x, y, w, h, id, sx, sy, maintainAspect);
}

DvtObj.createSubclass(DvtMarker, DvtShape, "DvtMarker");

// TODO HZHANG: This class is a mess after collapsing the toolkit, but that reflects its state before the collapse.  We
// should refactor the code for creating a marker shape into a separate, simple marker class.
/**
 * No marker shape defined.
 */
DvtMarker.NONE = "none";
/**
 * A circular marker.
 */
DvtMarker.CIRCLE = "circle";
/**
 * A square marker.
 */
DvtMarker.SQUARE = "square";
/**
 * A diamond shaped marker.
 */
DvtMarker.DIAMOND = "diamond";
/**
 * A triangular shaped marker with a vertex at the top.
 */
DvtMarker.TRIANGLE_UP = "triangleUp";
/**
 * A triangular shaped marker with a vertex at the bottom.
 */
DvtMarker.TRIANGLE_DOWN = "triangleDown";
/**
 * A plus-shaped marker.
 */
DvtMarker.PLUS = "plus";
/**
 * A human figure shaped marker.
 */
DvtMarker.HUMAN = "human";
/**
 * A rectangular marker with rounded corners.
 */
DvtMarker.ROUNDED_RECTANGLE = "roundedRect";
/**
 * A custom svg shaped marker.
 */
DvtMarker.CUSTOM = "custom";
/**
 * An image marker.
 */
DvtMarker.IMAGE = "image";

/**
 * @protected
 */
DvtMarker.SELECTION_STROKE_COLOR = "#000000";
/**
 * @protected
 */
DvtMarker.SELECTION_STROKE_ALPHA = 1;

// Array indicies if an array of image URIs are passed in type parameter
DvtMarker.IMAGE_SOURCE = 0;
DvtMarker.IMAGE_SOURCE_SELECTED = 1;
DvtMarker.IMAGE_SOURCE_HOVER = 2;
DvtMarker.IMAGE_SOURCE_HOVER_SELECTED = 3;

// The reference coords and sizes that the shapes will be initialized to.
DvtMarker._REFERENCE_X = 0;
DvtMarker._REFERENCE_Y = 0;
DvtMarker._REFERENCE_W = 10;
DvtMarker._REFERENCE_H = 10;

DvtMarker.MARKER_CIRCLE_ELEM_NAME = "circle";
DvtMarker.MARKER_ELLIPSE_ELEM_NAME = "ellipse";
DvtMarker.MARKER_LINE_ELEM_NAME = "line";
DvtMarker.MARKER_PATH_ELEM_NAME = "path";
DvtMarker.MARKER_POLYGON_ELEM_NAME = "polygon";
DvtMarker.MARKER_POLYLINE_ELEM_NAME = "polyline";
DvtMarker.MARKER_RECT_ELEM_NAME = "rect";

/**
 *  Object initializer.
 *  @protected
 */
DvtMarker.prototype.Init = function (context, type, skin, x, y, w, h, id, sx, sy, maintainAspect) {
  //BUG FIX #13376761: save initial parameters in case we want to create
  //a copy of this marker
  this._skin = skin;
  this._xx = x;
  this._yy = y;
  this._ww = w;
  this._hh = h;
  this._sx = sx ? sx : 1;
  this._sy = sy ? sy : 1;
  this._maintainAspect = maintainAspect;
  this._initType = type;

  var etype;
  var markerDef;

  if (type instanceof Array) {
    this._setMarkerImageStates(type);
    type = DvtMarker.IMAGE;
  }
  else {
    if (!DvtMarker.isBuiltInShape(type)) {
      markerDef = DvtMarkerUtils.getCustomMarkerInfo(context, type);
      if (markerDef) {
        // Custom marker is always DvtPath or DvtContainer containing a collection of DvtPaths
        etype = (markerDef instanceof DvtPath ? 'path' : 'g');
        if (!w || !h) {
          var dim = DvtDisplayableUtils._getDimForced(context, markerDef);
          w = w ? w : dim.w;
          h = h ? h : dim.h;
          this._ww = w;
          this._hh = h;
        }
        type = DvtMarker.CUSTOM;
      }
      else {
        // no markerDef found, default to rect
        type = DvtMarker.SQUARE;
      }
    }
    else {
      type = DvtMarker.convertShapeString(type);
    }
  }
  
  // Create the impl shape
  var elemType;
  if (etype) {
    elemType = etype;
  }
  else {
    elemType = (type === DvtMarker.CIRCLE ? 'ellipse' : (type === DvtMarker.SQUARE ? 'rect' : (type === DvtMarker.ROUNDED_RECTANGLE ? 'rect' : (type === DvtMarker.TRIANGLE_UP ? 'polygon' : (type === DvtMarker.TRIANGLE_DOWN ? 'polygon' : (type === DvtMarker.DIAMOND ? 'polygon' : (type === DvtMarker.PLUS ? 'polygon' : (type === DvtMarker.HUMAN ? 'path' : (type === DvtMarker.IMAGE ? 'image' : 'rect')))))))));
  }
  DvtMarker.superclass.Init.call(this, context, elemType, id);

  // Store the type
  this._type = type;

  //default scale of the marker used to force it to the reference size
  this._defaultScale = 1;

  if (type === DvtMarker.HUMAN) {
    markerDef = DvtMarkerUtils.getBuiltinMarkerInfo(context, "human", this.getSkin());
  }

  // Update the width and height with the scale factors
  var ww = this.getScaledWidth();
  var hh = this.getScaledHeight();
  this._size = Math.max(ww, hh);

  // Position and size the marker
  this.setBounds(x, y, ww, hh, markerDef);

  // Store other params
  this._dataColor = "#000000";

  //properties related to selection
  this._savedStroke = null;
  this._savedFill = null;
  this._bSavedStroke = false;
  this._bSavedFill = false;
  this._selStrokeWidth = null;
  this._selStrokeColor = null;
  this._selStrokeAlpha = null;
}

/**
 *  Returns the greater of the width and height measurement.
 *  @returns {number} the size of the marker.
 */
DvtMarker.prototype.getSize = function () {
  return this._size;
}

/**
 *  Returns the type of the marker that was passed into the constructor.
 *  The type can be a string indicating a built-in marker type, an array of image paths,
 *  or a single path for custom svg marker.
 *  @returns {Object} the type of the marker
 */
DvtMarker.prototype.getInitType = function () {
  return this._initType;
};

/**
 * Sets the position and size of the marker.
 * @param {number} x The top left x-coordinate of the marker's bounding rectangle.
 * @param {number} y The top left y-coordinate of the marker's bounding rectangle.
 * @param {number} w The width of the marker's bounding rectangle.
 * @param {number} h The height of the marker's bounding rectangle.
 * @param {DvtMarkerDef} markerDef
 */
DvtMarker.prototype.setBounds = function (x, y, w, h, markerDef) {
  // Initialize the shape to the reference coords
  if (!this._shapeInitialized)
    this.InitShape(this._type, markerDef, x, y, w, h);
}

/**
 * Initializes the shape to the specified coordinates.
 * @param {string} type The marker type
 * @param {DvtMarkerDef} markerDef The marker definition used for custom markers generated on the server
 * @param {number} x The top left x-coordinate of the marker's bounding rectangle.
 * @param {number} y The top left y-coordinate of the marker's bounding rectangle.
 * @param {number} w The width of the marker's bounding rectangle.
 * @param {number} h The height of the marker's bounding rectangle.
 * @private
 */
DvtMarker.prototype.InitShape = function (type, markerDef, x, y, w, h) {
  // Only need to do this once
  this._shapeInitialized = true;

  // Save info for underlay positioning
  this._x = x;
  this._y = y;
  this._w = w;
  this._h = h;

  var multiPathRoot;
  if (type === DvtMarker.CUSTOM || type === DvtMarker.HUMAN) {
    // Calculate the scale factor to get to the right size
    var dim = DvtDisplayableUtils._getDimForced(this.getCtx(), markerDef);
    var maxDim = Math.max(dim.w, dim.h);

    var sx = 1;
    var sy = 1;

    // Calculate the transform to get to the right position
    if (type === DvtMarker.CUSTOM) {
      sx = w / (this.getMaintainAspect() ? maxDim : dim.w);
      sy = h / (this.getMaintainAspect() ? maxDim : dim.h);
      var dx = x + ( - dim.x * sx) + (w - (dim.w * sx)) / 2;
      var dy = y + ( - dim.y * sy) + (h - (dim.h * sy)) / 2;
      multiPathRoot = this._setCustomMarker(markerDef, dx, dy, sx, sy);
    }
    else if (type === DvtMarker.HUMAN) {
      sx = w / maxDim;
      sy = h / maxDim;
      var dx = x + ( - dim.x * sx) + (w - (dim.w * sx)) / 2;
      var dy = y + ( - dim.y * sy) + (h - (dim.h * sy)) / 2;
      this._setCmds(DvtPathUtils.transformPath(this.getSkin() == DvtCSSStyle.SKIN_ALTA ? DvtMarkerDef.HUMAN2_CMDS : DvtMarkerDef.HUMAN_CMDS, dx, dy, sx, sy));
    }
    var scale = (dim.h === maxDim) ? (h / maxDim) : (w / maxDim);
    //save the default scale used to force the marker to the reference size
    //because we may need it later for inversely scaling the selection stroke
    this._defaultScale = scale;
  }
  else if (type === DvtMarker.IMAGE) {
    var src = this.GetMarkerImage(DvtMarker.IMAGE_SOURCE);
    this._setX(x);
    this._setY(y);
    this._setWidth(w);
    this._setHeight(h);
    this.setSource(src);
    DvtToolkitUtils.setAttrNullNS(this._elem, 'preserveAspectRatio', 'none');
    // IE doesn't allow interactivity unless there's a fill
    if (DvtAgent.isPlatformIE()) {
      DvtToolkitUtils.setAttrNullNS(this._elem, 'fill', '#FFFFFF');
      DvtToolkitUtils.setAttrNullNS(this._elem, 'fill-opacity', '0');
    }
  }
  else if (type === DvtMarker.SQUARE) {
    this._setX(x);
    this._setY(y);
    this._setWidth(w);
    this._setHeight(h);
  }
  else if (type === DvtMarker.ROUNDED_RECTANGLE) {
    this._setX(x);
    this._setY(y);
    this._setWidth(w);
    this._setHeight(h);
    var rx = 6;
    var ry = 6;
    if (w / 4 < rx || h / 4 < ry) {
      rx = Math.min(w, h) / 4;
      ry = rx;
    }
    this._setRX(rx);
    this._setRY(ry);
  }
  else if (type === DvtMarker.CIRCLE) {
    this._setCx(x + w / 2);
    this._setCy(y + h / 2);
    this._setRX(w / 2);
    this._setRY(h / 2);
  }
  else {
    var ar = [];
    var halfWidth = w / 2;
    var halfHeight = h / 2;

    if (type === DvtMarker.TRIANGLE_UP) {
      ar.push(x);
      ar.push(y + h);
      ar.push(x + w);
      ar.push(y + h);
      ar.push(x + halfWidth);
      ar.push(y);
      this._setPolygon(ar);
    }
    else if (type === DvtMarker.TRIANGLE_DOWN) {
      ar.push(x);
      ar.push(y);
      ar.push(x + w);
      ar.push(y);
      ar.push(x + halfWidth);
      ar.push(y + h);
      this._setPolygon(ar);
    }
    else if (type === DvtMarker.DIAMOND) {
      ar.push(x + halfWidth);
      ar.push(y);
      ar.push(x + w);
      ar.push(y + halfHeight);
      ar.push(x + halfWidth);
      ar.push(y + h);
      ar.push(x);
      ar.push(y + halfHeight);
      this._setPolygon(ar);
    }
    else if (type === DvtMarker.PLUS) {
      var wThird = w / 3;
      var wTwoThird = 2 * wThird;
      var hThird = h / 3;
      var hTwoThird = 2 * hThird;

      ar.push(x + wThird);
      ar.push(y);
      ar.push(x + wTwoThird);
      ar.push(y);
      ar.push(x + wTwoThird);
      ar.push(y + hThird);
      ar.push(x + w);
      ar.push(y + hThird);
      ar.push(x + w);
      ar.push(y + hTwoThird);
      ar.push(x + wTwoThird);
      ar.push(y + hTwoThird);
      ar.push(x + wTwoThird);
      ar.push(y + h);
      ar.push(x + wThird);
      ar.push(y + h);
      ar.push(x + wThird);
      ar.push(y + hTwoThird);
      ar.push(x);
      ar.push(y + hTwoThird);
      ar.push(x);
      ar.push(y + hThird);
      ar.push(x + wThird);
      ar.push(y + hThird);
      ar.push(x + wThird);
      ar.push(y);
      this._setPolygon(ar);
    }
  }
}

/**
 *  Returns the default scale of the marker used to force it to the
 *  reference size.
 *  @type number
 */
DvtMarker.prototype.getDefaultScale = function () {
  return this._defaultScale;
};

/**
 *  Returns the skin of the marker.
 *  @returns {String} the skin name
 */
DvtMarker.prototype.getSkin = function () {
  return this._skin;
}

/**
 *  Returns the x-coord of the marker.
 *  @returns {number} the x-coord of the marker
 */
DvtMarker.prototype.getX = function () {
  return this._xx;
};

/**
 *  Returns the y-coord of the marker.
 *  @returns {number} the y-coord of the marker
 */
DvtMarker.prototype.getY = function () {
  return this._yy;
};

/**
 *  Returns the width of the marker, before any scale is applied.
 *  @returns {number} the width of the marker
 */
DvtMarker.prototype.getWidth = function () {
  return this._ww;
};

/**
 *  Returns the height of the marker, before any scale is applied.
 *  @returns {number} the height of the marker
 */
DvtMarker.prototype.getHeight = function () {
  return this._hh;
};

/**
 *  Returns the width of the marker, after any scale is applied.
 *  @returns {number} the scaled width of the marker
 */
DvtMarker.prototype.getScaledWidth = function () {
  return this._sx ? this._ww * this._sx : this._ww;
};

/**
 *  Returns the height of the marker, after any scale is applied.
 *  @returns {number} the scaled height of the marker
 */
DvtMarker.prototype.getScaledHeight = function () {
  return this._sy ? this._hh * this._sy : this._hh;
};

/**
 *  Returns the type of the marker (such as {@link DvtMarker#CIRCLE}.
 *  @type number
 */
DvtMarker.prototype.getType = function () {
  return this._type;
};

/**
 *  Returns the horizontal scale of the marker.
 *  @returns {number} the horizontal scale of the marker
 */
DvtMarker.prototype.getSx = function () {
  return this._sx;
};

/**
 *  Returns the vertical scale of the marker.
 *  @returns {number} the vertical scale of the marker
 */
DvtMarker.prototype.getSy = function () {
  return this._sy;
};

/**
 *  Returns whether aspect ratio should be maintained.
 *  @returns {boolean} whether aspect ratio should be maintained
 */
DvtMarker.prototype.getMaintainAspect = function () {
  return this._maintainAspect == true;
};

/**
 * @protected
 */
DvtMarker.prototype.SetStrokeWidth = function (sw) {
  var stroke = this.getStroke();
  if (stroke) {
    stroke = stroke.clone();
    stroke.setWidth(sw);
    this.setStroke(stroke);
  }
};

/**
 * @protected
 */
DvtMarker.prototype.GetStrokeWidth = function () {
  var stroke = this.getStroke();
  if (stroke) {
    return stroke.getWidth();
  }
  return 0;
};

/**
 * @override
 */
DvtMarker.prototype.showHoverEffect = function () {
  if (this.getType() === DvtMarker.IMAGE) {
    this.IsShowingHoverEffect = true;
    if (this.isSelected())
      this.setSource(this.GetMarkerImage(DvtMarker.IMAGE_SOURCE_HOVER_SELECTED));
    else 
      this.setSource(this.GetMarkerImage(DvtMarker.IMAGE_SOURCE_HOVER));
  }
  else 
    DvtMarker.superclass.showHoverEffect.call(this);
};

/**
 * @override
 */
DvtMarker.prototype.hideHoverEffect = function () {
  if (this.getType() === DvtMarker.IMAGE) {
    this.IsShowingHoverEffect = false;
    if (this.isSelected())
      this.setSource(this.GetMarkerImage(DvtMarker.IMAGE_SOURCE_SELECTED));
    else 
      this.setSource(this.GetMarkerImage(DvtMarker.IMAGE_SOURCE));
  }
  else 
    DvtMarker.superclass.hideHoverEffect.call(this);
}

/**
 * @override
 */
DvtMarker.prototype.setSelected = function (selected) {
  if (this.IsSelected == selected)
    return;

  if (this.getType() === DvtMarker.IMAGE) {
    this.IsSelected = selected;
    if (selected) {
      if (this.isHoverEffectShown())
        this.setSource(this.GetMarkerImage(DvtMarker.IMAGE_SOURCE_HOVER_SELECTED));
      else 
        this.setSource(this.GetMarkerImage(DvtMarker.IMAGE_SOURCE_SELECTED));
    }
    else {
      this.setSource(this.GetMarkerImage(DvtMarker.IMAGE_SOURCE));
    }
  }
  else 
    DvtMarker.superclass.setSelected.call(this, selected);
}

/**
 * Specifies the color of the data item and its selection feedback, if different from the default.
 * @param {string} dataColor The CSS color string of the primary color of the data item.
 * @param {string} innerColor The CSS color string of the inner color of the selection effect.
 * @param {string} outerColor The CSS color string of the outer color of the selection effect.
 */
DvtMarker.prototype.setDataColor = function (dataColor, innerColor, outerColor) {
  this._dataColor = dataColor;
  var hoverColor = DvtColorUtils.adjustHSL(dataColor, 0, 0, 0.15);
  var sis = new DvtSolidStroke('#FFFFFF', 1, 1.5);
  this.setHoverStroke(new DvtSolidStroke(hoverColor, 1, 2));
  this.setSelectedStroke(sis, new DvtSolidStroke('#5A5A5A', 1, 4.5));
  this.setSelectedHoverStroke(sis, new DvtSolidStroke(hoverColor, 1, 4.5));
  this.HoverInnerStroke.setFixedWidth(true);
  this.SelectedInnerStroke.setFixedWidth(true);
  this.SelectedOuterStroke.setFixedWidth(true);
  this.SelectedHoverInnerStroke.setFixedWidth(true);
  this.SelectedHoverOuterStroke.setFixedWidth(true);
}

/**
 * Get the data color used as a base for selection colors.
 *
 * @type string
 */
DvtMarker.prototype.getDataColor = function () {
  return this._dataColor;
}

/**  
 * Changes the shape to an outline shape format.  Used for legend
 * markers that represent a hidden state for the associated series risers.
 * @param {String} color Border color for hollow shape in format of #aarrggbb
 * @override
 */
DvtMarker.prototype.setHollow = function (color) {
  //scale the stroke width inversely proportional to the marker scale
  //so that the stroke width appears to be the same for all markers
  var scaleX = this.getScaleX();
  var scaleY = this.getScaleY();
  var scale = Math.min(scaleX, scaleY);
  var strokeWidth = this.GetStrokeWidth();
  strokeWidth = (strokeWidth ? strokeWidth : 1) / scale;
  
  //save the stroke width so that we can reset it if needed
  DvtMarker.superclass.setHollow.call(this, color, strokeWidth);
}

/**  Adds reference for legend text to marker
 *  @param {DvtText} text Legend text
 */
DvtMarker.prototype.setText = function (text) {
  this._markerText = text;
}

/**  Adds reference for legend text to marker
 *  @param {number} alpha Opacity of object
 *  @override
 */
DvtMarker.prototype.setAlpha = function (alpha) {
  DvtMarker.superclass.setAlpha.call(this, alpha);
  if (this._markerText)
    this._markerText.setAlpha(alpha);
  this.UpdateSelectionEffect();
}

/**
 * @private
 */
DvtMarker.prototype._setCx = function (cx) {
  DvtToolkitUtils.setAttrNullNS(this._elem, 'cx', cx);
};

/**
 * @private
 */
DvtMarker.prototype._setCy = function (cy) {
  DvtToolkitUtils.setAttrNullNS(this._elem, 'cy', cy);
};

/**
 * @private
 */
DvtMarker.prototype._setX = function (x) {
  DvtToolkitUtils.setAttrNullNS(this._elem, 'x', x);
};

/**
 * @private
 */
DvtMarker.prototype._setY = function (y) {
  DvtToolkitUtils.setAttrNullNS(this._elem, 'y', y);
};

/**
 * @private
 */
DvtMarker.prototype._setWidth = function (w) {
  DvtToolkitUtils.setAttrNullNS(this._elem, 'width', w);
};

/**
 * @private
 */
DvtMarker.prototype._setHeight = function (h) {
  DvtToolkitUtils.setAttrNullNS(this._elem, 'height', h);
};

/**
 * @private
 */
DvtMarker.prototype._setRadius = function (r) {
  DvtToolkitUtils.setAttrNullNS(this._elem, 'r', r);
};

/**
 *   @private
 */
DvtMarker.prototype._setPolygon = function (ar) {
  var sPoints = DvtSvgShapeUtils.convertPointsArray(ar);
  DvtToolkitUtils.setAttrNullNS(this._elem, 'points', sPoints);
};

/**
 *   @private
 */
DvtMarker.prototype._setCmds = function (cmds) {
  if (cmds !== this._cmds) {
    this._cmds = cmds;
    DvtToolkitUtils.setAttrNullNS(this._elem, 'd', cmds);
  }
};

DvtMarker.prototype.UpdateMarkerImage = function (imgSrc) {
  this.setSource(imgSrc);
}

/**
 * Updates the marker image source based on the current selection state
 * @param {string} src The image uri to set for the current marker state
 */
DvtMarker.prototype.setSource = function (src) {
  if (DvtAgent.isEnvironmentBatik()) {
    var imageInfo = DvtJavaImageLoader.getImageInfo(src);
    if (imageInfo)
      src = imageInfo.uri;
  }
  DvtToolkitUtils.setAttrNS(this._elem, DvtImage.XLINK_NS, 'xlink:href', src);
}

/**
 * Converts the specified shape string to its constant value.
 * @param {string} shape The shape string.
 * @return {number} The corresponding constant value.
 */
DvtMarker.convertShapeString = function (shape) {
  if (shape == DvtMarker.CIRCLE || shape == "c")
    return DvtMarker.CIRCLE;
  else if (shape == DvtMarker.SQUARE || shape == "s")
    return DvtMarker.SQUARE;
  else if (shape == DvtMarker.DIAMOND || shape == "d")
    return DvtMarker.DIAMOND;
  else if (shape == DvtMarker.TRIANGLE_UP || shape == "tu" || shape == "t")
    return DvtMarker.TRIANGLE_UP;
  else if (shape == DvtMarker.TRIANGLE_DOWN || shape == "td")
    return DvtMarker.TRIANGLE_DOWN;
  else if (shape == DvtMarker.PLUS || shape == "p")
    return DvtMarker.PLUS;
  else if (shape == DvtMarker.HUMAN || shape == "h")
    return DvtMarker.HUMAN;
  else if (shape == DvtMarker.ROUNDED_RECTANGLE || shape == "rr")
    return DvtMarker.ROUNDED_RECTANGLE;
  else 
    return DvtMarker.NONE;
}

/**
 * @override
 */
DvtMarker.prototype.GetAttributesTransferableToGroup = function () {
  var attrNames = DvtContainer.AttributesTransferableToGroup.slice(0);
  // Check to see if matrix set since we don't transfer the 'transform' attr, bc it affects the clip path for custom markers.
  if (!this.getMatrix()) {
    var transformIndex = DvtArrayUtils.getIndex(attrNames, 'transform');
    attrNames.splice(transformIndex, 1);
  }
  var visibilityIndex = DvtArrayUtils.getIndex(attrNames, 'visibility');
  attrNames.splice(visibilityIndex, 1);
  return attrNames;
}

/**
 * Sets whether mouse events are enabled on this object.
 * @param {boolean} whether mouse events are enabled
 */
DvtMarker.prototype.setMouseEnabled = function (bEnabled) {
  DvtMarker.superclass.setMouseEnabled.call(this, bEnabled);
  if (this._childGroupElem) {
    var val;
    if (bEnabled) {
      val = "visiblePainted";
    }
    else {
      val = "none";
    }
    DvtToolkitUtils.setAttrNullNS(this._childGroupElem, "pointer-events", val);
  }
}

DvtMarker.prototype._setCustomMarker = function (markerDef, x, y, sx, sy) {
  if (this._isMultiPaths()) {
    var root = this._cloneMultiPaths(markerDef, x, y, sx, sy);
    this.addChild(root);

    // return container of multi paths
    return root;
  }
  else {
    this._setSingleShape(markerDef, x, y, sx, sy);
    return null;
  }
}

DvtMarker.prototype._setSingleShape = function (markerDef, x, y, sx, sy) {
  var type = markerDef.getElem().nodeName;

  if (type == DvtMarker.MARKER_PATH_ELEM_NAME) {
    this._setCmds(DvtPathUtils.transformPath(markerDef.getCmds(), x, y, sx, sy));
  }
  /*
  else if (type == DvtMarker.MARKER_CIRCLE_ELEM_NAME ||
           type == DvtMarker.MARKER_ELLIPSE_ELEM_NAME) {
    this._setCx(markerDef.getCx());
    this._setCy(markerDef.getCy());
    this._setRadius(markerDef.getRadius());
  }

  else if (type == DvtMarker.MARKER_LINE_ELEM_NAME) {
    this._setX1(defImpl.getX1());
    this._setX2(defImpl.getX2());
    this._setY1(defImpl.getY1());
    this._setY2(defImpl.getY2());
  }
  else if (type == DvtMarker.MARKER_POLYGON_ELEM_NAME) {
    this._setPoints(defImpl._sPoints);
  }
  else if (type == DvtMarker.MARKER_POLYLINE_ELEM_NAME) {
    this._setPoints(defImpl._sPoints);
  }
  else if (type == DvtMarker.MARKER_RECT_TYPE_ELEM_NAME) {
    this._setX(markerDef.getX());
    this._setY(markerDef.getY());
    this._setWidth(markerDef.getWidth());
    this._setHeight(markerDef.getHeight());
  }
  */

  var fill = markerDef.getFill();
  if (fill) {
    this.setFill(fill);
  }
  var alpha = markerDef.getAlpha();
  if (alpha) {
    this.setAlpha(alpha);
  }
  var stroke = markerDef.getStroke();
  if (stroke) {
    var scaledStroke = stroke.clone();
    scaledStroke.setWidth(Math.min(sx, sy) * scaledStroke.getWidth());
    this.setStroke(scaledStroke);
  }
};

/**
 *   @private
 */
DvtMarker.prototype._setPoints = function (points) {
  if (points !== this._points) {
    this._points = points;
    DvtToolkitUtils.setAttrNullNS(this._elem, 'points', points);
  }
};

/**
 * @private
 */
DvtMarker.prototype._setX1 = function (x1) {
  DvtToolkitUtils.setAttrNullNS(this._elem, 'x1', x1);
};

/**
 * @private
 */
DvtMarker.prototype._setY1 = function (y1) {
  DvtToolkitUtils.setAttrNullNS(this._elem, 'y1', y1);
};

/**
 * @private
 */
DvtMarker.prototype._setX2 = function (x2) {
  DvtToolkitUtils.setAttrNullNS(this._elem, 'x2', x2);
};

/**
 * @private
 */
DvtMarker.prototype._setY2 = function (y2) {
  DvtToolkitUtils.setAttrNullNS(this._elem, 'y2', y2);
};

/**
 * @private
 */
DvtMarker.prototype._setRX = function (rx) {
  DvtToolkitUtils.setAttrNullNS(this._elem, 'rx', rx);
};

/**
 * @private
 */
DvtMarker.prototype._setRY = function (ry) {
  DvtToolkitUtils.setAttrNullNS(this._elem, 'ry', ry);
};

/**
 * @private
 */
DvtMarker.prototype._cloneMultiPaths = function (markerDef, x, y, sx, sy) {
  var context = this.getCtx();
  var root = new DvtContainer(context, markerDef.getId() + "_x");

  var childCnt = markerDef.getNumChildren();
  var childDef;
  var child;
  for (var i = 0;i < childCnt;i++) {
    childDef = markerDef.getChildAt(i);
    child = new DvtPath(context, DvtPathUtils.transformPath(childDef.getCmds(), x, y, sx, sy), childDef.getId());

    if (childDef.getFill()) {
      child.setFill(childDef.getFill());
    }
    if (childDef.getAlpha()) {
      child.setAlpha(childDef.getAlpha());
    }
    if (childDef.getStroke()) {
      var scaledStroke = childDef.getStroke().clone();
      scaledStroke.setWidth(Math.min(sx, sy) * scaledStroke.getWidth());
      child.setStroke(scaledStroke);
    }
    root.addChild(child);
  }

  return root;
}

/**
 * @override
 */
DvtMarker.prototype.addChild = function (obj) {
  // if this marker has multi paths, don't add an additonal childGroupElem
  if (this._isMultiPaths()) {
    DvtToolkitUtils.appendChildElem(this._elem, obj.getOuterElem());
  }
  else {
    DvtMarker.superclass.addChild.call(this, obj);
  }
};

DvtMarker.prototype._isMultiPaths = function () {
  return (this.getElem().nodeName == "g" && this.getType() != DvtMarker.IMAGE);
};

/**
 * @override
 */
DvtMarker.prototype.getDimensions = function () {
  // Added in order to prevent getDimensions returning null or a 0 width and height while waiting for an image load
  if (this._type == DvtMarker.IMAGE) {
    var w = this.getScaledWidth();
    var h = this.getScaledHeight()
    return new DvtRectangle(this._x, this._y, w, h);
  }
  else {
    return DvtMarker.superclass.getDimensions.call(this);
  }
}

/**
 * @override
 */
DvtMarker.prototype.GetElemDimensionsWithStroke = function () {
  if (this._type == DvtMarker.IMAGE)
    return this.getDimensions();// images don't have borders
  else 
    return DvtMarker.superclass.GetElemDimensionsWithStroke.call(this);
}
/**
 *  Enables/disables the visibility of marker and text if reference exists.
 *  @param {Boolean}  bVis  True if the object is to be visible, else false if
 *  it is to be hidden.
 *  @override
 */
DvtMarker.prototype.setVisible = function (bVis) {
  DvtMarker.superclass.setVisible.call(this, bVis);
  if (this._markerText)
    this._markerText.setVisible(bVis);
}

DvtMarker.prototype._setMarkerImageStates = function (imageURIs) {
  // at a minimum an image URI will be provided for the active marker state
  var sourceImage = imageURIs[0];
  this._imageStates = [sourceImage];
  this._imageStates.push(imageURIs[1] ? imageURIs[1] : sourceImage);// sourceSelected
  this._imageStates.push(imageURIs[2] ? imageURIs[2] : sourceImage);// sourceHover
  this._imageStates.push(imageURIs[3] ? imageURIs[3] : this._imageStates[1]);// sourceHoverSelected
}

DvtMarker.prototype.GetMarkerImage = function (state) {
  if (this._imageStates)
    return this._imageStates[state];
  return null;
}

/**
 * Determines if the specified marker shape is a built-in shape.
 * @param {string} shape The shape. For custom markers this would be the shape path.
 * @return {boolean} True if shape is built-in.
 */
DvtMarker.isBuiltInShape = function (shape) {
  var shp = DvtMarker.convertShapeString(shape);
  if (shp == DvtMarker.CIRCLE || shp == DvtMarker.SQUARE || shp == DvtMarker.DIAMOND || shp == DvtMarker.TRIANGLE_UP || shp == DvtMarker.TRIANGLE_DOWN || shp == DvtMarker.PLUS || shp == DvtMarker.HUMAN || shp == DvtMarker.ROUNDED_RECTANGLE) {
    return true;
  }
  else {
    return false;
  }
}

/**
 * @override
 */
DvtMarker.prototype.copyShape = function () {
  return new DvtMarker(this.getCtx(), this.getInitType(), this.getSkin(), this.getX(), this.getY(), this.getWidth(), this.getHeight(), null, this.getSx(), this.getSy(), this.getMaintainAspect());
}

/**
 * @override
 */
DvtMarker.prototype.getDimensions = function (targetCoordinateSpace) {
  // Transforms on markers are not transferred to the outer group element so we must return dimensions of child 
  // element which has the matrix
  if (this.InnerShape && this.InnerShape.getParent())
    return this.InnerShape.getDimensions(targetCoordinateSpace);
  else 
    return DvtMarker.superclass.getDimensions.call(this, targetCoordinateSpace);
}

/**
 * Returns the bounds of the displayable relative to the target coordinate space.  If the target
 * coordinate space is not specified, returns the bounds relative to this displayable.  This function does not take
 * into account any child displayables.
 * @param {DvtDisplayable} targetCoordinateSpace The displayable defining the target coordinate space.
 * @return {DvtRectangle} The bounds of the displayable relative to the target coordinate space.
 */
DvtMarker.prototype.getDimensionsSelf = function (targetCoordinateSpace) {
  // Note: In the near future, we will not support children for shapes, so this routine will be refactored into the
  //       existing getDimensions calls.  For now, components must be aware of the presence of children to use this.
  var bounds = new DvtRectangle(this.getX(), this.getY(), this.getScaledWidth(), this.getScaledHeight());
  return this.ConvertCoordSpaceRect(bounds, targetCoordinateSpace);
}
// Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.
/**
 * Ellipse displayable.
 * @param {DvtContext} context
 * @param {number} cx The x coordinate of the center of the circle.
 * @param {number} cy The y coordinate of the center of the circle.
 * @param {number} rx The horizontal radius of the circle. 
 * @param {number} ry The vertical radius of the circle. 
 * @param {string} [id] The optional id for the corresponding DOM element.
 * @extends DvtCircularShape
 * @class
 * @constructor
 */
var DvtOval = function (context, cx, cy, rx, ry, id) {
  this.Init(context, cx, cy, rx, ry, id);
}

DvtObj.createSubclass(DvtOval, DvtCircularShape, "DvtOval");

/**
 * @param {DvtContext} context
 * @param {number} cx The x coordinate of the center of the circle.
 * @param {number} cy The y coordinate of the center of the circle.
 * @param {number} rx The horizontal radius of the circle.
 * @param {number} ry The vertical radius of the circle.
 * @param {string} [id] The optional id for the corresponding DOM element.
 * @protected
 */
DvtOval.prototype.Init = function (context, cx, cy, rx, ry, id) {
  DvtOval.superclass.Init.call(this, context, 'ellipse', cx, cy, id);
  this.setRx(rx).setRy(ry);
}

/**
 * Returns the horizontal radius of the ellipse.
 * @return {number}
 */
DvtOval.prototype.getRx = function () {
  return this.GetProperty('rx');
}

/**
 * Specifies the horizontal radius of the ellipse.
 * @param {number} rx
 * @return {DvtOval}
 */
DvtOval.prototype.setRx = function (rx) {
  return this.SetSvgProperty('rx', rx);
}

/**
 * Returns the vertical radius of the ellipse.
 * @return {number}
 */
DvtOval.prototype.getRy = function () {
  return this.GetProperty('ry');
}

/**
 * Specifies the vertical radius of the ellipse.
 * @param {number} ry
 * @return {DvtOval}
 */
DvtOval.prototype.setRy = function (ry) {
  return this.SetSvgProperty('ry', ry);
}

/**
 * @override
 */
DvtOval.prototype.copyShape = function () {
  return new DvtOval(this.getCtx(), this.getCx(), this.getCy(), this.getRx(), this.getRy());
}

/**
 * Returns the bounds of the displayable relative to the target coordinate space.  If the target
 * coordinate space is not specified, returns the bounds relative to this displayable.  This function does not take
 * into account any child displayables.
 * @param {DvtDisplayable} targetCoordinateSpace The displayable defining the target coordinate space.
 * @return {DvtRectangle} The bounds of the displayable relative to the target coordinate space.
 */
DvtOval.prototype.getDimensionsSelf = function (targetCoordinateSpace) {
  // Note: In the near future, we will not support children for shapes, so this routine will be refactored into the
  //       existing getDimensions calls.  For now, components must be aware of the presence of children to use this.
  var bounds = new DvtRectangle(this.getCx() - this.getRx(), this.getCy() - this.getRy(), this.getRx() * 2, this.getRy() * 2);
  return this.ConvertCoordSpaceRect(bounds, targetCoordinateSpace);
}
// Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.
/**
 * Path displayable.
 * @param {DvtContext} context
 * @param {object} cmds The string of SVG path commands or an array of SVG path commands, whose entries contain the 
 *                      commands followed by coordinates.
 * @param {string} [id] The optional id for the corresponding DOM element.
 * @extends DvtShape
 * @class
 * @constructor
 */
var DvtPath = function (context, cmds, id) {
  this.Init(context, cmds, id);
}

DvtObj.createSubclass(DvtPath, DvtShape, "DvtPath");

/**
 * @param {DvtContext} context
 * @param {object} cmds The string of SVG path commands or an array of SVG path commands, whose entries contain the 
 *                      commands followed by coordinates.
 * @param {string} [id] The optional id for the corresponding DOM element.
 */
DvtPath.prototype.Init = function (context, cmds, id) {
  DvtPath.superclass.Init.call(this, context, 'path', id);
 
  if (DvtArrayUtils.isArray(cmds))
    this.setCmds(DvtPathUtils.getPathString(cmds));
  else 
    this.setCmds(cmds);
}

/**
 * Returns the string of SVG path commands.
 * @param {string} cmds
 */
DvtPath.prototype.getCmds = function () {
  return this.GetProperty('d');
}

/**
 * Specifies the string of SVG path commands.
 * @param {String} cmds
 * @return {DvtPath}
 */
DvtPath.prototype.setCmds = function (cmds) {
  if(cmds)
    this.SetSvgProperty('d', cmds);

  // Clear the cached array commands, which will be populated when needed.
  this.SetProperty('arCmds', null);
  
  // Return self for linking setters
  return this;
}

/**
 * Returns the array of SVG path commands, whose entries contain the commands followed by coordinates.
 * @return {array}
 */
DvtPath.prototype.getCommands = function () {
  // TODO HZHANG rename to get/setCommandsArray
  
  // If cached copy exists, use it.
  var arCmds = this.GetProperty('arCmds');
  if(!arCmds) {
    // Otherwise, convert, cache and return.
    arCmds = this.GetProperty('d') ? DvtPathUtils.createPathArray(this.GetProperty('d')) : null;
    this.SetProperty('arCmds', arCmds);
  }
  return arCmds;
}

/**
 * Specifies the array of SVG path commands, whose entries contain the commands followed by coordinates.
 * @param {array} arCmds
 * @return {DvtPath}
 */
DvtPath.prototype.setCommands = function (arCmds) {
  // Convert to string and set
  var cmds = arCmds ? DvtPathUtils.getPathString(arCmds) : null;
  this.setCmds(cmds);

  // Cache the array
  this.SetProperty('arCmds', arCmds);
  
  // Return self for linking setters
  return this;
}

/**
 * @override
 */
DvtPath.prototype.copyShape = function () {
  return new DvtPath(this.getCtx(), this.getCmds());
}
// Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.
/**
 * Polygon displayable.
 * @param {DvtContext} context
 * @param {array} arPoints The array of coordinates for this polygon, in the form [x1,y1,x2,y2...].
 * @param {string} [id] The optional id for the corresponding DOM element.
 * @extends DvtPolygonalShape
 * @class
 * @constructor
 */
var DvtPolygon = function (context, arPoints, id) {
  this.Init(context, arPoints, id);
}

DvtObj.createSubclass(DvtPolygon, DvtPolygonalShape, "DvtPolygon");

/**
 * @param {DvtContext} context
 * @param {array} arPoints The array of coordinates for this polygon, in the form [x1,y1,x2,y2...].
 * @param {string} [id] The optional id for the corresponding DOM element.
 * @protected
 */ 
DvtPolygon.prototype.Init = function (context, arPoints, id) {
  DvtPolygon.superclass.Init.call(this, context, 'polygon', arPoints, id);
}

/**
 * @override
 */
DvtPolygon.prototype.copyShape = function()
{
  return new DvtPolygon(this.getCtx(), this.getPoints());
}
// Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.
/**
 * Polyline displayable.
 * @param {DvtContext} context
 * @param {array} arPoints The array of coordinates for this polyline, in the form [x1,y1,x2,y2...].
 * @param {string} [id] The optional id for the corresponding DOM element.
 * @extends DvtPolygonalShape
 * @class
 * @constructor
 */
var DvtPolyline = function (context, arPoints, id) {
  this.Init(context, arPoints, id);
}

DvtObj.createSubclass(DvtPolyline, DvtPolygonalShape, "DvtPolyline");

/**
 * @param {DvtContext} context
 * @param {array} arPoints The array of coordinates for this polyline, in the form [x1,y1,x2,y2...].
 * @param {string} [id] The optional id for the corresponding DOM element.
 * @protected
 */ 
DvtPolyline.prototype.Init = function (context, arPoints, id) {
  DvtPolyline.superclass.Init.call(this, context, 'polyline', arPoints, id);
  DvtToolkitUtils.setAttrNullNS(this._elem, 'fill', 'none') ;
}

/**
 * @override
 */
DvtPolyline.prototype.copyShape = function()
{
  return new DvtPolyline(this.getCtx(), this.getPoints());
}
// Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.
/**
 * Rectangle displayable.
 * @param {DvtContext} context
 * @param {number} x
 * @param {number} y
 * @param {number} w
 * @param {number} h
 * @param {string} [id] The optional id for the corresponding DOM element.
 * @extends DvtShape
 * @class
 * @constructor
 */
var DvtRect = function (context, x, y, w, h, id) {
  this.Init(context, x, y, w, h, id);
}

DvtObj.createSubclass(DvtRect, DvtShape, "DvtRect");

DvtRect._cssAttrs = ["background-color", "border-color", "border-width"];

/**
 * @param {DvtContext} context
 * @param {number} x
 * @param {number} Y
 * @param {number} w
 * @param {number} h
 * @param {string} [id] The optional id for the corresponding DOM element.
 * @protected
 */
DvtRect.prototype.Init = function (context, x, y, w, h, id) {
  DvtRect.superclass.Init.call(this, context, 'rect', id);
  this.setX(x).setY(y).setWidth(w).setHeight(h);
}

/**
 * Returns the x coordinate of the rectangle.
 * @return {number}
 */
DvtRect.prototype.getX = function () {
  return this.GetProperty('x');
}

/**
 * Specifies the x coordinate of the rectangle.
 * @param {number} x
 * @return {DvtRect}
 */
DvtRect.prototype.setX = function (x) {
  return this.SetSvgProperty('x', x, 0);  
}

/**
 * Returns the y coordinate of the rectangle.
 * @return {number}
 */
DvtRect.prototype.getY = function () {
  return this.GetProperty('y');
}

/**
 * Specifies the y coordinate of the rectangle.
 * @param {number} y
 * @return {DvtRect}
 */
DvtRect.prototype.setY = function (y) {
  return this.SetSvgProperty('y', y, 0);
}

/**
 * Returns the width of the rectangle.
 * @return {number}
 */
DvtRect.prototype.getWidth = function () {
  return this.GetProperty('width');
}

/**
 * Specifies the width of the rectangle.
 * @param {number} w
 * @return {DvtRect}
 */
DvtRect.prototype.setWidth = function (w) {
  return this.SetSvgProperty('width', w);
}

/**
 * Returns the height of the rectangle.
 * @return {number}
 */
DvtRect.prototype.getHeight = function () {
  return this.GetProperty('height');
}

/**
 * Specifies the height of the rectangle.
 * @param {number} h
 * @return {DvtRect}
 */
DvtRect.prototype.setHeight = function (h) {
  return this.SetSvgProperty('height', h);
}

/**
 * Returns the horizontal radius of the rounded corners, if any.
 * @return {number}
 */ 
DvtRect.prototype.getRx = function () {
  return this.GetProperty('rx');
}

/**
 * Specifies the horizontal radius of the rounded corners, if any.
 * @param {number} rx
 * @return {DvtRect}
 */ 
DvtRect.prototype.setRx = function (rx) {
  return this.SetSvgProperty('rx', rx);
}

/**
 * Returns the vertical radius of the rounded corners, if any.
 * @return {number}
 */ 
DvtRect.prototype.getRy = function () {
  return this.GetProperty('ry');
}

/**
 * Specifies the vertical radius of the rounded corners, if any.
 * @param {number} ry
 * @return {DvtRect}
 */ 
DvtRect.prototype.setRy = function (ry) {
  return this.SetSvgProperty('ry', ry);
}

/**
 * Sets the DvtCSSStyle of this object.
 * @param {DvtCSSStyle} style The DvtCSSStyle of this object.
 */
DvtRect.prototype.setCSSStyle = function (style) {
  DvtRect.superclass.setCSSStyle.call(this, style);

  // TODO HZHANG CLEANUP: This code seems to apply to all shapes.  It's unclear why we only support it here.
  var elem = this._elem;
  if (style) {
    var val = style.getStyle("background-color");
    if (val) {
      DvtToolkitUtils.setAttrNullNS(elem, "fill", val);
    }
    val = style.getStyle("border-color");
    if (val) {
      DvtToolkitUtils.setAttrNullNS(elem, "stroke", val);
    }
    val = style.getStyle("border-width");
    if (val) {
      DvtToolkitUtils.setAttrNullNS(elem, "stroke-width", val);
    }

    //bug 13826956 - border-radius css property not supported when used inside <dvt:node>
    val = style.getStyle("border-radius");
    if (val) {
      var radArr = DvtStringUtils.trim(val).split(" ");
      if (radArr.length > 0 && radArr[0]) {
        this.setRx(radArr[0]);
      }
      if (radArr.length > 1 && radArr[1]) {
        this.setRy(radArr[1]);
      }
    }
  }
  else {
    DvtToolkitUtils.removeAttrNullNS(this._elem, "style");
  }
}

/**
  *  Sets the top left position of the rectangle.
  *  @param {number} x  The <code>x</code> coordinate of the top left coordinate of the rectangle.
  *  @param {number} y  The <code>y</code> coordinate of the top left coordinate of the rectangle.
  */
DvtRect.prototype.setPos = function(x,y)
{
   this.setX(x).setY(y); // TODO HZHANG CLEANUP/NECESSARY?
}

/**
  *  Sets the corner radius value(s) to create rounded corners.
  *  @param {number} rx  The horizontal (x) radius.
  *  @param {number} ry  Optional: The vertical (y) radius. if omitted the rx
  *                      value is used.
  */
DvtRect.prototype.setCornerRadius = function(rx, ry)
{
   this.setRx(rx).setRy(ry); // TODO HZHANG CLEANUP/NECESSARY?
} 

/**
  *  Sets the position and size of the rectangle.
  *  May be specified as individual values or using a DvtRectangle object.
  *  <p>
  *  Example<br><br><code>
  *  rect.setRect(10, 10, 50, 100) ; &nbsp;  or<br>
  *  <br>
  *  rect.setRect(myRect) ; &nbsp; &nbsp;  where myRect = new DvtRectangle(10, 10, 50, 100);<br>
  *
  *  @param {number} x  The x position of the top left corner of the rectangle.
  *  @param {number} y  The y position of the top left corner of the rectangle.
  *  @param {number} w  The width of the rectangle.
  *  @param {number} h  The height of the rectangle.
  */
DvtRect.prototype.setRect = function(x,y,w,h)
{
  // TODO HZHANG CLEANUP/NECESSARY?
   if (x instanceof DvtRectangle) {
     this.setX(x.x).setY(x.y).setWidth(x.w).setHeight(x.h);
   }
   else {
     this.setX(x).setY(y).setWidth(w).setHeight(h) ;
   }
}

/**
 * @override
 */
DvtRect.prototype.copyShape = function()
{
  var copy = new DvtRect(this.getCtx(), this.getX(), this.getY(), this.getWidth(), this.getHeight());
  copy.setRx(this.getRx()).setRy(this.getRy());
  return copy;
}

/**
 * Returns the bounds of the displayable relative to the target coordinate space.  If the target
 * coordinate space is not specified, returns the bounds relative to this displayable.  This function does not take
 * into account any child displayables.
 * @param {DvtDisplayable} targetCoordinateSpace The displayable defining the target coordinate space.
 * @return {DvtRectangle} The bounds of the displayable relative to the target coordinate space.
 */
DvtRect.prototype.getDimensionsSelf = function (targetCoordinateSpace) {
  // Note: In the near future, we will not support children for shapes, so this routine will be refactored into the
  //       existing getDimensions calls.  For now, components must be aware of the presence of children to use this.
  var bounds = new DvtRectangle(this.getX(), this.getY(), this.getWidth(), this.getHeight());
  return this.ConvertCoordSpaceRect(bounds, targetCoordinateSpace);
}
// Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.
/**
 * Creates an instance of DvtOutputText.
 * @extends DvtShape
 * @class DvtOutputText
 * @constructor
 * @param {DvtContext} context
 * @param {string} textString
 * @param {number} x  
 * @param {number} y  
 * @param {string} id
 */
var DvtOutputText = function (context, textStr, x, y, id) {
  this.Init(context, textStr, x, y, id);
}

DvtObj.createSubclass(DvtOutputText, DvtShape, "DvtOutputText");

DvtOutputText.ELLIPSIS = "...";

// Horizontal Alignments
DvtOutputText.H_ALIGN_LEFT = 'left';
DvtOutputText.H_ALIGN_CENTER = 'center';
DvtOutputText.H_ALIGN_RIGHT = 'right';
DvtOutputText.H_ALIGN_DEFAULT = DvtOutputText.H_ALIGN_LEFT;

// Vertical Alignments
DvtOutputText.V_ALIGN_TOP = 'top';
DvtOutputText.V_ALIGN_MIDDLE = 'middle';
DvtOutputText.V_ALIGN_BOTTOM = 'bottom';
DvtOutputText.V_ALIGN_BASELINE = 'baseline';
DvtOutputText.V_ALIGN_DEFAULT = DvtOutputText.V_ALIGN_TOP;

/**
 * @param {DvtContext} context
 * @param textStr {string} the text string
 * @param x {number} x
 * @param y {number} y
 * @param {string} [id] The optional id for the corresponding DOM element.
 * @protected
 */
DvtOutputText.prototype.Init = function (context, textStr, x, y, id) {
  DvtOutputText.superclass.Init.call(this, context, 'text', id);
  this._context = context;
  this.setTextString(textStr);
  this.setX(x);
  this.setY(y);


  //Bug 13879007 - NODE RENDERED INCORRECTLY IN IE9
  this._baseline = null;
  //FIX BUG 16856961: additional pixel offset for baseline, currently only
  //specified by DvtOutputTextArea subclass
  this._baselineOffset = null;

  // Initialize the alignment attrs.  Our impl defaults to start and baseline, so set the alignment if the defaults
  // don't match the impl defaults.
  this._horizAlign = DvtOutputText.H_ALIGN_DEFAULT;
  if (DvtOutputText.H_ALIGN_DEFAULT != DvtOutputText.H_ALIGN_LEFT)
    this.setHorizAlignment(DvtOutputText.H_ALIGN_DEFAULT);

  this._vertAlign = DvtOutputText.V_ALIGN_DEFAULT;
  if (DvtOutputText.V_ALIGN_DEFAULT != DvtOutputText.V_ALIGN_BASELINE)
    this.setVertAlignment(DvtOutputText.V_ALIGN_DEFAULT);

  // TODO this should be defined elsewhere
  // cursor is needed for chrome, but should be dependent on interactivity
  DvtToolkitUtils.setAttrNullNS(this.getElem(), "font-family", "tahoma, sans-serif");

  // TODO hzhang: Remove this workaround and the incorrect none default in DvtSvgShape.
  // Workaround to remove some strange defaulting for the fill, which is set to none in DvtSvgShape.Init.
  DvtToolkitUtils.removeAttrNullNS(this.getElem(), "fill");

  // fix for bug 14528150 (the chrome case) and 14297988 (the ie case)
  if (DvtAgent.isRightToLeft(context)) {
    if (DvtOutputText.needsTextAnchorAdjustment(context)){
      this.alignLeft();
      if (DvtAgent.isPlatformIE())
        DvtToolkitUtils.setAttrNullNS(this.getElem(), "unicode-bidi", "embed");
    }
    else 
      DvtToolkitUtils.setAttrNullNS(this.getElem(), "unicode-bidi", "embed");
  }
}

/**
 * Returns the text string for this text object.
 * @return {string} the text string
 */
DvtOutputText.prototype.getTextString = function () {
  return this._textString;
}

/**
 * Specifies the text string for this text object.
 * @param {string} textString the text string
 * @return {DvtOutputText}
 */
DvtOutputText.prototype.setTextString = function (textString) {
  if (textString != null)
    textString = String(textString);
  
  if (DvtOutputText.needsTextAnchorAdjustment(this._context) && !this._hintAdded){
    textString = "\u200B" + textString;
    this._hintAdded = true;
  }
        
  this._textString = textString;

  // Update the text node if it is already created
  var textNode = this.getElem().firstChild;
  if (textNode !== null) {
    textNode.nodeValue = textString;
  }
  else {
    // Otherwise create it
    textNode = document.createTextNode(textString);
    DvtToolkitUtils.appendChildElem(this.getElem(), textNode);
  }
  
  return this;
}

/**
 * Returns true if this text instance has been truncated.  When truncated, the getUntruncatedTextString function can be
 * used to find the full text String.
 * @return {boolean}
 */
DvtOutputText.prototype.isTruncated = function () {
  return this.getUntruncatedTextString() != null;
}

/**
 * Returns the untruncated text string for this text object.  Returns null if the text string has not been truncated.
 * @return {string} the untruncated text string
 */
DvtOutputText.prototype.getUntruncatedTextString = function () {
  return this._untruncatedTextString;
}

/**
 * Specifies the untruncated text string for this text object. This should only be set if the DvtOutputText was
 * truncated by DvtTextUtils.
 * @param {string} textString the untruncated text string
 */
DvtOutputText.prototype.setUntruncatedTextString = function (textString) {
  if (textString != this.getTextString())
    this._untruncatedTextString = textString;
}

/**
 * Returns the x position for this text object.
 * @return {number} The x position.
 */
DvtOutputText.prototype.getX = function () {
  return this.GetProperty('x');
}

/**
 * Specifies the x position for this text object.
 * @param {number} x The x position
 * @return {DvtOutputText}
 */
DvtOutputText.prototype.setX = function (x) {
  return this.SetSvgProperty('x', x, 0);
}

/**
 * Returns the y position for this text object.
 * @return {number} The y position.
 */
DvtOutputText.prototype.getY = function () {
  return this.GetProperty('y');
}

/**
 * Specifies the y position for this text object.
 * @param {number} y The y position
 * @return {DvtOutputText}
 */
DvtOutputText.prototype.setY = function (y) {
  return this.SetSvgProperty('y', y, 0);
}

/**
 * Convenience function for specifying the font size. This function will clone the CSSStyle and apply it to the component.
 * @param {string} size The font-size which can be in the format '9', '9px', or 'xx-small'
 */
DvtOutputText.prototype.setFontSize = function (size) {
  var style = this.getCSSStyle();
  style = style ? style.clone() : new DvtCSSStyle();
  style.setFontSize(DvtCSSStyle.FONT_SIZE, String(size));
  this.setCSSStyle(style);
}

/**
 * Returns the horizontal alignment for this text object.  Valid constants begin with DvtOutputText.H_ALIGN_.
 * @return {string}
 */
DvtOutputText.prototype.getHorizAlignment = function () {
  return this._horizAlign;
}

/**
 * Specifies the horizontal alignment for this text object.  Valid constants begin with DvtOutputText.H_ALIGN_.
 * @param {string} align
 */
DvtOutputText.prototype.setHorizAlignment = function (align) {
  if (align == DvtOutputText.H_ALIGN_LEFT)
    this.alignLeft();
  else if (align == DvtOutputText.H_ALIGN_CENTER)
    this.alignCenter();
  else if (align == DvtOutputText.H_ALIGN_RIGHT)
    this.alignRight();
}

/**
 * Returns the vertical alignment for this text object.  Valid constants begin with DvtOutputText.V_ALIGN_.
 * @return {string} The horizontal alignment
 */
DvtOutputText.prototype.getVertAlignment = function () {
  return this._vertAlign;
}

/**
 * Specifies the vertical alignment for this text object.  Valid constants begin with DvtOutputText.V_ALIGN_.
 * @param {string} align
 */
DvtOutputText.prototype.setVertAlignment = function (align) {
  if (align == DvtOutputText.V_ALIGN_TOP)
    this.alignTop();
  else if (align == DvtOutputText.V_ALIGN_MIDDLE)
    this.alignMiddle();
  else if (align == DvtOutputText.V_ALIGN_BOTTOM)
    this.alignBottom();
  else if (align == DvtOutputText.V_ALIGN_BASELINE)
    this.alignBaseline();
}

/**
 * Aligns the left side of the text to the x coordinate. Note: This does not always correspond to what the browser
 * considers a "start" alignment, as we work around issues in rtl locales to provide a consistent API.
 */
DvtOutputText.prototype.alignLeft = function () {
  this._horizAlign = DvtOutputText.H_ALIGN_LEFT;

  // Bug 17776065: When html dir="rtl", Webkit and FF25+ treat the right side of the text as the start, and the left 
  // side of the text as end.  Our API always treats the left side as start, so we need to adjust based on agent.
  var bAdjust = DvtOutputText.needsTextAnchorAdjustment(this._context);
  DvtToolkitUtils.setAttrNullNS(this.getElem(), "text-anchor", bAdjust ? "end" : "start");
}

/**
 * Aligns the center of the text to the x coordinate.
 */
DvtOutputText.prototype.alignCenter = function () {
  this._horizAlign = DvtOutputText.H_ALIGN_CENTER;

  DvtToolkitUtils.setAttrNullNS(this.getElem(), "text-anchor", "middle");
}

/**
 * Aligns the right side of the text to the x coordinate. Note: This does not always correspond to what the browser
 * considers an "end" alignment, as we work around issues in rtl locales to provide a consistent API.
 */
DvtOutputText.prototype.alignRight = function () {
  this._horizAlign = DvtOutputText.H_ALIGN_RIGHT;

  // Bug 17776065: When html dir="rtl", Webkit and FF25+ treat the right side of the text as the start, and the left 
  // side of the text as end.  Our API always treats the left side as start, so we need to adjust based on agent.
  var bAdjust = DvtOutputText.needsTextAnchorAdjustment(this._context);
  DvtToolkitUtils.setAttrNullNS(this.getElem(), "text-anchor", bAdjust ? "start" : "end");
}

/**
 * Aligns the top of the text to the y coordinate.
 */
DvtOutputText.prototype.alignTop = function () {
  this._vertAlign = DvtOutputText.V_ALIGN_TOP;

  //Bug 13879007 - NODE RENDERED INCORRECTLY IN IE9
  if (DvtAgent.isPlatformIE()) {
    //+ font-size
    this.SetBaseline(1);
  }
  else
    this.SetDominantBaselineAttr("text-before-edge");
}

/**
 * Aligns the middle of the text to the y coordinate.
 */
DvtOutputText.prototype.alignMiddle = function () {
  this._vertAlign = DvtOutputText.V_ALIGN_MIDDLE;

  //Bug 13879007 - NODE RENDERED INCORRECTLY IN IE9
  if (DvtAgent.isPlatformIE()) {
    //+ 2/5 font-size
    this.SetBaseline(.4);
  }
  else 
    this.SetDominantBaselineAttr("middle");
}

/**
 * Aligns the bottom of the text to the y coordinate.
 */
DvtOutputText.prototype.alignBottom = function () {
  this._vertAlign = DvtOutputText.V_ALIGN_BOTTOM;

  //Bug 13879007 - NODE RENDERED INCORRECTLY IN IE9
  if (DvtAgent.isPlatformIE()) {
    //+ 1/5 font-size
    this.SetBaseline(.2);
  }
  else 
    this.SetDominantBaselineAttr("text-after-edge");
}

/**
 * Aligns the baseline of the text to the y coordinate.
 */
DvtOutputText.prototype.alignBaseline = function () {
  this._vertAlign = DvtOutputText.V_ALIGN_BASELINE;

  //Bug 13879007 - NODE RENDERED INCORRECTLY IN IE9
  if (DvtAgent.isPlatformIE()) {
    this.SetBaseline(0);
  }
  else
    this.SetDominantBaselineAttr(null);
}

/**
 * Save the baseline and adjust the matrix for vertical alignment in IE.
 * @protected
 */
DvtOutputText.prototype.SetBaseline = function (baseline) {
  this._baseline = baseline;
  this.setMatrix(this.getMatrix());
}

/**
 * Set the dominant baseline for vertical alignment.
 * @param {string} baseline The value of the dominant-baseline attribute
 * @protected
 */
DvtOutputText.prototype.SetDominantBaselineAttr = function (baseline) {
  if (baseline) 
    DvtToolkitUtils.setAttrNullNS(this.getElem(), "dominant-baseline", baseline);
  else 
    DvtToolkitUtils.removeAttrNullNS(this.getElem(), "dominant-baseline");
}

/**
 * Sets the DvtCSSStyle of this object.
 * @param {DvtCSSStyle} style The DvtCSSStyle of this object.
 */
DvtOutputText.prototype.setCSSStyle = function (style) {
  DvtOutputText.superclass.setCSSStyle.call(this, style);
  var elem = this.getOuterElem();

  if (style) {
    //NOTE: svg does not recognize css "color" attribute, use "fill" instead
    var val = style.getStyle("color");
    if (val)
      DvtToolkitUtils.setAttrNullNS(elem, "fill", val);

    val = style.getStyle("font-family");
    if (val) {
      DvtToolkitUtils.setAttrNullNS(elem, "font-family", val);
    }
    
    val = style.getStyle("font-size");
    if (val) {
      DvtToolkitUtils.setAttrNullNS(elem, "font-size", val);

      //Bug 13879007 - NODE RENDERED INCORRECTLY IN IE9
      if (DvtAgent.isPlatformIE()) {
        this.setMatrix(this.getMatrix());
      }
    }
    
    val = style.getStyle("font-style");
    if (val) {
      DvtToolkitUtils.setAttrNullNS(elem, "font-style", val);
    }
    
    val = style.getStyle("font-weight");
    if (val) {
      DvtToolkitUtils.setAttrNullNS(elem, "font-weight", val);
    }

    //NOTE: svg does not recognize css "text-align" attribute, 
    //call alignCenter, alignLeft, alignRight... if needed.
    //For multi line text, text-align is handled in DvtOutputTextArea
    val = style.getStyle("text-decoration");
    if (val) {
      //BUG 17988455 - FF: BREADCRUMBS: The underline is rendering above the text item. 
      // FF25+ does not render underline correctly when "text-rendering" attribute is set to "geometricPrecision"
      // The "text-rendering" is set on svg element for some components. See bug 16776435 for details.
      if (val !== "underline" || !(DvtAgent.isPlatformGecko() && DvtAgent.getVersion() >= 25 && this._context.getRootAttribute("text-rendering") === "geometricPrecision"))
        DvtToolkitUtils.setAttrNullNS(elem, "text-decoration", val);
    }

    val = style.getStyle("cursor");
    if (val) {
      DvtToolkitUtils.setAttrNullNS(elem, "cursor", val);
    }
  }
}

//Bug 13879007 - NODE RENDERED INCORRECTLY IN IE9
/**
 * Returns the y translation used to compensate for IE's lack of dominant-baseline support
 * 
 * @return {number} the y translation
 */
DvtOutputText.prototype._getBaselineTranslation = function () {
  //if not in IE, no adjustment required
  var dy = 0;
  if (this._baseline != null) {
    //default fontSize to 11px
    var fontSize = DvtToolkitUtils.getAttrNullNS(this.getElem(), 'font-size');
    if (!fontSize) {
      fontSize = DvtToolkitUtils.getAttrNullNS(this.getOuterElem(), 'font-size');
      if (!fontSize) {
        fontSize = "11";
      }
    }
    dy = this._baseline * parseFloat(fontSize);
    //FIX BUG 16856961: additional pixel offset for baseline, currently only
    //specified by DvtOutputTextArea subclass
    if (this._baselineOffset != null)
      dy += this._baselineOffset;
  }
  return dy;
}

/**
 * Returns the specified matrix adjusted by the baseline (if any)
 * 
 * @param {DvtMatrix} the matrix to adjust
 * 
 * @return {DvtMatrix} the adjusted matrix
 */
DvtOutputText.prototype._getBaselineAdjustedMatrix = function (mat) {
  if (this._baseline != null) {
    // this._baseline is only set for IE
    if (!mat) {
      mat = new DvtMatrix();
    }
    var nmat = new DvtMatrix(null, null, null, null, null, this._getBaselineTranslation());
    nmat.concat(mat);
    mat = nmat;
  }
  return mat;
}

/**
 *  @override
 */
DvtOutputText.prototype.setMatrix = function (mat) {
  if (DvtAgent.isPlatformIE()) {
    this._matrixForIE = mat;
    mat = this._getBaselineAdjustedMatrix(mat);
  }
  DvtOutputText.superclass.setMatrix.call(this, mat);
}

/**
 *  @override
 */
DvtOutputText.prototype.getMatrix = function () {
  var matrix = null;
  if (DvtAgent.isPlatformIE()) {
    matrix = this._matrixForIE;
  }
  if (!matrix) {
    matrix = DvtOutputText.superclass.getMatrix.call(this);
  }
  return matrix;
}

/**
 * @override
 */
DvtOutputText.prototype.GetSvgDimensions = function () { // TODO HZHANG target coord space would be broken here
  var bbox = DvtOutputText.superclass.GetSvgDimensions.call(this);

  //Bug 13879007 - NODE RENDERED INCORRECTLY IN IE9
  if (bbox)
    bbox.y += this._getBaselineTranslation();

  return bbox;
}

/**
 * @override
 */
DvtOutputText.prototype.UpdateSelectionEffect = function() {
  // noop: Does not participate in selection effects
}

/**
 * Calculate the optimal text size based on the bounds provided.
 * @param {DvtRectangle} bounds The bounds to fit the label
 */
DvtOutputText.prototype.getOptimalFontSize = function (bounds) {
  for (var i = Math.max(Math.min(bounds.w / this.getTextString().length, bounds.h / 2), 9);i < 51;i += 1) {
    this.setFontSize(i);
    var textDim = this.measureDimensions();
    if (textDim.w > bounds.w || textDim.h > bounds.h)
      return Math.min(i - 1, 50);
  }
  return 50;
}

/**
 * Optimized version of getDimensions.  Unlike getDimensions, this function will always returns useful dimensions,
 * adding the object to the DOM as needed.  The current implementation achieves improvements in performance by
 * storing the text calculations in a LRU cache, taking advantage of the fact that dimensions calculations do
 * not depend on container information.
 * @param {DvtDisplayable} [targetCoordinateSpace] The displayable defining the target coordinate space.
 * @return {DvtRectangle} The bounds of the text
 */
DvtOutputText.prototype.measureDimensions = function (targetCoordinateSpace) {
  // TODO this should be integrated into getDimensions
  var textString = this.getTextString() != null ? this.getTextString() : "";
  
  // Initialize the cache if not done already.  The cache stores the stage relative dims of text at (0,0).
  if (!DvtOutputText._cache)
    DvtOutputText._cache = new DvtCache();

  // Create the key for cache, which is a combination of all attrs that affect dimensions calculations.
  var cssStyle = this.getCSSStyle();
  var cssStyleKey = (cssStyle != null) ? cssStyle.hashCodeForTextMeasurement() : "";
  var cacheKey = (textString.length > 0) ? textString + this.getHorizAlignment() + this.getVertAlignment() + cssStyleKey : "";

  // Look for the value in the cache and add it if not found. Calculate the localDims.
  var localDims;
  var stageDims = DvtOutputText._cache.get(cacheKey);
  if (stageDims != null)// Cache hit found, convert from stage coords to local and return.
    localDims = new DvtRectangle(stageDims.x + this.getX(), stageDims.y + this.getY(), stageDims.w, stageDims.h);
  else {
    // No cache hit.  Find the stage coords and add to cache.
    // Get the real local dimensions and cache the stage dimensions by removing x and y offsets.
    localDims = this.getDimensions();

    // For Firefox, localDims is null for disconnected elements
    if (!localDims)
      localDims = new DvtRectangle(0, 0, 0, 0);

    // If the object is not connected to the DOM, it will return incorrect size of 0.
    if (localDims.w <= 0 && localDims.h <= 0 && textString.length > 0) {
      // Saves the parent and the index
      var parent = this.getParent();
      var index;
      if (parent) {
        index = parent.getChildIndex(this);
      }
      // Add to the stage to obtain correct measurements      
      var stage = this.getCtx().getStage();
      stage.addChild(this);
      localDims = this.getDimensions();
      stage.removeChild(this);
      // Restore the parent
      if (parent) {
        parent.addChildAt(this, index);
      }
    }

    // Convert to stage dims by removing own x and y.
    stageDims = new DvtRectangle(localDims.x - this.getX(), localDims.y - this.getY(), localDims.w, localDims.h);
    DvtOutputText._cache.put(cacheKey, stageDims);
  }

  // Transform to the target coord space and return
  return (!targetCoordinateSpace || targetCoordinateSpace === this) ? localDims : this.ConvertCoordSpaceRect(localDims, targetCoordinateSpace);
}

/**
 * @override
 */
DvtOutputText.prototype.copyShape = function () {
  var ret = new DvtOutputText(this.getCtx(), this.getTextString(), this.getX(), this.getY());
  ret.setCSSStyle(this.getCSSStyle());
  ret.setHorizAlignment(this.getHorizAlignment());
  ret.setVertAlignment(this.getVertAlignment());
  return ret;
}

/**
 * @override
 */  
DvtOutputText.prototype.addChild = function (obj) {
  // Prevent this class from being used as a shape container.  It's bad practice and doesn't make sense.  Placeholder 
  // until the shape container APIs are removed altogether.
  if(DvtAgent.isEnvironmentTest()) {
    out.println("DvtOutputText.prototype.addChild: Text should not be used as a shape container.");
    var nullObj = null;
    nullObj.errorShouldOccurDueToInvalidAddChild();
  }
}

/**
 * Returns true if the text anchor needs to be flipped from "start" to "end" and vice versa.
 * @param {DvtContext} context
 * @return {boolean}
 */
DvtOutputText.needsTextAnchorAdjustment = function (context) {
  // TODO HZHANG MAKE PRIVATE
  // Bug 17776065: When html dir="rtl", Webkit and FF25+ treat the right side of the text as the start, and the left 
  // side of the text as end.  Our API always treats the left side as start, so we need to adjust based on agent.
  // Note: Technically this context check is not correct, because the text anchor adjustment is not based on the reading
  // direction of our context, but rather the rtl flag on the page.  We are passing context incorrectly here so that our
  // unit tests can be used to verify rtl support for JET components, and we should remove this context param once all
  // components have been updated to support rtl in JET (by passing context within their RTL calls).  We'd do this by
  // setting documentElement.document.dir to rtl in the test environment, which mimics the situation where the adjustment
  // is needed in the browser.
  return DvtAgent.isRightToLeft(context) && (DvtAgent.isPlatformWebkit() || (DvtAgent.isPlatformGecko() && DvtAgent.getVersion() >= 25)|| (DvtAgent.isPlatformIE()));
}
// Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.
/**
 * Read-only text object that supports wrapping.
 * @extends DvtContainer
 * @class DvtMultilineText
 * @constructor
 * @param {DvtContext} context
 * @param {string} textString
 * @param {number} x
 * @param {number} y
 * @param {string} id
 */
var DvtMultilineText = function (context, textStr, x, y, id) {
  this.Init(context, textStr, x, y, id);
}

DvtObj.createSubclass(DvtMultilineText, DvtContainer, "DvtMultilineText");

/**
 * The space between lines expressed as a percentage of line height.
 * @private
 */
DvtMultilineText._LINE_SPACE = 0;

/**
 * @param {DvtContext} context
 * @param textStr {string} the text string
 * @param x {number} x
 * @param y {number} y
 * @param {string} [id] The optional id for the corresponding DOM element.
 * @protected
 */
DvtMultilineText.prototype.Init = function (context, textStr, x, y, id) {
  DvtMultilineText.superclass.Init.call(this, context, null, id);
  
  /**
   * The primary text instance.  All properties are stored here.  If DvtTextUtils.fitText is not called, the text will
   * appear as a single line using this instance.
   * @private
   */
  this._textInstance = null;
  
  /**
   * Any additional lines of text resulting from text wrapping.
   * @private
   */
  this._additionalLines = [];
  
  // Apply properties
  this.setTextString(textStr);
  this.setX(x ? x : 0);
  this.setY(y ? y : 0);
  this.setMaxLines(Infinity);
}

/**
 * Returns the text string for this text object.  Unlike the implementation on DvtOutputText, this always returns the
 * full and untruncated text string.
 * @return {string} the text string
 */
DvtMultilineText.prototype.getTextString = function () {
  return this._textString;
}

/**
 * Specifies the text string for this text object.
 * @param {string} textString the text string
 */
DvtMultilineText.prototype.setTextString = function (textString) {
  // Store the full string
  this._textString = (textString != null) ? String(textString) : null;
  
  // Update the text instances
  if(!this._textInstance) {
    // Create the primary text instance.  This instance is used to store all properties.
    this._textInstance = new DvtOutputText(this.getCtx(), this._textString);
    this.addChild(this._textInstance);
  }
  else {
    this._textInstance.setTextString(textString);
    
    // Remove any additional text lines
    this._removeAdditionalLines();
  }
  
  // Since this is a new text string, truncation has not occurred
  this._bTruncated = false;
}

/**
 * Returns the x position for this text object.
 * @return {number} The x position.
 */
DvtMultilineText.prototype.getX = function () {
  return this._textInstance.getX();
}

/**
 * Specifies the x position for this text object.
 * @param {number} x The x position
 * @return {DvtMultilineText}
 */
DvtMultilineText.prototype.setX = function (x) {
  this._textInstance.setX(x);
  return this;
}

/**
 * Returns the y position for this text object.
 * @return {number} The y position.
 */
DvtMultilineText.prototype.getY = function () {
  return this._textInstance.getY();
}

/**
 * Specifies the y position for this text object.
 * @param {number} y The y position
 * @return {DvtMultilineText}
 */
DvtMultilineText.prototype.setY = function (y) {
  this._textInstance.setY(y);
  return this;
}

/**
 * Returns the y position for this text object.
 * @return {number} The y position.
 */
DvtMultilineText.prototype.getMaxLines = function () {
  return this.GetProperty('maxLines');
}

/**
 * Specifies the maximum number of lines to display when wrapped. Defaults to Infinity.
 * @param {number} maxLines
 * @return {DvtMultilineText}
 */
DvtMultilineText.prototype.setMaxLines = function (maxLines) {
  // Ignore values of 0 or less
  if(maxLines > 0)
    return this.SetProperty('maxLines', maxLines);
}

/**
 * Returns true if this text instance has been truncated.
 * @return {boolean}
 */
DvtMultilineText.prototype.isTruncated = function () {
  return this._bTruncated;
}

/**
 * Returns the horizontal alignment for this text object.  Valid constants begin with DvtOutputText.H_ALIGN_.
 * @return {string}
 */
DvtMultilineText.prototype.getHorizAlignment = function () {
  return this._textInstance.getHorizAlignment();
}

/**
 * Specifies the horizontal alignment for this text object.  Valid constants begin with DvtOutputText.H_ALIGN_.
 * @param {string} align
 * @return {DvtMultilineText}
 */
DvtMultilineText.prototype.setHorizAlignment = function (align) {
  this._textInstance.setHorizAlignment(align);
  return this;
}

/**
 * Aligns the left side of the text to the x coordinate. Note: This does not always correspond to what the browser
 * considers a "start" alignment, as we work around issues in rtl locales to provide a consistent API.
 */
DvtMultilineText.prototype.alignLeft = function () {
  this._textInstance.alignLeft();
}

/**
 * Aligns the center of the text to the x coordinate.
 */
DvtMultilineText.prototype.alignCenter = function () {
  this._textInstance.alignCenter();
}

/**
 * Aligns the right side of the text to the x coordinate. Note: This does not always correspond to what the browser
 * considers an "end" alignment, as we work around issues in rtl locales to provide a consistent API.
 */
DvtMultilineText.prototype.alignRight = function () {
  this._textInstance.alignRight();
}

/**
 * Returns the DvtCSSStyle for this object.
 * @return {DvtCSSStyle} The DvtCSSStyle of this object.
 */
DvtMultilineText.prototype.getCSSStyle = function () {
  return this._textInstance.getCSSStyle();
}

/**
 * Sets the DvtCSSStyle of this object.
 * @param {DvtCSSStyle} style The DvtCSSStyle of this object.
 * @return {DvtMultilineText}
 */
DvtMultilineText.prototype.setCSSStyle = function (style) {
  this._textInstance.setCSSStyle(style);
  return this;
}

/**
 * @override
 */
DvtMultilineText.prototype.copyShape = function () {
  var ret = new DvtMultilineText(this.getCtx(), this.getTextString(), this.getX(), this.getY());
  ret.setCSSStyle(this.getCSSStyle()).setHorizAlignment(this.getHorizAlignment()).setMaxLines(this.getMaxLines());
  return ret;
}

/**
 * Helper function to remove additional text lines.
 * @private
 */
DvtMultilineText.prototype._removeAdditionalLines = function() {
  for(var i=0; i<this._additionalLines.length; i++) {
    this.removeChild(this._additionalLines[i]);
  }
  
  this._additionalLines = [];
}

/**
 * Truncates the text instance to fit within the given width.  Sets the untruncated text string on itself if
 * truncated text does not fit.  Only for use by DvtTextUtils.
 * @param {number} maxWidth The maximum width of the text.
 * @param {number} maxHeight The maximum height of the text.
 * @param {number} minChars The minimum number of characters that should be displayed before ellipsis after truncation.
 * @return {boolean} false if the text cannot fit at all, true otherwise.
 */
DvtMultilineText.prototype.__fitText = function(maxWidth, maxHeight, minChars) {
  // Clear any previous layout results
  this._textInstance.setTextString(this.getTextString());
  this._removeAdditionalLines();

  // First try to fit the entire string in 1 line
  if(!DvtTextUtils.fitText(this._textInstance, maxWidth, maxHeight, this, minChars)) {
    // String doesn't fit at all, remove from parent and return
    this.getParent().removeChild(this);
    return false;
  }
  else if(!this._textInstance.isTruncated()) // No truncation needed, text fits in one line.
    return true;
  
  // Truncation occurred.  Calculate line height so that we can add additional lines as space allows.
  var lineHeight = this._textInstance.measureDimensions().h;
  var lineSpace = lineHeight * DvtMultilineText._LINE_SPACE;
  var maxLines = this.getMaxLines();
  var availHeight = Math.min(maxHeight, maxLines * (lineHeight + lineSpace) - lineSpace) - lineHeight - lineSpace;
  
  // Split the string into parts.  Reverse the array so that we can use like a queue.
  var splits = this.getTextString().split(" ");
  splits.reverse();
  
  // Loop and add each part into the current line.  Create a new line once the current is full.  
  var currentLine = this._textInstance;
  var currentString = null;
  while(splits.length > 0) {
    // Try adding the next split into the current line.
    var split = splits.pop();
    var newString = currentString ? currentString + " " + split : split;
    currentLine.setTextString(newString);
    currentLine.setUntruncatedTextString(null);
    
    if(!DvtTextUtils.fitText(currentLine, maxWidth, Infinity, this, minChars)) {
      // Text doesn't fit at all, and there's no more space.  Returns true because previous lines had fit.
      return true;
    }
    else if(currentLine.isTruncated()) {
      // If there's no more space to add lines, we're done
      if(availHeight < lineSpace + lineHeight) {
        this._bTruncated = true;
        return true;
      }
    
      // Decide whether to keep this split in the current line or push to the next
      if(currentString) {
        // Always push the split to the next line if it didn't fit with the current one.
        currentLine.setTextString(currentString);
        splits.push(split);
      }
      else {
        // This means that we are keeping a truncated text line, because we're not pushing the split back onto the stack
        this._bTruncated = true;
      }
    
      // Text partially fit, create a new line for the next split
      if(splits.length > 0) {
        var newLine = currentLine.copyShape();
        newLine.setY(currentLine.getY() + lineSpace + lineHeight);
        this.addChild(newLine);
        this._additionalLines.push(newLine);
        
        // Update the pointers to the line and the availHeight
        currentLine = newLine;
        currentString = null;
        availHeight -= (lineSpace + lineHeight);
      }
    }
    else // Text completely fit, continue using this line
      currentString = newString;
  }
  
  return true;
}
/**
 * Style Utilities 
 * @class DvtStyleUtils 
 * @constructor
 */
var DvtStyleUtils = function() {
}

DvtObj.createSubclass(DvtStyleUtils, DvtObj, "DvtStyleUtils");

DvtStyleUtils.DEFAULT_FONT_FAMILY = "Tahoma,Verdana,Helvetica,sans-serif";
DvtStyleUtils.DEFAULT_FONT_SIZE = "11px";
DvtStyleUtils.DEFAULT_FONT_COLOR = "black";

DvtStyleUtils.getStyle = function(styleMap, styleName, defaultStyle) {
  if (styleMap && styleMap[styleName] !== null && typeof styleMap[styleName] !== "undefined")
    return styleMap[styleName];
  else
    return defaultStyle;
}

DvtStyleUtils.setStyle = function(styleMap, styleName, styleValue) {
  if (styleMap && styleValue !== null && typeof styleValue !== "undefined" )
    styleMap[styleName] = styleValue;
}

/**
 * Creates a DvtShadow object from a CSS box-shadow specification
 * 
 * @param {string} shadowStyle the CSS box-shadow specification
 * @return {DvtShadow} the DvtShadow object
 */
DvtStyleUtils.getShadow = function(shadowStyle) {
  var shadow = null;
  if (shadowStyle != null && shadowStyle != "none") {
    var shadowRGBA;
    var shadowH = 0;
    var shadowV = 0;
    var shadowBlur = 0;
    
    var arr = shadowStyle.replace(/, /g,",").split(" ");
  
    if (shadowStyle.match(/rgb/i) == null)
      arr[arr.length] = "rgba(0, 0, 0, 0.2)";
        
    if (arr.length < 3)
        return null;
      
    for (i=0;i<arr.length;i++){
      if (i == 0)
        shadowH = parseInt(arr[0]);
      else if (i == 1)
        shadowV = parseInt(arr[1]);
      else if (i == 2 && arr[i].match(/rgb/i) == null)
        shadowBlur = parseInt(arr[i]);
      else if (arr[i].match(/rgb/i))
        shadowRGBA = arr[i];
    }

    var shadowDistance = Math.sqrt(shadowH*shadowH + shadowV*shadowV);
    var angle = Math.atan2(shadowV, shadowH) * 180/Math.PI;
      
    shadow = new DvtShadow(shadowRGBA, 
                          shadowDistance, // distance
                          shadowBlur, // blurX
                          shadowBlur, // blurY
                          angle, // angle of the shadow
                          1, // strength or the imprint/spread
                          3, // quality
                          false, // inner shadow
                          false, // knockout effect
                          false // hide object
                          );
  }
  
  return shadow;  
}
/**
 * @constructor
 * DvtCSSGradient
 */
var DvtCSSGradient = function(type) {
  this.Init(type);
};

DvtObj.createSubclass(DvtCSSGradient, DvtObj, "DvtCSSGradient");


DvtCSSGradient.LINEAR = 0;
DvtCSSGradient.RADIAL = 1;


DvtCSSGradient.prototype.Init = function(type) {
  this._type = type;
}

/**
  *   Returns DvtCSSGradient.LINEAR or DvtCSSGradient.RADIAL
  */
DvtCSSGradient.prototype.getGradientType = function()
{
  return this._type;
};

/**
  *   Returns an array of alpha's.
  *   @type Array
  */
DvtCSSGradient.prototype.getAlphas = function()
{
  return this._arAlphas;
};

/**
  *  Sets the alphas of the gradient.
  *  @param {Array} arAlphas  The array of alphas
  */
DvtCSSGradient.prototype.setAlphas = function(arAlphas)
{
   this._arAlphas = arAlphas;
};

/**
  *   Returns an array of colors.
  *   @type Array
  */
DvtCSSGradient.prototype.getColors = function()
{
  return this._arColors;
};

/**
  *  Sets the colors of the gradient.
  *  @param {Array} arColors  The array of colors
  */
DvtCSSGradient.prototype.setColors = function(arColors)
{
   this._arColors = arColors;
};


/**
  *   Returns an array of stop ratios.
  *   @type Array
  */
DvtCSSGradient.prototype.getRatios = function()
{
  return this._arRatios;
};

/**
  *  Sets the ratios of the gradient.
  *  @param {Array} arRatios  The array of ratios
  */
DvtCSSGradient.prototype.setRatios = function(arRatios)
{
   this._arRatios = arRatios;
};


/**
 * @constructor
 * DvtLinearGradient
 */
var DvtLinearGradient = function() {
  this.Init();
};

/*
 * make DvtCSSGradient a subclass of DvtLinearGradient
 */
DvtObj.createSubclass(DvtLinearGradient, DvtCSSGradient, "DvtLinearGradient");

//convert sides into an angle (in radian)
//Note: in toolkit, angles are in degree (not radian)
DvtLinearGradient.LEFT = 0;   //0;
DvtLinearGradient.BOTTOM_LEFT= 45;
DvtLinearGradient.BOTTOM = 90; //Math.PI / 2;
DvtLinearGradient.BOTTOM_RIGHT = 135;
DvtLinearGradient.RIGHT = 180;    //Math.PI;
DvtLinearGradient.TOP_RIGHT = 225;
DvtLinearGradient.TOP = 270;     //3 * Math.PI / 2;
DvtLinearGradient.TOP_LEFT = 315;

DvtLinearGradient.prototype.Init = function() {
  DvtLinearGradient.superclass.Init.call(this, DvtCSSGradient.LINEAR);
}

/*---------------------------------------------------------------------*/
/*   get/setAngle()                                                    */
/*---------------------------------------------------------------------*/
/**
  *  Returns the angle of the gradient.
  *  @returns {number} the angle of the gradient.
  */
DvtLinearGradient.prototype.getAngle = function()
{
  // return angle
  // usage:
  // angle = Math.atan2(hh, ww)
  // var fill_matrix:Matrix = new Matrix();
  // fill_matrix.createGradientBox(ww, hh, angle, xx, yy);

  return this._angle;
};

/**
  *  Sets the angle of the gradient.
  *  @param {number} angle  The angle of the gradient.
  */
DvtLinearGradient.prototype.setAngle = function(angle)
{
  this._angle = angle;
};

/**
 * parse gradient string into gradient object
 * @class DvtGradientParser
 * @constructor
 */
var DvtGradientParser = function() {
};

DvtObj.createSubclass(DvtGradientParser, DvtObj, "DvtGradientParser");


/*ADF Faces FusionFx-v3-desktop linear gradient syntax */
/*using CSS3 gradients for button background-image */

/*********************************************************************
@agent webkit {
  .AFButtonBackground:alias {
    background-image: -webkit-gradient(linear, 0% 0%, 0% 100%, from(#FFFFFF), to(#CCD6E8));
  }
}

@agent webkit and (min-version: 534.16) {
  .AFButtonBackground:alias {
    background-image: -webkit-linear-gradient(top, #FFFFFF, #CCD6E8);
  }
}

@agent gecko {
  .AFButtonBackground:alias {
    background-image: -moz-linear-gradient(top, #FFFFFF, #CCD6E8);
  }
}

@agent ie and (max-version: 7.0) {
  .AFButtonBackground:alias {
    filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#FFFFFF', endColorstr='#CCD6E8');
  }
}

@agent ie and (min-version: 8.0) {
  .AFButtonBackground:alias {
    -ms-filter: "progid:DXImageTransform.Microsoft.gradient(startColorstr='#FFFFFF', endColorstr='#CCD6E8')";
  }
}
*********************************************************************/

/* End of CSS3 gradients for buttom background-image*/


DvtGradientParser.WEBKIT_GD_LINEAR = "-webkit-linear-gradient";
DvtGradientParser.FIREFOX_GD_LINEAR = "-moz-linear-gradient";
DvtGradientParser.IE_GD_LINEAR = "progid:DXImageTransform.Microsoft.gradient";
DvtGradientParser.IE_GD_LINEAR2 = "progid:DXImageTransform.Microsoft.Gradient";
DvtGradientParser.IE7_GD_FILTER = "filter";
DvtGradientParser.IE8_GD_FILTER = "-ms-filter";
DvtGradientParser.IE10_GD_LINEAR = "-ms-linear-gradient";

DvtGradientParser.IE_GD_START_COLOR_STR = "startColorstr";
DvtGradientParser.IE_GD_END_COLOR_STR = "endColorstr";
DvtGradientParser.IE_GD_GRADIENT_TYPE = "GradientType";


//TODO: should we support old webkit gradient syntax???
DvtGradientParser.OLD_WEBKIT_GD_LINEAR = "-webkit-gradient"; 

//W3C CSS3 gradient
DvtGradientParser.GD_LINEAR = "linear-gradient";
DvtGradientParser.GD_RADIAL = "radial-gradient";


DvtGradientParser.GD_TOP = "top";
DvtGradientParser.GD_BOTTOM = "bottom";
DvtGradientParser.GD_LEFT = "left";
DvtGradientParser.GD_RIGHT = "right";
DvtGradientParser.GD_CENTER = "center";
DvtGradientParser.GD_TO = "to";


/**
 * Parse a gradient style String and turn it into a DvtCSSStyle.
 * @param {String} gradient string
 * @return a CSSGradient object if it is a gradient value,
 *         a null otherwise. 
 */
DvtGradientParser.parseCSSGradient = function (gradient) {

  if (gradient != null) {
    gradient = DvtStringUtils.trim(gradient);

    if (DvtGradientParser._startsWith(gradient, DvtGradientParser.WEBKIT_GD_LINEAR)) {
      gradient = DvtGradientParser._removeParenthesis(gradient, DvtGradientParser.WEBKIT_GD_LINEAR);
      return DvtGradientParser._parseLinearGradient(gradient);
    }
    else if (DvtGradientParser._startsWith(gradient, DvtGradientParser.FIREFOX_GD_LINEAR)) {
      gradient = DvtGradientParser._removeParenthesis(gradient, DvtGradientParser.FIREFOX_GD_LINEAR);
      return DvtGradientParser._parseLinearGradient(gradient);
    }
    else if (DvtGradientParser._startsWith(gradient, DvtGradientParser.IE_GD_LINEAR)) {
      gradient = DvtGradientParser._removeParenthesis(gradient, DvtGradientParser.IE_GD_LINEAR);
      return DvtGradientParser._parseIELinearGradient(gradient);
    }
    else if (DvtGradientParser._startsWith(gradient, DvtGradientParser.IE_GD_LINEAR2)) {
      gradient = DvtGradientParser._removeParenthesis(gradient, DvtGradientParser.IE_GD_LINEAR2);
      return DvtGradientParser._parseIELinearGradient(gradient);
    }
    else if (DvtGradientParser._startsWith(gradient, DvtGradientParser.IE10_GD_LINEAR)) {
      gradient = DvtGradientParser._removeParenthesis(gradient, DvtGradientParser.IE10_GD_LINEAR);
      return DvtGradientParser._parseLinearGradient(gradient);
    }
    //W3C CSS3 gradient (Draft 13 Dec 2011)
    else if (DvtGradientParser._startsWith(gradient, DvtGradientParser.GD_LINEAR)) {
      gradient = DvtGradientParser._removeParenthesis(gradient, DvtGradientParser.GD_LINEAR);
      return DvtGradientParser._parseLinearGradient(gradient);
    }
  }
  return null;
}


  /****************************************************************
   CSS3 - http://dev.w3.org/csswg/css3-images/#gradients

   <linear-gradient> = linear-gradient(
      [ [ <angle> | to <side-or-corner> ] ,]? 
      <color-stop>[, <color-stop>]+
   )

   <side-or-corner> = [left | right] || [top | bottom]

/(([0-9]+)(deg|rad|grad)|\s*(to\s+)?((left|right)\s+)?(top|bottom)?\s*,\s*)?/i

/(#[0-9a-f]+|rgb\(\s*(\d+),\s*(\d+),\s*(\d+)\s*\)|rgba\(\s*(\d+),\s*(\d+),\s*(\d+),\s*(\d?)(\.\d+)?\s*\)|[a-z]+)(\s+\d+%)?/gi


  ******************************************************************/

DvtGradientParser._parseLinearGradient = function (gradient) {
  var number = new RegExp("(-?(?:\\d*\\.)?\\d+)");
  var angleUnit = new RegExp("(deg|rad|grad|turn)")
  var horiz = new RegExp("(left|right)");
  var vert = new RegExp("(top|bottom)");
  var to = new RegExp("(?:(to)\\s+)");
  var angle = new RegExp("(?:" + number.source + angleUnit.source + ")");
  var horizThenVert = new RegExp("(?:" + horiz.source + "(?:\\s+" + vert.source + ")?)");
  var vertThenHoriz = new RegExp("(?:" + vert.source + "(?:\\s+" + horiz.source + ")?)");
  var sideOrCorner = new RegExp("(?:" + horizThenVert.source + "|" + vertThenHoriz.source + ")");
  var direction = new RegExp("(?:" + angle.source + "|(?:" + to.source + "?" + sideOrCorner.source + "))");
  var everythingBeforeColorStops = new RegExp("(?:\\s*" + direction.source + "\\s*,\\s*)", "i");
  var sides = gradient.match(everythingBeforeColorStops);

  if (sides == null || sides.length == 0)
    return null;

  // sides
  // 0: match string
  // 1: angle
  // 2: angle unit
  // 3: to (if present)
  // 4: horiz (if horizThenVert)
  // 5: vert (if horizThenVert)
  // 6: vert (if vertThenHoriz)
  // 7: horiz (if vertThenHoriz)

  var size = sides.length;
  var gradObj = new DvtLinearGradient();

  var bTop = sides[5] == DvtGradientParser.GD_TOP || sides[6] == DvtGradientParser.GD_TOP;
  var bBottom = sides[5] == DvtGradientParser.GD_BOTTOM || sides[6] == DvtGradientParser.GD_BOTTOM;
  var bLeft = sides[4] == DvtGradientParser.GD_LEFT || sides[7] == DvtGradientParser.GD_LEFT;
  var bRight = sides[4] == DvtGradientParser.GD_RIGHT || sides[7] == DvtGradientParser.GD_RIGHT;
  var bTo = sides[3] == DvtGradientParser.GD_TO;
  if (bTo) {
    // specifying end rather than start, swap top/bottom, left/right if specified
    if (bTop || bBottom) {
      bTop = !bTop;
      bBottom = !bBottom;
    }
    
    if (bLeft || bRight) {
      bLeft = !bLeft;
      bRight = !bRight;
    }
  }

  // top left | top right | top
  if (bTop) {
    if (bLeft) {
      gradObj.setAngle(DvtLinearGradient.TOP_LEFT);      
    }
    else if (bRight) {
      gradObj.setAngle(DvtLinearGradient.TOP_RIGHT);      
    }
    else {
      gradObj.setAngle(DvtLinearGradient.TOP);
    }
  }
  // bottom left | bottom right | bottom
  else if (bBottom) {
    if (bLeft) {
      gradObj.setAngle(DvtLinearGradient.BOTTOM_LEFT);
    }
    else if (bRight) {
      gradObj.setAngle(DvtLinearGradient.BOTTOM_RIGHT);
    }
    else {
      gradObj.setAngle(DvtLinearGradient.BOTTOM);
    }
  }
  else if (bLeft) {
    gradObj.setAngle(DvtLinearGradient.LEFT);
  }
  else if (bRight) {
    gradObj.setAngle(DvtLinearGradient.RIGHT);
  }
  // parse angle if specified
  else if (sides[2]) {
    var angle = parseFloat(sides[1]);

    if (! isNaN(angle)) {
      if (sides[2] == "grad") {
        angle = (angle/200) * 180;
      }
      else if (sides[2] == "rad") {
        angle = (angle/Math.PI) * 180;
      }
      else if (sides[2] == "turn") {
        angle = (angle/.5) * 180;
      }
      //TODO: dont need to convert negative angle to positive
      //because beginGradientFill take negative angle
      //      angle = angle % (2 * Math.PI);
      //      if (angle < 0) {
      //        angle += 2 * Math.PI;
      //      }

      gradObj.setAngle(angle);
    }
  }

  // parse colorStops
  gradient = gradient.substring(sides[0].length);    
  DvtGradientParser._parseCSSColorStops(gradient, gradObj);

  return gradObj;
}


DvtGradientParser._parseIELinearGradient = function (gradient) {
  var props = gradient.split(",");
  var size = props.length;
  var prop;
  var colorStops = [];

  //In IE GradientType = 0 (default, vertical)
  //      GradientType = 1 (horizontal)
  var gradObj = new DvtLinearGradient();
  gradObj.setAngle(DvtLinearGradient.TOP);

  // parse gradient properties
  for (var i = 0; i < size; i++) {
    prop = (DvtStringUtils.trim(props[i])).split("=");
    if (prop.length == 2) {
      prop[0] = DvtStringUtils.trim(prop[0]);
      if (prop[0] == DvtGradientParser.IE_GD_START_COLOR_STR) {
        colorStops[0] = DvtGradientParser.removeQuotes(prop[1], DvtCSSStyle.SINGLE_QUOTE);
      }
      else if (prop[0] == DvtGradientParser.IE_GD_END_COLOR_STR) {
        colorStops[1] = DvtGradientParser.removeQuotes(prop[1], DvtCSSStyle.SINGLE_QUOTE);
      }
      else if (prop[0] == DvtGradientParser.IE_GD_GRADIENT_TYPE) {
        if (prop[1] == "1") {
          gradObj.setAngle(DvtLinearGradient.LEFT);
        }
      }
    }
  }

  // parse color stops
  DvtGradientParser._parseColorStops(colorStops, gradObj);

  return gradObj;
}


DvtGradientParser._parseCSSColorStops = function (s, gradObj) {

  var colorStops = s.match(/(#[0-9a-f]+|rgb\(\s*(\d+),\s*(\d+),\s*(\d+)\s*\)|rgba\(\s*(\d+),\s*(\d+),\s*(\d+),\s*(\d?)(\.\d+)?\s*\)|[a-z]+)(\s+\d+%)?/gi);

  if (colorStops != null && colorStops.length > 0) {
    DvtGradientParser._parseColorStops(colorStops, gradObj);
  }
}


DvtGradientParser._parseColorStops = function (colorStops, gradObj) {

  var size = colorStops.length;
  var alphas = [];
  var colors = [];
  var ratios = [];
  var alphaColor;
  var position;
  var noRatio = true;
  var sPosition;
  var colorArray = [];

  for (var i = 0; i < colorStops.length; i++) {
    sPosition = DvtCSSStyle.parseBorderColor(colorStops[i], colorArray);
    alphaColor = colorArray.pop();

    colors[i] = alphaColor;
    alphas[i] = DvtColorUtils.getAlpha(alphaColor);;

    sPosition = DvtStringUtils.trim(sPosition);
    if (sPosition.length > 0) {
      position = parseFloat(sPosition);
      if (! isNaN(position)){
        //NOTE: support % but not length or ratio.
        if (DvtStringUtils.endsWith(sPosition, "%")) {
          ratios[i] = position / 100;
          noRatio = false;
        }
      }
    }
  }

  // no location is specified, even space is assumed
  if (size > 1 && noRatio) {
    for (var r=0; r < size; r++) {
      ratios[r] = r / (size - 1);
    }
  }
  else if (noRatio) {
    ratios[0] = 0;
  }

  gradObj.setColors(colors);
  gradObj.setAlphas(alphas);
  gradObj.setRatios(ratios);
}

DvtGradientParser._removeParenthesis = function (gradient, keyWord) {
  if (gradient.charAt(gradient.length - 1) != ")")
    return null;

  // remove keyWord and parethesis around it
  gradient = gradient.substring(keyWord.length);

  return DvtGradientParser.removeQuotes(gradient, "(", ")");
}

DvtGradientParser.removeQuotes = function (colorStr, openQ, closeQ) {
  // remove quote around the color string
  colorStr = DvtStringUtils.trim(colorStr);
  if (colorStr.charAt(0) != openQ)
    return colorStr;

  if (closeQ == null)
    closeQ = openQ;

  var iStart = 1;
  var iEnd = colorStr.lastIndexOf(closeQ);
  if (iEnd < 0)
    return colorStr.substring(iStart);

  return colorStr.substring(iStart, iEnd);
}



DvtGradientParser._startsWith = function (str, value) {
  return str.indexOf(value) == 0;
}

/**
 * @constructor
 * Represents a set of CSS styles.
 * @param {String} style inlineStyle
 */
var DvtCSSStyle = function (style) {
  this.Init(style);
}

DvtObj.createSubclass(DvtCSSStyle, DvtObj, "DvtCSSStyle");

// Skin names. Not proper CSS and should move when possible
DvtCSSStyle.SKIN_SKYROS = 'skyros';
DvtCSSStyle.SKIN_ALTA = 'alta';

// Background Properties
DvtCSSStyle.BACKGROUND = "background";
DvtCSSStyle.BACKGROUND_COLOR = "background-color";
DvtCSSStyle.BACKGROUND_IMAGE = "background-image";
DvtCSSStyle.BACKGROUND_REPEAT = "background-repeat";
DvtCSSStyle.BACKGROUND_POSITION = "background-position";

// Border Properties
DvtCSSStyle.BORDER = "border";
DvtCSSStyle.BORDER_TOP = "border-top";
DvtCSSStyle.BORDER_BOTTOM = "border-bottom";
DvtCSSStyle.BORDER_LEFT = "border-left";
DvtCSSStyle.BORDER_RIGHT = "border-right";

DvtCSSStyle.BORDER_WIDTH = "border-width";
DvtCSSStyle.BORDER_TOP_WIDTH = "border-top-width";
DvtCSSStyle.BORDER_BOTTOM_WIDTH = "border-bottom-width";
DvtCSSStyle.BORDER_LEFT_WIDTH = "border-left-width";
DvtCSSStyle.BORDER_RIGHT_WIDTH = "border-right-width";

DvtCSSStyle.BORDER_COLOR = "border-color";
DvtCSSStyle.BORDER_TOP_COLOR = "border-top-color";
DvtCSSStyle.BORDER_BOTTOM_COLOR = "border-bottom-color";
DvtCSSStyle.BORDER_LEFT_COLOR = "border-left-color";
DvtCSSStyle.BORDER_RIGHT_COLOR = "border-right-color";

//bug 13826956 - border-radius css property not supported when used inside <dvt:node>
DvtCSSStyle.BORDER_RADIUS = "border-radius";
DvtCSSStyle.BORDER_TOP_LEFT_RADIUS = "border-top-left-radius";
DvtCSSStyle.BORDER_TOP_RIGHT_RADIUS = "border-top-right-radius";
DvtCSSStyle.BORDER_BOTTOM_RIGHT_RADIUS = "border-bottom-right-radius";
DvtCSSStyle.BORDER_BOTTOM_LEFT_RADIUS = "border-bottom-left-radius";

// Margin Properties
DvtCSSStyle.MARGIN = "margin";
DvtCSSStyle.MARGIN_TOP = "margin-top";
DvtCSSStyle.MARGIN_BOTTOM = "margin-bottom";
DvtCSSStyle.MARGIN_LEFT = "margin-left";
DvtCSSStyle.MARGIN_RIGHT = "margin-right";

// Padding Properties
DvtCSSStyle.PADDING = "padding";
DvtCSSStyle.PADDING_TOP = "padding-top";
DvtCSSStyle.PADDING_BOTTOM = "padding-bottom";
DvtCSSStyle.PADDING_LEFT = "padding-left";
DvtCSSStyle.PADDING_RIGHT = "padding-right";

// Font Properties
DvtCSSStyle.COLOR = "color";
DvtCSSStyle.FONT_FAMILY = "font-family";
DvtCSSStyle.FONT_SIZE = "font-size";
DvtCSSStyle.FONT_STYLE = "font-style";
DvtCSSStyle.FONT_WEIGHT = "font-weight";
DvtCSSStyle.TEXT_DECORATION = "text-decoration";
DvtCSSStyle.TEXT_ALIGN = "text-align";

//Bug 13842185 - DIFFICULT TO SIZE PGLS WHEN USING PADDING AND BORDERS
//value for box-sizing
DvtCSSStyle.BORDER_BOX = "border-box";
DvtCSSStyle.CONTENT_BOX = "content-box";

// Size Properties
DvtCSSStyle.HEIGHT = "height";
DvtCSSStyle.WIDTH = "width";

//value for background-image
DvtCSSStyle.NONE = "none";

//values for background-repeat
DvtCSSStyle.NO_REPEAT = "no-repeat";
DvtCSSStyle.REPEAT = "repeat";
DvtCSSStyle.REPEAT_X = "repeat-x";
DvtCSSStyle.REPEAT_Y = "repeat-y";

//value for margin
DvtCSSStyle.AUTO = "auto";
DvtCSSStyle.AUTO_MARGIN = "8";

//HV recognizes these for "gradient" or "solid"
DvtCSSStyle.BORDER_TYPE = "border-type";
DvtCSSStyle.FILL_TYPE = "fill-type";

//used for icon url
DvtCSSStyle.CONTENT = "content";

//For Alta selection effects. Not proper CSS and should move when possible
DvtCSSStyle.INNER_COLOR = "-tr-inner-color";
DvtCSSStyle.OUTER_COLOR = "-tr-outer-color";

/** @private **/
DvtCSSStyle._NAMED_FONT_SIZE_MAP = {
  "xx-small" : "9", "x-small" : "10", "small" : "13", "medium" : "16", "large" : "18", "x-large" : "24", "xx-large" : "32"
};

/** @private **/
DvtCSSStyle._NAMED_WIDTH_MAP = {
  thin : "2", medium : "4", thick : "6"
};

/** @private **/
DvtCSSStyle._NAMED_COLOR_MAP = {
  aqua : "#00FFFF", black : "#000000", blue : "#0000FF", white : "#FFFFFF", fuchsia : "#FF00FF", gray : "#848284", lime : "#00FF00", maroon : "#840000", green : "#008200", navy : "#000084", olive : "#848200", red : "#FF0000", silver : "#C6C3C6", teal : "#008284", yellow : "#FFFF00", purple : "#800080", 

  // for testing used
  cyan : "#D2B48C", goldenrod : "#DAA520", lightblue : "#ADD8E6", lightyellow : "#FFFFE0", orange : "#FFA500", paleGoldenRod : "#EEE8AA", paleturquoise : "#AFEEEE", peachpuff : "#FFDAB9", pink : "#FFC0CB", tan : "#D2B48C", thistle : "#D8BFD8", transparent : "transparent"
};

// numeric attributes List
DvtCSSStyle._numericAttrsList = [DvtCSSStyle.WIDTH, DvtCSSStyle.HEIGHT, DvtCSSStyle.BORDER_WIDTH, DvtCSSStyle.BORDER_TOP_WIDTH, DvtCSSStyle.BORDER_BOTTOM_WIDTH, DvtCSSStyle.BORDER_LEFT_WIDTH, DvtCSSStyle.BORDER_RIGHT_WIDTH, DvtCSSStyle.MARGIN, DvtCSSStyle.MARGIN_TOP, DvtCSSStyle.MARGIN_BOTTOM, DvtCSSStyle.MARGIN_LEFT, DvtCSSStyle.MARGIN_RIGHT, DvtCSSStyle.PADDING, DvtCSSStyle.PADDING_TOP, DvtCSSStyle.PADDING_BOTTOM, DvtCSSStyle.PADDING_LEFT, DvtCSSStyle.PADDING_RIGHT];

DvtCSSStyle._DOUBLE_QUOTE = "\"";
DvtCSSStyle._SINGLE_QUOTE = "'";

// Default color ramps
DvtCSSStyle.COLORS_SKYROS = ["#003366", "#CC3300", "#666699", "#006666", "#FF9900", "#993366", "#99CC33", "#624390", "#669933", "#FFCC33", "#006699", "#EBEA79"];
DvtCSSStyle.COLORS_ALTA = ["#267db3", "#68c182", "#fad55c", "#ed6647", "#8561c8", "#6ddbdb", "#ffb54d", "#e371b2", "#47bdef", "#a2bf39", "#a75dba", "#f7f37b"];

/**
 * Initializes the DvtCSSStyle using the specified inline style string.
 * @param {String} style The inline style string containing the attributes for this DvtCSSStyle.
 * @protected
 */
DvtCSSStyle.prototype.Init = function (style) {
  // Initialize the object map containing all the style properties
  this._styleMap = {
  };

  this.parseInlineStyle(style);
};

/**
 * Parse an inlineStyle string into a set of CSS styles and merge the results to this style object.
 * @param {String} style inlineStyle
 */
DvtCSSStyle.prototype.parseInlineStyle = function (style) {
  if (style && style.length > 0) {
    var splits = style.split(";");
    for (var i = 0;i < splits.length;i++) {
      var s = splits[i];
      if (s && s.length > 0) {
        //find the first colon instead of using String.split because
        //there may be other colons in the string, for instance in
        //a fully qualified background-image url (http://some.server.com/...)
        var colonIndex = s.indexOf(":");
        if (colonIndex >  - 1) {
          var attrName = DvtStringUtils.trim(s.substring(0, colonIndex));
          var attrVal = DvtStringUtils.trim(s.substring(colonIndex + 1));

          if (attrName && attrName.length > 0 && attrVal && attrVal.length > 0) {

            //inline images with data url
            if (attrName == DvtCSSStyle.BACKGROUND_IMAGE && attrVal.indexOf("data:image/") >= 0) {
              attrVal = attrVal + ";" + splits[i + 1];
              i++;
            }

            this.setStyle(attrName, attrVal);
          }
        }
      }
    }
  }
}

/**
 * Sets the value for a CSS attribute. This function will do all necessary conversion for the value.
 * @param {string} key The attribute name.
 * @param {string} val The attribute value.
 * @return {DvtCSSStyle} This DvtCSSStyle instance, useful for linking calls.
 */
DvtCSSStyle.prototype.setStyle = function (key, val) {
  // TODO: This function can be made faster by indexing the attributes to their conversion routines.
  // TODO: This function can be made faster by removing unnecessary conversion routines (color)
  if(val == null)
    this._setStyleAttr(key, val);
  else {
    // The specialized routines don't do a good job of null checking. TODO CLEANUP
    switch (key) {
      case "background-repeat":
        this._setBackgroundRepeat(key, val);
        break;
      case "color":
      case "background-color":
      case "border-top-color":
      case "border-bottom-color":
      case "border-left-color":
      case "border-right-color":
        this._setColorAttr(key, val);
        break;
  
      case "border-top":
      case "border-bottom":
      case "border-left":
      case "border-right":
        this._setBorderSide(key, val);
        break;
  
      case "border":
        this._setBorderShorthand(key, val);
        break;
      case "border-color":
        this._setBorderColorShorthand(key, val);
        break;
      case "border-width":
        this._setBorderWidthShorthand(key, val);
        break;
  
      //bug 13826956 - border-radius css property not supported when used inside <dvt:node>
      case "border-radius":
        this._setBorderRadius(key, val);
        break;
  
      case "padding":
        this._setPaddingShorthand(key, val);
        break;
      case "margin":
        this._setMarginShorthand(key, val);
        break;
      case "font-size":
        this.setFontSize(key, val);
        break;
  
      //Bug 13365200 - hv command button loses gradient
      //TODO: allow gradient syntax on BACKGROUND_COLOR???
      case "background-image":
        var gradObj = DvtGradientParser.parseCSSGradient(val);
        if (gradObj) {
          val = gradObj;
        }
        this._setStyleAttr(key, val);
        break;
  
      //IE gradient syntax
      case DvtGradientParser.IE7_GD_FILTER:
      case DvtGradientParser.IE8_GD_FILTER:
      //remove quotes around the value
        var val1 = DvtGradientParser.removeQuotes(val, DvtCSSStyle._DOUBLE_QUOTE);
  
        var gradObj = DvtGradientParser.parseCSSGradient(val1);
        if (gradObj) {
          key = DvtCSSStyle.BACKGROUND_IMAGE;
          val = gradObj;
        }
  
        this._setStyleAttr(key, val);
        break;
  
      default :
        this._setStyleAttr(key, val);
        break;
    }
  }

  // Return this instance to support linking of set calls.
  return this;
}

/**
 * Returns the value of the specified style property.
 * @param {string} key The style property whose value will be returned.
 * @return {string} The value of the specified style property.
 */
DvtCSSStyle.prototype.getStyle = function (key) {
  return this._styleMap[key];
}

/**
 * Specifies the value of the specified style property.  Does not perform any conversion.
 * @param {string} key The style property whose value will be returned.
 * @param {string} value The value of the specified style property.
 * @return {DvtCSSStyle} This DvtCSSStyle instance, useful for linking calls.
 * @private
 */
DvtCSSStyle.prototype._setStyleAttr = function (key, value) {
  if (value != null)
    this._styleMap[key] = value;
  else delete this._styleMap[key];

  return this;
}

/**
 * Sets the font-size on a DvtCSSStyle object
 * @param {string} key The css key to set the font-size under TODO hzhang, is this ever not font-size?
 * @param {string} val The font-size which can be in the format '9', '9px', or 'xx-small'
 */
DvtCSSStyle.prototype.setFontSize = function (key, val) {
  var fsize = DvtStringUtils.trim(val);
  var specSize = DvtCSSStyle._NAMED_FONT_SIZE_MAP[fsize];
  if (specSize)
    this._setStyleAttr(key, (String(specSize) + "px"));
  else 
    this._setStyleAttr(key, isNaN(parseFloat(fsize)) ? DvtStyleUtils.DEFAULT_FONT_SIZE : fsize);
}

/**
 * @param key is a shorthand for the four border properties: top, right, bottom and left border, respectively.
 * @param val may contain up to 4 border-width values.
 * @private
 */
DvtCSSStyle.prototype._setBorderWidthShorthand = function (key, val) {
  var bwArray = val.split(" ");
  var bWidth = null;

  switch (bwArray.length) {
    case 1:
      this._setStyleAttr(key, DvtCSSStyle._getBorderWidth(bwArray[0]));
      // remove other border widths
      this._setStyleAttr(DvtCSSStyle.BORDER_TOP_WIDTH, null);
      this._setStyleAttr(DvtCSSStyle.BORDER_BOTTOM_WIDTH, null);
      this._setStyleAttr(DvtCSSStyle.BORDER_RIGHT_WIDTH, null);
      this._setStyleAttr(DvtCSSStyle.BORDER_LEFT_WIDTH, null);
      break;

    case 2:
      bWidth = DvtCSSStyle._getBorderWidth(bwArray[0]);
      this._setStyleAttr(DvtCSSStyle.BORDER_TOP_WIDTH, bWidth);
      this._setStyleAttr(DvtCSSStyle.BORDER_BOTTOM_WIDTH, bWidth);

      bWidth = DvtCSSStyle._getBorderWidth(bwArray[1]);
      this._setStyleAttr(DvtCSSStyle.BORDER_LEFT_WIDTH, bWidth);
      this._setStyleAttr(DvtCSSStyle.BORDER_RIGHT_WIDTH, bWidth);
      break;

    case 3:
      this._setStyleAttr(DvtCSSStyle.BORDER_TOP_WIDTH, DvtCSSStyle._getBorderWidth(bwArray[0]));
      bWidth = DvtCSSStyle._getBorderWidth(bwArray[1]);
      this._setStyleAttr(DvtCSSStyle.BORDER_LEFT_WIDTH, bWidth);
      this._setStyleAttr(DvtCSSStyle.BORDER_RIGHT_WIDTH, bWidth);
      this._setStyleAttr(DvtCSSStyle.BORDER_BOTTOM_WIDTH, DvtCSSStyle._getBorderWidth(bwArray[2]));
      break;

    case 4:
      this._setStyleAttr(DvtCSSStyle.BORDER_TOP_WIDTH, DvtCSSStyle._getBorderWidth(bwArray[0]));
      this._setStyleAttr(DvtCSSStyle.BORDER_RIGHT_WIDTH, DvtCSSStyle._getBorderWidth(bwArray[1]));
      this._setStyleAttr(DvtCSSStyle.BORDER_BOTTOM_WIDTH, DvtCSSStyle._getBorderWidth(bwArray[2]));
      this._setStyleAttr(DvtCSSStyle.BORDER_LEFT_WIDTH, DvtCSSStyle._getBorderWidth(bwArray[3]));
      break;

    case 0:
    default :
      break;
  }
}

/**
 * @param val contain only one borderWidth value
 * @private
 */
DvtCSSStyle._getBorderWidth = function (val) {

  var bwidth = DvtStringUtils.trim(val);
  var specSize = DvtCSSStyle._NAMED_WIDTH_MAP[bwidth];
  if (!specSize) {
    specSize = isNaN(parseFloat(bwidth)) ? "0px" : bwidth;
  }

  return specSize;
}

/**
 * @param {string} key The border-*** attribute, such as border-top.
 * @param {string} val The value of the border property, such as "#797975 1px solid".  Accepts width, style, and color
 *                     in any order, separated by spaces.
 * @private
 */
DvtCSSStyle.prototype._setBorderSide = function (key, val) {
  var borderArray = val.split(" ");
  var borderVal = null;
  var noBorder = false;
  var key1;

  for (var i = 0;i < borderArray.length;i++) {
    borderVal = borderArray[i];
    key1 = key;

    //rgb border color
    if (borderVal.indexOf("rgb") == 0) {
      for (var k = i + 1;k < borderArray.length;k++) {
        borderVal += borderArray[k];
        i++;
        if (borderArray[k].indexOf(")") !=  - 1)
          break;
      }
      if (!DvtStringUtils.endsWith(key, "-" + DvtCSSStyle.COLOR))
        key1 = key + "-" + DvtCSSStyle.COLOR;
      this._setStyleAttr(key1, borderVal);
    }
    //border color
    else if (DvtCSSStyle._isColorValue(borderVal)) {
      if (!DvtStringUtils.endsWith(key, "-" + DvtCSSStyle.COLOR))
        key1 = key + "-" + DvtCSSStyle.COLOR;
      this._setStyleAttr(key1, DvtCSSStyle._parseHexColor(borderVal));
    }
    //border width
    else if (DvtCSSStyle._isBorderWidthValue(borderVal)) {
      if (!DvtStringUtils.endsWith(key, "-" + DvtCSSStyle.WIDTH))
        key1 = key + "-" + DvtCSSStyle.WIDTH;
      this._setStyleAttr(key1, borderVal);
    }
    //we don't currently handle border style, but if it's none, set width=0
    else if (val == "none")
      noBorder = true;
  }

  if (noBorder) {
    this._setStyleAttr(key + "-" + DvtCSSStyle.WIDTH, "0");
  }
}

/**
 * Computes and returns the border width for the specified side.
 * @param {string} key The border-***-width attribute, such as border-top-width.
 * @param {number}
 */
DvtCSSStyle.prototype.getBorderSideWidth = function (key) {
  return this._getSideWidth(key, DvtCSSStyle.BORDER_WIDTH);
}

/**
 * Computes and returns the margin for the specified side.
 * @param {string} key The margin-*** attribute, such as margin-top.
 * @param {number}
 */
DvtCSSStyle.prototype.getMargin = function (key) {
  return this._getSideWidth(key, DvtCSSStyle.MARGIN);
}

/**
 * Computes and returns the padding for the specified side.
 * @param {string} key The padding-*** attribute, such as padding-top.
 * @param {number}
 */
DvtCSSStyle.prototype.getPadding = function (key) {
  return this._getSideWidth(key, DvtCSSStyle.PADDING);
}

DvtCSSStyle.prototype.getBorderWidth = function () {
  var bwidth = this.getStyle(DvtCSSStyle.BORDER_WIDTH);
  if (bwidth) {
    return DvtCSSStyle.toNumber(bwidth);
  }
  bwidth = this.getStyle(DvtCSSStyle.BORDER_TOP_WIDTH);
  if (bwidth) {
    return DvtCSSStyle.toNumber(bwidth);
  }
  bwidth = this.getStyle(DvtCSSStyle.BORDER_RIGHT_WIDTH);
  if (bwidth) {
    return DvtCSSStyle.toNumber(bwidth);
  }
  bwidth = this.getStyle(DvtCSSStyle.BORDER_BOTTOM_WIDTH);
  if (bwidth) {
    return DvtCSSStyle.toNumber(bwidth);
  }
  bwidth = this.getStyle(DvtCSSStyle.BORDER_LEFT_WIDTH);
  if (bwidth) {
    return DvtCSSStyle.toNumber(bwidth);
  }
  return 0;
}

// width and height
DvtCSSStyle.prototype.getWidth = function () {
  return this.getStyle(DvtCSSStyle.WIDTH);
}

DvtCSSStyle.prototype.getHeight = function () {
  return this.getStyle(DvtCSSStyle.HEIGHT);
}

/**
 * Convert a string to a number
 *
 * @return a number or zero if not a number or value is not specified
 */
DvtCSSStyle.toNumber = function (val) {
  if (val) {
    val = parseFloat(val);
    return isNaN(val) ? 0 : val;
  }
  return 0;
};

/**
 * Determine if the given style can be inherited.
 *
 * @return true if the style can be inherited from an ancestor,
 *         false if not
 */
DvtCSSStyle.isInheritable = function (key) {
  switch (key) {
    case DvtCSSStyle.COLOR:
    case DvtCSSStyle.FONT_FAMILY:
    case DvtCSSStyle.FONT_SIZE:
    case DvtCSSStyle.FONT_STYLE:
    case DvtCSSStyle.FONT_WEIGHT:
    case DvtCSSStyle.TEXT_ALIGN:
      return true;

    default :
      return false;
  }
}

// val is a string contains up to 4 rgb colors, ex:
// border-color: rgb(221, 221, 216) rgb(185, 185, 132) rgb(121, 121, 117)
DvtCSSStyle.prototype._setBorderColorShorthand = function (key, val) {
  var bcArray = DvtCSSStyle._parseBorderColorString(key, val);
  var bcolor;

  switch (bcArray.length) {
    case 1:
      this._setStyleAttr(key, bcArray[0]);
      this._setStyleAttr(DvtCSSStyle.BORDER_TOP_COLOR, null);
      this._setStyleAttr(DvtCSSStyle.BORDER_BOTTOM_COLOR, null);
      this._setStyleAttr(DvtCSSStyle.BORDER_RIGHT_COLOR, null);
      this._setStyleAttr(DvtCSSStyle.BORDER_LEFT_COLOR, null);
      break;

    case 2:
      bcolor = bcArray[0];
      this._setStyleAttr(DvtCSSStyle.BORDER_TOP_COLOR, bcolor);
      this._setStyleAttr(DvtCSSStyle.BORDER_BOTTOM_COLOR, bcolor);

      bcolor = bcArray[1];
      this._setStyleAttr(DvtCSSStyle.BORDER_LEFT_COLOR, bcolor);
      this._setStyleAttr(DvtCSSStyle.BORDER_RIGHT_COLOR, bcolor);
      break;

    case 3:
      this._setStyleAttr(DvtCSSStyle.BORDER_TOP_COLOR, bcArray[0]);
      bcolor = bcArray[1];
      this._setStyleAttr(DvtCSSStyle.BORDER_LEFT_COLOR, bcolor);
      this._setStyleAttr(DvtCSSStyle.BORDER_RIGHT_COLOR, bcolor);
      this._setStyleAttr(DvtCSSStyle.BORDER_BOTTOM_COLOR, bcArray[2]);
      break;

    case 4:
      this._setStyleAttr(DvtCSSStyle.BORDER_TOP_COLOR, bcArray[0]);
      this._setStyleAttr(DvtCSSStyle.BORDER_RIGHT_COLOR, bcArray[1]);
      this._setStyleAttr(DvtCSSStyle.BORDER_BOTTOM_COLOR, bcArray[2]);
      this._setStyleAttr(DvtCSSStyle.BORDER_LEFT_COLOR, bcArray[3]);
      break;

    case 0:
    default :
      break;
  }
};

// val is a string contains up to 4 padding sizes, ex:
// padding: 2px 9px 1px
DvtCSSStyle.prototype._setPaddingShorthand = function (key, val) {
  var padArray = val.split(" ");
  var padding = null;

  switch (padArray.length) {
    case 1:
      this._setStyleAttr(key, this._getPercent(padArray[0]));
      this._setStyleAttr(DvtCSSStyle.PADDING_TOP, null);
      this._setStyleAttr(DvtCSSStyle.PADDING_BOTTOM, null);
      this._setStyleAttr(DvtCSSStyle.PADDING_RIGHT, null);
      this._setStyleAttr(DvtCSSStyle.PADDING_LEFT, null);
      break;

    case 2:
      padding = this._getPercent(padArray[0]);
      this._setStyleAttr(DvtCSSStyle.PADDING_TOP, padding);
      this._setStyleAttr(DvtCSSStyle.PADDING_BOTTOM, padding);

      padding = this._getPercent(padArray[1]);
      this._setStyleAttr(DvtCSSStyle.PADDING_LEFT, padding);
      this._setStyleAttr(DvtCSSStyle.PADDING_RIGHT, padding);
      break;

    case 3:
      this._setStyleAttr(DvtCSSStyle.PADDING_TOP, this._getPercent(padArray[0]));
      padding = this._getPercent(padArray[1]);
      this._setStyleAttr(DvtCSSStyle.PADDING_LEFT, padding);
      this._setStyleAttr(DvtCSSStyle.PADDING_RIGHT, padding);
      this._setStyleAttr(DvtCSSStyle.PADDING_BOTTOM, this._getPercent(padArray[2]));
      break;

    case 4:
      this._setStyleAttr(DvtCSSStyle.PADDING_TOP, this._getPercent(padArray[0]));
      this._setStyleAttr(DvtCSSStyle.PADDING_RIGHT, this._getPercent(padArray[1]));
      this._setStyleAttr(DvtCSSStyle.PADDING_BOTTOM, this._getPercent(padArray[2]));
      this._setStyleAttr(DvtCSSStyle.PADDING_LEFT, this._getPercent(padArray[3]));
      break;

    case 0:
    default :
      break;
  }
};

// val is a string contains up to 4 margin sizes, ex:
// margin: 2px 9px 1px
//TODO: margin can be negative numbers and in CM
DvtCSSStyle.prototype._setMarginShorthand = function (key, val) {
  var padArray = val.split(" ");
  var margin = null;

  switch (padArray.length) {
    case 1:
      this._setStyleAttr(key, this._getMargin(padArray[0]));
      this._setStyleAttr(DvtCSSStyle.MARGIN_TOP, null);
      this._setStyleAttr(DvtCSSStyle.MARGIN_BOTTOM, null);
      this._setStyleAttr(DvtCSSStyle.MARGIN_RIGHT, null);
      this._setStyleAttr(DvtCSSStyle.MARGIN_LEFT, null);
      break;

    case 2:
      margin = this._getMargin(padArray[0]);
      this._setStyleAttr(DvtCSSStyle.MARGIN_TOP, margin);
      this._setStyleAttr(DvtCSSStyle.MARGIN_BOTTOM, margin);

      margin = this._getMargin(padArray[1]);
      this._setStyleAttr(DvtCSSStyle.MARGIN_LEFT, margin);
      this._setStyleAttr(DvtCSSStyle.MARGIN_RIGHT, margin);
      break;

    case 3:
      this._setStyleAttr(DvtCSSStyle.MARGIN_TOP, this._getMargin(padArray[0]));
      margin = this._getMargin(padArray[1]);
      this._setStyleAttr(DvtCSSStyle.MARGIN_LEFT, margin);
      this._setStyleAttr(DvtCSSStyle.MARGIN_RIGHT, margin);
      this._setStyleAttr(DvtCSSStyle.MARGIN_BOTTOM, this._getMargin(padArray[2]));
      break;

    case 4:
      this._setStyleAttr(DvtCSSStyle.MARGIN_TOP, this._getMargin(padArray[0]));
      this._setStyleAttr(DvtCSSStyle.MARGIN_RIGHT, this._getMargin(padArray[1]));
      this._setStyleAttr(DvtCSSStyle.MARGIN_BOTTOM, this._getMargin(padArray[2]));
      this._setStyleAttr(DvtCSSStyle.MARGIN_LEFT, this._getMargin(padArray[3]));
      break;

    case 0:
    default :
      break;
  }
};

//TODO: auto size defined by browsers
DvtCSSStyle.prototype._getMargin = function (val) {
  var margin = DvtStringUtils.trim(val);
  if (DvtCSSStyle.AUTO == margin)
    return DvtCSSStyle.AUTO_MARGIN;
  else 
    return this._getPercent(margin);
}

// TODO: No idea how this has anything to do with percentages
DvtCSSStyle.prototype._getPercent = function (val) {
  return DvtStringUtils.trim(val);
}

DvtCSSStyle.prototype._setBorderShorthand = function (key, val) {
  /*
   * "border" Shorthand property can specify width, style, and color
   * separated by spaces, which are applied to all 4 border sides
   * ex: "1px solid rgb(185, 185, 180)"
   */
  var borderArray = val.split(" ");
  var borderVal = null;
  var noBorder = false;

  for (var i = 0;i < borderArray.length;i++) {
    borderVal = borderArray[i];

    //rgb border color
    if (borderVal.indexOf("rgb") == 0) {
      for (var k = i + 1;k < borderArray.length;k++) {
        borderVal += borderArray[k];
        i++;
        if (borderArray[k].indexOf(")") !=  - 1)
          break;
      }
      this._setBorderColorShorthand(DvtCSSStyle.BORDER_COLOR, borderVal);
    }

    //border color
    else if (DvtCSSStyle._isColorValue(borderVal))
      this._setBorderColorShorthand(DvtCSSStyle.BORDER_COLOR, borderVal);

    //border width
    else if (DvtCSSStyle._isBorderWidthValue(borderVal))
      this._setBorderWidthShorthand(DvtCSSStyle.BORDER_WIDTH, borderVal);

    //we don't currently handle border style, but if it's none, set width=0
    else if (val == "none")
      noBorder = true;

  }

  if (noBorder) {
    this._setBorderWidthShorthand(DvtCSSStyle.BORDER_WIDTH, "0");
  }
};

DvtCSSStyle._getBorderRadius = function (val) {

  var radii = DvtStringUtils.trim(val);
  return isNaN(parseFloat(radii)) ? "0px" : radii;
};

//bug 13826956 - border-radius css property not supported when used inside <dvt:node>
DvtCSSStyle.prototype._setBorderRadius = function (key, val) {
  /*
   * border-radius: 1-4 length|% / 1-4 length|%;
   *
   * Note: order of 4 values: top-left, top-right, bottom-right, bottom-left.
   * If bottom-left is omitted it is the same as top-right. If bottom-right is omitted 
   * it is the same as top-left. 
   */
  var brArray = val.split("/");
  if (brArray[0] == null) {
    this._setStyleAttr(key, "0px");
    return;
  }
  // horizontal radii
  var brHorzArr = DvtStringUtils.trim(brArray[0]).split(" ");
  var bRadius = null;

  switch (brHorzArr.length) {
    case 1:
    default :
      this._setStyleAttr(key, DvtCSSStyle._getBorderRadius(brHorzArr[0]));
      // remove other border radius
      this._setStyleAttr(DvtCSSStyle.BORDER_TOP_LEFT_RADIUS, null);
      this._setStyleAttr(DvtCSSStyle.BORDER_TOP_RIGHT_RADIUS, null);
      this._setStyleAttr(DvtCSSStyle.BORDER_BOTTOM_RIGHT_RADIUS, null);
      this._setStyleAttr(DvtCSSStyle.BORDER_BOTTOM_LEFT_RADIUS, null);
      break;

    /*
 * only support 4 corner with the same radius

  case 2:
    bRadius = DvtCSSStyle._getBorderRadius(brHorzArr[0]);
    this._setStyleAttr(DvtCSSStyle.BORDER_TOP_LEFT_RADIUS, bRadius);
    this._setStyleAttr(DvtCSSStyle.BORDER_BOTTOM_RIGHT_RADIUS, bRadius);

    bRadius = DvtCSSStyle._getBorderRadius(brHorzArr[1]);
    this._setStyleAttr(DvtCSSStyle.BORDER_TOP_RIGHT_RADIUS, bRadius);
    this._setStyleAttr(DvtCSSStyle.BORDER_BOTTOM_LEFT_RADIUS, bRadius);
    break;

  case 3:
    this._setStyleAttr(DvtCSSStyle.BORDER_TOP_LEFT_RADIUS, DvtCSSStyle._getBorderRadius(brHorzArr[0]));
    bRadius = DvtCSSStyle._getBorderRadius(brHorzArr[1]);
    this._setStyleAttr(DvtCSSStyle.BORDER_TOP_RIGHT_RADIUS, bRadius);
    this._setStyleAttr(DvtCSSStyle.BORDER_BOTTOM_RIGHT_RADIUS, DvtCSSStyle._getBorderRadius(brHorzArr[2]));
    this._setStyleAttr(DvtCSSStyle.BORDER_BOTTOM_LEFT_RADIUS, bRadius);
    break;

  case 4:
    this._setStyleAttr(DvtCSSStyle.BORDER_TOP_LEFT_RADIUS, DvtCSSStyle._getBorderRadius(brHorzArr[0]));
    this._setStyleAttr(DvtCSSStyle.BORDER_TOP_RIGHT_RADIUS, DvtCSSStyle._getBorderRadius(brHorzArr[1]));
    this._setStyleAttr(DvtCSSStyle.BORDER_BOTTOM_RIGHT_RADIUS, DvtCSSStyle._getBorderRadius(brHorzArr[2]));
    this._setStyleAttr(DvtCSSStyle.BORDER_BOTTOM_LEFT_RADIUS, DvtCSSStyle._getBorderRadius(brHorzArr[3]));
    break;

  case 0:
  default:
    break;

*/
  }

  // vertical radii
  if (brArray.length == 2 && brArray[1] != null) {
    var brVertArr = DvtStringUtils.trim(brArray[1]).split(" ");

    switch (brVertArr.length) {
      case 1:
        if (this.getStyle(key))
          this._setStyleAttr(key, this.getStyle(key) + " " + DvtCSSStyle._getBorderRadius(brVertArr[0]));
        else 
          this._setStyleAttr(key, DvtCSSStyle._getBorderRadius(brVertArr[0]));
        break;

      case 0:
      default :
        break;
    }
  }

};

/**
 * Returns border radius as a number. If the radius were not set for this style, returns 0
 * @return {number} border radius
 */
DvtCSSStyle.prototype.getBorderRadius = function () {
  if (this.getStyle(DvtCSSStyle.BORDER_RADIUS) !== "undefined" && this.getStyle(DvtCSSStyle.BORDER_RADIUS) !== null)
    return DvtCSSStyle.toNumber(this.getStyle(DvtCSSStyle.BORDER_RADIUS));
  else 
    return 0;
};

DvtCSSStyle.prototype._setBackgroundRepeat = function (key, val) {
  var a = val.split(" ");

  // Bug 10080044 - buttons look broken on safari
  // in Safari button -> background-repeat: repeat no-repeat 
  if (a.length == 2) {
    // both repeat or no_repeat
    if (a[0] == a[1])
      val = a[0];
    else if (a[0] == DvtCSSStyle.REPEAT && a[1] == DvtCSSStyle.NO_REPEAT)
      val = DvtCSSStyle.REPEAT_X;
    if (a[0] == DvtCSSStyle.NO_REPEAT && a[1] == DvtCSSStyle.REPEAT)
      val = DvtCSSStyle.REPEAT_Y;
  }
  this._setStyleAttr(key, val);
};

/**
 * set a color attribute
 *
 * @param {string} key color attribute
 * @param {string} val is a string in color keyword or a numeric value in #AARRGGBB or #RRGGBB format
 */
DvtCSSStyle.prototype._setColorAttr = function (key, val) {
  // TODO HZHANG: This entire function seems unnecessary
  var color = DvtCSSStyle._toColorVal(val);
  if (color) {
    this._setStyleAttr(key, color);
  }
  else if (DvtCSSStyle._isColorValue(val)) {
    this._setStyleAttr(key, val);
  }
}

/**
 * If the given string is a color keyword, return its color value
 *
 * @param s string that may specify a color keyword
 * @return color value if the string is a color keyword.
 */
DvtCSSStyle._toColorVal = function (val) {
  // TODO HZHANG: This entire function seems unnecessary
  val = DvtStringUtils.trim(val);

  // color name?
  var color = DvtCSSStyle._NAMED_COLOR_MAP[val.toLowerCase()];
  if (color) {
    return color;
  }
  return null;
}

DvtCSSStyle.prototype.setColor = function (key, val) {
  this._setStyleAttr(key, val);
}

/**
 * @private
 * @param value a number with unit
 */
DvtCSSStyle._isValueInEM = function (value) {
  return value.toLowerCase().indexOf("em") >= 0;
}

/**
 * @private
 * @param key its value is a number with unit
 * @param fontSize (string) a number with unit
 *
 */
DvtCSSStyle.prototype._resolveEMx = function (key, fontSize) {
  var value = this.getStyle(key);

  if (value && DvtCSSStyle._isValueInEM(value)) {
    // if value is in EM unit, convert it to px so value no longer in EM
    if (fontSize) {
      this._setStyleAttr(key, String(Math.round(parseFloat(value) * parseFloat(fontSize))) + "px");
      return true;
    }
    return false;
  }
  return true;
};

/**
 * @return font size if is a font size is specified and not in relative length unit(em)
 * otherwise return null
 */
DvtCSSStyle.prototype.getAbsoluteFontSize = function () {
  // get the current font size
  var fontSize = this.getFontSize();
  if (fontSize && !DvtCSSStyle._isValueInEM(fontSize)) {
    return fontSize;
  }
  return null;
};

/**
 * @param {string} fontSize to be used in resolving em if no fontSize specified in this css style
 */
DvtCSSStyle.prototype.resolveEM = function (fontSize) {

  // try to resolved em unit with the current font size
  var myFontSize = this.getFontSize();

  if (myFontSize) {
    // FONT_SIZE value is in "em" 
    if (DvtCSSStyle._isValueInEM(myFontSize)) {
      // resolve fontSize and use this new fontSize value
      this._resolveEMx(DvtCSSStyle.FONT_SIZE, fontSize);
    }
    // FONT_SIZE value is NOT in "em", use new fontSize value
    else {
      fontSize = myFontSize;
    }
  }

  var numList = DvtCSSStyle._numericAttrsList;
  for (var i = 0;i < numList.length;i++) {
    if (!this._resolveEMx(numList[i], fontSize)) {
      return false;
    }
  }
  return true;
};

/**
 * return a copy of this object
 */
DvtCSSStyle.prototype.clone = function () {
  var ret = new DvtCSSStyle();
  for (var key in this._styleMap) {
    ret._setStyleAttr(key, this.getStyle(key));
  }
  return ret;
}

/**
 * Merge the properties of the given CSSStyle into this one.
 *
 * @param style properties to merge into this CSSStyle
 */
DvtCSSStyle.prototype.merge = function (style) {
  if (style) {
    for (var key in style._styleMap) {
      this._setStyleAttr(key, style.getStyle(key));
    }
  }
  return this;
}

/**
 * Merge the properties of the given CSSStyle under this one.
 *
 * @param style properties to merge under this CSSStyle
 */
DvtCSSStyle.prototype.mergeUnder = function (style) {
  if (style) {
    for (var key in style._styleMap) {
      if (!this.getStyle(key))
        this._setStyleAttr(key, style.getStyle(key));
    }
  }
  return this;
}

/**
 * Returns a inline style representation of the style attributes contained in this DvtCSSStyle.
 * @return {string}
 */
DvtCSSStyle.prototype.toString = function () {
  var strBuf = "";
  for (var key in this._styleMap) {
    strBuf += key + ":" + this.getStyle(key) + "; ";
  }
  return strBuf;
}

DvtCSSStyle.prototype.getBackgroundImage = function () {
  var ret = this.getStyle(DvtCSSStyle.BACKGROUND_IMAGE);

  var startx;
  var endx;

  if (ret && (ret instanceof DvtCSSGradient)) {
    return ret;
  }

  //strip off the 'url(' and ')'
  if (ret) {
    startx = ret.indexOf("url(");
    endx = ret.lastIndexOf(")");
    if ((startx == 0) && (endx == (ret.length - 1))) {
      ret = ret.substring(4, endx);
    }
  }

  //strip off single or double quotes
  if (ret) {
    startx = ret.indexOf(DvtCSSStyle._SINGLE_QUOTE);
    endx = ret.lastIndexOf(DvtCSSStyle._SINGLE_QUOTE);
    if ((startx == 0) && (endx == (ret.length - 1))) {
      ret = ret.substring(1, endx);
    }
    else {
      startx = ret.indexOf(DvtCSSStyle._DOUBLE_QUOTE);
      endx = ret.lastIndexOf(DvtCSSStyle._DOUBLE_QUOTE);
      if ((startx == 0) && (endx == (ret.length - 1))) {
        ret = ret.substring(1, endx);
      }
    }
  }

  return ret;
};

/**
 * Determine if the given string specifies a color value.
 *
 * @param s string that may specify a color value
 *
 * @return true if the string specifies a color value, false otherwise
 */
DvtCSSStyle._isColorValue = function (val) {
  val = DvtStringUtils.trim(val);

  if (val.indexOf("rgb") == 0 || val.indexOf("#") == 0)
    return true;

  // color name?
  var color = DvtCSSStyle._NAMED_COLOR_MAP[val.toLowerCase()];
  if (color) {
    return true;
  }
  return false;
};

/**
 * @private
 * #param val contain only one borderWidth value
 */
DvtCSSStyle._isBorderWidthValue = function (val) {

  var bwidth = DvtStringUtils.trim(val);
  if (DvtCSSStyle._NAMED_WIDTH_MAP[bwidth])
    return true;

  return !isNaN(parseFloat(bwidth));
};

// val is a string contains up to 4 rgb colors, ex:
// border-color: rgb(221, 221, 216) rgb(185, 185, 132) rgb(121, 121, 117)
DvtCSSStyle._parseBorderColorString = function (key, val) {

  var val = DvtStringUtils.trim(val);
  var cArray = [];
  while (val != null && val.length > 0) {
    val = DvtCSSStyle.parseBorderColor(val, cArray);
  }
  return cArray;
};

DvtCSSStyle.parseBorderColor = function (val, cArray) {
  val = DvtStringUtils.trim(val);
  var strLen = val.length;
  var endIndex =  - 1;
  var colorObj;

  if (!val) {
    return val;
  }
  // rgb format?
  if (val.indexOf("rgb") == 0) {
    endIndex = val.indexOf(")") + 1;
    colorObj = val.slice(0, endIndex);
  }

  // color name?
  else {
    endIndex = val.indexOf(" ");
    if (endIndex ==  - 1)
      endIndex = strLen;
    var singleColor = val.slice(0, endIndex);

    colorObj = DvtCSSStyle._toColorVal(singleColor);

    // hex color
    if (!colorObj) {
      colorObj = DvtCSSStyle._parseHexColor(singleColor);
    }
  }

  if (colorObj) {
    cArray.push(colorObj);
    val = val.slice(endIndex);
  }
  return val;
}

// val is a string in #AARRGGBB or #RRGGBB format
DvtCSSStyle._parseHexColor = function (s) {
  var n;
  var colorObj;
  if (s && s.length > 0) {
    var bHasAlpha = (s.length > 7);
    n = Number("0x" + s.substring(1));
    if (isNaN(n)) {
      n = 0;// assume black if we didn't get a valid numeric string
    }
    if (bHasAlpha) {
      var x = "#" + s.substring(3);
      colorObj = x;
    }
    else {
      colorObj = s;
    }
  }
  return colorObj;
}

// get padding-top, padding-right, padding-bottom and padding-left
// get border-top-width, border-right-width, border-bottom-width and border-left=width
// get margin-top, margin-right, margin-bottom and margin-left
//TODO: percent
DvtCSSStyle.prototype._getSideWidth = function (key, shortKey) {
  var side = this.getStyle(key);
  if (!side) {
    side = this.getStyle(shortKey);
  }
  return DvtCSSStyle.toNumber(side);
}

DvtCSSStyle.prototype.getFontSize = function () {
  return this.getStyle(DvtCSSStyle.FONT_SIZE);
}

// Returns a CSSStyle object as a merge of the array
DvtCSSStyle.mergeStyles = function (styleArray) {
  var style = new DvtCSSStyle();
  if (styleArray) {
    for (var i = 0;i < styleArray.length;i++) {
      style.merge(styleArray[i]);
    }
  }
  return style;
}

/**
 * Returns true if this object does not contain any style properties.
 * @return {boolean}
 */
DvtCSSStyle.prototype.isEmpty = function () {
  for (var key in this._styleMap) {
    return false;
  }
  return true;
}

/**
 * Returns true if the text is set to align end.  Takes reading direction into account when dealing with values of
 * "left" and "right".
 * @param {DvtContext} context
 * @return {boolean}
 */
DvtCSSStyle.prototype.isTextAlignEnd = function (context) {
  var align = this.getStyle(DvtCSSStyle.TEXT_ALIGN);
  if (align == "end")
    return true;

  if (DvtAgent.isRightToLeft(context)) {
    return (align == "left");
  }
  else {
    return (align == "right");
  }
}

DvtCSSStyle.prototype.parseBackgroundPosition = function () {
  var s = this.getStyle(DvtCSSStyle.BACKGROUND_POSITION);
  if (!s)
    return null;

  var sPosArray = s.split(" ");
  if (sPosArray.length == 0)
    return ["0%", "0%"];

  var posArray = ["50%", "50%"];
  var position;
  if (sPosArray.length > 0) {
    position = DvtStringUtils.trim(sPosArray[0]);
    if (position == "left") {
      posArray[0] = "0%";
    }
    else if (position == "right") {
      posArray[0] = "100%";
    }
    else if (position == "top") {
      posArray[1] = "0%";
    }
    else if (position == "bottom") {
      posArray[1] = "100%";
    }
    // percent
    else if (position != "center") {
      posArray[0] = position;
    }
  }
  if (sPosArray.length > 1) {
    position = DvtStringUtils.trim(sPosArray[1]);
    if (position == "left") {
      posArray[0] = "0%";
    }
    else if (position == "right") {
      posArray[0] = "100%";
    }
    else if (position == "top") {
      posArray[1] = "0%";
    }
    else if (position == "bottom") {
      posArray[1] = "100%";
    }
    // percent
    else if (position != "center") {
      posArray[1] = position;
    }

  }
  return posArray;
}

DvtCSSStyle.prototype.getIconUrl = function () {
  return this.getStyle(DvtCSSStyle.CONTENT);
}

DvtCSSStyle.prototype.setIconUrl = function (url) {
  this._setStyleAttr(DvtCSSStyle.CONTENT, url);
}

/**
 * Returns a string that can be used as a hash code for caching text measurements.  Includes all attributes which can
 * affect the size of text.
 * @return {string}
 */
DvtCSSStyle.prototype.hashCodeForTextMeasurement = function() {
  // Use a combination of all attrs that affect dimensions calculations.
  var ret = "";
  if (this.getStyle(DvtCSSStyle.FONT_FAMILY))
    ret += this.getStyle(DvtCSSStyle.FONT_FAMILY);
  if (this.getStyle(DvtCSSStyle.FONT_SIZE))
    ret += this.getStyle(DvtCSSStyle.FONT_SIZE);
  if (this.getStyle(DvtCSSStyle.FONT_STYLE))
    ret += this.getStyle(DvtCSSStyle.FONT_STYLE);
  if (this.getStyle(DvtCSSStyle.FONT_WEIGHT))
    ret += this.getStyle(DvtCSSStyle.FONT_WEIGHT);
      
  return ret;
}
/**
 * Base class for JSON components.
 * @class
 * @constructor
 * @extends {DvtContainer}
 * @export
 */
var DvtBaseComponent = function() {
  // Components should implement newInstance factory methods instead of exposing contructors.
}

DvtObj.createSubclass(DvtBaseComponent, DvtContainer, "DvtBaseComponent");

/**
 * Initializes the component.
 * @param {DvtContext} context The rendering context.
 * @param {string} callback The function that should be called to dispatch component events.
 * @param {object} callbackObj The optional object instance on which the callback function is defined.
 * @protected
 */
DvtBaseComponent.prototype.Init = function(context, callback, callbackObj) {
  DvtBaseComponent.superclass.Init.call(this, context);
  this._callback = callback;
  this._callbackObj = callbackObj;
  
  /**
   * Reference to the DvtBaseComponentDefaults instance for this component.
   * @type {DvtBaseComponentDefaults}
   * @protected
   */
  this.Defaults = null;
  
  /**
   * Reference to the options specifications for the component.
   * @protected
   */
  this.Options = null;
}

/**
 * Returns a copy of the default options for the specified skin.
 * @param {string} skin The skin whose defaults are being returned.
 * @return {object} The object containing defaults for this component.
 * @protected
 */
DvtBaseComponent.prototype.GetDefaults = function(skin) 
{  
  // This function will work as long as this.Defaults is properly initialized.
  return this.Defaults ? this.Defaults.getDefaults(skin) : {};
}

/**
 * Specifies the options specifications for this component.
 * @param {object} options The object containing options specifications for this component.
 * @protected
 */
DvtBaseComponent.prototype.SetOptions = function(options) {
  // Subclasses should override
}

/**
 * Applies the specified options on top of the existing properties.  This function is only supported after the 
 * component is initially rendered.
 * @param {object} options The object containing data and specifications for this component.
 * @export
 */
DvtBaseComponent.prototype.applyOptions = function(options) 
{  
  if(!this.Options || !options)
    return;
    
  // Merge the new properties with the existing ones and set
  this.SetOptions(DvtJSONUtils.merge(options, this.Options));
}

/**
 * Renders the component with the specified options object.  If no options are supplied to a component
 * that has already been rendered, the component will be rerendered to the specified size.
 * @param {object} options The object containing data and specifications for this component.
 * @param {number} width The width of the component.
 * @param {number} height The height of the component.
 * @export
 */
DvtBaseComponent.prototype.render = function(options, width, height) 
{  
  // Subclasses should override
}

/**
 * Dispatches the event to the callback function.
 * @param {object} event The event to be dispatched.
 */
DvtBaseComponent.prototype.__dispatchEvent = function(event) {
  DvtEventDispatcher.dispatchEvent(this._callback, this._callbackObj, this, event);
}
/**
 * Base class for JSON component defaults.
 * @class
 * @constructor
 * @extends {DvtObj}
 */
var DvtBaseComponentDefaults = function() {
  this.Init();
}

DvtObj.createSubclass(DvtBaseComponentDefaults, DvtObj, "DvtBaseComponentDefaults");

/**
 * @param {object} defaultsMap A map of the skin names to the JSON of defaults.
 */
DvtBaseComponentDefaults.prototype.Init = function(defaultsMap) {
  this._defaults = defaultsMap ? defaultsMap : {};
}

/**
 * Returns the base skin name for this component
 * @return {String} The base skin name for this component
 */
DvtBaseComponentDefaults.prototype.getBaseSkinName = function() 
{  
  return 'alta';
}

/**
 * Combines the user options with the defaults for the specified version.  Returns the combined options object.  This 
 * object will contain internal attribute values and should be accessed in internal code only.
 * @param {object} userOptions The object containing options specifications for this component.
 * @return {object} The combined options object.
 */
DvtBaseComponentDefaults.prototype.calcOptions = function(userOptions) {
  var skin = userOptions ? userOptions['skin'] : null;
  var defaults = this.getDefaults(skin);

  // Use defaults if no overrides specified
  if(!userOptions)
    return defaults;
  else // Merge the options object with the defaults
    return DvtJSONUtils.merge(userOptions, defaults);
}

/**
 * Returns a copy of the default options for the specified skin.
 * @param {string} skin The skin whose defaults are being returned.
 * @return {object} The object containing defaults for this component.
 */
DvtBaseComponentDefaults.prototype.getDefaults = function(skin) {
  if (!skin)
    skin = this.getBaseSkinName();
  // Note: Subsequent default objects are deltas on top of previous objects
  if(skin == 'alta')
    return DvtJSONUtils.merge(this._defaults['alta'], DvtJSONUtils.merge(this._defaults['skyros'], this._defaults['fusion']));
  else if(skin == 'skyros')
    return DvtJSONUtils.merge(this._defaults['skyros'], this._defaults['fusion']);
  else
    return DvtJSONUtils.clone(this._defaults['fusion']);
}
/**
 * Context Menu Item property bag.
 * @param {DvtContextMenuSelectEvent} event  The event to fire in response to selection of this menu item.
 * @param {string} text The text of the context menu item.
 * @param {boolean} disabled True if this context menu item is disabled.
 * @param {boolean} sepBefore True if a separator should appear before this menu item.
 * @class
 * @constructor
 */
var DvtContextMenuItem = function(event, text, disabled, sepBefore) {
  this._event = event;
  this._text = text;
  this._disabled = disabled;
  this._sepBefore = sepBefore;
}

DvtObj.createSubclass(DvtContextMenuItem, DvtObj, "DvtContextMenuItem");

/**
 * Returns the event to fire in response to selection of this menu item.
 * @return {DvtContextMenuSelectEvent} The event to fire in response to selection of this menu item.
 */
DvtContextMenuItem.prototype.getEvent = function() {
  return this._event;
}

/**
 * Returns the text of the context menu item.
 * @return {string} The text of the context menu item.
 */
DvtContextMenuItem.prototype.getText = function() {
  return this._text;
}

/**
 * Returns true if this context menu item is disabled.
 * @return {string} True if this context menu item is disabled.
 */
DvtContextMenuItem.prototype.isDisabled = function() {
  return this._disabled;
}

/**
 * Returns true if a separator should appear before this menu item.
 * @return {string} True if a separator should appear before this menu item.
 */
DvtContextMenuItem.prototype.hasSeparatorBefore = function() {
  return this._sepBefore;
}
/**
 * ShowPopupBehavior property bag.
 * @param {string} popupId The id of the popup that will be fired.
 * @param {string} triggerType The interaction type that triggers the popup.
 * @param {string} alignId The id of the object that the popup will be aligned to.
 * @param {string} align  The alignment position for the popup.
 * @class
 * @constructor
 */
var DvtShowPopupBehavior = function(popupId, triggerType, alignId, align) {
  this._popupId = popupId;
  this._triggerType = triggerType;
  this._alignId = alignId;
  this._align = align;
}

DvtObj.createSubclass(DvtShowPopupBehavior, DvtObj, "DvtShowPopupBehavior");

DvtShowPopupBehavior.TRIGGER_TYPE_ACTION = "action";
DvtShowPopupBehavior.TRIGGER_TYPE_CLICK = "click";
DvtShowPopupBehavior.TRIGGER_TYPE_CONTEXT_MENU = "contextMenu";
DvtShowPopupBehavior.TRIGGER_TYPE_MOUSE_HOVER = "mouseHover";

DvtShowPopupBehavior.ALIGN_AFTER_START = "afterStart";
DvtShowPopupBehavior.ALIGN_AFTER_END = "afterEnd";
DvtShowPopupBehavior.ALIGN_BEFORE_START = "beforeStart";
DvtShowPopupBehavior.ALIGN_BEFORE_END = "beforeEnd";
DvtShowPopupBehavior.ALIGN_END_AFTER = "endAfter";
DvtShowPopupBehavior.ALIGN_END_BEFORE = "endBefore";
DvtShowPopupBehavior.ALIGN_START_AFTER = "startAfter";
DvtShowPopupBehavior.ALIGN_START_BEFORE = "startBefore";
DvtShowPopupBehavior.ALIGN_OVERLAP = "overlap";

/**
 * Creates and returns a new instance of DvtShowPopupBehavior with properties parsed from
 * the specified DvtXmlNode.
 * @param {DvtXmlNode} xmlNode The xml node containing properties for the new instance.
 * @return {DvtShowPopupBehavior}
 */
DvtShowPopupBehavior.newInstance = function(xmlNode) {
  var popupId = xmlNode.getAttr("popupId");
  var triggerType = xmlNode.getAttr("triggerType");
  var alignId = xmlNode.getAttr("alignId");
  var align = xmlNode.getAttr("align");
  return new DvtShowPopupBehavior(popupId, triggerType, alignId, align);
}

/**
 * Returns the id of the popup that will be fired by this instance.
 * @return {string} The id of the popup that will be fired.
 */
DvtShowPopupBehavior.prototype.getPopupId = function() {
  return this._popupId;
}

/**
 * Returns the interaction type that triggers the popup.
 * @return {string} The the interaction type that triggers the popup.
 */
DvtShowPopupBehavior.prototype.getTriggerType = function() {
  return this._triggerType;
}

/**
 * Returns the id of the object that the popup will be aligned to.
 * @return {string} The id of the object that the popup will be aligned to.
 */
DvtShowPopupBehavior.prototype.getAlignId = function() {
  return this._alignId;
}

/**
 * Returns the alignment position for the popup.
 * @return {string} The alignment position for the popup.
 */
DvtShowPopupBehavior.prototype.getAlign = function() {
  return this._align;
}
/**
 * DvtClientBehavior property bag.
 * @param {string} type The type of client behavior
 * @param {string} triggerType The interaction type that triggers the client behavior.
 * @class
 * @constructor
 */
var DvtClientBehavior = function(type, triggerType) {
  this._type = type;
  this._triggerType = triggerType;
  this._props = {};
}

DvtObj.createSubclass(DvtClientBehavior, DvtObj, "DvtClientBehavior");

DvtClientBehavior.TRIGGER_TYPE_ACTION = "action";
DvtClientBehavior.TRIGGER_TYPE_CLICK = "click";

DvtClientBehavior.TYPE_ROW_DISCLOSURE = "DvtRowDisclosureBehavior";
DvtClientBehavior.TYPE_DRILL = "DvtDrillBehavior";
DvtClientBehavior.TYPE_ISOLATE_LEVELS = "DvtIsolateLevelsBehavior";
DvtClientBehavior.TYPE_RESTORE = "DvtRestoreBehavior";

/**
 * Returns the type of client behavior
 * @return {string} The type of client behavior
 */
DvtClientBehavior.prototype.getType = function() {
  return this._type;
}

/**
 * Returns the interaction type that triggers the client behavior.
 * @return {string} The interaction type that triggers the client behavior.
 */
DvtClientBehavior.prototype.getTriggerType = function() {
  return this._triggerType;
}

DvtClientBehavior.prototype.setProperty = function(propName, propValue) {
  this._props[propName] = propValue;
}

DvtClientBehavior.prototype.getProperty = function(propName) {
  return this._props[propName];
}

DvtClientBehavior.prototype.getProperties = function() {
  return this._props;
}
/*--------------------------------------------------------------------*/
/*   DvtScrollbar             Scrollbar Component                     */
/*--------------------------------------------------------------------*/
/**
  *  Scrollbar component.
  *  @extends DvtContainer
  *  @class DvtScrollbar component. 
  *  @constructor  
  *  @implements {DvtAutomationContainer}
  */
var   DvtScrollbar = function(context, x, y, w, h, isHoriz, skinName, styleMap, id) {
    this.Init(context, x, y, w, h, isHoriz, skinName, styleMap, id);
}

DvtObj.createSubclass(DvtScrollbar, DvtContainer, "DvtScrollbar");

DvtScrollbar.SMALL_SCROLL_AMOUNT = 0.2;
DvtScrollbar.LARGE_SCROLL_AMOUNT = 1.0;

DvtScrollbar.MIN_THUMB_SIZE = 30;

DvtScrollbar.SCROLL_TIMER_DELAY = 50;
DvtScrollbar.SCROLL_TIMER_INITIAL_DELAY = 400;

DvtScrollbar.THUMB_TYPE = "thumb";

// constants used for test automation
DvtScrollbar._TEST_ID_THIS                = 0;
DvtScrollbar._TEST_ID_SCROLL_THUMB        = 1;
DvtScrollbar._TEST_ID_SCROLL_BUTTON_DOWN  = 2;
DvtScrollbar._TEST_ID_SCROLL_BUTTON_UP    = 3;

DvtScrollbar.BACKGROUND = "scrollbarBackground";
DvtScrollbar.BORDER_COLOR = "scrollbarBorderColor";
DvtScrollbar.HANDLE_COLOR = "scrollbarHandleColor";
DvtScrollbar.HANDLE_ACTIVE_COLOR = "scrollbarHandleActiveColor";
DvtScrollbar.HANDLE_HOVER_COLOR = "scrollbarHandleHoverColor";

/**
 *    @private
 */
DvtScrollbar.prototype.Init = function(context, x, y, w, h, isHoriz, skinName, styleMap, id) {
    DvtScrollbar.superclass.Init.call(this, context);
    this._isHoriz             = isHoriz;

    this._styleMap = styleMap;
    this._skinName = skinName;
    
    // used to remember initial state while dragging the thumb
    this._clickDiff = new Object();
    this._clickStartPos = new Object();
    this._clickEndPos = new Object();
    this._lastMovePos = -1;
    
    this._container = new DvtRect(context, x, y, w, h, id);
    this._container.setPixelHinting(true);
    this.addChild(this._container);
    this._background = new DvtScrollbarBackground(this);
    this._container.addChild(this._background);
    
    // Create scroll arrows
    if (!this.IsSkinAlta()) {
      this._arrowWidth = DvtScrollbarArrow.WIDTH;
      if (this._isHoriz) {
        this._arrowDown = new DvtScrollbarArrow(this, DvtScrollbarArrow.ORIENT_LEFT);
        this._arrowUp = new DvtScrollbarArrow(this, DvtScrollbarArrow.ORIENT_RIGHT);
      } else {
        this._arrowDown = new DvtScrollbarArrow(this, DvtScrollbarArrow.ORIENT_DOWN);
        this._arrowUp = new DvtScrollbarArrow(this, DvtScrollbarArrow.ORIENT_UP);
      }
      this._container.addChild(this._arrowDown);
      this._container.addChild(this._arrowUp);
      this._container.setSolidStroke("black");
    } else {
      this._arrowWidth = 0;
    }
    
    // Create scroll handle
    this._thumbStartMin = this._arrowWidth;
    this._thumbStartPos = this._thumbStartMin;  
    if (this._isHoriz)
      this._thumbLengthMax = w - this._arrowWidth * 2;
    else
      this._thumbLengthMax = h - this._arrowWidth * 2;
    this._thumbLength = this._thumbLengthMax;
    this._thumb = new DvtScrollbarThumb(this, this.getSkinName());
    this._container.addChild(this._thumb)
    
    this._scrollTimer = new DvtTimer(context, DvtScrollbar.SCROLL_TIMER_DELAY, this.repeatScroll, this);
    this._initScrollTimer = new DvtTimer(context, DvtScrollbar.SCROLL_TIMER_INITIAL_DELAY, this.initRepeatScroll, this);

    this._bScrolled = false;
    this._isLiveScroll = true;
}

DvtScrollbar.prototype.getStyleMap = function() {
  return this._styleMap;
}

DvtScrollbar.prototype.getSkinName = function() {
  return this._skinName;
}

DvtScrollbar.prototype.IsSkinAlta = function() {
  return (this._skinName == "alta");
};

DvtScrollbar.prototype.isHorizontal = function() {
  return this._isHoriz;
}

DvtScrollbar.prototype.getThumbStart = function() {
  return this._thumbStartPos;
}

DvtScrollbar.prototype.getThumbLength = function() {
  return this._thumbLength;
}

DvtScrollbar.prototype.setThumbStartAndLength = function(start, length) {

    var k = 0;

    if (this._isHoriz) {
        k = (this.getWidth() - 2 * this._arrowWidth) / this.getWidth();
        this._thumbStartPos = this._arrowWidth + Math.round(start * k);
        this._thumbLength = Math.round(length * k);
    }
    else {
        k = (this.getHeight() - 2 * this._arrowWidth) / this.getHeight();
        // revert for horizontal axis
        // start = this.getHeight() - start - length;
        this._thumbStartPos = this._arrowWidth + Math.round(start * k);
        this._thumbLength = Math.round(length * k);
    }
    this._thumb.updateSize();
}

DvtScrollbar.prototype.getScrollAreaStart = function() {
  return this._thumbStartMin;
}

DvtScrollbar.prototype.getScrollAreaLength = function() {
  return this._thumbLengthMax;
}

DvtScrollbar.prototype.initRepeatScroll = function() {
    this._initScrollTimer.stop();
    this._scrollTimer.stop();
    this._scrollTimer.start();
}

DvtScrollbar.prototype.repeatScroll = function() {
    if (this._arrow && !this._arrow.isDisabled())
        this.arrowScroll();
}

DvtScrollbar.prototype.arrowScroll = function() {
    
    // BUT #12805200: update scrolling speed to match flash
    var delta = DvtScrollbar.SMALL_SCROLL_AMOUNT;

    this._lastMovePos = this._thumbStartPos;
    
    switch(this._arrow.getOrientation()) {
        case DvtScrollbarArrow.ORIENT_RIGHT:
        case DvtScrollbarArrow.ORIENT_DOWN:
            this.doScroll(delta);
            break;

        case DvtScrollbarArrow.ORIENT_LEFT:
        case DvtScrollbarArrow.ORIENT_UP:
            this.doScroll(-delta);
            break;
    }

    this._bScrolled = true;
    this._fireMoveEvent(!this._isLiveScroll);
}

DvtScrollbar.prototype.doScroll = function(delta) {
    var pos = this._thumbStartPos + Math.round(this._thumbLength * delta);

    this.moveTo(pos);
}

DvtScrollbar.prototype.moveTo = function(pos) {

    if (pos < this._thumbStartMin) {
        pos = this._thumbStartMin;
    }
    if ((pos + this._thumbLength) > (this._thumbStartMin + this._thumbLengthMax)) {
        pos = this._thumbStartMin + this._thumbLengthMax - this._thumbLength;
    }
    this._thumbStartPos = pos;
    this._thumb.updateSize();
}

DvtScrollbar.prototype.moveStart = function(pos) {

    var endPos = this._thumbStartPos + this._thumbLength;

    if (pos < this._thumbStartMin) {
        pos = this._thumbStartMin;
    }
    if (pos > (endPos - DvtScrollbar.MIN_THUMB_SIZE)) {
        pos = endPos - DvtScrollbar.MIN_THUMB_SIZE;
    }
    this._thumbStartPos = pos;
    this._thumbLength = endPos - pos;
    this._thumb.updateSize();
}

DvtScrollbar.prototype.moveEnd = function(pos) {

    if (pos < (this._thumbStartPos + DvtScrollbar.MIN_THUMB_SIZE)) {
        pos = this._thumbStartPos + DvtScrollbar.MIN_THUMB_SIZE;
    }
    if (pos > (this._thumbStartMin + this._thumbLengthMax)) {
        pos = this._thumbStartMin + this._thumbLengthMax;
    }
    this._thumbLength = pos - this._thumbStartPos;
    this._thumb.updateSize();
}

DvtScrollbar.prototype.processBackgroundClick = function(point) {
    var pos;
    var delta = 0;

    if (this._isHoriz) {
        pos = point.x - this.getX();
        if (pos < this._thumbStartPos)
            delta = -DvtScrollbar.LARGE_SCROLL_AMOUNT;
        else if (pos > this._thumbStartPos + this._thumbLength)
            delta = DvtScrollbar.LARGE_SCROLL_AMOUNT;
    }
    else {
        pos = point.y - this.getY();
        if (pos < this._thumbStartPos)
            delta = -DvtScrollbar.LARGE_SCROLL_AMOUNT;
        else if (pos > this._thumbStartPos + this._thumbLength)
            delta = DvtScrollbar.LARGE_SCROLL_AMOUNT;
    }

    if (delta != 0) {
        // remember the current pos for live scroll
        this._lastMovePos = this._thumbStartPos;
        // recalculate thumb position
        this.doScroll(delta);
        // and notify listeners
        // for live scroll, need to fire both MOVE and MOVE_COMPLETE events
        if (this._isLiveScroll)
            this._fireMoveEvent(false);
        this._fireMoveEvent(true);
    }
}

DvtScrollbar.prototype.processArrowDown = function(arrow) {
    this._arrow = arrow;

    this.arrowScroll();
    this._initScrollTimer.stop();
    this._initScrollTimer.start();
}

DvtScrollbar.prototype.handleArrowDown = function(arrow, event) {
    this.processArrowDown(arrow);
}

DvtScrollbar.prototype.processArrowUp = function(arrow) {
    this._clearTimers();
    // fire MOVE_COMPLETE, if scroll occured and live scroll
    if (this._bScrolled && this._isLiveScroll) {
        this._fireMoveEvent(true);
    }
    this._bScrolled = false;
}

DvtScrollbar.prototype._clearTimers = function() {
    this._initScrollTimer.stop();
    this._scrollTimer.stop();
}

DvtScrollbar.prototype.handleArrowUp = function(arrow, event) {
    this.processArrowUp();
}

DvtScrollbar.prototype.processThumbDragStart = function(point) {
    // note the drag start position
    if (this.isHorizontal()) {
        this._clickDiff[DvtScrollbar.THUMB_TYPE] = point.x;
    }
    else {
        this._clickDiff[DvtScrollbar.THUMB_TYPE] = point.y;
    }

    // remember the thumb start position at the time of drag start
    this._clickStartPos[DvtScrollbar.THUMB_TYPE] = this._thumbStartPos;
    // also remember if for tracking move
    this._lastMovePos = this._thumbStartPos;
}

DvtScrollbar.prototype.processThumbDragMove = function(point) {
    var pos;
    if (this.isHorizontal()) {
        pos = this._clickStartPos[DvtScrollbar.THUMB_TYPE] + (point.x - this._clickDiff[DvtScrollbar.THUMB_TYPE]);
    }
    else {
        pos = this._clickStartPos[DvtScrollbar.THUMB_TYPE] + (point.y - this._clickDiff[DvtScrollbar.THUMB_TYPE]);
    }
    this.moveTo(pos);

    this._fireMoveEvent(false);
}

DvtScrollbar.prototype.processThumbDragEnd = function(point) {
    var moveDelta = 0;
    
    if (this.isHorizontal())
        moveDelta = this._clickDiff[DvtScrollbar.THUMB_TYPE] - point.x;
    else
        moveDelta = this._clickDiff[DvtScrollbar.THUMB_TYPE] - point.y;

    if (moveDelta != 0)
      this._fireMoveEvent(true);      // fire MOVE_COMPLETE event
}

DvtScrollbar.prototype._fireMoveEvent = function(complete) {

    var eType;

    if (complete)
        eType = DvtScrollbarEvent.SB_MOVE_COMPLETE;
    else if (this._isLiveScroll)
        eType = DvtScrollbarEvent.SB_MOVE;
    else
        return;     // no live scroll, do not fire event

    var start = this._thumbStartPos - this._thumbStartMin;
    var end   = start + this._thumbLength;

    var movedDelta;
    var scaledDelta;
    var sbEvent = null;

    movedDelta = this._thumbStartPos - this._lastMovePos;
    this._lastMovePos = this._thumbStartPos;
    scaledDelta = movedDelta / this._thumbLengthMax;

    if (movedDelta != 0 || complete) {
        sbEvent = new DvtScrollbarEvent(eType, this, start, end, movedDelta, scaledDelta);
    }
    if (sbEvent)
        this.FireListener(sbEvent, false);
}


DvtScrollbar.prototype._fireResizeEvent = function(complete) {

    var start = this._thumbStartPos - this._thumbStartMin;
    var end   = start + this._thumbLength;
    var eType = complete ? DvtScrollbarEvent.SB_RESIZE_COMPLETE : DvtScrollbarEvent.SB_RESIZE;

    var sbEvent = new DvtScrollbarEvent(eType, this, start, end);

    this.FireListener(sbEvent, false);
}

DvtScrollbar.prototype.move = function(offsetPct, dispatchEvent, complete) {
    this.moveSliderPercent(offsetPct);
    if (dispatchEvent)
        this._fireMoveEvent(complete);      // fire MOVE_COMPLETE event
}

DvtScrollbar.prototype.moveSliderPercent = function(offsetPct) {
    if(offsetPct < -100 || offsetPct > 100)
      return;
    this.moveSlider((offsetPct/100) * (this._thumbLengthMax)); 
}

DvtScrollbar.prototype.moveSlider = function(deltaPxls) {
    // The moveTo function takes care of bounds for us, so don't worry about it here
    if(this.isHorizontal())
      this.moveTo(this._thumbStartPos + deltaPxls);
    else
      this.moveTo(this._thumbStartPos + deltaPxls);
}

DvtScrollbar.prototype.processGlobalMouseUp = function() {
    this._clearTimers();
}

DvtScrollbar.prototype.getX = function() {
    return this._container.getX();
}

DvtScrollbar.prototype.getY = function() {
    return this._container.getY();
}

DvtScrollbar.prototype.getWidth = function() {
    return this._container.getWidth();
}

DvtScrollbar.prototype.getHeight = function() {
    return this._container.getHeight();
}

/**
 * @override
 */
DvtScrollbar.prototype.dispatchTestEvent = function(subId, eventType, params) 
{
  // implementation of interface DvtAutomationContainer
  var subComponent;

  if(subId <= DvtScrollbar._TEST_ID_THIS)
    subComponent = this;
  else if(subId == DvtScrollbar._TEST_ID_SCROLL_THUMB)
    subComponent = this._thumb;
  else if(subId == DvtScrollbar._TEST_ID_SCROLL_BUTTON_DOWN)
    subcomponent = this._arrowDown;
  else if(subId == DvtScrollbar._TEST_ID_SCROLL_BUTTON_UP)
    subComponent = this._arrowUp;
             
  if(subComponent && subComponent instanceof DvtDisplayable)
    subComponent.dispatchDisplayableEvent(eventType, params);
  
}

DvtScrollbar.prototype.getScrollbarThumb = function() {
  return this._thumb;
}

/*
  *  These have been added for users of the scrollbar in a standalone
  *  situation (no MT involved).  Essentially, the existing setThumbStartAndLength()
  *  does not work correctly or logically. The thumb sits in the scrollable area,
  *  and its initial start position should be zero (and not related to any
  *  outside chrome such as the scroll-arrows).
  */
DvtScrollbar.prototype.setLogicalThumbStartAndLength = function(start, length) {

   this._thumbStartPos = this._arrowWidth + start ;
   this._thumbLength   = length ;

   this._thumb.updateSize();
}

DvtScrollbar.prototype.getLogicalThumbStart = function() {
  return this._thumbStartPos - this._arrowWidth ;
}

/**
 * @override
 */
DvtScrollbar.prototype.destroy = function () {
  //Bug 16893087 - HTML5 HV: SEARCH RESULTS SCROLLBAR TRAPS MOUSE
  if (this._container) {
    if (this._thumb) {
      this._thumb.destroy();
      this._container.removeChild(this._thumb);
      this._thumb = null;
    }

    if (this._arrowDown) {
      this._arrowDown.destroy();
      this._container.removeChild(this._arrowDown);
      this._arrowDown = null;
    }

    if (this._arrowUp) {
      this._arrowUp.destroy();
      this._container.removeChild(this._arrowUp);
      this._arrowUp = null;
    }

    if (this._background) {
      this._background.destroy();
      this._container.removeChild(this._background);
      this._background = null;
    }
  }

  DvtScrollbar.superclass.destroy.call(this);
  this._container = null;

}

/*--------------------------------------------------------------------*/
/*   DvtScrollbarArrow          ScrollbarArrow button                 */
/*--------------------------------------------------------------------*/
/**
  *  DvtScrollbarArrow subcomponent
  *  @extends DvtContainer
  *  @class DvtScrollbarArrow  a subcomponent created and used 
  *  by DvtScrollbar
  *  <p>
  *  @constructor  
  */

var   DvtScrollbarArrow = function(sb, orientation) {
    this.Init(sb, orientation);
}

DvtObj.createSubclass(DvtScrollbarArrow, DvtContainer, "DvtScrollbarArrow");

// Constants
//
DvtScrollbarArrow.WIDTH = 15;   // default arrow width/height

DvtScrollbarArrow.ORIENT_RIGHT = 0;
DvtScrollbarArrow.ORIENT_UP = 1;
DvtScrollbarArrow.ORIENT_LEFT = 2;
DvtScrollbarArrow.ORIENT_DOWN = 3;

DvtScrollbarArrow.ARROW_UP_BORDER       = '#000000';
DvtScrollbarArrow.ARROW_UP_BORDER_ALPHA = 0;
DvtScrollbarArrow.ARROW_UP_FILL         = '#000000';
DvtScrollbarArrow.BG_UP_FILL_COLORS     = ['#ffffff', '#ffffff'];
DvtScrollbarArrow.BG_UP_FILL_ALPHAS     = [0, 0];
DvtScrollbarArrow.BG_UP_FILL_RATIOS     = [0, 255];

DvtScrollbarArrow.ARROW_OVER_BORDER       = '#000000';
DvtScrollbarArrow.ARROW_OVER_BORDER_ALPHA = 0;
DvtScrollbarArrow.ARROW_OVER_FILL         = '#000000';
DvtScrollbarArrow.BG_OVER_FILL_COLORS     = ['#0d8cf9', '#4ab5fc'];
DvtScrollbarArrow.BG_OVER_FILL_ALPHAS     = [1, 1];
DvtScrollbarArrow.BG_OVER_FILL_RATIOS     = [0, 255];

DvtScrollbarArrow.ARROW_DOWN_BORDER       = '#4e555e';
DvtScrollbarArrow.ARROW_DOWN_BORDER_ALPHA = 1;
DvtScrollbarArrow.ARROW_DOWN_FILL         = '#ffffff';
DvtScrollbarArrow.BG_DOWN_FILL_COLORS     = ['#4e555e', '#a7b7d4'];
DvtScrollbarArrow.BG_DOWN_FILL_ALPHAS     = [1, 1];
DvtScrollbarArrow.BG_DOWN_FILL_RATIOS     = [0, 255];


/*--------------------------------------------------------------------*/
/*  Init()                                                            */
/*--------------------------------------------------------------------*/
/**
 *    @protected
 */
DvtScrollbarArrow.prototype.Init = function(sb, orientation)
{
    var x, y, w, h;
    this._sb = sb;
    this._orientation = orientation;
    this._arrow = null;
    this._disabled = false;
    
    if (sb.isHorizontal()) {
        if (orientation == DvtScrollbarArrow.ORIENT_LEFT) {
            x = sb.getX();
            y = sb.getY();
        }
        else if (orientation == DvtScrollbarArrow.ORIENT_RIGHT) {
            x = sb.getX() + sb.getWidth() - DvtScrollbarArrow.WIDTH;
            y = sb.getY();
        }
        w = DvtScrollbarArrow.WIDTH;
        h = sb.getHeight();
    }
    else {
        if (orientation == DvtScrollbarArrow.ORIENT_DOWN) {
            x = sb.getX();
            y = sb.getY() + sb.getHeight() - DvtScrollbarArrow.WIDTH;
        }
        else if (orientation == DvtScrollbarArrow.ORIENT_UP) {
            x = sb.getX();
            y = sb.getY();
        }
        w = sb.getWidth();
        h = DvtScrollbarArrow.WIDTH;

    }

    // initialize the underlying rect
    var context = sb.getCtx();
    DvtScrollbarArrow.superclass.Init.call(this, context);
    this._container = new DvtRect(context, x, y, w, h, null);

    this._arrowUpBorderColor = DvtScrollbarArrow.ARROW_UP_BORDER;
    this._arBGUpFillColors   = DvtScrollbarArrow.BG_UP_FILL_COLORS;

    this._arrowOverBorderColor = DvtScrollbarArrow.ARROW_OVER_BORDER;
    this._arBGOverFillColors   = DvtScrollbarArrow.BG_OVER_FILL_COLORS;

    this._arrowDownBorderColor = DvtScrollbarArrow.ARROW_DOWN_BORDER;
    this._arBGDownFillColors   = DvtScrollbarArrow.BG_DOWN_FILL_COLORS;

    this._upFill = new DvtLinearGradientFill(0, this._arBGUpFillColors, DvtScrollbarArrow.BG_UP_FILL_ALPHAS);
    this._overFill = new DvtLinearGradientFill(0, this._arBGOverFillColors, DvtScrollbarArrow.BG_OVER_FILL_ALPHAS);
    this._downFill = new DvtLinearGradientFill(0, this._arBGDownFillColors, DvtScrollbarArrow.BG_DOWN_FILL_ALPHAS);

    this._arrowUpFill = new DvtSolidFill(DvtScrollbarArrow.ARROW_UP_FILL, null);
    this._arrowOverFill = new DvtSolidFill(DvtScrollbarArrow.ARROW_OVER_FILL, null);
    this._arrowDownFill = new DvtSolidFill(DvtScrollbarArrow.ARROW_DOWN_FILL, null);

    this._arrowUpBorder = new DvtSolidStroke(DvtScrollbarArrow.ARROW_UP_BORDER, null, DvtScrollbarArrow.ARROW_UP_BORDER_ALPHA);
    this._arrowOverBorder = new DvtSolidStroke(DvtScrollbarArrow.ARROW_OVER_BORDER, null, DvtScrollbarArrow.ARROW_OVER_BORDER_ALPHA);
    this._arrowDownBorder = new DvtSolidStroke(DvtScrollbarArrow.ARROW_DOWN_BORDER, null, DvtScrollbarArrow.ARROW_DOWN_BORDER_ALPHA);

    this._arrow = this._createArrow();
    
    this._container.setPixelHinting(true);
    
    if (!DvtAgent.isTouchDevice()) {
        this.addEvtListener(DvtMouseEvent.MOUSEOVER, this._mouseOverHandler, false, this);
        this.addEvtListener(DvtMouseEvent.MOUSEOUT, this._mouseOutHandler, false, this);
        this.addEvtListener(DvtMouseEvent.MOUSEDOWN, this._mouseDownHandler, false, this);
        this.addEvtListener(DvtMouseEvent.MOUSEUP, this._mouseUpHandler, false, this);
    } else {
        this.addEvtListener(DvtTouchEvent.TOUCHSTART, this._touchHandler, false, this);
        this.addEvtListener(DvtTouchEvent.TOUCHMOVE, this._touchHandler, false, this);
        this.addEvtListener(DvtTouchEvent.TOUCHEND, this._touchHandler, false, this);
    }

    this._container.addChild(this._arrow);
    this.addChild(this._container);
    this._drawOutState();

}

DvtScrollbarArrow.prototype.getOrientation = function() {
    return this._orientation;
}

DvtScrollbarArrow.prototype._createArrow = function() {

    var centerX = this._container.getX() + this._container.getWidth() / 2;
    var centerY = this._container.getY() + this._container.getHeight() / 2;
    var aPoints = new Array();

    if (this._orientation == DvtScrollbarArrow.ORIENT_RIGHT) {
        aPoints.push(centerX - 2, centerY - 3);
        aPoints.push(centerX + 2, centerY);
        aPoints.push(centerX - 2, centerY + 3);
        aPoints.push(aPoints[0], aPoints[1]);
    }
    else if (this._orientation == DvtScrollbarArrow.ORIENT_UP) {
        aPoints.push(centerX - 3, centerY + 2);
        aPoints.push(centerX, centerY - 2);
        aPoints.push(centerX + 3, centerY + 2);
        aPoints.push(aPoints[0], aPoints[1]);
    }
    else if (this._orientation == DvtScrollbarArrow.ORIENT_LEFT) {
        aPoints.push(centerX + 2, centerY - 3);
        aPoints.push(centerX - 2, centerY);
        aPoints.push(centerX + 2, centerY + 3);
        aPoints.push(aPoints[0], aPoints[1]);
    }
    else if (this._orientation == DvtScrollbarArrow.ORIENT_DOWN) {
        aPoints.push(centerX - 3, centerY - 2);
        aPoints.push(centerX, centerY + 2);
        aPoints.push(centerX + 3, centerY - 2);
        aPoints.push(aPoints[0], aPoints[1]);
    }
    
    var shape = new DvtPolygon(this.getCtx(), aPoints, null);
    shape.setFill(this._arrowUpFill);
    shape.setStroke(this._arrowUpBorder);
    shape.setMouseEnabled(false);

    return shape;    
}

// Mouse event handling

DvtScrollbarArrow.prototype._mouseOverHandler = function(event) {
    this._drawOverState();
    this._disabled = false;
    
    if (event)
        event.preventDefault();
}

DvtScrollbarArrow.prototype._mouseOutHandler = function(event) {
    this._drawOutState();
    this._disabled = true;
    if (event)
        event.preventDefault();
}

DvtScrollbarArrow.prototype._mouseDownHandler = function(event) {
    this._drawDownState();
    this._sb.handleArrowDown(this, event);
    
    if (event)
        event.preventDefault();
}

DvtScrollbarArrow.prototype._mouseUpHandler = function(event) {
    this._drawOverState();
    this._sb.handleArrowUp(this, event);

    if (event)
        event.preventDefault();
}

DvtScrollbarArrow.prototype._touchHandler = function(event) {
    var type = event.type;
    if (type == DvtTouchEvent.TOUCHSTART) {
        if (!this._dragStarted) {
            var touch = event.targetTouches[0];
            if (touch) {
                this._sb.processArrowDown(this);
                this._dragStarted = true;
                this._touchId = touch.identifier;
            }
        }
    } else if (type == DvtTouchEvent.TOUCHMOVE) {
        if (this._dragStarted) { 
            var touch = DvtTouchManager.getTouchById(this._touchId, event.touches);
            if (touch) {
            }
        }
    } else if (type == DvtTouchEvent.TOUCHEND) {
        if (this._dragStarted) {
            var touch = DvtTouchManager.getTouchById(this._touchId, event.changedTouches);
            if (touch) {
                this._sb.processArrowUp(this);

                this._dragStarted = false;
                this._touchId = null;
            }
        }
    }
    event.blockTouchHold();
    event.preventDefault();
}

DvtScrollbarArrow.prototype._drawOutState = function() {
    this._container.setFill(this._upFill);
    this._arrow.setStroke(this._arrowUpBorder);
    this._arrow.setFill(this._arrowUpFill);
}

DvtScrollbarArrow.prototype._drawOverState = function() {
    this._container.setFill(this._overFill);
    this._arrow.setStroke(this._arrowOverBorder);
    this._arrow.setFill(this._arrowOverFill);
}

DvtScrollbarArrow.prototype._drawDownState = function() {
    this._container.setFill(this._downFill);
    this._arrow.setStroke(this._arrowDownBorder);
    this._arrow.setFill(this._arrowDownFill);
}

DvtScrollbarArrow.prototype.isDisabled = function() {
    return this._disabled;
}

/**
 * @override
 */
DvtScrollbarArrow.prototype.destroy = function () {
  //Bug 16893087 - HTML5 HV: SEARCH RESULTS SCROLLBAR TRAPS MOUSE
  if (DvtAgent.isTouchDevice()) {
    this.removeEvtListener(DvtTouchEvent.TOUCHSTART, this._touchHandler, false, this);
    this.removeEvtListener(DvtTouchEvent.TOUCHMOVE, this._touchHandler, false, this);
    this.removeEvtListener(DvtTouchEvent.TOUCHEND, this._touchHandler, false, this);
  }
  else {
    this.removeEvtListener(DvtMouseEvent.MOUSEOVER, this._mouseOverHandler, false, this);
    this.removeEvtListener(DvtMouseEvent.MOUSEOUT, this._mouseOutHandler, false, this);
    this.removeEvtListener(DvtMouseEvent.MOUSEDOWN, this._mouseDownHandler, false, this);
    this.removeEvtListener(DvtMouseEvent.MOUSEUP, this._mouseUpHandler, false, this);
  }

  if (this._container) {
    if (this._arrow) {
      this._container.removeChild(this._arrow);
      this._arrow = null;
    }
  }

  DvtScrollbarArrow.superclass.destroy.call(this);
  this._container = null;
}

/*--------------------------------------------------------------------*/
/*   DvtScrollbarBackground          Scrollbar background             */
/*--------------------------------------------------------------------*/
/**
  *  DvtScrollbarBackground subcomponent
  *  @extends DvtContainer
  *  @class DvtScrollbarBackground  a subcomponent created and used
  *  by DvtScrollbar
  *  <p>
  *  @constructor
  */

var   DvtScrollbarBackground = function(sb) {
    this.Init(sb);
}

DvtObj.createSubclass(DvtScrollbarBackground, DvtContainer, "DvtScrollbarBackground");

// Constants
//
DvtScrollbarBackground.BORDER_COLOR = "rgb(206,211,226)";
DvtScrollbarBackground.FILL_COLORS = [ '#fafafb', '#e7e9ef' ];
/*--------------------------------------------------------------------*/
/*  Init()                                                            */
/*--------------------------------------------------------------------*/
/**
 *    @private
 */
DvtScrollbarBackground.prototype.Init = function(sb)
{
    var x, y, w, h;
    this._sb = sb;

    x = sb.getX();
    y = sb.getY();
    w = sb.getWidth();
    h = sb.getHeight();

    // create and initialize the underlying rect
    var context = sb.getCtx();
    DvtScrollbarBackground.superclass.Init.call(this, context);
    this._container = new DvtRect(context, x, y, w, h, null) ;
    this.addChild(this._container);
    
    var fill; 
    var styleMap = sb.getStyleMap();
    var background;
    var borderColor;
    if (styleMap) {
      background = styleMap[DvtScrollbar.BACKGROUND];
      borderColor = styleMap[DvtScrollbar.BORDER_COLOR];
      if (background) {
        if (DvtColorUtils.isColor(background))
          fill = new DvtSolidFill(background);
      } else  {
          var grad = DvtGradientParser.parseCSSGradient(background);
          if (grad)
            fill = new DvtLinearGradientFill(grad.getAngle(), grad.getColors(), grad.getAlphas(), grad.getRatios());
      }
    }
    
    if (!fill) {
      var gradientAngle;
      if (sb.isHorizontal())
        gradientAngle = 90;
      else
        gradientAngle = 180;
      fill = new DvtLinearGradientFill(gradientAngle, DvtScrollbarBackground.FILL_COLORS);
    }
    
    this._container.setSolidStroke(borderColor ? borderColor : DvtScrollbarBackground.BORDER_COLOR);
    this._container.setFill(fill);

    this._container.setPixelHinting(true);
    
    if (!DvtAgent.isTouchDevice()) {
        this.addEvtListener(DvtMouseEvent.CLICK, this._mouseClickHandler, false, this);
    } else {
        this.addEvtListener(DvtTouchEvent.TOUCHSTART, this._touchHandler, false, this);
        this.addEvtListener(DvtTouchEvent.TOUCHMOVE, this._touchHandler, false, this);
        this.addEvtListener(DvtTouchEvent.TOUCHEND, this._touchHandler, false, this);
    }
}

DvtScrollbarBackground.prototype._touchHandler = function(event) {
    var type = event.type;
    if (type == DvtTouchEvent.TOUCHSTART) {
        if (!this._backgroundClickStarted) {
            var touch = event.targetTouches[0];
            if (touch) {
                this._backgroundClickStarted = true;
                this._touchId = touch.identifier;
            }
        }
    } else if (type == DvtTouchEvent.TOUCHMOVE) {
    } else if (type == DvtTouchEvent.TOUCHEND) {
        if (this._backgroundClickStarted) {
            var touch = DvtTouchManager.getTouchById(this._touchId, event.changedTouches);
            if (touch) {
                var pos = this.getCtx().pageToStageCoords(touch.pageX, touch.pageY);
                var point = new DvtPoint(pos.x, pos.y);
                this._sb.processBackgroundClick(point);

                this._backgroundClickStarted = false;
                this._touchId = null;
            }
        }
    }
    event.blockTouchHold();
    event.preventDefault();
}

DvtScrollbarBackground.prototype._mouseClickHandler = function(event) {
    var pos =  this.getCtx().pageToStageCoords(event._event.pageX, event._event.pageY);
    var point = new DvtPoint(pos.x, pos.y);
    this._sb.processBackgroundClick(point);

    if (event)
        event.preventDefault();
}

/**
 * @override
 */
DvtScrollbarBackground.prototype.destroy = function () {
  //Bug 16893087 - HTML5 HV: SEARCH RESULTS SCROLLBAR TRAPS MOUSE
  if (DvtAgent.isTouchDevice()) {
    this.removeEvtListener(DvtTouchEvent.TOUCHSTART, this._touchHandler, false, this);
    this.removeEvtListener(DvtTouchEvent.TOUCHMOVE, this._touchHandler, false, this);
    this.removeEvtListener(DvtTouchEvent.TOUCHEND, this._touchHandler, false, this);
  }
  else {
    this.removeEvtListener(DvtMouseEvent.CLICK, this._mouseClickHandler, false, this);
  }

  DvtScrollbarBackground.superclass.destroy.call(this);
  this._container = null;

}

/**
  *  DvtScrollbarThumb subcomponent
  *  @param {DvtScrollbar} sb
  *  @param {string} skinName
  *  @extends DvtContainer
  *  @class DvtScrollbarThumb  a subcomponent created and used by DvtScrollbar
  *  @constructor  
  */
var   DvtScrollbarThumb = function(sb, skinName) {
    this.Init(sb, skinName);
}

DvtObj.createSubclass(DvtScrollbarThumb, DvtContainer, "DvtScrollbarThumb");

DvtScrollbarThumb.UP_BORDER_COLOR       = '#c2cadb';
DvtScrollbarThumb.UP_FILL_COLORS        = ['#ffffff', '#e4eef8'];
DvtScrollbarThumb.UP_FILL_ALPHAS        = [1, 1];
DvtScrollbarThumb.UP_FILL_RATIOS        = [70, 255];

DvtScrollbarThumb.OVER_BORDER_COLOR     = '#097bf8';
DvtScrollbarThumb.OVER_FILL_COLORS      = ['#ffffff', '#bfdefd'];
DvtScrollbarThumb.OVER_FILL_ALPHAS      = [1, 1];
DvtScrollbarThumb.OVER_FILL_RATIOS      = [70, 255];

DvtScrollbarThumb.DOWN_BORDER_COLOR     = '#c2cadb';
DvtScrollbarThumb.DOWN_FILL_COLORS      = ['#ffffff', '#e4eef8'];
DvtScrollbarThumb.DOWN_FILL_ALPHAS      = [1, 1];
DvtScrollbarThumb.DOWN_FILL_RATIOS      = [70, 255];

DvtScrollbarThumb.GRIP_ZONE_COLOR       = '#b6bbca';

/**
 *  @param {DvtScrollbar} sb
 *  @param {string} skinName
 */
DvtScrollbarThumb.prototype.Init = function(sb, skinName)
{
    var x, y, w, h;
    this._sb = sb;
    this._skinName = skinName;

    if (sb.isHorizontal()) {
        x = sb.getX() + sb.getThumbStart();
        y = sb.getY();
        w = sb.getThumbLength();
        h = sb.getHeight();
    }
    else {
        x = sb.getX();
        y = sb.getY() + sb.getHeight() - sb.getThumbStart() - sb.getThumbLength();
        w = sb.getWidth();
        h = sb.getThumbLength();
    }

    // create and initialize the underlying rect
    var context = sb.getCtx();
    DvtScrollbarThumb.superclass.Init.call(this, context);
    this._container = new DvtRect(context, x, y, w, h, null) ;

    var angle = (this._sb.isHorizontal()) ? 270 : 0;

    var styleMap = sb.getStyleMap();
    if(this.IsSkinAlta() && styleMap) {
      this._upFill = new DvtSolidFill(styleMap[DvtScrollbar.HANDLE_COLOR]);
      this._overFill = new DvtSolidFill(styleMap[DvtScrollbar.HANDLE_HOVER_COLOR]);
      this._downFill = new DvtSolidFill(styleMap[DvtScrollbar.HANDLE_ACTIVE_COLOR]);
      this._upStroke = null;
      this._overStroke = null;
      this._downStroke = null;      
    }
    else {
      this._upFill = new DvtLinearGradientFill(angle, DvtScrollbarThumb.UP_FILL_COLORS, DvtScrollbarThumb.UP_FILL_ALPHAS);
      this._overFill = new DvtLinearGradientFill(angle, DvtScrollbarThumb.OVER_FILL_COLORS, DvtScrollbarThumb.OVER_FILL_ALPHAS);
      this._downFill = new DvtLinearGradientFill(angle, DvtScrollbarThumb.DOWN_FILL_COLORS, DvtScrollbarThumb.DOWN_FILL_ALPHAS);
      this._upStroke = new DvtSolidStroke(DvtScrollbarThumb.UP_BORDER_COLOR, null, 1);
      this._overStroke = new DvtSolidStroke(DvtScrollbarThumb.OVER_BORDER_COLOR, null, 1);
      this._downStroke = new DvtSolidStroke(DvtScrollbarThumb.DOWN_BORDER_COLOR, null, 1);
      this._grip = this._createGrip();
      this._container.addChild(this._grip);
    } 

    if (!DvtAgent.isTouchDevice()) {
        this.addEvtListener(DvtMouseEvent.MOUSEOVER, this._mouseOverHandler, false, this);
        this.addEvtListener(DvtMouseEvent.MOUSEOUT, this._mouseOutHandler, false, this);
        this.addEvtListener(DvtMouseEvent.MOUSEDOWN, this._mouseDownHandler, false, this);
    } else {    
        this.addEvtListener(DvtTouchEvent.TOUCHSTART, this._touchHandler, false, this);
        this.addEvtListener(DvtTouchEvent.TOUCHMOVE, this._touchHandler, false, this);
        this.addEvtListener(DvtTouchEvent.TOUCHEND, this._touchHandler, false, this);
    }

    this._container.setPixelHinting(true);
    this.addChild(this._container);
    
    if (!DvtAgent.isTouchDevice()) {
        this._drawUpState();
    } else {
        this._drawOverState();
    }

}

DvtScrollbarThumb.prototype.IsSkinAlta = function() {
  return (this._skinName == "alta");
};

/**
 * Processes "touchstart" event
 * @param {DvtTouchEvent} event Touch event
 * @param {DvtTouch} touch Touch object
 */
DvtScrollbarThumb.prototype.immediateTouchAttempted = function(event, touch) {
    // grippers are children of the thumb so this check is needed
    if (this.getTouchManager().containsTouchId(touch.identifier)) {
        return;
    }
    var point = this.getCtx().pageToStageCoords(touch.pageX, touch.pageY);
    this.processThumbDragStart(point);
    this.getTouchManager().saveProcessedTouchDefault(touch.identifier, this, this._container, this._sb, "thumb", this);

    this.drawHighlightState();

    event.blockTouchHold();
}

/**
 * Processes "touchmove" event
 * @param {DvtTouchEvent} event Touch event
 * @param {DvtTouch} touch Touch object
 */
DvtScrollbarThumb.prototype.immediateTouchMoved = function(event, touch) {
    var point = this.getCtx().pageToStageCoords(touch.pageX, touch.pageY);
    this.processThumbDragMove(point);
    event.preventDefault();
}

/**
 * Processes "touchend" event
 * @param {DvtTouchEvent} event Touch event
 * @param {DvtTouch} touch Touch object
 */
DvtScrollbarThumb.prototype.immediateTouchEnded = function(event, touch) {
    if (!this.getTouchManager().containsGrouping(this._sb)) {
        this.drawPlainState();
    }
    var point = this.getCtx().pageToStageCoords(touch.pageX, touch.pageY);
    this.processThumbDragEnd(point);
}

/**
 * Handler for the touch event
 * @param {DvtTouchEvent} event Touch event
 * @private
 */
DvtScrollbarThumb.prototype._touchHandler = function(event) {
  this.getTouchManager().preEventBubble(event);
  this.getTouchManager().processAssociatedTouchDefault(event, this);
  this.getTouchManager().postEventBubble(event);
}

DvtScrollbarThumb.prototype.updateSize = function() {
    var sb = this._sb;

    if (sb.isHorizontal()) {
        this.setX(sb.getX() + sb.getThumbStart());
        this.setWidth(sb.getThumbLength());
    }
    else {
        // this.setY(sb.getY() + sb.getHeight() - sb.getThumbStart() - sb.getThumbLength());
        this.setY(sb.getY() + sb.getThumbStart());
        this.setHeight(sb.getThumbLength());
    }

    if (this._grip != null && this._container._findChild(this._grip) != -1) {
        this._container.removeChild(this._grip);
        this._grip = this._createGrip();
        this._container.addChild(this._grip);
    }
    else {
        this._grip = this._createGrip();
    }
}


DvtScrollbarThumb.prototype.isHorizontal = function() {
    return this._sb.isHorizontal();
}

DvtScrollbarThumb.prototype._createGrip = function() {

    var centerX = this.getX() + this.getWidth() / 2;
    var centerY = this.getY() + this.getHeight() / 2;
    var w = 3;      // half of grip width

    var gripCmds = "";

    if (this._sb.isHorizontal()) {
        gripCmds += DvtPathUtils.moveTo(centerX - 4.5, centerY - w);
        gripCmds += DvtPathUtils.lineTo(centerX - 4.5, centerY + w);
        gripCmds += DvtPathUtils.moveTo(centerX - 1.5, centerY - w);
        gripCmds += DvtPathUtils.lineTo(centerX - 1.5, centerY + w);
        gripCmds += DvtPathUtils.moveTo(centerX + 1.5, centerY - w);
        gripCmds += DvtPathUtils.lineTo(centerX + 1.5, centerY + w);
        gripCmds += DvtPathUtils.moveTo(centerX + 4.5, centerY - w);
        gripCmds += DvtPathUtils.lineTo(centerX + 4.5, centerY + w);
    }
    else {
        gripCmds += DvtPathUtils.moveTo(centerX - w, centerY - 4.5);
        gripCmds += DvtPathUtils.lineTo(centerX + w, centerY - 4.5);
        gripCmds += DvtPathUtils.moveTo(centerX - w, centerY - 1.5);
        gripCmds += DvtPathUtils.lineTo(centerX + w, centerY - 1.5);
        gripCmds += DvtPathUtils.moveTo(centerX - w, centerY + 1.5);
        gripCmds += DvtPathUtils.lineTo(centerX + w, centerY + 1.5);
        gripCmds += DvtPathUtils.moveTo(centerX - w, centerY + 4.5);
        gripCmds += DvtPathUtils.lineTo(centerX + w, centerY + 4.5);
    }

    DvtPathUtils.closePath();
    var shape = new DvtPath(this.getCtx(), gripCmds);
    shape.setSolidStroke(DvtScrollbarThumb.GRIP_ZONE_COLOR);
    shape.setMouseEnabled(false);

    return shape;    
}

// Mouse event handlers

DvtScrollbarThumb.prototype._mouseOverHandler = function(event) {
    this._drawOverState();
    if (event)
        event.preventDefault();
}


DvtScrollbarThumb.prototype._mouseOutHandler = function(event) {
    this._drawUpState();

    if (event)
        event.preventDefault();
}

/**
 * Handles a mouse down event for this scrollbar thumb.
 * @param {DvtMouseEvent} event The mouse event to handle
 * @private
 */
DvtScrollbarThumb.prototype._mouseDownHandler = function(event) {

    // remove 'mouseover' and 'mouseout' listeners while dragging
    this.removeEvtListener(DvtMouseEvent.MOUSEOVER, this._mouseOverHandler, false, this);
    this.removeEvtListener(DvtMouseEvent.MOUSEOUT, this._mouseOutHandler, false, this);

    var point = new DvtPoint(event.pageX, event.pageY);
    this.processThumbDragStart(point);
    this._drawDownState();

    // add drag tracking listeners, listen everywhere
    this.getCtx().getStage().addEvtListener(DvtMouseEvent.MOUSEMOVE, this._mouseMoveHandler, false, this);
    this.getCtx().getStage().addEvtListener(DvtMouseEvent.MOUSEUP, this._mouseUpHandler, false, this);

    if (event)
        event.preventDefault();
}

DvtScrollbarThumb.prototype.processThumbDragStart = function(point) {
    this._sb.processThumbDragStart(point);
}

/**
 * Handles a mouse up event for this scrollbar thumb.
 * @param {DvtMouseEvent} event The event to handle
 * @private
 */
DvtScrollbarThumb.prototype._mouseUpHandler = function(event) {
    // remove drag tracking listeners
    this.getCtx().getStage().removeEvtListener(DvtMouseEvent.MOUSEMOVE, this._mouseMoveHandler, false, this);
    this.getCtx().getStage().removeEvtListener(DvtMouseEvent.MOUSEUP, this._mouseUpHandler, false, this);
    
    var point = new DvtPoint(event.pageX, event.pageY);
    this.processThumbDragEnd(point);
    this._drawUpState();

    // restore 'mouseover' and 'mouseout' listeners
    this.addEvtListener(DvtMouseEvent.MOUSEOVER, this._mouseOverHandler, false, this);
    this.addEvtListener(DvtMouseEvent.MOUSEOUT, this._mouseOutHandler, false, this);

    if (event)
        event.preventDefault();
}

DvtScrollbarThumb.prototype.processThumbDragEnd = function(point) {
    this._sb.processThumbDragEnd(point);
}

/**
 * Handles a mouse move event for this scrollbar thumb.
 * @param {DvtMouseEvent} event The mouse event to handle
 * @private
 */
DvtScrollbarThumb.prototype._mouseMoveHandler = function(event) {

    var point = new DvtPoint(event.pageX, event.pageY);

    this.processThumbDragMove(point);

    if (event)
        event.preventDefault();
}

DvtScrollbarThumb.prototype.processThumbDragMove = function(point) {
    this._sb.processThumbDragMove(point);    
}

DvtScrollbarThumb.prototype._drawUpState = function() {
    this.drawPlainState();
}

DvtScrollbarThumb.prototype.drawHighlightState = function() {
  if (this._overStroke)
    this.setStroke(this._overStroke);
  this.setFill(this._overFill);
}

DvtScrollbarThumb.prototype.drawPlainState = function() {
  if (this._upStroke)
    this.setStroke(this._upStroke);
  this.setFill(this._upFill);
}

DvtScrollbarThumb.prototype._drawOverState = function() {
    if (!DvtAgent.isTouchDevice()) {
        this.drawHighlightState();
    } else {
        this.drawPlainState();
    }
}

DvtScrollbarThumb.prototype._drawDownState = function() {
    if (this._downStroke)
      this.setStroke(this._downStroke);
    this.setFill(this._downFill);
}

DvtScrollbarThumb.prototype.getX = function() {
    return this._container.getX();
}

DvtScrollbarThumb.prototype.getY = function() {
    return this._container.getY();
}

DvtScrollbarThumb.prototype.getWidth = function() {
    return this._container.getWidth();
}

DvtScrollbarThumb.prototype.getHeight = function() {
    return this._container.getHeight();
}

DvtScrollbarThumb.prototype.setX = function(val) {
    this._container.setX(val);
}

DvtScrollbarThumb.prototype.setY = function(val) {
    this._container.setY(val);
}

DvtScrollbarThumb.prototype.setWidth = function(val) {
    this._container.setWidth(val);
}

DvtScrollbarThumb.prototype.setHeight = function(val) {
    this._container.setHeight(val);
}

DvtScrollbarThumb.prototype.setStroke = function(stroke) {
    this._container.setStroke(stroke);
}

DvtScrollbarThumb.prototype.setSolidStroke = function(color, alpha, strokeWidth) {
    this._container.setSolidStroke(color, alpha, strokeWidth);
}

DvtScrollbarThumb.prototype.setFill = function(fill) {
    this._container.setFill(fill);
}

DvtScrollbarThumb.prototype.setSolidFill = function(color, alpha) {
    this._container.setSolidFill(color, alpha);
}

/**
 * @override
 */
DvtScrollbarThumb.prototype.destroy = function () {
  //Bug 16893087 - HTML5 HV: SEARCH RESULTS SCROLLBAR TRAPS MOUSE
  if (DvtAgent.isTouchDevice()) {
    this.removeEvtListener(DvtTouchEvent.TOUCHSTART, this._touchHandler, false, this);
    this.removeEvtListener(DvtTouchEvent.TOUCHMOVE, this._touchHandler, false, this);
    this.removeEvtListener(DvtTouchEvent.TOUCHEND, this._touchHandler, false, this);
  }
  else {
    this.removeEvtListener(DvtMouseEvent.MOUSEOVER, this._mouseOverHandler, false, this);
    this.removeEvtListener(DvtMouseEvent.MOUSEOUT, this._mouseOutHandler, false, this);
    this.removeEvtListener(DvtMouseEvent.MOUSEDOWN, this._mouseDownHandler, false, this);

    this.getCtx().getStage().removeEvtListener(DvtMouseEvent.MOUSEMOVE, this._mouseMoveHandler, false, this);
    this.getCtx().getStage().removeEvtListener(DvtMouseEvent.MOUSEUP, this._mouseUpHandler, false, this);
  }

  if (this._container) {
    if (this._grip) {
      this._container.removeChild(this._grip);
      this._grip = null;
    }
  }

  DvtScrollbarThumb.superclass.destroy.call(this);
  this._container = null;

}

/**
 * Creates if necessary and returns a touch manager object
 * @return {DvtTouchManager} touch manager object for the scrollbar thumb
 */
DvtScrollbarThumb.prototype.getTouchManager = function () {
  if (!this._touchManager && DvtAgent.isTouchDevice())
    this._touchManager = new DvtTouchManager("_touchManager_sb", this._context);
  return this._touchManager;  
}
// Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.
/**  
 * A transparent container that adds vertical and horizontal scrollbars as needed
 *  @extends DvtContainer
 *  @constructor
 *  @param {DvtContext} context 
 *  @param {number}     minW    The min width of the scrollable container used for getDimensions.
 *  @param {number}     minH    The min height of the scrollable container used for getDimensions.
 *  @param {number}     maxW    The max width of the scrollable container. If null, no clipping will be performed.
 *  @param {number}     maxH    The max height of the scrollable container. If null, no clipping will be performed.
 *  @param {String}     id      Optional id for this object.
 */
var DvtScrollableContainer = function (context, minW, minH, maxW, maxH, gap, id) {
  this.Init(context, minW, minH, maxW, maxH, gap, id);
}

DvtObj.createSubclass(DvtScrollableContainer, DvtContainer, "DvtScrollableContainer");

DvtScrollableContainer.DEFAULT_SCROLLBAR_WIDTH = 14;// thickness of scrollbar
DvtScrollableContainer.DEFAULT_ALTA_SCROLLBAR_WIDTH = 11;
  
/**
 * Initializer for this object
 * @param {DvtContext} context The platform specific context object
 * @param {number} minW The minimum width for this container
 * @param {number} minH The minimum height for this container
 * @param {number} maxW The maximum width for this container
 * @param {number} maxH The maximum height for this container
 * @param {number} gap The gap between the scrollbar and the content
 * @param {string} id The id for this container
 * @protected
 */
DvtScrollableContainer.prototype.Init = function (context, minW, minH, maxW, maxH, gap, id) {
  DvtScrollableContainer.superclass.Init.call(this, context, null, id);
  this._scrollbarContentGap = gap;
  this._sbWidth = DvtScrollableContainer.DEFAULT_SCROLLBAR_WIDTH;
  this._skinName = null;
  this._horizScrollEnabled = true;
  this._vertScrollEnabled = true;
  
  if (maxW) {
    this._maxW = maxW;
    this._maxContentW = maxW - this._sbWidth - this._scrollbarContentGap;
  } else {
    this._maxW = Number.MAX_VALUE;
    this._maxContentW = Number.MAX_VALUE;
  }
  
  if (maxH) {
    this._maxH = maxH;
    this._maxContentH = maxH - this._sbWidth - this._scrollbarContentGap;
  } else {
    this._maxH = Number.MAX_VALUE;
    this._maxContentH = Number.MAX_VALUE;
  }
  
  this._minW = minW;
  this._fullW = 0;// current contentPane width
  
  this._minH  = minH;
  this._fullH = 0;// current contentPane height
  
  
  this._hsb = null;// horiz scrollbar obj
  this._hsbScale = 0;
  this._hsbStart = 0;
  
  this._vsb = null;// vert scriollbar obj
  this._vsbScale = 0;
  this._vsbStart = 0;
  
  this._translateY = 0;
  this._translateX = 0;
  this._contentPane = new DvtContainer(context); // user adds objs to this
  // Want to add content pane to DvtScrollableContainer
  DvtScrollableContainer.superclass.addChild.call(this, this._contentPane);
  
  this._isBiDi = DvtAgent.isRightToLeft(context);
}

DvtScrollableContainer.prototype.setHorizontalScrollingEnabled = function (enabled) {
  this._horizScrollEnabled = enabled;
}

DvtScrollableContainer.prototype.setVerticalScrollingEnabled = function (enabled) {
  this._vertScrollEnabled = enabled;
}

DvtScrollableContainer.prototype.getSkinName = function () {
  return this._skinName;
}

DvtScrollableContainer.prototype.setSkinName = function (skinName) {
  this._skinName = skinName;
  if (this.IsSkinAlta())
    this._sbWidth = DvtScrollableContainer.DEFAULT_ALTA_SCROLLBAR_WIDTH;
}

DvtScrollableContainer.prototype.IsSkinAlta = function() {
  return (this._skinName == "alta");
};

DvtScrollableContainer.prototype.setStyleMap = function(styleMap) {
  this._styleMap = styleMap;
}

DvtScrollableContainer.prototype.getScrollbarWidth = function () {
  return this._sbWidth;
}

DvtScrollableContainer.prototype.setScrollbarWidth = function (width) {
  // update max content width/height
  this._maxH = this._maxH + this._sbWidth - width;
  this._maxContentW = this._maxContentW + this._sbWidth - width;
  this._sbWidth = width;
}

/**  
 * Adds an object to the scrollable container and updates the container to include scrolling as necessary
 *  @param {DvtObj} obj The object to be added
 *  @override
 */
DvtScrollableContainer.prototype.addChild = function (obj) {
  this._contentPane.addChild(obj);
  this.refresh();
}

/**  
 * Adds an object to the scrollable container at the specified index and updates the container to include scrolling as necessary
 *  @param {DvtObj} obj The object to be added
 *  @param {number} index The index at which to add this object
 *  @override
 */
DvtScrollableContainer.prototype.addChildAt = function (obj, index) {
  this._contentPane.addChildAt(obj, index);
  this.refresh();
}

/**  
 * Removes an object from the scrollable container and updates the container to remove scrolling as necessary
 *  @param {DvtObj} obj The object to be removed
 *  @override
 */
DvtScrollableContainer.prototype.removeChild = function (obj) {
  this._contentPane.removeChild(obj);
  this.refresh();
}

/**  
 * Removes an object from the scrollable container at the specified index and updates the container to remove scrolling as necessary
 *  @param {number} index The index at which to add this object
 *  @override
 */
DvtScrollableContainer.prototype.removeChildAt = function (idx) {
  this._contentPane.removeChildAt(idx);
  this.refresh();
}

/**
 * @override
 */
DvtScrollableContainer.prototype.getNumChildren = function () {
  return this._contentPane.getNumChildren();
}

/**
 * @override
 */
DvtScrollableContainer.prototype.contains = function (obj) {
  return this._contentPane.contains(obj);
}

/**
 * @override
 */
DvtScrollableContainer.prototype.getChildAfter = function (obj) {
  return this._contentPane.getChildAfter(obj);
}

/**
 * @override
 */
DvtScrollableContainer.prototype.getChildBefore = function (obj) {
  return this._contentPane.getChildBefore(obj);
}

/**
 * @override
 */
DvtScrollableContainer.prototype.getChildIndex = function (obj) {
  return this._contentPane.getChildIndex(obj);
}

/**
 * @override
 */
DvtScrollableContainer.prototype.removeChildren = function () {
  this._contentPane.removeChildren();
}

/**
 * @override
 */
DvtScrollableContainer.prototype.destroy = function () {
  DvtScrollableContainer.superclass.destroy.call(this);
  // content pane's children have already been destroyed, just need to destroy content pane
  this._contentPane.setClipPath(null);
  this._contentPane.removeAllDrawEffects(null);
  this._removeHSB();
  this._removeVSB();
}

/**
 * @override
 */
DvtScrollableContainer.prototype.swap = function (obj1, obj2) {
  this._contentPane.swap(obj1, obj2);
}

/**
 * @override
 */
DvtScrollableContainer.prototype.getDimensions = function (targetCoordinateSpace) {  
  // Bug 16815388 - HTML5 HV: TWO SCROLLBARS WERE DISPLAYED AFTER SELECTING A SEARCH RESULT
  var dims = this._getDimensionsForContentPane(this);

  if (dims) {
    if (this.hasHorizontalScrollbar())
      dims.h = Math.min(this._maxContentH, dims.h) + this._scrollbarContentGap + this._sbWidth;
    if (this.hasVerticalScrollbar())
      dims.w = Math.min(this._maxContentW, dims.w) + this._scrollbarContentGap + this._sbWidth;

    dims.x = 0;
    dims.y = 0;
    dims.w = Math.min(this._maxW, dims.w);
    dims.h = Math.min(this._maxH, dims.h);
  }
  return targetCoordinateSpace && dims ? this.ConvertCoordSpaceRect(dims, targetCoordinateSpace) : dims;
}

DvtScrollableContainer.prototype.setVerticalThumbPosition = function (start) {
  if (this._vsb) {
    this._vsbStart = start;
    this._contentPane.setTranslateY(-start);
    this._vsb.moveSlider(start - this._vsb.getThumbStart());
  }
}

DvtScrollableContainer.prototype.getVerticalThumbPosition = function () {
  return this._vsb.getThumbStart();
}

/**
 *  Returns the visibility state of the horizontal scrollbar.
 *  @returns {boolean} true if the horizontal scrollbar is visible, else false.
 */
DvtScrollableContainer.prototype.hasHorizontalScrollbar = function () {
  return (this._hsb != null);
}

/**
 * Checks the current dimensions of the objects added to the scrollable container and adds scrollbars as needed.
 */
DvtScrollableContainer.prototype.refresh = function () {
  this._removeVSB();
  this._removeHSB();

  var addVSB = false;
  var addHSB = false;
  //Bug 16815388 - HTML5 HV: TWO SCROLLBARS WERE DISPLAYED AFTER SELECTING A SEARCH RESULT
  var dim = this._getDimensionsForContentPane();
  if (dim) {
    if (this._horizScrollEnabled && (dim.x + dim.w) > this._maxW)
      addHSB = true;
    if (this._vertScrollEnabled && (dim.y + dim.h) > (addHSB ? this._maxContentH : this._maxH))
      addVSB = true;
  
    this._fullH = Math.max(dim.y + dim.h, this._minH);
    this._fullW = Math.max(dim.x + dim.w, this._minW);
  } else {
    this._fullH = this._minH;
    this._fullW = this._minW;
  }
    
  var cp = new DvtClipPath(this.getId());
  if (addVSB && addHSB)
    cp.addRect(this._isBiDi ? this._scrollbarContentGap + this._sbWidth : 0, 0, this._maxContentW, this._maxContentH);
  else if (addVSB)
    cp.addRect(this._isBiDi ? this._scrollbarContentGap + this._sbWidth : 0, 0, this._maxContentW, this._maxH);
  else if (addHSB)
    cp.addRect(0, 0, this._maxW, this._maxContentH);
  else
    cp = null;
  this._contentPane.setClipPath(cp);
  

  if (addVSB)
    this._addVSB(addHSB);
   
  if (addHSB)
    this._addHSB(addVSB);
    
  if (this._isBiDi && addVSB)
    this._translateX = addHSB ? -(this._fullW - this._maxW) : this._sbWidth + this._scrollbarContentGap;
  else
    this._translateX = 0;
  this._contentPane.setTranslateX(this._translateX);
}

/**
 *  Returns the visibility state of the vertical scrollbar.
 *  @returns {boolean} true if the vertical scrollbar is visible, else false.
 */
DvtScrollableContainer.prototype.hasVerticalScrollbar = function () {
  return (this._vsb != null);
}

DvtScrollableContainer.prototype._removeHSB = function () {
  if (this._hsb) {
    this._hsb.removeEvtListener(DvtScrollbarEvent.SB_MOVE, this._onHorizontalScroll, false, this);
    this._hsb.destroy();
    DvtScrollableContainer.superclass.removeChild.call(this, this._hsb);
    this._hsb = null;
  }
}

DvtScrollableContainer.prototype._removeVSB = function () {
  if (this._vsb) {
    this._vsb.removeEvtListener(DvtScrollbarEvent.SB_MOVE, this._onVerticalScroll, false, this);
    this._vsb.destroy();
    DvtScrollableContainer.superclass.removeChild.call(this, this._vsb);
    this._vsb = null;
  }
}

/**
 * Creates a vertical scrollbar for this scrollable container
 * @param {boolean} hasHSB Whether there is a horizontal scrollbar 
 * @private
 */
DvtScrollableContainer.prototype._addVSB = function (hasHSB) {
  if (!this._vsb) {
    var scrollbarLength = hasHSB ? this._maxH - this._sbWidth : this._maxH;
    this._vsbLength = scrollbarLength;
    var x = this._isBiDi ? 0 : (hasHSB ? this._maxW - this._sbWidth : this._fullW + this._scrollbarContentGap);
    var width = this._sbWidth;
    var height = scrollbarLength;
    var y = 0;
    // if just vsb and is alta, adjust width/height/y so the scrollbar top, bottom, and right borders gets clipped
    var clip;
    if (this.IsSkinAlta() && !hasHSB) {
      width += 1;
      height += 2;
      y -= 1;
      clip = new DvtClipPath(this.getId()+"vsb");
      clip.addRect(x, 0, width-1, height-2);
    }
    this._vsb = new DvtScrollbar(this.getCtx(), x, y, width, height, false, this.getSkinName(), this._styleMap);
    if (clip)
      this._vsb.setClipPath(clip);
    // Want to add scrollbar to DvtScrollableContainer, not content pane
    DvtScrollableContainer.superclass.addChild.call(this, this._vsb);
  }
  
  var viewableContentH = hasHSB ? this._maxContentH : this._maxH;
  var neededThumbLength = (viewableContentH/this._fullH) * this._vsb.getScrollAreaLength();
  // constrain thumb length to max and min available thumb size
  var thumbLength = Math.min(this._vsb.getScrollAreaLength(), Math.max(neededThumbLength, DvtScrollbar.MIN_THUMB_SIZE));
  
  this._vsbScale = (this._fullH-viewableContentH)/(this._vsb.getScrollAreaLength() - thumbLength);
  this._vsb.setLogicalThumbStartAndLength(this._vsbStart, thumbLength);
  this._vsb.addEvtListener(DvtScrollbarEvent.SB_MOVE, this._onVerticalScroll, false, this);
}

/**
 * Creates a horizontal scrollbar for this scrollable container
 * @param {boolean} hasVSB Whether there is a vertical scrollbar 
 * @private
 */
DvtScrollableContainer.prototype._addHSB = function (hasVSB) {
  if (!this._hsb) {
    var scrollbarLength = hasVSB ? this._maxW - this._sbWidth : this._maxW;
    this._hsbLength = scrollbarLength;
    var x = (this._isBiDi && hasVSB) ? this._sbWidth : 0;
    var y = hasVSB ? (this._maxH - this._sbWidth) : (this._fullH + this._scrollbarContentGap);
    
    var height = this._sbWidth;
    var width = scrollbarLength;
    // if just hsb and is alta, adjust width/height so the scrollbar bottom, left, and right borders get clipped 
    var clip
    if (this.IsSkinAlta() && !hasVSB) {
      height += 1;
      width += 2;
      clip = new DvtClipPath(this.getId()+"hsb");
      clip.addRect(x, y, width-2, height-1);
    }
    
    this._hsb = new DvtScrollbar(this.getCtx(), x, y, width, height, true, this.getSkinName(), this._styleMap);
    if (clip)
      this._hsb.setClipPath(clip);
    // Want to add scrollbar to DvtScrollableContainer, not content pane
    DvtScrollableContainer.superclass.addChild.call(this, this._hsb);
  }
  
  var viewableContentW = hasVSB ? this._maxContentW : this._maxW;
  var neededThumbLength = (viewableContentW/this._fullW) * this._hsb.getScrollAreaLength();
  // constrain thumb length to max and min available thumb size
  var thumbLength = Math.min(this._hsb.getScrollAreaLength(), Math.max(neededThumbLength, DvtScrollbar.MIN_THUMB_SIZE));
  this._hsbScale = (this._fullW-viewableContentW)/(this._hsb.getScrollAreaLength() - thumbLength);
  if (this._isBiDi)
    this._hsbStart = this._hsb.getScrollAreaLength() - thumbLength;
  this._hsb.setLogicalThumbStartAndLength(this._hsbStart, thumbLength);
  this._hsb.addEvtListener(DvtScrollbarEvent.SB_MOVE, this._onHorizontalScroll, false, this);
}

/**
 *  Handle vertical scroll event
 *  @param {DvtScrollbarEvent} event scrollbar event
 *  @private
 */
DvtScrollableContainer.prototype._onVerticalScroll = function (event) {
  var delta = event.getMovedDelta();
  if (delta != 0) {
    this._translateY -= delta * this._vsbScale;
    this._contentPane.setTranslateY(this._translateY);

    //Bug 17329022 - HTML5: HORIZONTAL SCROLL TRIGGERS LOADING OF ADDT'L SEARCH RESULTS
    var x = null;
    var y = this._vsbLength*this._vsbScale + this._translateY;
    this._fireScrollEvent(x, y);
  }
}

/**
 *  Handle horizontal scroll event
 *  @param {DvtScrollbarEvent} event scrollbar event
 *  @private
 */
DvtScrollableContainer.prototype._onHorizontalScroll = function (event) {
  var delta = event.getMovedDelta();
  if (delta != 0) {
    this._translateX -= delta * this._hsbScale;
    this._contentPane.setTranslateX(this._translateX);
    var x = this._hsbLength*this._hsbScale + this._translateX;
    //Bug 17329022 - HTML5: HORIZONTAL SCROLL TRIGGERS LOADING OF ADDT'L SEARCH RESULTS
    var y = null;
    this._fireScrollEvent(x, y);
  }
}

DvtScrollableContainer.prototype._fireScrollEvent = function (x, y) {
  this.FireListener(new DvtScrollEvent(x, y));
}

// Bug 16815388 - HTML5 HV: TWO SCROLLBARS WERE DISPLAYED AFTER SELECTING A SEARCH RESULT
// Need to call getDimensions on each child of _contentPane in case 
// it has the method getDimensions overidden
DvtScrollableContainer.prototype._getDimensionsForContentPane = function (targetCoordinateSpace) {

  var dims = null;
  var cdims;
  
  for (var i = 0; i < this.getNumChildren(); i++) {
    var child = this._contentPane.getChildAt(i);
    
    if (child) {
      cdims = child.getDimensions(this._contentPane);
      if (cdims) {
        if (dims == null)
          dims = new DvtRectangle(cdims.x, cdims.y, cdims.w, cdims.h);
        else
          dims = dims.getUnion(cdims);
      }
    }
  }

  return targetCoordinateSpace && dims ? this.ConvertCoordSpaceRect(dims, targetCoordinateSpace) : dims; 
}
/**
 * A minimalist scrollbar.
 * @class
 * @constructor
 * @extends {DvtContainer}
 * @param {DvtContext} context
 * @param {object} [callback]
 * @param {object} [callbackObj]
 * @export
 */
var DvtSimpleScrollbar = function(context, callback, callbackObj) {
  DvtSimpleScrollbar.superclass.Init.call(this, context);
  this._callback = callback;
  this._callbackObj = callbackObj;
};

DvtObj.createSubclass(DvtSimpleScrollbar, DvtContainer, "DvtSimpleScrollbar");

/**
 * Renders the simple scrollbar at the specified size.
 * @param {object} options The object containing specifications for the scrollbar.
 * @param {number} width The width of the scrollbar.
 * @param {number} height The height of the scrollbar.
 * @export
 */
DvtSimpleScrollbar.prototype.render = function(options, width, height) {  
  this._options = DvtJSONUtils.clone(options);
  this._width = width;
  this._height = height;
  
  // Global min/max
  this._globalMin = options['min'];
  this._globalMax = options['max'];
  
  this._isHoriz = options['isHorizontal'];
  this._isReversed = options['isReversed'];
  
  // Create background
  var background = new DvtRect(this.getCtx(), 0, 0, width, height);
  background.setSolidFill(options['backgroundColor']);
  background.setPixelHinting(true);
  this.addChild(background);
  
  // Create thumb
  this._thumb = new DvtRect(this.getCtx(), 0, 0, width, height);
  this._thumb.setSolidFill(options['color']);
  this._thumb.setPixelHinting(true);
  this.addChild(this._thumb);
  
  this._thumbMin = this._globalMin;
  this._thumbMax = this._globalMax;
  
  // Add event listeners
  this.addEvtListener(DvtMouseEvent.CLICK, this._onClick, false, this);
  if (DvtAgent.isTouchDevice()) {
    this.addEvtListener(DvtTouchEvent.TOUCHSTART, this._onDragStart, false, this);
    this.addEvtListener(DvtTouchEvent.TOUCHMOVE,  this._onDragMove,  false, this);
    this.addEvtListener(DvtTouchEvent.TOUCHEND,   this._onDragEnd,   false, this);
  } else {
    this.addEvtListener(DvtMouseEvent.MOUSEDOWN, this._onDragStart, false, this);
    this.addEvtListener(DvtMouseEvent.MOUSEMOVE, this._onDragMove,  false, this);
    this.addEvtListener(DvtMouseEvent.MOUSEUP,   this._onDragEnd,   false, this);
  } 
  
  this._dragged = false; // flag to indicate mouse/touch down
}

/**
 * Sets the range of the scrollbar thumb.
 * @param {number} min The min value of the range.
 * @param {number} max The max value of the range.
 */
DvtSimpleScrollbar.prototype.setViewportRange = function(min, max) {
  // Get the coords and modify the thumb
  var minCoord = this._getCoord(min);
  var maxCoord = this._getCoord(max);
  
  if (this._isHoriz) {
    this._thumb.setX(Math.min(minCoord, maxCoord));
    this._thumb.setWidth(Math.abs(maxCoord - minCoord));
  } else {
    this._thumb.setY(Math.min(minCoord, maxCoord));
    this._thumb.setHeight(Math.abs(maxCoord - minCoord));
  }
  
  this._thumbMin = min;
  this._thumbMax = max;
}

/**
 * Gets the coordinate of a value.
 * @param {number} value
 * @return {number} coord
 * @private
 */
DvtSimpleScrollbar.prototype._getCoord = function(value) {
  var ratio = (value - this._globalMin) / (this._globalMax - this._globalMin);
  if (this._isReversed)
    ratio = 1 - ratio;
  
  if (this._isHoriz)
    return ratio * this._width;
  else
    return ratio * this._height;
}

/**
 * Gets the value from a coord.
 * @param {number} pageX
 * @param {number} pageY
 * @return {number} value
 * @private
 */
DvtSimpleScrollbar.prototype._getValue = function(pageX, pageY) {
  var coord = this.stageToLocal(this.getCtx().pageToStageCoords(pageX, pageY));
  var ratio = this._isHoriz ? coord.x / this._width : coord.y / this._height;
  if (this._isReversed)
    ratio = 1 - ratio;
  return this._globalMin + ratio * (this._globalMax - this._globalMin);
}

/**
 * Handles click event.
 * @param {object} event
 * @private
 */
DvtSimpleScrollbar.prototype._onClick = function(event) {
  var val = this._getValue(event.pageX, event.pageY);
  if (val >= this._thumbMin && val <= this._thumbMax)
    return;
  
  var range = this._thumbMax - this._thumbMin;
  this._setViewportRange(val - range/2, val + range/2, DvtOverviewEvent.SUBTYPE_SCROLL_TIME);
}

/**
 * Handles drag start.
 * @param {object} event
 * @private
 */
DvtSimpleScrollbar.prototype._onDragStart = function(event) {
  var val;
  if (event.touches) {
    if (event.touches.length != 1)
      return;
    val = this._getValue(event.touches[0].pageX, event.touches[0].pageY);
  } 
  else
    val = this._getValue(event.pageX, event.pageY);
  
  if (val >= this._thumbMin && val <= this._thumbMax) {
    this._dragged = true;
    this._prevVal = val;
    
    event.stopPropagation(); // prevent click event
  }
}

/**
 * Handles drag move.
 * @param {object} event
 * @private
 */
DvtSimpleScrollbar.prototype._onDragMove = function(event) {
  if (!this._dragged)
    return;
  
  var val;
  if (event.touches) {
    if (event.touches.length != 1)
      return;
    val = this._getValue(event.touches[0].pageX, event.touches[0].pageY);
  } 
  else
    val = this._getValue(event.pageX, event.pageY);
  
  var dragOffset = val - this._prevVal;
  this._setViewportRange(this._thumbMin + dragOffset, this._thumbMax + dragOffset, DvtOverviewEvent.SUBTYPE_SCROLL_POS);
  this._prevVal = val;
}

/**
 * Handles drag end.
 * @param {object} event
 * @private
 */
DvtSimpleScrollbar.prototype._onDragEnd = function(event) {
  if (!this._dragged)
    return;
  
  if (event.touches) 
    this._setViewportRange(this._thumbMin, this._thumbMax, DvtOverviewEvent.SUBTYPE_SCROLL_END);
  else {
    var val = this._getValue(event.pageX, event.pageY);
    var dragOffset = val - this._prevVal;
    this._setViewportRange(this._thumbMin + dragOffset, this._thumbMax + dragOffset, DvtOverviewEvent.SUBTYPE_SCROLL_END);
  }
  
  this._dragged = false;
}

/**
 * Sets the range of the scrollbar thumb and fires an overview event.
 * @param {number} min The min value of the range.
 * @param {number} max The max value of the range.
 * @param {string} eventType The subtype of the overview event.
 * @private
 */
DvtSimpleScrollbar.prototype._setViewportRange = function(min, max, eventType) {
  // Adjust min/max so that they are within globalMin/Max
  var range = max - min;
  if (min < this._globalMin) {
    min = this._globalMin;
    max = this._globalMin + range;
  }
  if (max > this._globalMax) {
    max = this._globalMax;
    min = this._globalMax - range;
  }
  
  this.setViewportRange(min, max);
  
  // Fire event
  if (this._callback) {
    var evt = new DvtOverviewEvent(eventType);
    evt.setNewStartTime(min);
    evt.setNewEndTime(max);
    this._callback.call(this._callbackObj, evt, this);
  }
}
/**
 * Drag recognizer
 * @class DvtDragRecognizer
 * @constructor
 */
var DvtDragRecognizer = function () {};

DvtObj.createSubclass(DvtDragRecognizer, DvtObj, "DvtDragRecognizer");

/**
 * Notifies the component that a drag may have started.
 */
DvtDragRecognizer.prototype.prepDrag = function () {
  // subclasses should override
}

/**
 * Notifies the component that a drag has been aborted.
 */
DvtDragRecognizer.prototype.abortPrep = function () {
  // subclasses should override
}

/**
 * Returns true if the component allows drag. This function gives the peer the
 * chance to prevent a drag.  All other conditions for a drag
 * must be satisfied even if the peer returns true.
 */
DvtDragRecognizer.prototype.recognizeDrag = function () {
  return true; // subclasses should override
}
/**
 * Drag source event handler.
 * @param {DvtContext} context
 * @class DvtDragSource
 * @constructor
 */
var DvtDragSource = function (context) {
  this.Init(context);
};

DvtObj.createSubclass(DvtDragSource, DvtObj, "DvtDragSource");

// Margin to add to drag feedback bounds to minimize clipping
DvtDragSource.DRAG_FEEDBACK_MARGIN = 2;

/**
 * @param {DvtContainer} container
 * @param {DvtContext} context
 */
DvtDragSource.prototype.Init = function(context) {
    this._context = context;
    
    // current draggable object under the mouse pointer
    this._dragCandidate = null;
    
    // object being dragged
    this._dragObj = null;
    this._dragCoords = null;
} ;

/**
 * Returns the current drag candidate object.
 */
DvtDragSource.prototype.getDragCandidate = function () {
  return this._dragCandidate;
}

/**
 * Sets the specified object as the current drag candidate, if it supports the DvtDraggable interface.
 * @param {object} obj 
 */
DvtDragSource.prototype.setDragCandidate = function (obj) {
  // a DnD candidate object must support all DvtDraggable methods
  if (obj && obj.isDragAvailable && obj.getDragTransferable)
    this._dragCandidate = obj;
  else
    this._dragCandidate = null;
}

/**
 * If there are any drag candidate, returns the client id of the drag component.
 * Otherwise returns null.
 */
DvtDragSource.prototype.isDragAvailable = function (clientIds) {
  if (this._dragCandidate != null) {
    return this._dragCandidate.isDragAvailable(clientIds);
  }
  return null;
};


/**
 * If there are a drag candidate, return the dragTransferable object.
 */
DvtDragSource.prototype.getDragTransferable = function (mouseX, mouseY) {
  // if there's anything to drag
  if (this._dragCandidate) {
    // store the dragObj and current mouse coords
    this._dragObj = this._dragCandidate;
    this._dragCoords = {
      x : mouseX, y : mouseY
    };

    return this._dragCandidate.getDragTransferable(mouseX, mouseY);
  }
  return null;
};

/**
 * Returns the feedback for the drag operation.
 */
DvtDragSource.prototype.getDragOverFeedback = function (mouseX, mouseY) {
  // Hide the tooltip, since this is the last hook before the drag feedback is created
  this._context.getTooltipManager().hideTooltip();

  // Return the drag feedback
  var dragObj = this.getDragObject();
  if (dragObj && dragObj.getDragFeedback)
    return dragObj.getDragFeedback(mouseX, mouseY);
  else 
    return null;
}

/**
 * Returns component specific context for the drag.
 */
DvtDragSource.prototype.getDragContext = function (mouseX, mouseY) {
  if (this._dragObj && this._dragObj.getDragContext) {
    return this._dragObj.getDragContext(mouseX, mouseY);
  }
  return null;
}

/**
 * Returns the object currently being dragged.
 */
DvtDragSource.prototype.getDragObject = function() {
    return this._dragObj;
}

/**
 * Returns the coordinates where the current drag was initiated.
 */
DvtDragSource.prototype.getDragCoords = function () {
  return this._dragCoords;
}

/**
 * Return the offset to use for the drag feedback.
 */
DvtDragSource.prototype.getDragOffset = function (mouseX, mouseY) {
  var offset = null;
  var feedback = this.getDragOverFeedback(mouseX, mouseY);
  if(feedback) {
    var bounds = DvtDnDUtils.getDragFeedbackBounds(feedback, this._context.getStage());
    
    //return displayables to their original condition, if necessary,
    //after determining bounds
    var dragObj = this.getDragObject();
    if (dragObj && dragObj.afterDragOverFeedback) {
      dragObj.afterDragOverFeedback(feedback);
    }
    
    if (bounds) {
      offset = {};
      offset.x = mouseX - bounds.x;
      offset.y = mouseY - bounds.y;
      offset.x += DvtDragSource.DRAG_FEEDBACK_MARGIN;
      offset.y += DvtDragSource.DRAG_FEEDBACK_MARGIN;
    }
  }
  return offset;
}

/**
 * Returns the offset from the mouse pointer where the drag is considered to be located.
 * @param {number} xOffset A suggested offset, usually the center of the drag feedback.
 * @param {number} yOffset A suggested offset, usually the center of the drag feedback.
 * @return {object}
 */
DvtDragSource.prototype.getPointerOffset = function (xOffset, yOffset) {
  // Default implementation does not apply an offset, mouse position is used instead
  return {x: 0, y: 0};
}

/**
 * Called when a drag is started.
 */
DvtDragSource.prototype.initiateDrag = function () {
  // On touch devices, when a drag is initiated, immediately cancel any touch and hold
  var tm = this.getTouchManager();
  if(DvtAgent.isTouchDevice() && tm) 
    tm.cancelTouchHold();
}

/**
 * Clean up after the drag is completed.
 */
DvtDragSource.prototype.dragDropEnd = function () {
  this._dragCandidate = null;
  this._dragObj = null;
  this._dragCoords = null;
}

/**
 * Sets a touch manager object
 * @param {DvtTouchManager} touch manager object
 */ 
DvtDragSource.prototype.setTouchManager = function (touchManager) {
  this._touchManager = touchManager;
}

/**
 * Gets a touch manager object
 * @return {DvtTouchManager} touch manager object
 */
DvtDragSource.prototype.getTouchManager = function () {
  return this._touchManager;
}
/**
 * Drop target event handler.
 * @class DvtDropTarget
 * @constructor
 */
var DvtDropTarget = function() {};

DvtObj.createSubclass(DvtDropTarget, DvtObj, "DvtDropTarget");

/**
 * If a drop is possible at these mouse coordinates, returns the client id
 * of the drop component. Returns null if drop is not possible.
 */
DvtDropTarget.prototype.acceptDrag = function(mouseX, mouseY, clientIds) {
  return null; // subclasses should override
}

/**
 * Paints drop site feedback as a drag enters the drop site.
 */
DvtDropTarget.prototype.dragEnter = function() {
  // subclasses should override
}

/**
 * Cleans up drop site feedback as a drag exits the drop site.
 */
DvtDropTarget.prototype.dragExit = function() {
  // subclasses should override
}

/**
 * Returns the object representing the drop site. This method is called when a valid
 * drop is performed.
 */
DvtDropTarget.prototype.getDropSite = function(mouseX, mouseY) {
  return null; // subclasses should override
}
// Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.

/**
 * DvtButton
 * @param {DvtContext} context
 * @param {DvtDisplayable} upState
 * @param {DvtDisplayable} overState
 * @param {DvtDisplayable} downState
 * @param {DvtDisplayable} disabledState
 * @param {string} id
 * @param {object} [callback]
 * @param {object} [callbackObj]
 * @constructor
 */
var DvtButton = function (context, upState, overState, downState, disabledState, id, callback, callbackObj)
{
  this.Init(context, upState, overState, downState, disabledState, id, callback, callbackObj);
};

DvtObj.createSubclass(DvtButton, DvtContainer, "DvtButton");

DvtButton.STATE_ENABLED  = 0;
DvtButton.STATE_OVER     = 1;
DvtButton.STATE_DOWN     = 2;
DvtButton.STATE_DISABLED = 3;

DvtButton.NO_EVENT_LISTENERS = true;       //dont register any event listeners


/**
 * Initialization method called by the constructor
 * 
 * @protected
 * 
 * @param {DvtContext} context  Platform specific context object
 * @param {DvtDisplayable} upState      Button up state
 * @param {DvtDisplayable} overState    Button over state
 * @param {DvtDisplayable} downState    Button down state
 * @param {DvtDisplayable} disabledState    Button disabled state
 * @param {string} id   The id for this object
 * @param {function} callback   The optional function that should be called on click event
 * @param {object} callbackObj  The optional object instance on which the callback function is defined
 * 
 */
DvtButton.prototype.Init = function (context, upState, overState, downState, disabledState, id, callback, callbackObj)
{
  DvtButton.superclass.Init.call(this, context, null, id);
  
  this.setCallback(callback, callbackObj);
  
  //FIX BUG 16173601: don't do anything special in setUpState() during construction
  this._bDuringInit = true;

  this.setUpState(upState);
  this.setOverState(overState);
  this.setDownState(downState);

  if (disabledState) {
    this.setDisabledState(disabledState);
  }

  this.setEnabled(true);                 // enable mouse events for upState
  this._drawUpState();
  
  this._tooltip = null;
  
  this._bToggleEnabled = false;
  this._bToggled = false;
  
  //FIX BUG 16173601: don't do anything special in setUpState() during construction
  this._bDuringInit = false;
};



/**
  *  Returns the enabled state of this button
  *  @returns {boolean}  true if the button is enabled,, else false.
  */
DvtButton.prototype.isEnabled = function () {
  return this._enabled;
};




/**
  *   Enable/disable the button
  */
DvtButton.prototype.setEnabled = function (bEnabled)
{
  if (this._enabled != bEnabled)
  {
    this._enabled = bEnabled;
    var clickEvent = DvtAgent.isTouchDevice() ? DvtTouchEvent.TOUCHSTART : DvtMouseEvent.CLICK;

    if (bEnabled) {
      this.addEvtListener(DvtMouseEvent.MOUSEOVER, this._mouseOverHandler, false, this);
      this.addEvtListener(DvtMouseEvent.MOUSEOUT,  this._mouseOutHandler,  false, this);
      this.addEvtListener(DvtMouseEvent.MOUSEDOWN, this._mouseDownHandler, false, this);
      this.addEvtListener(DvtMouseEvent.MOUSEUP,   this._mouseUpHandler,   false, this);
      this.addEvtListener(clickEvent,              this._clickHandler,     false, this);
    }
    else {
      this.removeEvtListener(DvtMouseEvent.MOUSEOVER, this._mouseOverHandler, false, this);
      this.removeEvtListener(DvtMouseEvent.MOUSEOUT,  this._mouseOutHandler,  false, this);
      this.removeEvtListener(DvtMouseEvent.MOUSEDOWN, this._mouseDownHandler, false, this);
      this.removeEvtListener(DvtMouseEvent.MOUSEUP,   this._mouseUpHandler,   false, this);
      this.removeEvtListener(clickEvent,              this._clickHandler,     false, this);
    }
  }
};



/**
 * Mouse over handler
 * @private
 * @param {DvtMouseEvent} event The dispatched event to be processed by the object
 */
DvtButton.prototype._mouseOverHandler = function (event) {
  this._logEvent(event);
  if (!this._bToggled) {
    this._drawOverState();
  }
  else {
    this._drawOverDownState();
  }
};

/**
 * Mouse out handler
 * @private
 * @param {DvtMouseEvent} event The dispatched event to be processed by the object
 */
DvtButton.prototype._mouseOutHandler = function (event) {
  this._logEvent(event);
  if (!this._bToggled) {
    this._drawUpState();
  }
  else {
    this._drawDownState();
  }
};

/**
 * Mouse down handler
 * @private
 * @param {DvtMouseEvent} event The dispatched event to be processed by the object
 */
DvtButton.prototype._mouseDownHandler = function (event) {
  this._logEvent(event);
  this._drawDownState();
};

/**
 * Mouse up handler
 * @private
 * @param {DvtMouseEvent} event The dispatched event to be processed by the object
 */
DvtButton.prototype._mouseUpHandler = function (event) {
  this._logEvent(event);
  if (!this._bToggled) {
    DvtAgent.isTouchDevice() ? this._drawUpState() : this._drawOverState();
  }
  else {
    DvtAgent.isTouchDevice() ? this._drawDownState() : this._drawOverDownState();
  }
};

DvtButton.prototype._clickHandler = function (event) {
  this._logEvent(event);
  if (this._bToggleEnabled) {
    this._bToggled = !this._bToggled;
    if (!this._bToggled) {
      DvtAgent.isTouchDevice() ? this._drawUpState() : this._drawOverState();
    }
    else {
      DvtAgent.isTouchDevice() ? this._drawDownState() : this._drawOverDownState();
    }
  }
  
  // Call the callback
  if (this._callback) {
    this._callback.call(this._callbackObj, event);
    event.stopPropagation();
    event.preventDefault();
  }
};

DvtButton.prototype._drawUpState = function () {
  this._enableButton(this.upState, true);
  this._enableButton(this.downState, false);
  this._enableButton(this.overState, false);
  this._enableButton(this.disabledState, false);
  this._enableButton(this.overDownState, false);
};

DvtButton.prototype._drawOverState = function () {
  this._enableButton(this.upState, false);
  this._enableButton(this.downState, false);
  this._enableButton(this.overState, true);
  this._enableButton(this.disabledState, false);
  this._enableButton(this.overDownState, false);
};

DvtButton.prototype._drawDownState = function () {
  this._enableButton(this.upState, false);
  this._enableButton(this.downState, true);
  this._enableButton(this.overState, false);
  this._enableButton(this.disabledState, false);
  this._enableButton(this.overDownState, false);
};

DvtButton.prototype._drawDisabledState = function () {
  this._enableButton(this.upState, false);
  this._enableButton(this.overState, false);
  this._enableButton(this.downState, false);
  this._enableButton(this.disabledState, true);
  this._enableButton(this.overDownState, false);
};

/**
 * Draws the over + down (hover selected) state.
 * If the state doesn't exist, defaults to drawing down state.
 * @private
 */
DvtButton.prototype._drawOverDownState = function () {
  if (this.overDownState) {
    this._enableButton(this.upState, false);
    this._enableButton(this.overState, false);
    this._enableButton(this.downState, false);
    this._enableButton(this.disabledState, false);
    this._enableButton(this.overDownState, true);
  }
  else
    this._drawDownState();
};

/**
  *   Show or hide the specified button face shape.
  */
DvtButton.prototype._enableButton = function (button, enabled) {
  //   this._enableMouseEvents(button, enabled);
  if (button) {
    button.setAlpha(enabled ? 1 : 0);
  }

  //image button does not work when swapping different image states
  //   button.setVisible(enabled);
};


DvtButton.prototype._enableMouseEvents = function (container, enabled) {
  if (container.setMouseEnabled) {
    container.setMouseEnabled(enabled);
  }
  var child = container.firstChild;

  //loop over all childs
  while (child != null) {
    this._enableMouseEvents(child, enabled);
    child = child.nextSibling;
  }
};

DvtButton.prototype.setUpState = function (upState) {

  if ( (!this.upState) || (this.upState != upState))
  {
     var enabled = false;
     if (this.upState) {
       enabled = this._isButtonEnabled(this.upState);
       this.removeChild(this.upState);
     }
     //FIX BUG 16173601: if the button has no enabled states, enable the up state by default
     else if (!this._bDuringInit) {
       var bDownEnabled = false;
       var bOverEnabled = false;
       var bDisabledEnabled = false;
       if (this.downState) {
         bDownEnabled = this._isButtonEnabled(this.downState);
       }
       if (this.overState) {
         bOverEnabled = this._isButtonEnabled(this.overState);
       }
       if (this.disabledState) {
         bDisabledEnabled = this._isButtonEnabled(this.disabledState);
       }
       if (!(bDownEnabled || bOverEnabled || bDisabledEnabled)) {
         enabled = true;
       }
     }

     if (upState) {
       this.addChild(upState);
     }

     this.upState = upState;
     this._enableButton(this.upState, enabled);
  }
};

DvtButton.prototype.setDownState = function (downState) {

  if ( (! this.downState) || (this.downState != downState))
  {
    var enabled = false;
    if (this.downState) {
      enabled = this._isButtonEnabled(this.downState);
      this.removeChild(this.downState);
    }

    if (downState) {
      this.addChild(downState);
    }

    this.downState = downState;
    this._enableButton(this.downState, enabled);
  }
};

DvtButton.prototype.setOverState = function (overState) {

  if ( (! this.overState)  || (this.overState != overState))
  {
     var enabled = false;
     if (this.overState) {
       enabled = this._isButtonEnabled(this.overState);
       this.removeChild(this.overState);
     }

     if (overState) {
       this.addChild(overState);
     }

     this.overState = overState;
     this._enableButton(this.overState, enabled);
  } 
};

DvtButton.prototype.setDisabledState = function (disabledState) {

  if ((! this.disabledState) || (this.disabledState == disabledState))
  {
    var enabled = false;
    if (this.disabledState) {
      enabled = this._isButtonEnabled(this.disabledState);
      this.removeChild(this.disabledState);
    }

    if (disabledState) {
      this.addChild(disabledState);
    }

    this.disabledState = disabledState;
    this._enableButton(this.disabledState, enabled);
  }
};

/**
 * Sets the over + down (hover selected) state of a toggle button
 * @param {DvtShape} overDownState
 */
DvtButton.prototype.setOverDownState = function (overDownState) {

  if ((! this.overDownState) || (this.overDownState == overDownState))
  {
    var enabled = false;
    if (this.overDownState) {
      enabled = this._isButtonEnabled(this.overDownState);
      this.removeChild(this.overDownState);
    }

    if (overDownState) {
      this.addChild(overDownState);
    }

    this.overDownState = overDownState;
    this._enableButton(this.overDownState, enabled);
  }
};

/**
 * Set the callback function handler
 * 
 * @public
 * 
 * @param {function} callback    The function that should be called on click event
 * @param {object} callbackObj   The object instance on which the callback function is defined
 */
DvtButton.prototype.setCallback = function (callback, callbackObj) {
  this._callback = callback;
  this._callbackObj = callbackObj;
}

DvtButton.prototype._logEvent = function (event) {
//  logEvent(event, "Button");
};

DvtButton.prototype.setTooltip = function(tooltip) {
  this._tooltip = tooltip;
};

DvtButton.prototype.getTooltip = function() {
  return this._tooltip;
};

DvtButton.prototype.isClickEventPropagationStopped = function() {
  return true;
};


DvtButton.prototype.initState = function()
{
  this.isEnabled() ? this._drawUpState() : this._drawDisabledState();
};


DvtButton.prototype.setSize = function(width, height) {
  var up = this.upState;
  if (up) {
    if (up.setWidth && width) {
      up.setWidth(width);
    }
    if (up.setHeight && height) {
      up.setHeight(height);
    }
  }

  var down = this.downState;
  if (down) {
    if (down.setWidth && width) {
      down.setWidth(width);
    }
    if (down.setHeight && height) {
      down.setHeight(height);
    }
  }

  var over = this.overState;
  if (over) {
    if (over.setWidth && width) {
      over.setWidth(width);
    }
    if (over.setHeight && height) {
      over.setHeight(height);
    }
  }

  var disabled = this.disabledState;
  if (disabled) {
    if (disabled.setWidth && width) {
      disabled.setWidth(width);
    }
    if (disabled.setHeight && height) {
      disabled.setHeight(height);
    }
  }
}


/*
 * Called from DvtAfMenu and DvtAfGoButton to right align this component or its content.
 */
DvtButton.prototype.rightAlign = function(maxw, ww, self) {
  var delta = maxw - ww;

  var up = this.upState;
  if (up && maxw) {
    if (self)
      up.setTranslateX(delta);
    else
      this._setChildX(up, delta)
  }

  var down = this.downState;
  if (down && maxw) {
    if (self)
      down.setTranslateX(delta);
    else
      this._setChildX(down, delta);
  }

  var over = this.overState;
  if (over && maxw) {
    if (self)
      over.setTranslateX(delta);
    else
      this._setChildX(over, delta);
  }

  var disabled = this.disabledState;
  if (disabled) {
    if (self)
      disabled.setTranslateX(delta);
    else
      this._setChildX(disabled, delta);
  }
}

DvtButton.prototype._setChildX = function(state, delta) {
  for (var i = 0; i < state.getNumChildren(); i++) {
    var child = state.getChildAt(i);

    if (child instanceof DvtDisplayable) {
      child.setTranslateX(delta);
    }
  }
}

DvtButton.prototype.setToggleEnabled = function(bToggleEnabled) {
  this._bToggleEnabled = bToggleEnabled;
};

DvtButton.prototype.isToggleEnabled = function() {
  return this._bToggleEnabled;
};

DvtButton.prototype.setToggled = function(bToggled) {
  if (this._bToggleEnabled) {
    this._bToggled = bToggled;
    if (!this._bToggled) {
      this._drawUpState();
    }
    else {
      this._drawDownState();
    }
  }
};

DvtButton.prototype.isToggled = function() {
  return this._bToggled;
};

DvtButton.prototype._isButtonEnabled = function (button) {
  var enabled = false;
  if (button) {
    enabled = button.getAlpha() > 0 ? true : false;
  }
  return enabled;
}

DvtButton.prototype.getUpState = function () {
  return this.upState;
}

DvtButton.prototype.getDownState = function () {
  return this.downState;
}

DvtButton.prototype.getOverState = function () {
  return this.overState;
}

/**
 * A logical object for a set of displayables.
 * @interface
 */
var DvtLogicalObject = function() {};

DvtObj.createSubclass(DvtLogicalObject, DvtObj, "DvtLogicalObject");

/**
 * Returns the array of DvtDisplayables corresponding to this object.
 * @return {array}
 */
DvtLogicalObject.prototype.getDisplayables = function() {};

/**
 * Optional function, used by DvtEventManager's WAI-ARIA support to provide an aria-label whose creation is deferred
 * until needed.
 * @return {string}
 */
DvtLogicalObject.prototype.getAriaLabel = function() {};
/**
 * An object that displays tooltips.
 * @interface
 */
var DvtTooltipSource = function() {};

DvtObj.createSubclass(DvtTooltipSource, DvtObj, "DvtTooltipSource");

/**
 * Returns the tooltip text for this object.
 * @param {DvtDisplayable} target The displayable that was the target of the event.
 * @return {string} The tooltip text for this object.
 */
DvtTooltipSource.prototype.getTooltip = function(target, x, y) {};

/**
 * Returns the datatip text for this object.
 * @param {DvtDisplayable} target The displayable that was the target of the event.
 * @return {string} The datatip text for this object.
 */
DvtTooltipSource.prototype.getDatatip = function(target, x, y) {};

/**
 * Returns the border color of the datatip for this object.
 * @return {string} The datatip border color.
 */
DvtTooltipSource.prototype.getDatatipColor = function() {};
/**
 * An object that can be selected.
 * @interface
 */
var DvtSelectable = function() {};

DvtObj.createSubclass(DvtSelectable, DvtObj, "DvtSelectable");

/**
 * Returns true if this object is selectable.
 * @return {boolean} true if this object is selectable.
 */
DvtSelectable.prototype.isSelectable = function() {};

/**
 * Returns true if this object is selected.
 * @return {boolean} true if this object is selected.
 */
DvtSelectable.prototype.isSelected = function() {};

/**
 * Specifies whether this object is selected.
 * @param {boolean} selected true if this object is selected.
 * @protected
 */
DvtSelectable.prototype.setSelected = function(selected) {};

/**
 * Displays the hover effect.
 */
DvtSelectable.prototype.showHoverEffect = function() {};

/**
 * Hides the hover effect.
 */
DvtSelectable.prototype.hideHoverEffect = function() {};
/**
 * An object that can handle keyboard events delegated to it by a DvtEventManager
 * @interface
 */
var DvtComponentKeyboardHandler = function() {};


/**
 * Process a keyboard event
 * @param {DvtKeyboardEvent} event
 * @return {Boolean} True if this DvtComponentKeyboardHandler consumed the event
 */
DvtComponentKeyboardHandler.prototype.handleKeyboardEvent = function(event) {};

/**
 * Hide the component's keyboard focus effect.  Used by the DvtEventManager
 * to hide keyboard focus on one component when another component receives
 * focus via mouse (e.g., keyboard focus is on breadcrumbs but then you mouse
 * click on a treemap node).
 */
DvtComponentKeyboardHandler.prototype.hideKeyboardFocusEffect = function() {};
/**
 * An object that can receive keyboard focus, and thus can be navigated to via the keyboard
 * @interface
 */
var DvtKeyboardNavigable = function() {};

DvtObj.createSubclass(DvtKeyboardNavigable, DvtObj, "DvtKeyboardNavigable");

/**
 * Returns the next item to receive keyboard focus
 * @param {DvtBaseEvent} event
 * @return {Object} The next item to get keyboard focus
 */
DvtKeyboardNavigable.prototype.getNextNavigable = function(event) {};

/**
 * Returns the bounding box for this navigable item
 * @return {DvtRectangle}
 */
DvtKeyboardNavigable.prototype.getKeyboardBoundingBox = function() {};

/**
 * Show a visual effect to indicate if this DvtKeyboardNavigable has keyboard focus
 */
DvtKeyboardNavigable.prototype.showKeyboardFocusEffect = function() {};

/**
 * Hide the visual effect to indicate if this DvtKeyboardNavigable has keyboard focus
 */
DvtKeyboardNavigable.prototype.hideKeyboardFocusEffect = function() {};

/**
 * Returns true if this navigable is showing its keyboard focus effect
 * @return {Boolean}
 */
DvtKeyboardNavigable.prototype.isShowingKeyboardFocusEffect = function() {};

/**
 * Optional method to implement. Returns the location for where a context menu should appear.
 * @return {DvtPoint}
 */
DvtKeyboardNavigable.prototype.getContextMenuLocation = function() {};
/**
 * An object that can belongs to a category.  
 * @interface
 */
var DvtCategoricalObject = function() {};

DvtObj.createSubclass(DvtCategoricalObject, DvtObj, "DvtCategoricalObject");

/**
 * Returns an array containing all categories to which this object belongs.
 * @return {array} The array of categories.
 */
DvtCategoricalObject.prototype.getCategories = function() {};
/**
 * An object that displays context menus.
 * @interface
 */
var DvtContextMenuSource = function() {};

DvtObj.createSubclass(DvtContextMenuSource, DvtObj, "DvtContextMenuSource");

/**
 * Returns the id of the specific context menu to display for the object.
 * @return {object} The menu id to pass into the context menu handler.
 */
DvtContextMenuSource.prototype.getContextMenuId = function() {};

/**
 * Returns the x,y coordinate of the upper left hand corner for the context menu, when the context menu
 * is triggered by a keyboard shortcut
 * Optional method to implement.
 * @return {DvtPoint} 
 */
DvtContextMenuSource.prototype.getContextMenuLocation = function() {};
/**
 * An object that displays popups.
 * @interface
 */
var DvtPopupSource = function() {};

DvtObj.createSubclass(DvtPopupSource, DvtObj, "DvtPopupSource");

/**
 * Returns the server side id for this object, which is used to set context on
 * the server.
 * @return {string} The server side id for this object.
 */
DvtPopupSource.prototype.getId = function() {};

/**
 * Returns the array of showPopupBehaviors for the object.
 * @return {array} The array of applicable DvtShowPopupBehaviors
 */
DvtPopupSource.prototype.getShowPopupBehaviors = function() {};
/**
 * For changing z-order of an object
 * @interface
 */
var DvtZOrderManager = function() {};

DvtObj.createSubclass(DvtZOrderManager, DvtObj, "DvtZOrderManager");

/**
 * Bring the object to the front of the z-order.
 *
 * @param {DvtDisplayable}  displayable  object to push back in the z-order
 */
DvtZOrderManager.prototype.bringToFrontOfSelection = function(displayable) {};

/**
 * Push the object to the back of the selected objects in the z-order.
 *
 * @param {DvtDisplayable}  displayable  object to push back in the z-order
 */
DvtZOrderManager.prototype.pushToBackOfSelection = function(displayable) {};

/**
 * Set the number of objects that must be kept in front of any selected
 * objects in the z-order.  
 * 
 * @param {number} num  number of objects to keep in front of selected objects
 */
DvtZOrderManager.prototype.setNumFrontObjs = function(num) {};
/**
 * An object that contains children that can be accessed by test automation 
 * @interface
 */
var DvtAutomationContainer = function() {};

DvtObj.createSubclass(DvtAutomationContainer, DvtObj, "DvtAutomationContainer");

/**
 * Dispatches an event triggered by test automation on the given subId
 * @param {Number} subId
 * @param {String} eventType
 * @param {String} params Parameters to initialize the event 
 */
DvtAutomationContainer.prototype.dispatchTestEvent = function(subId, eventType, params) {}; 

/**
 * Simple logical object for tooltip support.
 * @param {string} tooltip The tooltip to display.
 * @param {string} datatip The datatip to display.
 * @param {string} datatipColor The border color of the datatip.
 * @param {object} [params] Optional object containing additional parameters for use by component.
 * @class
 * @constructor
 * @implements {DvtTooltipSource}
 */
var DvtSimpleObjPeer = function(tooltip, datatip, datatipColor, params) {
  this.Init(tooltip, datatip, datatipColor, params);
}

DvtObj.createSubclass(DvtSimpleObjPeer, DvtObj, "DvtSimpleObjPeer");

/**
 * @param {string} tooltip The tooltip to display.
 * @param {string} datatip The datatip to display.
 * @param {string} datatipColor The border color of the datatip.
 * @param {object} [params] Optional object containing additional parameters for use by component.
 */
DvtSimpleObjPeer.prototype.Init = function(tooltip, datatip, datatipColor, params) {
  this._tooltip = tooltip;
  this._datatip = datatip;
  this._datatipColor = datatipColor;
  this._params = params;
}

/**
 * Specifies the tooltip for this object.
 * @param {string} tooltip
 */
DvtSimpleObjPeer.prototype.setTooltip = function(tooltip) {
  this._tooltip = tooltip;
}

/**
 * Specifies the datatip for this object.
 * @param {string} datatip
 */
DvtSimpleObjPeer.prototype.setDatatip = function(datatip) {
  this._datatip = datatip;
}

/**
 * Specifies the datatip color for this object.
 * @param {string} datatipColor
 */
DvtSimpleObjPeer.prototype.setDatatipColor = function(datatipColor) {
  this._datatipColor = datatipColor;
}

/**
 * Returns additional parameters for this object, if available.
 * @return {object}
 */
DvtSimpleObjPeer.prototype.getParams = function() {
  return this._params;
};

//---------------------------------------------------------------------//
// Tooltip Support: DvtTooltipSource impl                              //
//---------------------------------------------------------------------//

/**
 * @override
 */
DvtSimpleObjPeer.prototype.getTooltip = function(target) {
  return this._tooltip;
};

/**
 * @override
 */
DvtSimpleObjPeer.prototype.getDatatip = function(target) {
  return this._datatip;
};

/**
 * @override
 */
DvtSimpleObjPeer.prototype.getDatatipColor = function(target) {
  return this._datatipColor;
};
var DvtAgent = function () {
}

DvtObj.createSubclass(DvtAgent, DvtObj, "DvtAgent");

// Version Constants
DvtAgent.UNKNOWN_VERSION = -1;

// Platform Constants
DvtAgent.IE_PLATFORM = "ie";
DvtAgent.FLASH_PLATFORM = "flash";
DvtAgent.GECKO_PLATFORM = "gecko";
DvtAgent.WEBKIT_PLATFORM = "webkit";
DvtAgent.UNKNOWN_PLATFORM = "unknown";

// OS Constants
DvtAgent.WINDOWS_OS = "Windows";
DvtAgent.SOLARIS_OS = "Solaris";
DvtAgent.MAC_OS = "Mac";
DvtAgent.UNKNOWN_OS = "Unknown";

/**
 * Returns true if creation of aria-label attributes can be deferred.  This prevents costly string generation from
 * becoming necessary across the entire data set.  When deferred, the getAriaLabel API should be implemented on
 * the DvtLogicalObject implementation.
 * @return {boolean}
 */
DvtAgent.deferAriaCreation = function () {
  return !DvtAgent.isTouchDevice() && !DvtAgent.isEnvironmentTest();
}

/**
 * Returns the ratio between physical pixels and device independent pixels for the current device.
 * @return {number} the device pixel ratio
 */
DvtAgent.getDevicePixelRatio = function () {
  DvtAgent._initialize();
  return DvtAgent._devicePixelRatio;
}

/**
 * Returns the position of the specified DOM element in page coordinates.
 * @param {object} element
 * @return {DvtPoint}
 */
DvtAgent.getElementPosition = function (element) {
  if(DvtAgent.getPlatform() == DvtAgent.FLASH_PLATFORM)
    return new DvtPoint();
  else if(DvtAgent.isPlatformIE())
    return DvtAgent._getElementPositionIE(element);
  else if(DvtAgent.isPlatformGecko())
    return DvtAgent._getElementPositionGecko(element);
  else
    return DvtAgent._getElementPositionDefault(element);
}

/**
 * Returns the platform string.  Valid values are DvtAgent.***_PLATFORM.
 * @return {string}
 */
DvtAgent.getPlatform = function () {
  DvtAgent._initialize();
  return DvtAgent._platform;
}

/**
 * Returns a guess of the operating system based on the user agent.
 * @return {string} 
 */
DvtAgent.getOS = function () {
  DvtAgent._initialize();
  return DvtAgent._os;
}

/**
 * Returns the version of the browser reported by the user agent.
 * @return {number} 
 */
DvtAgent.getVersion = function () {
  DvtAgent._initialize();
  return DvtAgent._version;
}

/**
 * Returns true if rendering in Chrome.
 * @return {boolean}
 */
DvtAgent.isBrowserChrome = function () {
  DvtAgent._initialize();
  return DvtAgent._bChrome;
}

/**
 * Returns true if rendering in Safari.
 * @return {boolean}
 */
DvtAgent.isBrowserSafari = function () {
  return DvtAgent.isPlatformWebkit() && !DvtAgent.isBrowserChrome();
}

/**
 * Returns true if rendering in Gecko.
 * @return {boolean}
 */
DvtAgent.isPlatformGecko = function () {
  return DvtAgent.getPlatform() == DvtAgent.GECKO_PLATFORM;
}

/**
 * Returns true if rendering in IE.
 * @return {boolean}
 */
DvtAgent.isPlatformIE = function () {
  return DvtAgent.getPlatform() == DvtAgent.IE_PLATFORM;
}

/**
 * Returns true if rendering in Webkit.
 * @return {boolean}
 */
DvtAgent.isPlatformWebkit = function () {
  return DvtAgent.getPlatform() == DvtAgent.WEBKIT_PLATFORM;
}

/**
 * Returns true if rendering in a right to left locale.
 * @param {DvtContext} [context] If specified, first tries to determine the reading direction from the context.
 * @return {boolean}
 */
DvtAgent.isRightToLeft = function (context) {
  DvtAgent._initialize();
  if (context && context.getReadingDirection() != null)
    return context.getReadingDirection() == "rtl";
  else 
    return DvtAgent._bRtl;
}

/**
 * Returns true if rendering on a touch device.
 * @return {boolean}
 */
DvtAgent.isTouchDevice = function () {
  DvtAgent._initialize();
  return DvtAgent._bTouchDevice;
}


/**
 * Sets the current environment type
 * @param {String} type The environment type.  Currently supports 'batik' and 'test'
 * @export
 */
DvtAgent.setEnvironment = function (type) {
  DvtAgent._environment = type;
}

/**
 * Returns whether the current environment is test
 * @return {boolean} 
 */
DvtAgent.isEnvironmentTest = function () {
  return DvtAgent._environment == 'test';
}

/**
 * Returns whether the current environment is batik
 * @return {boolean}
 */
DvtAgent.isEnvironmentBatik = function () {
  return DvtAgent._environment == 'batik';
}

/**
 * Returns whether the current environment is browser
 * @return {boolean}
 */
DvtAgent.isEnvironmentBrowser = function () {
  return !DvtAgent.isEnvironmentTest() && !DvtAgent.isEnvironmentBatik();
}

/**
 * Works around Firefox bug where displayable isn't rendered correctly for matrix update
 * @param {DvtDisplayable} displayable The displayable to check
 */
DvtAgent.workaroundFirefoxRepaint = function (displayable) {
  //Fix for bug #17897328
  if (DvtAgent.isPlatformGecko()) {
    var parent = displayable.getParent();
    if (parent) {
      var idx = parent.getChildIndex(displayable);
      parent.removeChildAt(idx);
      parent.addChildAt(displayable, idx);
    }
  }
}

/**
 * Initializes the agent.  This caches all the relevant agent parameters and must be called before accessing any of
 * the variables on DvtAgent.
 * @return {DvtAgent}
 * @private
 */
DvtAgent._initialize = function () {
  // Initialize DvtAgent if it hasn't been already.
  if(!DvtAgent._bInitialized) {  
    var userAgent = (navigator && navigator.userAgent) ? navigator.userAgent.toLowerCase() : null;
    
    DvtAgent._os = DvtAgent._determineOS(userAgent);
    DvtAgent._platform = DvtAgent._determinePlatform(userAgent);
    DvtAgent._version = DvtAgent._determineVersion(userAgent, DvtAgent._platform);
    
    DvtAgent._bChrome = this.isEnvironmentTest() || (userAgent && (userAgent.indexOf("chrome/") != -1));
    DvtAgent._bRtl = (document && document.documentElement) ? document.documentElement.dir == "rtl" : false;
    DvtAgent._bTouchDevice = (DvtAgent._platform == DvtAgent.WEBKIT_PLATFORM) && userAgent &&
                             (userAgent.indexOf("mobile") != -1 || userAgent.indexOf("android") != -1);
    DvtAgent._devicePixelRatio = (window && window.devicePixelRatio != null) ? window.devicePixelRatio : 1;
    
    // Don't initialize again
    DvtAgent._bInitialized = true;
  }
}


/**
 * Determines the operating system. This value should be cached to prevent costly calculations. This value should be 
 * treated as a guess, as this code is copied from AdfAgent.guessOS().
 * @param {string} userAgent The lowercase user agent string, if available.
 * @return {string} The DvtAgent.***_OS constant describing the platform.
 * @private
 */
DvtAgent._determineOS = function(userAgent)
{  
  if(userAgent) {
    if (userAgent.indexOf('win')!= -1)
      return DvtAgent.WINDOWS_OS;
    else if (userAgent.indexOf('mac') != -1)
      return DvtAgent.MAC_OS;
    else if (userAgent.indexOf('sunos') != -1)
      return DvtAgent.SOLARIS_OS;
  }
  
  return DvtAgent.UNKNOWN_OS;
}

/**
 * Determines the name of the platform. This value should be cached to prevent costly calculations.
 * @param {string} userAgent The lowercase user agent string, if available.
 * @return {string} The DvtAgent.***_PLATFORM constant describing the platform.
 * @private
 */
DvtAgent._determinePlatform = function(userAgent)
{  
  if (DvtAgent.isEnvironmentTest()) {
    return DvtAgent.WEBKIT_PLATFORM;
  } else {
    if(window.isFlashEnvironment)
      return DvtAgent.FLASH_PLATFORM;

    if (userAgent) { 
      if(userAgent.indexOf("opera") != -1) // check opera first, since it mimics other browsers
        return DvtAgent.UNKNOWN_PLATFORM;
      else if (userAgent.indexOf("trident") != -1 || userAgent.indexOf("msie")!= -1)
        return DvtAgent.IE_PLATFORM;
      else if ((userAgent.indexOf("applewebkit") != -1) || (userAgent.indexOf("safari") != -1))
        return DvtAgent.WEBKIT_PLATFORM;
      else if(userAgent.indexOf("gecko/") != -1)
        return DvtAgent.GECKO_PLATFORM;
    }
  }
  return DvtAgent.UNKNOWN_PLATFORM;
}

/**
 * Determines the version of the platform. This value should be cached to prevent costly calculations.
 * @param {string} userAgent The lowercase user agent string, if available.
 * @param {string} platform The DvtAgent.***_PLATFORM constant describing the platform.
 * @return {number} The version number.
 * @private
 */
DvtAgent._determineVersion = function(userAgent, platform)
{  
  if(userAgent) {
    if(platform == DvtAgent.GECKO_PLATFORM)
      return DvtAgent._parseFloatVersion(userAgent, /rv:(\d+[.]\d+)/);
    else if(platform == DvtAgent.IE_PLATFORM) {
      var tridentVersion = DvtAgent._parseFloatVersion(userAgent, /trident\/(\d+[.]\d+)/);
      if(tridentVersion != DvtAgent.UNKNOWN_VERSION) {
        // Match found, resolve to IE version number, which is trident version + 4
        return tridentVersion + 4;
      }
      else {
        // One of the two approaches will return the correct version
        var msieVersion = DvtAgent._parseFloatVersion(userAgent, /msie (\d+\.\d+);/);
        if(msieVersion == DvtAgent.UNKNOWN_VERSION)
          msieVersion = DvtAgent._parseFloatVersion(userAgent, /msie (\d+\.\d+)b;/);
          
        return msieVersion;
      }
    }
    else if(platform == DvtAgent.WEBKIT_PLATFORM)
      return DvtAgent._parseFloatVersion(userAgent, /applewebkit\/(\d+([.]\d+)*)/);
  } else {
    if (DvtAgent.isEnvironmentTest())
      return 999;
  }
  
  return DvtAgent.UNKNOWN_VERSION;
}

/**
 * Parses the version from the specified agent string using the regular expression.
 * @param {string} userAgent The lowercase user agent string.
 * @param {regexp} versionNumberPattern The regular expression used to parse the version number.
 * @return {number}
 * @private
 */
DvtAgent._parseFloatVersion = function (userAgent, versionNumberPattern)
{
  try {
    var matches = userAgent.match(versionNumberPattern);
    return (matches && matches[1]) ? parseFloat(matches[1]) : DvtAgent.UNKNOWN_VERSION;
  }
  catch(e) {
    // Technically we should not assume console exists, but it will in all cases where we call this function.
    console.error("DvtAgent._parseFloatVersion error: ");
    console.error(e);
    return DvtAgent.UNKNOWN_VERSION;
  }
}

/**
 * Returns the position of an HTML element relative to the document body.
 * @param {object} element The HTML element.
 * @return {DvtPoint}
 * @private
 */
DvtAgent._getElementPositionGecko = function(element)
{
  // Note: This code was copied from AdfAgent and is not cleaned up for purposes of maintainability and comparison.
  //AdfAssert.assertDomElement(element);
  var boundingRect = element.getBoundingClientRect();
  // top and bottom are not rounded off in Gecko1.9
  // http://www.quirksmode.org/dom/w3c_cssom.html#elementviewm
  var elemTop = Math.round(boundingRect.top);
  var elemLeft = boundingRect.left;
  var docElement = element.ownerDocument.documentElement;
  // clientLeft and clientTop would be 0 for Gecko1.9
  // https://bugzilla.mozilla.org/show_bug.cgi?id=174397#c34
  elemLeft += docElement.scrollLeft;
  elemTop += docElement.scrollTop;
  return new DvtPoint(elemLeft, elemTop);
}

/**
 * Returns the position of an HTML element relative to the document body.
 * @param {object} element The HTML element.
 * @return {DvtPoint}
 * @private
 */
DvtAgent._getElementPositionIE = function(element)
{
  // Note: This code was copied from AdfAgent and is not cleaned up for purposes of maintainability and comparison.
  //AdfAssert.assertDomElement(element);
  var boundingRect = element.getBoundingClientRect();
  var elemTop = boundingRect.top;
  var elemLeft = boundingRect.left;
  var docElement = element.ownerDocument.documentElement;
  var scrollLeft = docElement.scrollLeft;

  // RTL adjustment for IE scrolled view
  //if(AdfPage.PAGE.getLocaleContext().isRightToLeft())
  //  scrollLeft += docElement.clientWidth - docElement.scrollWidth;

  // adjust for the document scroll positions and window borders
  elemLeft -= (docElement.clientLeft - scrollLeft);
  elemTop -= (docElement.clientTop - docElement.scrollTop);
  return {x:elemLeft, y:elemTop};
}

/**
 * Returns the position of an HTML element relative to the document body.
 * @param {object} element The HTML element.
 * @return {DvtPoint}
 * @private
 */
DvtAgent._getElementPositionDefault = function(element)
{ 
  // Note: This code was copied from AdfAgent and is not cleaned up for purposes of maintainability and comparison.
  // =-= VG Default implementation for Safari/Opera
  var bodyElement = element.ownerDocument.body;

  var currParent = element.offsetParent;
  var currLeft   = element.offsetLeft;
  var currTop   = element.offsetTop;
  //In safari/opera position absolute incorrectly account for body offsetTop
  //if (this.getComputedStyle(element).position == "absolute")
  //{
  //  currTop -= bodyElement.offsetTop;
  //}

  // store cssLengthAsInt function in local
  //var cssLengthAsInt = AdfAgent.getCSSLengthAsInt;

  while (currParent)
  {
    element = currParent;
    currLeft += element.offsetLeft;
    currTop += element.offsetTop;
    if (element != bodyElement)
    {
      //adjust for border
      //var style = this.getComputedStyle(element);
      //currLeft += cssLengthAsInt(style.borderLeftWidth);
      //currTop += cssLengthAsInt(style.borderTopWidth);

      currLeft -= element.scrollLeft;
      currTop -= element.scrollTop;
    }

    currParent = currParent.offsetParent;
  }

  return {x:currLeft, y:currTop};
}
/**
 * Resource bundle base class.
 * @class
 * @constructor
 * @extends {DvtObj}
 * @export
 */
var DvtBundle = function() {}
DvtBundle["_localizedStrings"] = {};

DvtObj.createSubclass(DvtBundle, DvtObj, "DvtBundle");

/**
 * Adds localized resources into DvtBundle. Called by the resource bundle implementations to register localized strings.
 * Example: 
 * var DvtChartBundle_CS = {
 *   "DvtChartBundle.LABEL_LEGEND" : "Legenda"
 * }
 * DvtBundle.addLocalizedStrings(DvtChartBundle_CS);
 * @param {object} object containing key - value pairs to be added
 * @export
 */
DvtBundle.addLocalizedStrings = function(jsonObj) {
  for(key in jsonObj) {
    DvtBundle["_localizedStrings"][key] = jsonObj[key];
  } 
}

/**
 * Returns localized string for given key.
 * @private
 * @param {string} key
 * @return {string} localized string for given key
 */
DvtBundle.prototype._getLocalizedStringForKey = function(key) {
  var fqKey = this._getFQKey(key);
  return DvtBundle["_localizedStrings"][fqKey];
}

/**
 * Returns bundle prefix. This prefix specifies the prefix of all keys in a localized bundle,
 * e.g. in case of localized dvt gauge bundle the key prefix is 'DvtGaugeBundle' since every key
 * is of the form 'DvtGaugeBundle.KEY_NAME'.
 * This method is called by the getTranslatedString function to construct fully qualified key and is intended to be overriden by descendands.
 * @protected
 * @return {string} bundle prefix
 */
DvtBundle.prototype.GetBundlePrefix = function() {}

/**
 * Returns default string for given key. This method is intended to be overriden by descendands.
 * @protected
 * @param {string} key
 * @return {string} default string for given key
 */
DvtBundle.prototype.GetDefaultStringForKey = function(key) {}

/**
 * Substitutes the replacement objects into the specified pattern.
 * @param {string} pattern The pattern string with placeholders.
 * @param {array} replacements The array of replacement strings.
 * @return {string} The resulting string.
 */
DvtBundle.format = function(pattern, replacements) {
  return pattern.replace(/\{(\d+)\}/g, function() {return replacements[arguments[1]];});
}

/**
 * Returns a translated string with replacements. If an array of replacement
 * strings is provided, these strings will be substituted into the translated string.
 * @param {string} key The key in the message bundle.
 * @param {replacements} replacements The array of replacement strings.
 * @return {string} The translated string.
 */ 
DvtBundle.prototype.getTranslatedString = function(key, replacements) {
  var ret = this._getLocalizedStringForKey(key);
  if(!ret)
    ret = this.GetDefaultStringForKey(key);
  
  // Substitute the replacements if provided
  if(ret && replacements !== null && replacements !== undefined) {
    if(replacements instanceof Array)
      ret = DvtBundle.format(ret, replacements);
    else // Wrap a single object for convenience
      ret = DvtBundle.format(ret, [replacements]);
  }
    
  return ret; 
}

/**
 * Returns a fully qualified key.
 * @private
 * @param {string} key The key in the message bundle.
 * @return {string} The fully qualified key.
 */ 
DvtBundle.prototype._getFQKey = function(key) {
  var bPrefix = this.GetBundlePrefix();
  var fqKey = key;
  if(key.length <= bPrefix.length || !(key.substring(0, bPrefix.length) === bPrefix)) {
    fqKey = bPrefix + "." + key;
  }
  return fqKey;
}
/**
 * LRU cache implementation for use in improving performance.  Alternate cache implementation options may be added in
 * the future as needed.
 * @param {number} targetSize The target size of the cache. Once populated, this is the minimum size of the cache.
 * @class DvtCache
 * @extends DvtObj
 * @constructor
 */
var DvtCache = function(targetSize) {
  this.Init(targetSize);
}

DvtObj.createSubclass(DvtCache, DvtObj, "DvtCache");

/**
 * The default target size of the cache.
 * @private
 */
DvtCache._TARGET_SIZE = 200;

/**
 * The overflow allowed in cache size before a removal of old keys is performed.
 * @private
 */
DvtCache._BUFFER_SIZE = 0.50;

/**
 * Initializes the cache and its underlying data structures.
 * @param {number} targetSize The target size of the cache. Once populated, this is the minimum size of the cache.
 */
DvtCache.prototype.Init = function(targetSize) {
  this._targetSize = targetSize != null ? targetSize : DvtCache._TARGET_SIZE;
  this._maxSize = Math.ceil(this._targetSize * (1+DvtCache._BUFFER_SIZE));
  
  // Initialize the cache and array of keys, where the first key is the least recently used.
  this._cache = {};
  this._lruArray = [];
  
  // Initialize debug params for cache tuning
  this._hits = 0;
  this._misses = 0;
}

/**
 * Retrieves the value corresponding to the key from the cache.  If the key cannot be found in the cache, returns null.
 * @param {object} key
 * @return {object}
 */
DvtCache.prototype.get = function(key) {
  var ret = this._cache[key];
  if(ret != null) {
    this._hits++;
    return ret;
  }
  else {
    this._misses++;
    return null;
  }
}

/**
 * Stores the value corresponding to the key in the cache.  If the cache has reached the maximum size, then the least
 * recently used key will be removed from the cache.
 * @param {object} key
 * @param {object} value
 */
DvtCache.prototype.put = function(key, value) {
  // Optimize the cache update based on whether the key already existed in the cache
  var bKeyExists = (this._cache[key] != null);
  
  // Update the cache first
  this._cache[key] = value;
  
  // Update the array tracking recently used items
  if(bKeyExists) {
    // Already exists, remove before we add to the end of the list
    var keyIndex = DvtArrayUtils.getIndex(this._lruArray, key);
    this._lruArray.splice(keyIndex, 1);
    this._lruArray.push(key);
  }
  else {
    // Doesn't exist already, add to the array.  This indicates the cache size has increased.
    this._lruArray.push(key);
    
    // If the cache size exceeds the max length, then remove the least recently used items.
    if(this._lruArray.length > this._maxSize) {
      var removedKeys = this._lruArray.splice(0, this._maxSize - this._targetSize);
      for(var i = 0; i < removedKeys.length; i++) {
        delete this._cache[removedKeys[i]];
      }
    }
  }
}

/**
 * @override
 */
DvtCache.prototype.toString = function() {
  // Returns a variety of tuning information
  var ret = "Cache Size: " + this._lruArray.length;
  ret += "\nHits: " + this._hits;
  ret += "\nMisses: " + this._misses;
  ret += "\nHit %: " + Math.round(10000*this._hits/(this._hits + this._misses))/100;
  return ret;
}
/**
 * Interactivity manager for context menu support.
 * @param {DvtContext} context The platform specific context object.
 * @class DvtContextMenuHandler
 * @constructor
 */
var DvtContextMenuHandler = function(context) {
  this.Init(context);
};

DvtObj.createSubclass(DvtContextMenuHandler, DvtObj, "DvtContextMenuHandler");

DvtContextMenuHandler.TYPE_BODY_CONTEXT_MENU = "bodyContextMenu";
DvtContextMenuHandler.TYPE_CONTEXT_MENU = "contextMenu";
DvtContextMenuHandler.TYPE_MULTI_SELECT_CONTEXT_MENU = "multiSelectContextMenu";

DvtContextMenuHandler._ATTR_MENU_CONTAINER_TYPE = "t";
DvtContextMenuHandler._ATTR_MENU_CONTAINER_POPUP_ID = "id";
DvtContextMenuHandler._ATTR_MENU_ITEMS = "i";
// Menu Item Attrs
DvtContextMenuHandler._ATTR_ITEM_TEXT = "t";
DvtContextMenuHandler._ATTR_ITEM_DISABLED = "di";
DvtContextMenuHandler._ATTR_ITEM_SEP_BEFORE = "sb";
// CommandMenuItem Attrs
DvtContextMenuHandler._ATTR_ITEM_CLIENT_ID = "id";
// GoMenuItem Attrs
DvtContextMenuHandler._ATTR_ITEM_DESTINATION = "d";
DvtContextMenuHandler._ATTR_ITEM_TARGET_FRAME = "tf";

DvtContextMenuHandler.prototype.Init = function(context) {
  this._context = context;
  this._xmlNodes = new Array();
  // Create the impl object
  this._impl = context.getImplFactory().newContextMenuHandler();
  this._impl.setObj(this);
}

/**
 * Adds the specified context menu definition to this handler.
 * @param {DvtXmlNode} xmlNode The xml node defining the context menu.
 */
DvtContextMenuHandler.prototype.add = function(xmlNode) {
  this._xmlNodes.push(xmlNode);  
}

/**
 * Displays the context menu with the specified type and id.  Depending on the rendering context,
 * a context menu will either be shown immediately, or a contextMenuEvent will be returned.  If
 * a contextMenuEvent is returned, it should be dispatched through the event callback mechanism.
 * @param {object} event The event that is triggering the context menu.
 * @param {string} menuType The type of context menu being requested, such as bodyContextMenu.
 * @param {string} menuId The id of the specific menu being requested.
 * @return {DvtContextMenuEvent} A context menu event to dispatch or null, depending on the rendering context.
 */
DvtContextMenuHandler.prototype.show = function(event, menuType, menuId) {
  return this._impl.getMenuEvent(this._xmlNodes, event, menuType, menuId);
}

DvtContextMenuHandler.prototype.prepareMenuItems = function(event, menuType, menuId) {
  this._impl.prepareMenuItems(event, menuType, menuId);
}

/**
 * Returns the array of menu items for the specified menu type and menu id.
 * @param {string} menuType The type of context menu being requested, such as bodyContextMenu.
 * @param {string} menuId The id of the specific menu being requested.
 * @return {array} The array of DvtContextMenuItems.
 */
DvtContextMenuHandler.prototype.getMenuItems = function(menuType, menuId) {
  if (!menuId)
    menuId = 0;
  if (menuType === DvtContextMenuHandler.TYPE_BODY_CONTEXT_MENU || menuType === DvtContextMenuHandler.TYPE_MULTI_SELECT_CONTEXT_MENU) {
    menuId = 0;
  }
  // Look through all context menu definitions for the right context menu to show
  for(var i=0; i<this._xmlNodes.length; i++) {
    var xmlNode = this._xmlNodes[i];
    if(menuType == xmlNode.getAttr(DvtContextMenuHandler._ATTR_MENU_CONTAINER_TYPE)) {
      if(menuId != null && menuId >= 0) {
        // menuNode is the menu definition that we are looking for
        var childNodes = xmlNode.getChildNodes();
        if(childNodes && childNodes.length > menuId) {
          var menuNode = childNodes[menuId];
          // Parse the list of items and return them
          var itemsStr = menuNode.getAttr(DvtContextMenuHandler._ATTR_MENU_ITEMS);
          if(itemsStr) {
            // itemsContainer is the xml node containing all menu item definitions
            var itemsContainer = childNodes[childNodes.length-1];
            
            // menuItemNodes is the array of all menu items
            var menuItemNodes = itemsContainer.getChildNodes();
            
            // targetIds is the array of menu items to be added into this menu
            var targetIds = itemsStr.split(",");
            
            // Gather all target menu items and return them
            var targetMenuItems = new Array();
            for(var j=0; j<targetIds.length; j++) {
              var menuItemXmlNode = menuItemNodes[targetIds[j]];
              
              // Parse the display attributes
              var text = menuItemXmlNode.getAttr(DvtContextMenuHandler._ATTR_ITEM_TEXT);
              var disabled = menuItemXmlNode.getAttr(DvtContextMenuHandler._ATTR_ITEM_DISABLED);
              var sepBefore = menuItemXmlNode.getAttr(DvtContextMenuHandler._ATTR_ITEM_SEP_BEFORE);
              
              // Create the event that would be fired on select
              var clientId = menuItemXmlNode.getAttr(DvtContextMenuHandler._ATTR_ITEM_CLIENT_ID);
              var destination = menuItemXmlNode.getAttr(DvtContextMenuHandler._ATTR_ITEM_DESTINATION);
              var targetFrame = menuItemXmlNode.getAttr(DvtContextMenuHandler._ATTR_ITEM_TARGET_FRAME);
              var event = new DvtContextMenuSelectEvent(menuType, clientId, destination, targetFrame);
              
              // Add the menu item
              targetMenuItems.push(new DvtContextMenuItem(event, text, disabled, sepBefore));
            }
            
            return targetMenuItems;
          }
        }
      }
    }
  }
  return null;
}

/**
 * Returns the DvtContext associated with this handler.
 * @return {DvtContext}
 */
DvtContextMenuHandler.prototype.getCtx = function() {
  return this._context;
}

/**
 * Dispatches an event to the external interface
 * @param {DvtContextmenuSelectEvent} event The event to dispatch
 * @protected
 */
DvtContextMenuHandler.prototype.DispatchContextMenuSelectEvent = function(event) {
  DvtEventDispatcher.dispatchEvent(null, null, null, event);
}
/**
 * Interactivity manager for popup support.
 * @param {DvtContext} context The platform specific context object.
 * @param {function} callback A function that responds to delayed popup events
 * @param {object} callbackObj The optional object instance that the callback function is defined on.
 * @class DvtPopupBehaviorHandler
 * @constructor
 */
var  DvtPopupBehaviorHandler = function(context, callback, callbackObj) {
  this._context = context;
  this._callback = callback;
  this._callbackObj = callbackObj;
  
  // Initialize the hover params
  this._popupPosition = null;   // The most recent position, useful for placing the popup
  this._hoverTarget = null;      // The current hover target
  this._hoverBehavior = null;    // The current showPopupBehavior for the hover
  this._hoverPopupShown = false; // true if a hover popup is being shown
  this._hoverTimer = new DvtTimer(context, 500, this._onHoverDelay, this, 1);
};

DvtObj.createSubclass(DvtPopupBehaviorHandler, DvtObj, "DvtPopupBehaviorHandler");

// TODO define an interface for the targets of the popup handler functions
// 1. getPopupBounds()
// 2. getId()

/**
 * Processes a click event and fires a DvtShowPopupEvent if a popup should be shown.
 * @param {object} target The target of the mouse event.
 * @param {array} behaviors The array of applicable show popup behaviors.
 * @param {DvtPoint} position The position for placing the popup.
 * @param {object} event The mouse event
 */
DvtPopupBehaviorHandler.prototype.processClick = function(target, behaviors, position, event) {
  return this._processClickHelper(target, behaviors, [DvtShowPopupBehavior.TRIGGER_TYPE_ACTION, DvtShowPopupBehavior.TRIGGER_TYPE_CLICK], position, event);
};

/**
 * Processes a context menu event and fires a DvtShowPopupEvent if a popup should be shown.
 * @param {object} target The target of the mouse event.
 * @param {array} behaviors The array of applicable show popup behaviors.
 * @param {DvtPoint} position The position for placing the popup.
 * @param {object} event The mouse event
 */
DvtPopupBehaviorHandler.prototype.processContextMenu = function(target, behaviors, position, event) {
  return this._processClickHelper(target, behaviors, [DvtShowPopupBehavior.TRIGGER_TYPE_CONTEXT_MENU], position, event);
};


/**
 * Processes click and context menu events and fires a DvtShowPopupEvent if a popup should be shown.
 * @param {object} target The target of the mouse event.
 * @param {array} behaviors The array of applicable show popup behaviors.
 * @param {array} triggers The array of trigger types to process
 * @param {DvtPoint} position The position for placing the popup.
 * @param {object} event The mouse event
 */
DvtPopupBehaviorHandler.prototype._processClickHelper = function(target, behaviors, triggers, position, event) {
  var consumed = false;
  if(target && behaviors && behaviors.length>0) {
    for(var i=0; i<behaviors.length; i++) {
      var behavior = behaviors[i];
      if (behavior && triggers.indexOf(behavior.getTriggerType()) != -1) {
        //BUG FIX 15851577: hide an existing popup before showing a new one
        this.HidePopup(event);
        // Create and fire the popup event
        var popupEvent = this._createShowPopupEvent(target, behavior, position);
        DvtEventDispatcher.dispatchEvent(this._callback, this._callbackObj, this, popupEvent);
        consumed = true;
      }
    }
  }
  return consumed;
};




/**
 * Processes a mouseOver event.
 * @param {object} target The target of the mouse event.
 * @param {array} behaviors The array of applicable show popup behaviors.
 * @param {DvtPoint} position The position for the popup.
 * @param <DvtDisplayable> displayable The DvtDisplayable associated with the logical target of the event.
 * @param {object} event The mouse event
 */
DvtPopupBehaviorHandler.prototype.processMouseOver = function(target, behaviors, position, displayable, event) {
  // Same target, no action needed
  if(target === this._hoverTarget)
    return true;
  
  // Different target, look for applicable showPopupBehavior
  if(target && behaviors && behaviors.length>0) 
  {
    for(var i=0; i<behaviors.length; i++) {
      var behavior = behaviors[i];
      if(behavior && behavior.getTriggerType() == DvtShowPopupBehavior.TRIGGER_TYPE_MOUSE_HOVER) {
        //BUG FIX 15851577: hide an existing popup before showing a new one
        this.HidePopup(event);
        // Found hover behavior, store the info for use in callback and rollout
        this._hoverTarget = target;
        this._hoverBehavior = behavior;
        //BUG FIX 15851577: save the displayable so we know when to hide a mousehover popup
        this._hoverDisplayable = displayable;
        
        this._popupPosition = position;
        // Start the hover timer
        this._hoverTimer.start();
        return true;
      }
    }
  }
  return false;
};

/**
 * Processes a mouseOver event and fires a DvtHidePopupEvent if a popup is to be hidden.
 * @param {object} target The target of the mouse event.
 * @param {array} displayableHierarchy The hierarchy of DvtDisplayables associated with the relatedTarget of the
 * @param {object} event The mouse event
 * mouseout event
 */
DvtPopupBehaviorHandler.prototype.processMouseOut = function(target, displayableHierarchy, event) {
  //BUG FIX 15851577: if we're mousing out of the whole component, hide the popup
  var bLeavingComponent = false;
  if (displayableHierarchy) {
    bLeavingComponent = (displayableHierarchy.length < 1);
  }
  // Continue only if a hover popup was processed for this target
  if(!this._hoverTarget || !this._hoverBehavior || (target !== this._hoverTarget && !bLeavingComponent))
    return;
  
  //BUG FIX 15851577: don't hide the popup if the DvtDisplayable that launched it is still in the
  //hierarchy of DvtDisplayables for the event's relatedTarget, in other words, if we haven't moused out
  //of the launching displayable entirely (for example, when mousing between children of the
  //launching displayable)
  if (displayableHierarchy && this._hoverDisplayable) {
    if (DvtArrayUtils.getIndex(displayableHierarchy, this._hoverDisplayable) > -1) {
      return;
    }
  }
  
  this.HidePopup(event);
};

/**
 * Hides a popup
 * @param {object} relatedTarget The related target of the event that triggered the hide popup event
 * @param {object} event The mouse event
 * @protected
 */
DvtPopupBehaviorHandler.prototype.HidePopup = function(event) {
  if(this._hoverPopupShown) {
    // Popup already shown, hide it
    var popupEvent = new DvtHidePopupEvent(this._hoverBehavior.getPopupId(), event.getNativeEvent().relatedTarget);
    DvtEventDispatcher.dispatchEvent(this._callback, this._callbackObj, this, popupEvent);
  }
  else {
    // Popup not shown yet, just stop the timer
    this._hoverTimer.stop();
  }
  
  // Clear out the fields
  this._hoverTarget = null;
  this._hoverBehavior = null;
  this._hoverPopupShown = false;
  this._hoverDisplayable = null;
};

/**
 * Processes a mouseMove event.  The most recent position is stored to help position
 * hover popups relative to the mouse.
 * @param {DvtPoint} position The position for the popup.
 */
DvtPopupBehaviorHandler.prototype.processMouseMove = function(position) {
  this._popupPosition = position;
}

/**
 * Helper function used to create the DvtShowPopupEvent.
 * @param {object} target The target of the mouse event.
 * @param {DvtShowPopupBehavior} behavior The show popup behavior that is being fired.
 * @param {DvtPoint} position The position for placing the popup.
 * @return {DvtShowPopupEvent} The showPopupEvent, if a popup should be shown.
 * @private
 */
DvtPopupBehaviorHandler.prototype._createShowPopupEvent = function(target, behavior, position) {
  //FIX BUG 14498642: only align to the moue when align information is not specified if this._bForceAlignToMouse is true
  
  // If align and alignId are not defined, position the popup with alignId="endAfter".  The original
  // showPopupBehavior is not modified.
  var spb = behavior;
  var behaviorForBounds = behavior;
  var canAlignToMouse = spb.getAlign() && !spb.getAlignId();
  if (canAlignToMouse) {
    behaviorForBounds = new DvtShowPopupBehavior(spb.getPopupId(), spb.getTriggerType(), null, null);
  }
  
  // Find the bounds that the popup should align to
  var launcherBounds = target.getPopupBounds ? target.getPopupBounds(behaviorForBounds) : null;
  if(canAlignToMouse && !launcherBounds) {
    // If the object doesn't specify a bounds, then align to the mouse
    var pos = this._context.pageToStageCoords(position.x, position.y);
    launcherBounds = new DvtRectangle(pos.x, pos.y-5, 1, 5);
  }
  else if (launcherBounds) {
    //BUG FIX 13971862: if we have launcher bounds, then create a new behavior object and set the alignId
    //to null so that the JS peer will recognize that the popup should be aligned to a component
    //rendered by the toolkit and position the helper div accordingly
    spb = new DvtShowPopupBehavior(spb.getPopupId(), spb.getTriggerType(), null, spb.getAlign());
  }

  var event = new DvtShowPopupEvent(spb, launcherBounds, null);
  // add the component specific context
  DvtEventManager._addContextInfo(target, event);

  return event;
}

/**
 * Callback function that is called by the timer when a hover popup should be shown.
 * @private
 */
DvtPopupBehaviorHandler.prototype._onHoverDelay = function() {
  if(!this._hoverTarget || !this._hoverBehavior)
    return;
  // Show the popup: Create the event and pass to the hover callback
  this._hoverPopupShown = true;
  var event = this._createShowPopupEvent(this._hoverTarget, this._hoverBehavior, this._popupPosition);
  DvtEventDispatcher.dispatchEvent(this._callback, this._callbackObj, this, event);
}
/**
 * Interactivity manager for dvt component client behaviors
 * @param {DvtContext} context The platform specific context object.
 * @param {function} callback A function that responds to client behavior events
 * @param {object} callbackObj The optional object instance that the callback function is defined on.
 * @class DvtClientBehaviorHandler
 * @constructor
 */
var DvtClientBehaviorHandler = function(context, callback, callbackObj) {
  this.Init(context, callback, callbackObj);
};

DvtObj.createSubclass(DvtClientBehaviorHandler, DvtObj, "DvtClientBehaviorHandler");

DvtClientBehaviorHandler.prototype.Init = function(context, callback, callbackObj) {
  this._context = context;
  this._callback = callback;
  this._callbackObj = callbackObj;      
};

/**
 * Processes a click event and fires a DvtClientBehaviorEvent if a client behavior was triggered.
 * @param {object} target The target of the mouse event.
 * @param {array} behaviors The array of applicable client behaviors.
 * @return {boolean} true if a client behavior was triggered, false otherwise
 */
DvtClientBehaviorHandler.prototype.processClick = function(target, behaviors) {
  var consumed = false;
  if(target && behaviors && behaviors.length>0) 
  {
    for(var i=0; i<behaviors.length; i++) {
      var behavior = behaviors[i];
      if(behavior && (behavior.getTriggerType() == DvtClientBehavior.TRIGGER_TYPE_ACTION ||
                      behavior.getTriggerType() == DvtClientBehavior.TRIGGER_TYPE_CLICK)) {
        // Create and fire the popup event
        var behaviorEvent = this.CreateClientBehaviorEvent(target, behavior);        
        DvtEventDispatcher.dispatchEvent(this._callback, this._callbackObj, null, behaviorEvent);
        consumed = true;
      }
    }
  }

  return consumed;
};

DvtClientBehaviorHandler.prototype.CreateClientBehaviorEvent = function(target, behavior) {
  var behaviorEvent = new DvtClientBehaviorEvent(behavior);
  DvtEventManager._addContextInfo(target, behaviorEvent);
  return behaviorEvent;
}
/**
  * Interactivity manager for selection.
  * @class DvtSelectionHandler
  * @constructor
  */
var  DvtSelectionHandler = function(type) {
  this.Init(type);
};

DvtObj.createSubclass(DvtSelectionHandler, DvtObj, "DvtSelectionHandler");

DvtSelectionHandler.TYPE_SINGLE   = "s";
DvtSelectionHandler.TYPE_MULTIPLE = "m";

DvtSelectionHandler.prototype.Init = function(type) {
  this._selection = [];
  this._type = type ? type : DvtSelectionHandler.TYPE_SINGLE;
  
  // Some selected id may not correspond to a drawn target because it's outside the viewport.
  this._hiddenSelectedIds = [];
} ;

DvtSelectionHandler.prototype.getType = function() {
  return this._type;
};

/**
 * Returns the number of currently selected objects.
 * @return {number}
 */
DvtSelectionHandler.prototype.getSelectedCount = function() {
  return this._selection.length;
};

/**
 * Returns the current selection.
 * @return {array} The current selection.
 */
DvtSelectionHandler.prototype.getSelection = function() {
  return this._selection.slice(0);
}

/**
 * Returns the ids for the currently selected objects. Includes the ids of the hidden selected objects.
 * @return {array} The ids for the currently selected objects.
 */
DvtSelectionHandler.prototype.getSelectedIds = function() {
  var selectedIds = [];
  for(var i=0; i<this._selection.length; i++) {
    selectedIds.push(this._selection[i].getId());
  }
  return selectedIds.concat(this._hiddenSelectedIds);
}

/**
 * Processes the initially selected objects, updating the state of this handler.
 * @param {array} selectedIds The array of ids for the selected objects.
 * @param {array} targets The array of selectable objects.
 */
DvtSelectionHandler.prototype.processInitialSelections = function(selectedIds, targets) {
  // Clear current selection state
  this.clearSelection();

  // If nothing selected, we are done
  if(!selectedIds || !targets)
    return;
    
  // Loop through all the selected ids, matching them to the targets  
  for(var i=0; i<selectedIds.length; i++) {
    var hidden = true;
    for(var j=0; j<targets.length; j++) {
      var targetId = targets[j].getId();
      if(targetId != null && DvtSelectionHandler._isEquals(selectedIds[i], targetId) && targets[j].isSelectable && targets[j].isSelectable()) {
        // Found a match, continue to next selected id
        this._addToSelection(targets[j], true);
        hidden = false;
        break;
      }
    }
    if (hidden)
      this._hiddenSelectedIds.push(selectedIds[i]);
  }
}

/**
 * Processes a click event.
 * @param {DvtSelectable} target
 * @param {boolean} addToExisting true if a key indicating multi-select should be performed was pressed during the click.
 * @return {boolean} true if the selection has changed.
 */
DvtSelectionHandler.prototype.processClick = function(target, addToExisting) {
  //BUG FIX 13381888: if this click is unrelated to selection, then
  //don't change selection at all
  if (target && target.isUnrelatedToSelection && target.isUnrelatedToSelection()) {
    return false;
  }
  
  // Check whether we are in multi-select mode
  var bMulti = (addToExisting && this._type == DvtSelectionHandler.TYPE_MULTIPLE);
  
  //*************************************************
  // Possible cases:
  // 1. Multi-select of selectable target
  // 2. Multi-select of non-selectable target (noop)
  // 3. Single select of selectable target
  // 4. Single select of non-selectable target
  //*************************************************
  
  var bChanged = false; // Keep track of whether the selection is changed
  if(bMulti) 
  {
    if(target && target.isSelectable && target.isSelectable()) {
      // 1. Multi-select of selectable target
      if(target.isSelected()) {
        bChanged = this.removeFromSelection(target);
      }
      else {
        bChanged = this._addToSelection(target, true);
      }
    }
    // Otherwise 2. Multi-select of non-selectable target (noop)
  }
  else // Single Select
  {
    if(target && target.isSelectable && target.isSelectable()) {
      // 3. Single select of selectable target
      bChanged = this._addToSelection(target, false);
    }
    else {
      // 4. Single select of non-selectable target
      bChanged = this.clearSelection();
    }
  }
  
  // Return whether the selection has changed.
  return bChanged;
};

/**
 * Processes selection event involving a group of target items.
 * @param {array} targets Array of DvtSelectable objects
 * @param {boolean} addToExisting true if a key indicating multi-select should be performed was pressed during the click.
 */
DvtSelectionHandler.prototype.processGroupSelection = function(targets, addToExisting) {
  if (!addToExisting)
    this.clearSelection();
  
  var target;
  for (var i = 0; i < targets.length; i++) {
    target = targets[i];
    
    //BUG FIX 13381888: if this click is unrelated to selection, then
    //don't change selection at all
    if (target && target.isUnrelatedToSelection && target.isUnrelatedToSelection()) {
      continue;
    }
    
    this._addToSelection(target, true);
  }
};

/**
 * Processes a mouseOver event.
 * @param {DvtSelectable} target
 */
DvtSelectionHandler.prototype.processMouseOver = function(target) {
  if(target && target.isSelectable && target.isSelectable() && target.showHoverEffect) {
    target.showHoverEffect();
  }
};

/**
 * Processes a mouseOut event.
 * @param {DvtSelectable} target
 */
DvtSelectionHandler.prototype.processMouseOut = function(target) {
  if(target && target.isSelectable && target.isSelectable() && target.hideHoverEffect) {
    target.hideHoverEffect();
  }
};

/**
 * Selects a single object.
 * @param {DvtSelectable} target the object to select
 * @param {boolean} bAddToExisting true if the object should be added to the current selection.
 * @return {boolean} true if the selection has changed.
 */
DvtSelectionHandler.prototype._addToSelection = function(target, bAddToExisting) {
  // If already selected, return.  This intentionally ignores bAddToExisting.
  if(target.isSelected()) {
    return false;
  }
  
  // If not adding to the current selection, deselect all
  if(!bAddToExisting) {
    this.clearSelection();
  }
  
  // Finally, select the object
  target.setSelected(true);
  this._selection.push(target);
  return true;
};

/**
 * Deselects a single object in the selection.
 * @param {DvtSelectable} target the object to deselect
 * @return {boolean} true if the selection has changed.
 */
DvtSelectionHandler.prototype.removeFromSelection = function(target) {
  if(!target.isSelected())
    return false;

  // First deselect the object, then remove it from the selected array
  target.setSelected(false);
  for(var i = 0; i < this._selection.length; i++) {
    if(this._selection[i] == target) {
      this._selection.splice(i, 1);
      break; 
    }
  }
  return true;
};

/**
 * Clears the current selection.
 * @return {boolean} true if the selection has changed.
 */
DvtSelectionHandler.prototype.clearSelection = function() {
  if(this._selection.length <= 0 && this._hiddenSelectedIds.length <= 0)
    return false;

  while(this._selection.length > 0) {
    var obj = this._selection.pop();
    obj.setSelected(false);
  }
  this._hiddenSelectedIds.length = 0;
  return true;
};

/**
 * Utility function used to determine if two id objects are equal.
 * @param {object} a
 * @param {object} b
 * @private
 * @return {boolean}
 */
DvtSelectionHandler._isEquals = function(a, b) {
  if(a == b)
    return true;
  else if (a instanceof String)       // Flash doesn't have a String.equals()
    return false ;
  else if(a && a.equals)
    return a.equals(b);
  else
    return false;
}
/**
  * Interactivity manager for keyboard events.
  * @param {DvtEventManager} manager The owning DvtEventManager
  * @class DvtKeyboardHandler
  * @constructor
  */
var  DvtKeyboardHandler = function(manager) 
{ 
  this.Init(manager);
};

DvtObj.createSubclass(DvtKeyboardHandler, DvtObj, "DvtKeyboardHandler");

// Constants used for calculating penalties when calculating distances between two DvtKeyboardNavigables
// in DvtKeyboardHandler._calcDistanceAngleWeighted
DvtKeyboardHandler._OPTIMAL_ANGLE1 = 15/180*Math.PI;
DvtKeyboardHandler._OPTIMAL_ANGLE2 = 40/180*Math.PI;
DvtKeyboardHandler._SUBOPTIMAL_ANGLE_PENALTY1 = 2; // multiplier to the distance
DvtKeyboardHandler._SUBOPTIMAL_ANGLE_PENALTY2 = 6; // multiplier to the distance

DvtKeyboardHandler.prototype.Init = function(manager)
{
  this._eventManager = manager;
}


/**
 * Processes key down events.
 * @param {DvtKeyboardEvent} event
 * @return {DvtKeyboardNavigable} The object that has keyboard focus as a result of the keyboard event. Null if the event
 *                                does not affect which DvtKeyboardNavigable has focus.
 */
DvtKeyboardHandler.prototype.processKeyDown = function(event) 
{ 
  var currentNavigable = this._eventManager.getFocus();
  
  if(currentNavigable && (this.isNavigationEvent(event) || this.isMultiSelectEvent(event)))
  {
    event.preventDefault();
    var next = currentNavigable.getNextNavigable(event);
    this._eventManager.setFocus(next);
    return next;
  }

  return null;
} ;


/**
 * Simple implementation to return a navigable item based on direction and bounding box of current focused item
 * @param {DvtKeyboardNavigable} currentNavigable The DvtKeyboardNavigable item with current focus
 * @param {DvtKeyboardEvent} event
 * @param {Array} navigableItems An array of items that could receive focus next
 */
DvtKeyboardHandler.getNextNavigable = function(currentNavigable, event, navigableItems) 
{
  var nextNavigable = null;
  var nextNavigableDelta = 0;
  var delta = 0;
  
  var direction = event.keyCode;

  if(!currentNavigable)
  {
    if(!navigableItems || navigableItems.length < 1)
      return null;
    else
      return navigableItems[0];
  }
    
  // get the bounds of the current navigable
  var currentBounds = currentNavigable.getKeyboardBoundingBox();
  var candidateBounds;

  for(var i=0; i < navigableItems.length; i++)
  {
    var navigable = navigableItems[i];
    
    if(currentNavigable === navigable)  
      continue;

    candidateBounds = navigable.getKeyboardBoundingBox();  

    if(DvtKeyboardHandler._isInBounds(currentBounds, candidateBounds, direction))
    {
      delta = DvtKeyboardHandler._computeDelta(currentBounds, candidateBounds, direction);

      if( (((direction == DvtKeyboardEvent.UP_ARROW) || (direction == DvtKeyboardEvent.LEFT_ARROW)) && (delta < 0) && (!nextNavigable || (delta > nextNavigableDelta))) ||
          (((direction == DvtKeyboardEvent.DOWN_ARROW) || (direction == DvtKeyboardEvent.RIGHT_ARROW)) && (delta > 0) && (!nextNavigable || (delta < nextNavigableDelta)))
        )
      {
        nextNavigable = navigable;
        nextNavigableDelta = delta;
      }
    }  
  }
  
  return nextNavigable ? nextNavigable : currentNavigable;
}

 
/**
 * Returns a default keyboard navigable by selecting the upper left or lower right-most item in the navigableItems
 * array.  Utility method that can be called by classes that implement DvtKeyboardNavigable
 * @param {Array} An array of DvtKeyboardNavigables from which to choose the default one to receive focus
 */
DvtKeyboardHandler.prototype.getDefaultNavigable = function(navigableItems)
{ 
  if(!navigableItems || navigableItems.length <= 0)
    return null;
 
  var defaultNavigable = navigableItems[0];
  var defaultLocation = defaultNavigable.getKeyboardBoundingBox();
  var navigable;
  var navigableLocation;
  
  for(var i=1; i<navigableItems.length; i++)
  {
    navigable = navigableItems[i];
    navigableLocation = navigable.getKeyboardBoundingBox();
    // return the top left-most item in non-bidi and top right-most item in bidi
    if( (((navigableLocation.x == defaultLocation.x && navigableLocation.y < defaultLocation.y) ||
        navigableLocation.x < defaultLocation.x) && !DvtAgent.isRightToLeft(this._eventManager.getCtx())) ||
        (((navigableLocation.x + navigableLocation.w == defaultLocation.x + defaultLocation.w && navigableLocation.y < defaultLocation.y) ||
        navigableLocation.x + navigableLocation.w < defaultLocation.x + defaultLocation.w) && DvtAgent.isRightToLeft(this._eventManager.getCtx())))
    {
      defaultNavigable = navigable;
      defaultLocation = defaultNavigable.getKeyboardBoundingBox();
    } 
  }
  
  return defaultNavigable;
} 


/**
 * Returns true if the event requires us to update the DvtKeyboardNavigable with keyboard focus.  In the base 
 * implementation, we return true if the given event is an arrow keystroke. 
 * @param {DvtKeybaordEvent} event
 * @return {Boolean}
 */
DvtKeyboardHandler.prototype.isNavigationEvent = function(event)
{
  var keyCode = event.keyCode;

  switch(keyCode)
  {
    case DvtKeyboardEvent.UP_ARROW:
    case DvtKeyboardEvent.DOWN_ARROW:
    case DvtKeyboardEvent.LEFT_ARROW:
    case DvtKeyboardEvent.RIGHT_ARROW:
      return true;
    default:
      break;
  }
  return false;
}


/**
 * Returns true if the event requires us to perform a single select
 * @param {DvtKeyboardEvent} event
 * @return {Boolean}
 */
DvtKeyboardHandler.prototype.isSelectionEvent = function(event)
{
  return false; // subclasses should override
}

/**
 * Returns true if the event requires us to perform a multi select
 * @param {DvtKeybaordEvent} event
 * @return {Boolean}
 */ 
DvtKeyboardHandler.prototype.isMultiSelectEvent = function(event)
{
  return false; // subclasses should override
}

/**
 * Returns true if the keyboard event is the standard keystroke for opening context menus
 * (Ctrl + Alt + M)
 * @param {DvtKeyboardEvent} event
 * @return {Boolean} true if the event is Ctrl+Alt+M, false otherwise
 */
DvtKeyboardHandler.prototype.isContextMenuEvent = function(event)
{
  return  event.keyCode == DvtKeyboardEvent.M &&
          event.altKey && event.ctrlKey;
};


/**
 * Determines if the candidate bounds line up with the current bounds in the given direction
 * For example, if the direction is up, then the candidate's x-bounds should overlap with the 
 * current's x-bounds
 * 
 * @param {DvtRectangle} currentBounds
 * @param {DvtRectangle} candidateBounds
 * @param {Number} direction  One of DvtKeyboardEvent.UP_ARROW, DvtKeyboardEvent.DOWN_ARROW, 
 *                            DvtKeyboardEvent.LEFT_ARROW, or DvtKeyboardEvent.RIGHT_ARROW
 * @return {Boolean} True if the candidate bounds line up with the current bounds, in the given direction
 * @private
 */
DvtKeyboardHandler._isInBounds = function(currentBounds, candidateBounds, direction) 
{
  if(direction == DvtKeyboardEvent.UP_ARROW || direction == DvtKeyboardEvent.DOWN_ARROW)
  {
    // if up/down, check that the current x-bounds overlap with the candidate's x-bounds.
    // by making sure that the left edge of the current is not to the right of the candidate
    // and that the right edge of the current is not to the left of the candidate
    
    var currentX1 = currentBounds.x;
    var currentX2 = currentX1 + currentBounds.w;
    var candidateX1 = candidateBounds.x;
    var candidateX2 = candidateX1 + candidateBounds.w;
    
    return !((currentX1 >= candidateX2) || (currentX2 <= candidateX1));
  }
  else if(direction == DvtKeyboardEvent.LEFT_ARROW || direction == DvtKeyboardEvent.RIGHT_ARROW)
  {
    // if left/right, check that the current y-bounds overlap with the candidate's y-bounds.
    // by making sure that the top edge of the current is not below the candidate
    // and that the bottom edge of the current is not above the candidate
    
    var currentY1 = currentBounds.y;
    var currentY2 = currentY1 + currentBounds.h;
    var candidateY1 = candidateBounds.y;
    var candidateY2 = candidateY1 + candidateBounds.h;
    
    return !((currentY1 >= candidateY2) || (currentY2 <= candidateY1));    
  }
}


/**
 * Determines the diffeerence between the centers of the currentBounds and the candidatBounds,
 * in the given direction.  The difference is negative if the candidate is above or to the left
 * of the current, positive if the candidate is below or to the right
 * 
 * @param {DvtRectangle} currentBounds
 * @param {DvtRectangle} candidateBounds
 * @param {Number} direction  One of DvtKeyboardEvent.UP_ARROW, DvtKeyboardEvent.DOWN_ARROW, 
 *                            DvtKeyboardEvent.LEFT_ARROW, or DvtKeyboardEvent.RIGHT_ARROW
 * @return {Number} The difference between the centers of the currentBounds and candidateBounds, in
 *                  the given direction
 * @private                          
 */

DvtKeyboardHandler._computeDelta = function(currentBounds, candidateBounds, direction)
{
  var delta = 0;
  var currentX = currentBounds.getCenter().x;
  var currentY = currentBounds.getCenter().y;
  var candidateX = candidateBounds.getCenter().x;
  var candidateY = candidateBounds.getCenter().y;
  
  if((direction == DvtKeyboardEvent.UP_ARROW) || (direction == DvtKeyboardEvent.DOWN_ARROW))
    delta = candidateY - currentY;
  else if((direction == DvtKeyboardEvent.LEFT_ARROW) || (direction == DvtKeyboardEvent.RIGHT_ARROW))
    delta = candidateX - currentX;
    
  return delta;
}



/**
 * Returns the next navigable based on the arrow key that was pressed. This method will return the next navigable that
 * is adjacent to the current navigable, in the direction of the arrow key. If there are no adjacent navigables, the
 * closest navigable in the direction of the arrow key is returned.  Distance to the nearest navigable is based on
 * straight line distance between the midpoints of the navigables' keyboard bounding box, multiplied by a penalty
 * factor if the midpoints are too far off the vertical (in the case of up and down) or horizontal (for left and right)
 * 
 * @param {DvtKeyboardNavigable} current
 * @param {DvtKeyboardEvent} event
 * @param {Array} listOfObjects Array of DvtKeyboardNavigable objects
 * @return {DvtKeyboardNavigable}
 */
DvtKeyboardHandler.getNextAdjacentNavigable = function(current, event, listOfObjects)
{
  var keycode = event.keyCode;
  
  if (!listOfObjects)
    return null;			
			
  if (!current)
    return listOfObjects[0];
			
  var nextObject = current; //init to current object
  var nextDistance = Number.MAX_VALUE;
			
  // If an object is in contact it overrules all other attributes
  // Only another in contact object with better attributes will have higher precedence
  var nextInContact = false; 

  for(var i=0; i<listOfObjects.length; i++)
  {
    var object = listOfObjects[i];
    			
    if (object === current)
      continue;
            				
    if (!DvtKeyboardHandler._isValidDestination(object, current, keycode))
      continue;

    var inContact = DvtKeyboardHandler._calcInContact(object, current, keycode);
    
    if (nextInContact && !inContact)
      continue;

    var distance = DvtKeyboardHandler._calcDistanceAngleWeighted(object, current, keycode);
    // Make sure incontact flag have highest precedence
    if( (!nextInContact && inContact) ||
        (distance < nextDistance && ((nextInContact && inContact) || !nextInContact)) ) 
    {
      nextDistance = distance;
      nextObject = object;
      nextInContact = inContact;
    }
  }
  return nextObject;
}	



/**
 * Determine if two objects are in contact in the specified direction 
 * 
 * @param {DvtKeyboardNavigable} object
 * @param {DvtKeyboardNavigable} current
 * @param {Number} keycode
 * @return {Boolean}
 * @private
 */
DvtKeyboardHandler._calcInContact = function(object, current, keycode)
{
  var objRect = object.getKeyboardBoundingBox();
  var curRect = current.getKeyboardBoundingBox();

  switch (keycode) 
  {
    case DvtKeyboardEvent.UP_ARROW: 
      return  DvtKeyboardHandler._isVerticallyAligned(objRect, curRect) && 
              (curRect.y <= (objRect.y+objRect.h) || DvtKeyboardHandler._areEqualWithinTolerance(curRect.y, objRect.y+objRect.h));  
    case DvtKeyboardEvent.DOWN_ARROW: 
      return  DvtKeyboardHandler._isVerticallyAligned(objRect, curRect) && 
              (objRect.y <= (curRect.y+curRect.h) || DvtKeyboardHandler._areEqualWithinTolerance(objRect.y, curRect.y+curRect.h));
    case DvtKeyboardEvent.RIGHT_ARROW: 
      return  DvtKeyboardHandler._isHorizontallyAligned(objRect, curRect) && 
              (objRect.x <= (curRect.x+curRect.w) || DvtKeyboardHandler._areEqualWithinTolerance(objRect.x, curRect.x+curRect.w));
    case DvtKeyboardEvent.LEFT_ARROW: 
      return  DvtKeyboardHandler._isHorizontallyAligned(objRect, curRect) && 
              (curRect.x <= (objRect.x+objRect.w) || DvtKeyboardHandler._areEqualWithinTolerance(curRect.x, objRect.x+objRect.w));
    default:
      break;
  }
            
  return false;
}

/**
 * Returns true if the two input rectangles are lined up vertically
 * 
 * @param {DvtRectangle} rect1
 * @param {DvtRectangle} rect2
 * @return {Boolean}
 * @private
 */
DvtKeyboardHandler._isVerticallyAligned = function(rect1, rect2)
{
  return ((rect1.x >= rect2.x && rect1.x <= (rect2.x+rect2.w)) ||
          (rect2.x >= rect1.x && rect2.x <= (rect1.x+rect1.w)));
}

/**
 * Returns true if the two input rectangles are lined up horizontally
 * 
 * @param {DvtRectangle} rect1
 * @param {DvtRectangle} rect2
 * @return {Boolean}
 * @private
 */
DvtKeyboardHandler._isHorizontallyAligned = function(rect1, rect2)
{
  return ((rect1.y >= rect2.y && rect1.y <= (rect2.y+rect2.h)) ||
          (rect2.y >= rect1.y && rect2.y <= (rect1.y+rect1.h)));
}



/**
 * Returns the distance between the centers of the keyboard bounding boxes of the input DvtKeyboardNavigables.
 * Distance is multiplied by a penalty factor if the centers are too far off the vertical (in the case of up and down) 
 * or horizontal (for left and right)
 * 
 * @param {DvtKeyboardNavigable} object
 * @param {DvtKeyboardNavigable} current
 * @param {Number} keycode
 * @return {Number} 
 * @private
 */
DvtKeyboardHandler._calcDistanceAngleWeighted = function(object, current, keycode)
{
  var objectBB = object.getKeyboardBoundingBox();
  var objCenterX = objectBB.x + objectBB.w/2;
  var objCenterY = objectBB.y + objectBB.h/2;

  var currentBB = current.getKeyboardBoundingBox();
  var curCenterX = currentBB.x + currentBB.w/2;
  var curCenterY = currentBB.y + currentBB.h/2;

  var x_dist = Math.abs(objCenterX - curCenterX);
  var y_dist = Math.abs(objCenterY - curCenterY);
            
  var angle = Math.atan2(y_dist, x_dist);
            
  var distance = Math.sqrt(x_dist * x_dist + y_dist * y_dist);

  // Angle penalty based on direction   
  if( (angle > DvtKeyboardHandler._OPTIMAL_ANGLE1 && (keycode == DvtKeyboardEvent.RIGHT_ARROW || keycode == DvtKeyboardEvent.LEFT_ARROW)) ||
      (angle < DvtMath.HALF_PI - DvtKeyboardHandler._OPTIMAL_ANGLE1 && (keycode == DvtKeyboardEvent.UP_ARROW || keycode == DvtKeyboardEvent.DOWN_ARROW)) ) 
  {
    if( (angle > DvtKeyboardHandler._OPTIMAL_ANGLE2 && (keycode == DvtKeyboardEvent.RIGHT_ARROW || keycode == DvtKeyboardEvent.LEFT_ARROW)) ||
        (angle < DvtMath.HALF_PI - DvtKeyboardHandler._OPTIMAL_ANGLE2 && (keycode == DvtKeyboardEvent.UP_ARROW || keycode == DvtKeyboardEvent.DOWN_ARROW)) ) 
    {
      distance *= DvtKeyboardHandler._SUBOPTIMAL_ANGLE_PENALTY2;
    }
    else 
    {
      distance *= DvtKeyboardHandler._SUBOPTIMAL_ANGLE_PENALTY1;
    }
  }
                
  return distance;
}


/**
  * Determine if a point is valid based on the direction
  * @param {DvtKeyboardNavigable} object
  * @param {DvtKeyboardNavigable} current
  * @param {Number} keycode
  * @return {Boolean}
  * @private
  */
DvtKeyboardHandler._isValidDestination = function(object, current, keycode)
{
  var objBB = object.getKeyboardBoundingBox();
  var curBB = current.getKeyboardBoundingBox();
  
  switch (keycode) 
  {
    case DvtKeyboardEvent.UP_ARROW: 
      return (objBB.y<curBB.y) || DvtKeyboardHandler._areEqualWithinTolerance(objBB.y, curBB.y);
    case DvtKeyboardEvent.DOWN_ARROW: 
      return objBB.y>curBB.y || DvtKeyboardHandler._areEqualWithinTolerance(objBB.y, curBB.y);
    case DvtKeyboardEvent.RIGHT_ARROW: 
      return objBB.x>curBB.x || DvtKeyboardHandler._areEqualWithinTolerance(objBB.x, curBB.x);
    case DvtKeyboardEvent.LEFT_ARROW: 
      return objBB.x<curBB.x || DvtKeyboardHandler._areEqualWithinTolerance(objBB.x, curBB.x);
    default:
      break;
  }
  return true;
}

/**
 * Utility method to check if two numbers are equal, within a small tolerance. Used to account for small rounding
 * errors
 * 
 * @param {Number} a
 * @param {Number} b
 * @return {Boolean} true if the numbers are within 0.0000001 of each other
 * @private
 */
DvtKeyboardHandler._areEqualWithinTolerance = function(a,b)
{
  return Math.abs(a-b) <= 0.0000001;
}

/**
 * Handler used for marquee operations.
 * @constructor
 * @param {DvtContainer} container Marquee container.
 * @param {DvtRectangle} marqueeBounds The area in which the marquee can be initiated and drawn.
 * @param {DvtRectangle} glassPaneBounds The area that will be covered by the glass pane when the marquee is active.
 * @param {DvtFill} fill The marquee rect fill
 * @param {DvtStroke} stroke The marquee rect stroke
 * @param {boolean} [allowHorizResize] Whether horizontal resize is allowed. Defaults to true.
 * @param {boolean} [allowVertResize] Whether vertical resize is allowed. Defaults to true.
 * @param {DvtRectangle} [horizResizeBounds] The bounds for initiating a marquee that only resizes horizontally.
 * @param {DvtRectangle} [vertResizeBounds] The bounds for initiating a marquee that only resizes vertically.
 */
var DvtMarqueeHandler = function(container, marqueeBounds, glassPaneBounds, fill, stroke, 
    allowHorizResize, allowVertResize, horizResizeBounds, vertResizeBounds) {
  this.Init(container, marqueeBounds, glassPaneBounds, fill, stroke, allowHorizResize, allowVertResize, 
      horizResizeBounds, vertResizeBounds);
}  


DvtObj.createSubclass(DvtMarqueeHandler, DvtObj, "DvtMarqueeHandler");


/**
 * @param {DvtContainer} container Marquee container.
 * @param {DvtRectangle} marqueeBounds The area in which the marquee can be initiated and drawn.
 * @param {DvtRectangle} glassPaneBounds The area that will be covered by the glass pane when the marquee is active.
 * @param {DvtFill} fill The marquee rect fill
 * @param {DvtStroke} stroke The marquee rect stroke
 * @param {boolean} [allowHorizResize] Whether horizontal resize is allowed. Defaults to true.
 * @param {boolean} [allowVertResize] Whether vertical resize is allowed. Defaults to true.
 * @param {DvtRectangle} [horizResizeBounds] The bounds for initiating a marquee that only resizes horizontally.
 * @param {DvtRectangle} [vertResizeBounds] The bounds for initiating a marquee that only resizes vertically.
 */
DvtMarqueeHandler.prototype.Init = function(container, marqueeBounds, glassPaneBounds, fill, stroke, 
    allowHorizResize, allowVertResize, horizResizeBounds, vertResizeBounds) {
  this._context = container.getCtx();
  this._container = container;
  this._bounds = marqueeBounds;
  this._fill = fill;
  this._stroke = stroke;  
  this._allowHoriz = allowHorizResize == null ? true : allowHorizResize;
  this._allowVert = allowVertResize == null ? true : allowVertResize;
  this._horizBounds = horizResizeBounds;
  this._vertBounds = vertResizeBounds;
  
  // Set up the glass pane
  this._glassPane = new DvtRect(this._context, glassPaneBounds.x, glassPaneBounds.y, glassPaneBounds.w, glassPaneBounds.h);
  this._glassPane.setInvisibleFill();
  
  // Flags
  this._marqueeOn = false;     // whether the marquee has been activated
  this._marqueeDrawn = false;  // whether the marquee has been drawn
  this._resizeHoriz = false;   // whether the marquee is resizeable horizontally
  this._resizeVert = false;    // whether the marquee is resizeable vertically
}


/**
 * Processes drag start.
 * @param {DvtPoint} relPos The event position relative to the stage.
 * @param {boolean} ctrlKey Whether the ctrl key is pressed during the event.
 * @return {DvtMarqueeEvent}
 */
DvtMarqueeHandler.prototype.processDragStart = function(relPos, ctrlKey) {
  if (!this._marqueeOn) {
    this._origPt = this._container.stageToLocal(relPos); // marquee origin
    
    // Determine if the marquee is resizeable horizontally and/or vertically:
    // - if origin is inside marqueeBounds, then allow resize in both directions if possible;
    // - if origin is inside vertResizeBounds, then only vert resize is possible;
    // - if origin is inside horizResizeBounds, then only horiz resize is possible;
    // - otherwise, marquee shouldn't be initiated.
    this._resizeHoriz = this._allowHoriz;
    this._resizeVert = this._allowVert;
    if (!this._bounds.containsPoint(this._origPt.x, this._origPt.y)) {
      if (this._vertBounds && this._vertBounds.containsPoint(this._origPt.x, this._origPt.y))
        this._resizeHoriz = false;
      else if (this._horizBounds && this._horizBounds.containsPoint(this._origPt.x, this._origPt.y))
        this._resizeVert = false;
      else
        return null;
    }
    
    this._marqueeOn = true;
    this._marquee = null;
    return this._createMarqueeEvent(DvtMarqueeEvent.SUBTYPE_START, ctrlKey);
  }
  
  return null;
}


/**
 * Processes drag move.
 * @param {DvtPoint} relPos The event position relative to the stage.
 * @param {boolean} ctrlKey Whether the ctrl key is pressed during the event.
 * @return {DvtMarqueeEvent}
 */
DvtMarqueeHandler.prototype.processDragMove = function(relPos, ctrlKey) {
  if (!this._marqueeOn)
    return null;
  
  if (!this._marqueeDrawn) {
    this._container.addChild(this._glassPane);
    
    // Initiate the marquee
    this._marquee = new DvtRect(this._context, this._bounds.x, this._bounds.y, this._bounds.w, this._bounds.h);
    if (this._resizeHoriz) {
      this._marquee.setX(this._origPt.x);
      this._marquee.setWidth(0);
    }
    if (this._resizeVert) {
      this._marquee.setY(this._origPt.y);
      this._marquee.setHeight(0);
    }
    
    this._marquee.setStroke(this._stroke);
    this._marquee.setFill(this._fill);
    this._marquee.setPixelHinting(true);
    this._glassPane.addChild(this._marquee);
    
    this._marqueeDrawn = true;
  }
    
  var newPt = this._container.stageToLocal(relPos);
 
  // Bound the newPt within the marquee bounds
  newPt.x = Math.max(newPt.x, this._bounds.x);
  newPt.x = Math.min(newPt.x, this._bounds.x + this._bounds.w);
  newPt.y = Math.max(newPt.y, this._bounds.y);
  newPt.y = Math.min(newPt.y, this._bounds.y + this._bounds.h);
  
  // Update marquee x and w
  if (this._resizeHoriz) {
    this._marquee.setWidth(Math.abs(newPt.x - this._origPt.x));
    if (newPt.x < this._origPt.x)
      this._marquee.setX(newPt.x);
    else
      this._marquee.setX(this._origPt.x);
  }
  
  // Update marquee y and h
  if (this._resizeVert) {
    this._marquee.setHeight(Math.abs(newPt.y - this._origPt.y));
    if (newPt.y < this._origPt.y)
      this._marquee.setY(newPt.y);
    else
      this._marquee.setY(this._origPt.y);
  }
  
  return this._createMarqueeEvent(DvtMarqueeEvent.SUBTYPE_MOVE, ctrlKey);
}


/**
 * Processes drag end.
 * @param {DvtPoint} relPos The event position relative to the stage.
 * @param {boolean} ctrlKey Whether the ctrl key is pressed during the event.
 * @return {DvtMarqueeEvent}
 */
DvtMarqueeHandler.prototype.processDragEnd = function(relPos, ctrlKey) {
  if (this._marqueeOn) {
    this._marqueeOn = false;
    
    if (this._marqueeDrawn) {
      // Remove the marquee and glass pane
      this._glassPane.removeChild(this._marquee);
      this._container.removeChild(this._glassPane);
      this._marqueeDrawn = false;
      
      return this._createMarqueeEvent(DvtMarqueeEvent.SUBTYPE_END, ctrlKey);
    }
  }
  
  return null;
}

/**
 * Processes drag end.
 * @param {DvtPoint} relPos The event position relative to the stage.
 * @param {boolean} ctrlKey Whether the ctrl key is pressed during the event.
 * @return {DvtMarqueeEvent}
 */
DvtMarqueeHandler.prototype.cancelMarquee = function() {
  if (this._marqueeOn) {
    this._marqueeOn = false;
    
    if (this._marqueeDrawn) {
      // Remove the marquee and glass pane
      this._glassPane.removeChild(this._marquee);
      this._container.removeChild(this._glassPane);
      this._marqueeDrawn = false;
      
      return true;
    }
  }
  
  return false;
}


/**
 * Creates a marquee event.
 * @param {string} type Event type.
 * @param {boolean} ctrlKey Whether the ctrl key is pressed during the event.
 * @return {DvtMarqueeEvent} The event.
 */
DvtMarqueeHandler.prototype._createMarqueeEvent = function(type, ctrlKey) {
  var x = null;
  var y = null;
  var w = null;
  var h = null;
  
  if (this._resizeHoriz) {
    x = this._marquee ? this._marquee.getX() : this._origPt.x;
    w = this._marquee ? this._marquee.getWidth() : 0;
  }
  if (this._resizeVert) {
    y = this._marquee ? this._marquee.getY() : this._origPt.y;
    h = this._marquee ? this._marquee.getHeight() : 0;
  }
  
  return new DvtMarqueeEvent(type, x, y, w, h, ctrlKey);
}

/**
 * Returns the appropriate cursor type.
 * @param {DvtPoint} relPos The current cursor position relative to the stage.
 * @return {string} The cursor type.
 */
DvtMarqueeHandler.prototype.getCursor = function(relPos) {
  var pos = this._container.stageToLocal(relPos);
  var withinBounds = this._bounds.containsPoint(pos.x, pos.y);
  var withinVertBounds = this._vertBounds && this._vertBounds.containsPoint(pos.x, pos.y);
  var withinHorizBounds = this._horizBounds && this._horizBounds.containsPoint(pos.x, pos.y);
  
  if (withinBounds || withinVertBounds || withinHorizBounds)
    return "crosshair";
  else
    return "inherit";
}
/**
 * Handler used for pan and zoom operations.
 * @constructor
 * @param {DvtContainer} container Glass pane container.
 * @param {DvtRectangle} panZoomBounds The area in which pan/zoom can be initiated.
 * @param {DvtRectangle} glassPaneBounds The area that will be covered by the glass pane during pan.
 * @param {number} zoomRate The rate of mouse wheel zoom.
 */
var DvtPanZoomHandler = function(container, panZoomBounds, glassPaneBounds, zoomRate) {
  this.Init(container, panZoomBounds, glassPaneBounds, zoomRate);
}  

DvtObj.createSubclass(DvtPanZoomHandler, DvtObj, "DvtPanZoomHandler");


/**
 * @param {DvtContainer} container Glass pane container.
 * @param {DvtRectangle} panZoomBounds The area in which the pan/zoom can be initiated.
 * @param {DvtRectangle} glassPaneBounds The area that will be covered by the glass pane when the marquee is active.
 * @param {number} zoomRate The rate of mouse wheel zoom.
 */
DvtPanZoomHandler.prototype.Init = function(container, panZoomBounds, glassPaneBounds, zoomRate) {
  this._context = container.getCtx();
  this._container = container;
  this._bounds = panZoomBounds;
  this._zoomRate = zoomRate;
  
  // Set up the glass pane
  this._glassPane = new DvtRect(this._context, glassPaneBounds.x, glassPaneBounds.y, glassPaneBounds.w, glassPaneBounds.h);
  this._glassPane.setInvisibleFill();
  
  // Flags
  this._panOn = false;           // whether the pan has been initiated
  this._glassPaneDrawn = false;  // whether the glass pane has been drawn
  this._pinchOn = false;         // whether the pinch has been initiated
}


/**
 * Processes drag start.
 * @param {DvtPoint} relPos The event position relative to the stage.
 * @return {DvtPanZoomEvent}
 */
DvtPanZoomHandler.prototype.processDragStart = function(relPos) {
  if (!this._panOn) {
    this._origPt = this._container.stageToLocal(relPos); // drag origin
    this._lastPt = this._origPt;
    
    // Ignore if the start point is outside the pan/zoom bounds
    if (!this._bounds.containsPoint(this._origPt.x, this._origPt.y))
      return null;
    
    this._panOn = true;
    
    return new DvtPanZoomEvent(DvtPanZoomEvent.SUBTYPE_PAN_START, 0, 0, 0, 0, 0, 0, 0, 0);
  }
  
  return null;
}


/**
 * Processes drag move.
 * @param {DvtPoint} relPos The event position relative to the stage.
 * @return {DvtPanZoomEvent}
 */
DvtPanZoomHandler.prototype.processDragMove = function(relPos) {
  if (!this._panOn)
    return null;
  
  if (!this._glassPaneDrawn) {
    this._container.addChild(this._glassPane);
    this._glassPaneDrawn = true;
  }
    
  var newPt = this._container.stageToLocal(relPos);
  var deltaX = newPt.x - this._lastPt.x;
  var deltaY = newPt.y - this._lastPt.y;
  var totalDeltaX = newPt.x - this._origPt.x;
  var totalDeltaY = newPt.y - this._origPt.y;
  this._lastPt = newPt;
  
  return new DvtPanZoomEvent(DvtPanZoomEvent.SUBTYPE_PAN_MOVE, -deltaX, -deltaX, -deltaY, -deltaY,
      -totalDeltaX, -totalDeltaX, -totalDeltaY, -totalDeltaY);
}


/**
 * Processes drag end.
 * @param {DvtPoint} relPos The event position relative to the stage.
 * @return {DvtPanZoomEvent}
 */
DvtPanZoomHandler.prototype.processDragEnd = function(relPos) {
  if (this._panOn) {
    this._panOn = false;
    
    if (this._glassPaneDrawn) {
      // Remove the glass pane
      this._container.removeChild(this._glassPane);
      this._glassPaneDrawn = false;
      
      var newPt = relPos ? this._container.stageToLocal(relPos) : this._lastPt;
      var deltaX = newPt.x - this._lastPt.x;
      var deltaY = newPt.y - this._lastPt.y;
      var totalDeltaX = newPt.x - this._origPt.x;
      var totalDeltaY = newPt.y - this._origPt.y;
      this._lastPt = null;
  
      return new DvtPanZoomEvent(DvtPanZoomEvent.SUBTYPE_PAN_END, -deltaX, -deltaX, -deltaY, -deltaY,
          -totalDeltaX, -totalDeltaX, -totalDeltaY, -totalDeltaY);
    }
  }
  
  return null;
}

/**
 * Processes mouse wheel.
 * @param {DvtPoint} relPos The event position relative to the stage.
 * @param {number} delta The mouse wheel delta.
 * @return {DvtPanZoomEvent}
 */
DvtPanZoomHandler.prototype.processMouseWheel = function(relPos, delta) {
  // Ignore if the cursor is outside the pan/zoom bounds
  var startPt = this._container.stageToLocal(relPos);
  if (!this._bounds.containsPoint(startPt.x, startPt.y))
    return null;
      
  delta *= this._zoomRate;
  
  // Compute the deltas. It should maintain the cursor pointing at the same item.
  var deltaXMin = delta * (startPt.x - this._bounds.x);
  var deltaXMax = -delta * (this._bounds.x + this._bounds.w - startPt.x);
  var deltaYMin = delta * (startPt.y - this._bounds.y);
  var deltaYMax = -delta * (this._bounds.y + this._bounds.h - startPt.y);
  
  return new DvtPanZoomEvent(DvtPanZoomEvent.SUBTYPE_ZOOM, deltaXMin, deltaXMax, deltaYMin, deltaYMax,
      deltaXMin, deltaXMax, deltaYMin, deltaYMax);
}

/**
 * Processes pinch start.
 * @return {DvtPanZoomEvent}
 */
DvtPanZoomHandler.prototype.processPinchStart = function(relPos1, relPos2) {
  if (!this._pinchOn) {    
    // Save pinch origin
    this._origPt1 = this._container.stageToLocal(relPos1);
    this._origPt2 = this._container.stageToLocal(relPos2);
    this._lastPt1 = this._origPt1;
    this._lastPt2 = this._origPt2;
    
    // Ignore if the start points are outside the pan/zoom bounds
    if (!this._bounds.containsPoint(this._origPt1.x, this._origPt1.y) || !this._bounds.containsPoint(this._origPt2.x, this._origPt2.y))
      return null;
    
    this._pinchOn = true;
    
    return new DvtPanZoomEvent(DvtPanZoomEvent.SUBTYPE_PINCH_START, 0, 0, 0, 0, 0, 0, 0, 0);
  }
  
  return null;
}


/**
 * Processes pinch move.
 * @param {number} cx The x location of the center of the two fingers.
 * @param {number} cy The y location of the center of the two fingers.
 * @param {number} dcx How much the center of the two fingers moved in the x direction.
 * @param {number} dcy How much the center of the two fingers moved in the y direction.
 * @param {number} rx The ratio of the current intra-finger x distance to previous distance.
 * @param {number} ry The ratio of the current intra-finger y distance to previous distance.
 * @return {DvtPanZoomEvent}
 */
DvtPanZoomHandler.prototype.processPinchMove = function(relPos1, relPos2) {
  if (!this._pinchOn)
    return null;
  
  var newPt1 = this._container.stageToLocal(relPos1);
  var newPt2 = this._container.stageToLocal(relPos2);
  
  var deltas = this._computePinchDeltas(newPt1, newPt2, this._lastPt1, this._lastPt2);
  var totalDeltas = this._computePinchDeltas(newPt1, newPt2, this._origPt1, this._origPt2);
  
  this._lastPt1 = newPt1;
  this._lastPt2 = newPt2;

  return new DvtPanZoomEvent(DvtPanZoomEvent.SUBTYPE_PINCH_MOVE, deltas.dxMin, deltas.dxMax, deltas.dyMin, deltas.dyMax, 
      totalDeltas.dxMin, totalDeltas.dxMax, totalDeltas.dyMin, totalDeltas.dyMax);
}


/**
 * Processes pinch end.
 * @return {DvtPanZoomEvent}
 */
DvtPanZoomHandler.prototype.processPinchEnd = function() {
  if (this._pinchOn) {
    this._pinchOn = false;
    var totalDeltas = this._computePinchDeltas(this._lastPt1, this._lastPt2, this._origPt1, this._origPt2);    
    
    this._lastPt1 = null;
    this._lastPt2 = null;
    
    return new DvtPanZoomEvent(DvtPanZoomEvent.SUBTYPE_PINCH_END, 0, 0, 0, 0, 
        totalDeltas.dxMin, totalDeltas.dxMax, totalDeltas.dyMin, totalDeltas.dyMax);
  }
  
  return null;
}

/**
 * Computes how much the bounds should change based on the two finger movements.
 * @param {DvtPoint} pos1 Current position of the first finger.
 * @param {DvtPoint} pos2 Current position of the second finger.
 * @param {DvtPoint} prevPos1 Previous position of the first finger.
 * @param {DvtPoint} prevPos2 Previous position of the second finger.
 * @return {object} An object containing deltas for the bounds: dxMin, dxMax, dyMin, and dyMax.
 */
DvtPanZoomHandler.prototype._computePinchDeltas = function(pos1, pos2, prevPos1, prevPos2) {
  // Calculate the ratio of the current inter-finger distance to the previous
  var dx = Math.abs(pos1.x - pos2.x);
  var dy = Math.abs(pos1.y - pos2.y);
  var prevDx = Math.abs(prevPos1.x - prevPos2.x);
  var prevDy = Math.abs(prevPos1.y - prevPos2.y);
  // The check dx > dy/2 is to make it easier to zoom in y-direction alone. Otherwise, one might pinch in y-direction,
  // but the slight finger movement in the x-direction will cause the x-axis to zoom as well.
  var zoomX = dx > dy/2 ? prevDx/dx : 1;
  var zoomY = dy > dx/2 ? prevDy/dy : 1;
  
  // Calculate the distance the center of the two fingers has moved
  var cx = (pos1.x + pos2.x) / 2;
  var cy = (pos1.y + pos2.y) / 2;
  var prevCx = (prevPos1.x + prevPos2.x) / 2;
  var prevCy = (prevPos1.y + prevPos2.y) / 2;
  var dcx = cx - prevCx;
  var dcy = cy - prevCy;
    
  // Perform a zoom
  var dxMin = (1-zoomX) * (cx - this._bounds.x);
  var dxMax = (zoomX-1) * (this._bounds.x + this._bounds.w - cx);
  var dyMin = (1-zoomY) * (cy - this._bounds.y);
  var dyMax = (zoomY-1) * (this._bounds.y + this._bounds.h - cy);
  
  // Perform a scroll
  dxMin -= dcx;
  dxMax -= dcx;
  dyMin -= dcy;
  dyMax -= dcy;
  
  return {dxMin: dxMin, dxMax: dxMax, dyMin: dyMin, dyMax: dyMax};
}

/**
 * Sets the pan cursor.
 * @param {string} panUpCursor The URI of the cursor image for the non-dragged state.
 * @param {string} panDownCursor The URI of the cursor image for the dragged state. 
 */
DvtPanZoomHandler.prototype.setPanCursor = function(panUpCursor, panDownCursor) {
  // IE doesn't support cursor image with custom positioning
  if (DvtAgent.isPlatformIE())
    return;
    
  if (panUpCursor)
    this._panUpCursor = "url(" + panUpCursor + ") 8 8, auto";
  if (panDownCursor)
    this._panDownCursor = "url(" + panDownCursor + ") 8 8, auto";
}

/**
 * Returns the appropriate cursor type.
 * @param {DvtPoint} [relPos] The current cursor position relative to the stage.
 * @return {string} The cursor type.
 */
DvtPanZoomHandler.prototype.getCursor = function(relPos) {
  var withinBounds = true;
  if (relPos) {
    var pos = this._container.stageToLocal(relPos);
    withinBounds = this._bounds.containsPoint(pos.x, pos.y);
  }
  
  if (withinBounds) {
    if (this._panOn)
      return this._panDownCursor ? this._panDownCursor : "move";
    else
      return this._panUpCursor ? this._panUpCursor: "move";
  }
  else
    return "inherit";
}
/**
 * Animation handler for black box animations.
 * @class DvtBlackBoxAnimationHandler
 */
var DvtBlackBoxAnimationHandler = function() {};

DvtObj.createSubclass(DvtBlackBoxAnimationHandler, DvtObj, "DvtBlackBoxAnimationHandler");

// Black Box Animation Types
DvtBlackBoxAnimationHandler.ALPHA_FADE            = "alphaFade";   
DvtBlackBoxAnimationHandler.CONVEYOR_FROM_RIGHT   = "conveyorFromRight";   
DvtBlackBoxAnimationHandler.CONVEYOR_FROM_LEFT    = "conveyorFromLeft";
DvtBlackBoxAnimationHandler.CUBE_TO_RIGHT         = "cubeToRight";
DvtBlackBoxAnimationHandler.CUBE_TO_LEFT          = "cubeToLeft";
DvtBlackBoxAnimationHandler.FLIP_RIGHT            = "flipRight";
DvtBlackBoxAnimationHandler.FLIP_LEFT             = "flipLeft";   
DvtBlackBoxAnimationHandler.TRANSITION_TO_RIGHT   = "transitionToRight";
DvtBlackBoxAnimationHandler.TRANSITION_TO_LEFT    = "transitionToLeft"; 
DvtBlackBoxAnimationHandler.SLIDE_TO_RIGHT        = "slideToRight";
DvtBlackBoxAnimationHandler.SLIDE_TO_LEFT         = "slideToLeft"; 
DvtBlackBoxAnimationHandler.ZOOM                  = "zoom";

/**
 * Returns true if the specified animation type should be handled by a black box animation.
 * @param {string} type The animation type.
 * @return {boolean}
 */
DvtBlackBoxAnimationHandler.isSupported = function(type) {
  return (type == DvtBlackBoxAnimationHandler.ALPHA_FADE || 
          type == DvtBlackBoxAnimationHandler.CONVEYOR_FROM_RIGHT || 
          type == DvtBlackBoxAnimationHandler.CONVEYOR_FROM_LEFT || 
          type == DvtBlackBoxAnimationHandler.CUBE_TO_RIGHT || 
          type == DvtBlackBoxAnimationHandler.CUBE_TO_LEFT || 
          type == DvtBlackBoxAnimationHandler.FLIP_RIGHT || 
          type == DvtBlackBoxAnimationHandler.FLIP_LEFT || 
          type == DvtBlackBoxAnimationHandler.TRANSITION_TO_RIGHT || 
          type == DvtBlackBoxAnimationHandler.TRANSITION_TO_LEFT || 
          type == DvtBlackBoxAnimationHandler.SLIDE_TO_RIGHT || 
          type == DvtBlackBoxAnimationHandler.SLIDE_TO_LEFT || 
          type == DvtBlackBoxAnimationHandler.ZOOM);
}

/**
 * Creates and returns the specified black box animation for the displayables.
 * @param {DvtContext} context The platform specific context object.
 * @param {string} type The animation type.
 * @param {object} objs The displayable or array of displayables.
 * @param {DvtRectangle} bounds The bounds of the objects to animate.
 * @param {number} duration The duration of the animation
 * @return {DvtPlayable} The animation from the old object to the new object.
 */
DvtBlackBoxAnimationHandler.getInAnimation = function(context, type, objs, bounds, duration) {
  if(type == DvtBlackBoxAnimationHandler.ALPHA_FADE) 
    return new DvtAnimFadeIn(context, objs, duration);
  else if(type == DvtBlackBoxAnimationHandler.CONVEYOR_FROM_RIGHT)
    return new DvtAnimConveyorIn(context, objs, DvtBaseAnimation.DIR_E, duration); 
  else if(type == DvtBlackBoxAnimationHandler.CONVEYOR_FROM_LEFT)
    return new DvtAnimConveyorIn(context, objs, DvtBaseAnimation.DIR_W, duration); 
  else if(type == DvtBlackBoxAnimationHandler.CUBE_TO_RIGHT)
    return new DvtAnimCubeIn(context, objs, DvtBaseAnimation.AXIS_Y, DvtBaseAnimation.ROT_DIR_CLOCKWISE, duration);  
  else if(type == DvtBlackBoxAnimationHandler.CUBE_TO_LEFT)
    return new DvtAnimCubeIn(context, objs, DvtBaseAnimation.AXIS_Y, DvtBaseAnimation.ROT_DIR_COUNTERCLOCKWISE, duration); 
  else if(type == DvtBlackBoxAnimationHandler.FLIP_RIGHT)
    return new DvtAnimFlipIn(context, objs, DvtBaseAnimation.AXIS_Y, DvtBaseAnimation.ROT_DIR_CLOCKWISE, duration);  
  else if(type == DvtBlackBoxAnimationHandler.FLIP_LEFT)
    return new DvtAnimFlipIn(context, objs, DvtBaseAnimation.AXIS_Y, DvtBaseAnimation.ROT_DIR_COUNTERCLOCKWISE, duration); 
  else if(type == DvtBlackBoxAnimationHandler.TRANSITION_TO_RIGHT)
    return new DvtAnimScaleFadeIn(context, objs, bounds, DvtBaseAnimation.DIR_NW, 0.5, duration); 
  else if(type == DvtBlackBoxAnimationHandler.TRANSITION_TO_LEFT) 
    return new DvtAnimScaleFadeIn(context, objs, bounds, DvtBaseAnimation.DIR_NE, 0.5, duration); 
  else if(type == DvtBlackBoxAnimationHandler.SLIDE_TO_RIGHT) {
    DvtBlackBoxAnimationHandler._offsetObjects(objs, -bounds.w, 0);
    return new DvtAnimMoveBy(context, objs, new DvtPoint(bounds.w, 0), duration); 
  }
  else if(type == DvtBlackBoxAnimationHandler.SLIDE_TO_LEFT) {
    DvtBlackBoxAnimationHandler._offsetObjects(objs, bounds.w, 0);
    return new DvtAnimMoveBy(context, objs, new DvtPoint(-bounds.w, 0), duration); 
  }
  else if(type == DvtBlackBoxAnimationHandler.ZOOM)
    return new DvtAnimScaleFadeIn(context, objs, bounds, DvtBaseAnimation.DIR_C, 0.5, duration); 
  else 
    return null; 
}

/**
 * Creates and returns the specified black box animation between the old displayable and
 * the new displayable.
 * @param {DvtContext} context The platform specific context object.
 * @param {string} type The animation type.
 * @param {object} outObjs The displayable or array of displayables to animate out.
 * @param {object} inObjs The displayable or array of displayables to animate in.
 * @param {DvtRectangle} bounds The bounds of the objects to animate.
 * @param {number} duration The duration of the animation (in seconds).
 * @return {DvtPlayable} The animation from the old object to the new object.
 */
DvtBlackBoxAnimationHandler.getCombinedAnimation = function(context, type, outObjs, inObjs, bounds, duration) {
  if(type == DvtBlackBoxAnimationHandler.ALPHA_FADE)
    return new DvtCombinedAnimFade(context, outObjs, inObjs, duration); 
  else if(type == DvtBlackBoxAnimationHandler.CONVEYOR_FROM_RIGHT)
    return new DvtCombinedAnimConveyor(context, outObjs, inObjs, DvtBaseAnimation.DIR_W, DvtBaseAnimation.DIR_E, duration); 
  else if(type == DvtBlackBoxAnimationHandler.CONVEYOR_FROM_LEFT)
    return new DvtCombinedAnimConveyor(context, outObjs, inObjs, DvtBaseAnimation.DIR_E, DvtBaseAnimation.DIR_W, duration); 
  else if(type == DvtBlackBoxAnimationHandler.CUBE_TO_RIGHT)
    return new DvtCombinedAnimCube(context, outObjs, inObjs, DvtBaseAnimation.AXIS_Y, DvtBaseAnimation.ROT_DIR_CLOCKWISE, duration); 
  else if(type == DvtBlackBoxAnimationHandler.CUBE_TO_LEFT)
    return new DvtCombinedAnimCube(context, outObjs, inObjs, DvtBaseAnimation.AXIS_Y, DvtBaseAnimation.ROT_DIR_COUNTERCLOCKWISE, duration); 
  else if(type == DvtBlackBoxAnimationHandler.FLIP_RIGHT)
    return new DvtCombinedAnimFlip(context, outObjs, inObjs, DvtBaseAnimation.AXIS_Y, DvtBaseAnimation.ROT_DIR_CLOCKWISE, duration); 
  else if(type == DvtBlackBoxAnimationHandler.FLIP_LEFT)
    return new DvtCombinedAnimFlip(context, outObjs, inObjs, DvtBaseAnimation.AXIS_Y, DvtBaseAnimation.ROT_DIR_COUNTERCLOCKWISE, duration); 
  else if(type == DvtBlackBoxAnimationHandler.TRANSITION_TO_RIGHT) 
    return new DvtCombinedAnimScaleFade(context, outObjs, inObjs, bounds, DvtBaseAnimation.DIR_SE, DvtBaseAnimation.DIR_NW, 0.5, duration); 
  else if(type == DvtBlackBoxAnimationHandler.TRANSITION_TO_LEFT)
    return new DvtCombinedAnimScaleFade(context, outObjs, inObjs, bounds, DvtBaseAnimation.DIR_SW, DvtBaseAnimation.DIR_NE, 0.5, duration); 
  else if(type == DvtBlackBoxAnimationHandler.SLIDE_TO_RIGHT) {
    DvtBlackBoxAnimationHandler._offsetObjects(inObjs, -bounds.w, 0);
    return new DvtCombinedAnimMoveBy(context, outObjs, inObjs, new DvtPoint(bounds.w, 0), new DvtPoint(bounds.w, 0), duration); 
  }
  else if(type == DvtBlackBoxAnimationHandler.SLIDE_TO_LEFT) {
    DvtBlackBoxAnimationHandler._offsetObjects(inObjs, bounds.w, 0);
    return new DvtCombinedAnimMoveBy(context, outObjs, inObjs, new DvtPoint(-bounds.w, 0), new DvtPoint(-bounds.w, 0), duration); 
  }
  else if(type == DvtBlackBoxAnimationHandler.ZOOM) 
    return new DvtCombinedAnimScaleFade(context, outObjs, inObjs, bounds, DvtBaseAnimation.DIR_C, DvtBaseAnimation.DIR_C, 0.5, duration); 
  else 
    return null; 
}

/**
 * Adjusts the objects by the specified offset.
 * @param {object} objs The displayable or array of displayables.
 * @param {number} offsetX The x offset to add.
 * @param {number} offsetY The y offset to add.
 @private
 */
DvtBlackBoxAnimationHandler._offsetObjects = function(objs, offsetX, offsetY) {
  if(objs.length) {
    for(var i=0; i<objs.length; i++)
      DvtBlackBoxAnimationHandler._offsetObjects(objs[i], offsetX, offsetY);
  }
  else if(objs) {
    // Adjust the displayable
    objs.setTranslate(objs.getTranslateX() + offsetX, objs.getTranslateY() + offsetY);
  }
}
/**
 * Animation handler for data objects.
 * @param {DvtContext} context The platform specific context object.
 * @param {DvtContainer} deleteContainer The container where deletes should be moved for animation.
 * @class DvtDataAnimationHandler
 * @constructor
 */
var DvtDataAnimationHandler = function(context, deleteContainer) {
  this.Init(context, deleteContainer);
};

DvtObj.createSubclass(DvtDataAnimationHandler, DvtObj, "DvtDataAnimationHandler");

// TODO Document the expected interface for animatable objects:
// getId()
// animateUpdate(oldObj)
// animateDelete()
// animateInsert()

/**
 * Initializes the handler.
 * @param {DvtContext} context The platform specific context object.
 * @param {DvtContainer} deleteContainer The container where deletes should be moved for animation.
 * @protected
 */
DvtDataAnimationHandler.prototype.Init = function(context, deleteContainer) {
  this._context         = context;
  this._deleteContainer = deleteContainer;
  this._playables       = new Array();
  this._newChart        = null; // TODO this should be removed, doesn't belong in a generic animation handler
}

/**
 * Constructs an animation between two lists of logical objects.  This function 
 * delegates the specific animation behavior to the logical objects.  The animation
 * can be retrieved using getAnimation().
 * @param {array} oldList The list to animate from.
 * @param {array} newList The list to animate to.
 */
DvtDataAnimationHandler.prototype.constructAnimation = function(oldList, newList) {
  if (!newList)
    return;

  // Copy the new objects list, since we will modify it
  newList = newList.slice(0);

  // Loop through the two lists and diff the changes.
  // Note: This implementation considers changes in order to be updates.
  if (oldList) {
    for(var oldIndex=0; oldIndex<oldList.length; oldIndex++) {
      var oldItem = oldList[oldIndex];
      if(!oldItem) // oldItem must exist for update or delete
        continue;
      
      // Loop through the new list looking for a match
      var oldId = oldItem.getId();
      var bMatchFound = false;
      for(var newIndex=0; newIndex<newList.length; newIndex++) {
        var newItem = newList[newIndex];
        if(!newItem) // newItem must exist for update
          continue;
        
        var newId = newItem.getId();
        if((oldId === newId) || (oldId && oldId instanceof DvtObj && oldId.equals && oldId.equals(newId))) {
          // Match found, remove the item from the new list since it's handled
          newItem.animateUpdate(this, oldItem);
          newList.splice(newIndex, 1);
          bMatchFound = true;
          break;
        }
      }
      
      // If no match found, it was a delete.  Pass in the delete container so that
      // the object can choose whether to move to the new container.
      if(!bMatchFound) {
        if (newList[0]) {
          if (newList[0].getChart)
	          oldItem._newChart = newList[0].getChart() ;        // new chart needed for
        }                                                    // some delete animation
        oldItem.animateDelete(this, this._deleteContainer);
      }
    }
  }

  // All remaining objects in newList are inserts
  for(var i=0; i<newList.length; i++) {
    if(newList[i]) // must be valid object for insert
      newList[i].animateInsert(this);
  }
}

/**
 * Adds the specified playable to this handler's animation.
 * @param {DvtPlayable} The playable to add to this animation.
 * @param {number} index The relative ordering of the animation, beginning at 0.
 */
DvtDataAnimationHandler.prototype.add = function(playable, index) {
  if(!playable)
    return;
    
  if(!index)
    index = 0;

  // Make sure the playables array is large enough
  while(this._playables.length <= index)
    this._playables.push(new Array());
  
  // Add the playable to the array
  this._playables[index].push(playable);
}

/**
 * Returns the animation constructed by this handler.
 * @return {DvtPlayable} The animation constructed by this handler.
 */
DvtDataAnimationHandler.prototype.getAnimation = function() {
  // Construct the sequential playable
  var masterPlayable = new Array();
  for(var i=0; i<this._playables.length; i++) {
    // Construct and add the playable for this index in the sequence
    if(this._playables[i].length > 0) {
      var detailPlayable = new DvtParallelPlayable(this._context, this._playables[i]);
      masterPlayable.push(detailPlayable);
    }
  }

  return new DvtSequentialPlayable(this._context, masterPlayable);
}


/**
 * Returns the number of playables in this animation.
 * @returns {Number} the number of playables in this animation.
 */
DvtDataAnimationHandler.prototype.getNumPlayables = function()
{
    return this._playables.length ;
};
/**
 * Base class object for tooltip services.
 * @class DvtTooltipManager
 * @extends DvtObj
 * @constructor
 */
var DvtTooltipManager = function() {};

DvtObj.createSubclass(DvtTooltipManager, DvtObj, "DvtTooltipManager");

/**
 * Displays a tooltip with the given parameters.
 * @param {int} x the x position as relative to coordinate space of implementation
 * @param {int} y the y position as relative to coordinate space of implementation
 * @param {string} text the text to show within the tooltip
 * @param {string} borderColor the border color of the tooltip
 */
DvtTooltipManager.prototype.showDatatip = function(x, y, text, borderColor)
{
  // TODO subclasses should override
};


/**
 * Displays a tooltip.
 * @param {int} x the x position as relative to coordinate space of implementation
 * @param {int} y the y position as relative to coordinate space of implementation
 * @param (string) text The text to display in the tooltip. 
 * @param (DvtDisplayable) component The display object to use for tracking mouse movements.
 * @param (boolean) bTrackMouse Optional boolean to specify whether mouse movement should
 *                  also reposition the tooltip.  Default is true.
 * @param {string} borderColor Optional the border color of the tooltip
 *
 * @see hideTooltip()
 * @see showDatatip()
 */
DvtTooltipManager.prototype.showTooltip = function(x, y, text, component, bTrackMouse, borderColor)
{
  // TODO subclasses should override
};


/**
 * Hides the tooltip.
 */
DvtTooltipManager.prototype.hideTooltip = function()
{
  // TODO subclasses should override
};


/**
 * Interactivity handle for category rollover effects support.  
 * Objects must implement DvtLogicalObject and DvtCategoricalObject to be supported by this handler.
 * @class DvtCategoryRolloverHandler
 * @extends DvtObj
 * @constructor
 */
var DvtCategoryRolloverHandler = function() {};

DvtObj.createSubclass(DvtCategoryRolloverHandler, DvtObj, "DvtCategoryRolloverHandler");

/**
 * Processes the specified DvtCategoryRolloverEvent for the array of objects.
 * @param {DvtCategoryRolloverEvent} event The event that was triggered.
 * @param {array} objs The array of objects containing hide and show targets.
 * @deprecated We should update all components to use the highlight API instead.
 */
DvtCategoryRolloverHandler.processEvent = function(event, objs, customAlpha)
{
  if(!event || !objs)
    return;
  
  var dimmedAlpha = !customAlpha ? 0.35 : customAlpha;
  var eventCategories = event.getCategory();
  var alpha = (event.getType() === DvtCategoryRolloverEvent.TYPE_OVER) ? dimmedAlpha : 1;
  
  // Loop through the objects and update objects not belonging to the specified
  // category.
  for(var i=0; i<objs.length; i++) {
    var obj = objs[i];
    if(obj && obj.getCategories && !DvtCategoryRolloverHandler._hasCategory(obj, eventCategories)) {
      // Found a match, update the displayables
      var displayables = obj.getDisplayables(displayables);
      DvtCategoryRolloverHandler._updateAlpha(displayables, alpha);
    }
  }
}

/**
 * Highlights the objects corresponding to the specified objects.  If no categories are specified, all highlight will
 * be removed.
 * @param {array} categories The array of categories whose data items will be highlighted.
 * @param {array} objs The array of objects containing hide and show targets.
 * @param {number} customAlpha A custom alpha for the dimmed objects.
 */
DvtCategoryRolloverHandler.highlight = function(categories, objs, customAlpha) {
  if(!categories || !objs)
    return;
  
  var dimmedAlpha = !customAlpha ? 0.35 : customAlpha;
  
  // Loop through the objects and update objects not belonging to the specified category.
  for(var i=0; i<objs.length; i++) {
    var obj = objs[i];
    if(obj && obj.getCategories) {
      var alpha = categories && categories.length > 0 && !DvtCategoryRolloverHandler._hasCategory(obj, categories) ? dimmedAlpha : 1;
      var displayables = obj.getDisplayables(displayables);
      DvtCategoryRolloverHandler._updateAlpha(displayables, alpha);
    }
  }
}

/**
 * Updates the alpha of the displayables to the specified value.
 * @param {array} displayables The array of displayables.
 * @param {number} alpha The new alpha value.
 * @private
 */
DvtCategoryRolloverHandler._updateAlpha = function(displayables, alpha) {
  if(!displayables)
    return;

  for(var i=0; i<displayables.length; i++) {
    displayables[i].setAlpha(alpha);
  }
}

/**
 * Returns true if the specified object belongs to one of the specified categories.
 * @param {DvtCategoricalObject} obj
 * @param {array} categories
 * @private
 */
DvtCategoryRolloverHandler._hasCategory = function(obj, categories) {
  if(!obj || !obj.getCategories)
    return false;
  
  var objCategories = obj.getCategories();
  if(categories instanceof Array) {
    for(var categoryIndex=0; categoryIndex<categories.length; categoryIndex++) {
      // Return true if any category matches
      if(DvtArrayUtils.getIndex(objCategories, categories[categoryIndex]) >= 0)
        return true;
    }
    
    // No match found
    return false;
  }
  else // categories is just a single object
    return DvtArrayUtils.getIndex(objCategories, categories) >= 0;
}
/**
 * Interactivity handle for category hide and show support.  
 * Objects must implement DvtLogicalObject and DvtCategoricalObject to be supported by this handler.
 * @class DvtHideShowCategoryHandler
 * @extends DvtObj
 * @constructor
 */
var DvtHideShowCategoryHandler = function() {};

DvtObj.createSubclass(DvtHideShowCategoryHandler, DvtObj, "DvtHideShowCategoryHandler");

/**
 * Processes the specified DvtCategoryHideShowEvent for the array of objects.
 * @param {DvtCategoryHideShowEvent} event The event that was triggered.
 * @param {array} objs The array of objects containing hide and show targets.
 */
DvtHideShowCategoryHandler.processEvent = function(event, objs)
{
  if(!event || !objs)
    return;
    
  var category = event.getCategory();
  var bHide = (event.getType() === DvtCategoryHideShowEvent.TYPE_HIDE);
  
  // Loop through the objects and find the categorical matches
  for(var i=0; i<objs.length; i++) {
    var obj = objs[i];
    if(obj && obj.getCategories && DvtArrayUtils.getIndex(obj.getCategories(), category) >= 0) {
      // Found a match, update the displayables
      var displayables = obj.getDisplayables(displayables);
      DvtHideShowCategoryHandler._updateVisible(displayables, !bHide);
    }
  }
};

/**
 * Updates the visibility of the displayables to the specified value.
 * @param {array} displayables The array of displayables.
 * @param {boolean} bVisible
 */
DvtHideShowCategoryHandler._updateVisible = function(displayables, bVisible) {
  if(!displayables)
    return;

  for(var i=0; i<displayables.length; i++) {
    displayables[i].setVisible(bVisible);
  }
}
/**
 * Event manager that processes low level events and sends them to the appropriate handlers.
 * @param {DvtContext} context The platform specific context object.
 * @param {function} callback A function that responds to component events.
 * @param {object} callbackObj The optional object instance that the callback function is defined on.
 * @class
 * @implements {DvtComponentKeyboardHandler}
 * @constructor
 */
var DvtEventManager = function(context, callback, callbackObj) {
  this.Init(context, callback, callbackObj);
}

DvtObj.createSubclass(DvtEventManager, DvtObj, "DvtEventManager");

DvtEventManager.CLEAR_SELECTION_ACTION_TYPE = "clearSelectionActionType";

/**
 * Method called by the constructor to initialize this object
 * @param {DvtContext} context The platform specific context object.
 * @param {function} callback A function that responds to component events.
 * @param {object} callbackObj The optional object instance that the callback function is defined on.
 * @protected
 */
DvtEventManager.prototype.Init = function(context, callback, callbackObj) {
  this._context = context;
  this._callback = callback;
  this._callbackObj = callbackObj;
  
  // Initialize the higher level event handlers.  These handlers are exposed as protected fields 
  // so that subclasses can fully customize the behavior of this event manager.     
  this._selectionHandler = null; 
  this.ContextMenuHandler = null;
  this._marqueeHandler = null;
  this.PopupHandler = new DvtPopupBehaviorHandler(context, callback, callbackObj);
  this.ClientBehaviorHandler = this.CreateClientBehaviorHandler(context, callback, callbackObj);
  this.KeyboardHandler = null;
  
  // Tooltips enabled by default
  this.setTooltipsEnabled(true);
  
  var id = context.getStage().getId();
  if (!id)
    id = "undefinedId";
  this.CustomTooltipManager = this._context.getCustomTooltipManager();
  this.CustomTooltipManager.addTooltipEventListener(DvtActionTooltipEvent.TOOLTIP_CLOSED_TYPE, this.OnActionTooltipClosed, this);
  this.CustomTooltipManager.addTooltipEventListener(DvtActionTooltipEvent.TOOLTIP_STARTED_TYPE, this.OnActionTooltipStarted, this);
  
  this.TouchManager = null;
  if (DvtAgent.isTouchDevice())    
    this.TouchManager = new DvtTouchManager("touchmanager", this._context);
  
  // The DvtKeyboardNavigable item that currently has keyboard focus
  this._focusedObj = null;
  
  // flag to indicate if the component should display keyboard focus
  this._shouldDisplayKeyboardFocus = false;
  
  //BUG FIX #13376229: support for ignoring the next click after a mouse drag, 
  //so that panning Diagram doesn't change selection, for example
  this._bIgnoreClickAfterDrag = false;
  this._bMouseDown = false;
  this._bMouseDrag = false;
  this._bIgnoreNextClick = false;
  this._ignoreNextClickOffTimer = null;
  
  // Map associating an event with relevant info during its processing lifecycle
  this._eventInfo = {};
  
  // List of object types that should receive rollover/rollout events
  this._rolloverTypes = [];
  
  // An array of event managers that can process keyboard events sent to this
  // event manager, arranged in tab order. This event manager should be in this
  // array, but there may be other event managers as well, such as an event
  // manager for breadcrumbs
  this._keyboardHandlers = [this];
  
  // index to the _keyboardHandlers array indicating the current handler
  // that receives keyboard events
  this._currentKeyboardHandlerIdx = -1;
  
  this._bundle = new DvtUtilBundle();
}

/**
 * Returns the DvtContext associated with this event manager.
 * @return {DvtContext}
 */
DvtEventManager.prototype.getCtx = function() {
  return this._context;
}

/**
 * Associates the specified displayable with the specified object for this event manager.  This is used by the default
 * implementation of GetLogicalObject.
 * @param {DvtDisplayable} displayable The displayable to associate.
 * @param {object} obj The object to associate with.
 */
DvtEventManager.prototype.associate = function(displayable, obj) {
  if(displayable) {
    // Create the logical objects array if not already present
    if(!displayable._logicalObjects)
      displayable._logicalObjects = [];
    
    // Add this logical object and event manager mapping
    displayable._logicalObjects.push({logicalObject:obj, eventManager: this});
    
    // Tooltip support for XML renderer
    if (!DvtAgent.isEnvironmentBrowser() && displayable.getImpl().setLogicalObj)
      displayable.getImpl().setLogicalObj(obj);
  }
}

/**
 * Adds event listeners to the specified displayable.
 * @param {DvtDisplayable} displayable The object on which to add the listeners.
 */
DvtEventManager.prototype.addListeners = function(displayable) {
  if(!displayable)
    return;

  if (DvtAgent.isTouchDevice()) {
       // Hide any tooltips previously shown
       this.hideTooltip();       

       displayable.addEvtListener(DvtTouchEvent.TOUCHSTART, this.OnTouchStartBubble, false, this);
       displayable.addEvtListener(DvtTouchEvent.TOUCHMOVE, this.OnTouchMoveBubble, false, this);
       displayable.addEvtListener(DvtTouchEvent.TOUCHEND, this.OnTouchEndBubble, false, this);
     
       this.TouchManager.addTouchEventListener(DvtComponentTouchEvent.TOUCH_HOVER_START_TYPE, this._preOnComponentTouchHoverStart, this);
       this.TouchManager.addTouchEventListener(DvtComponentTouchEvent.TOUCH_HOVER_MOVE_TYPE, this._preOnComponentTouchHoverMove, this);
       this.TouchManager.addTouchEventListener(DvtComponentTouchEvent.TOUCH_HOVER_END_TYPE, this._preOnComponentTouchHoverEnd, this);
       this.TouchManager.addTouchEventListener(DvtComponentTouchEvent.TOUCH_HOVER_OUT_TYPE, this._preOnComponentTouchHoverOut, this);
       this.TouchManager.addTouchEventListener(DvtComponentTouchEvent.TOUCH_HOVER_OVER_TYPE, this._preOnComponentTouchHoverOver, this);

       this.TouchManager.addTouchEventListener(DvtComponentTouchEvent.TOUCH_CLICK_TYPE, this._preOnComponentTouchClick, this);
       this.TouchManager.addTouchEventListener(DvtComponentTouchEvent.TOUCH_DOUBLE_CLICK_TYPE, this._preOnComponentTouchDblClick, this);
       
  } else {
      displayable.addEvtListener(DvtMouseEvent.CLICK, this.PreOnClick, false, this);
      displayable.addEvtListener(DvtMouseEvent.DBLCLICK, this.PreOnDblClick, false, this);
      displayable.addEvtListener('contextmenu', this.PreOnContextMenu, false, this);
      displayable.addEvtListener(DvtMouseEvent.MOUSEMOVE,   this.PreOnMouseMove, false, this);
      displayable.addEvtListener(DvtMouseEvent.MOUSEOVER,   this.PreOnMouseOver, false, this);
      displayable.addEvtListener(DvtMouseEvent.MOUSEOUT,    this.PreOnMouseOut, false, this);
      displayable.addEvtListener(DvtMouseEvent.MOUSEDOWN,   this.PreOnMouseDown, false, this);
      displayable.addEvtListener(DvtMouseEvent.MOUSEUP,     this.PreOnMouseUp, false, this);
      displayable.addEvtListener(DvtKeyboardEvent.KEYDOWN,     this.OnKeyDown, false, this);
      displayable.addEvtListener(DvtKeyboardEvent.KEYUP,       this.OnKeyUp, false, this);
  }
}


/**
 * Removes event listeners from the specified displayable.
 * @param {DvtDisplayable} displayable The object on which to remove the listeners.
 */
DvtEventManager.prototype.removeListeners = function(displayable)
{
  if(!displayable)
    return;
    
  // Hide any tooltips previously shown
  this.hideTooltip();

  if (DvtAgent.isTouchDevice()) {
     displayable.removeEvtListener(DvtTouchEvent.TOUCHSTART, this.OnTouchStartBubble, false, this);
     displayable.removeEvtListener(DvtTouchEvent.TOUCHMOVE, this.OnTouchMoveBubble, false, this);
     displayable.removeEvtListener(DvtTouchEvent.TOUCHEND, this.OnTouchEndBubble, false, this);
     
     this.TouchManager.removeTouchEventListener(DvtComponentTouchEvent.TOUCH_HOVER_START_TYPE, this._preOnComponentTouchHoverStart, this);
     this.TouchManager.removeTouchEventListener(DvtComponentTouchEvent.TOUCH_HOVER_MOVE_TYPE, this._preOnComponentTouchHoverMove, this);
     this.TouchManager.removeTouchEventListener(DvtComponentTouchEvent.TOUCH_HOVER_END_TYPE, this._preOnComponentTouchHoverEnd, this);
     this.TouchManager.removeTouchEventListener(DvtComponentTouchEvent.TOUCH_HOVER_OUT_TYPE, this._preOnComponentTouchHoverOut, this);
     this.TouchManager.removeTouchEventListener(DvtComponentTouchEvent.TOUCH_HOVER_OVER_TYPE, this._preOnComponentTouchHoverOver, this);

     this.TouchManager.removeTouchEventListener(DvtComponentTouchEvent.TOUCH_CLICK_TYPE, this._preOnComponentTouchClick, this);
     this.TouchManager.removeTouchEventListener(DvtComponentTouchEvent.TOUCH_DOUBLE_CLICK_TYPE, this._preOnComponentTouchDblClick, this);     
   
  } else {
    displayable.removeEvtListener(DvtMouseEvent.CLICK, this.PreOnClick, false, this);
    displayable.removeEvtListener(DvtMouseEvent.DBLCLICK, this.PreOnDblClick, false, this);
    displayable.removeEvtListener('contextmenu', this.PreOnContextMenu, false, this);
    displayable.removeEvtListener(DvtMouseEvent.MOUSEMOVE,   this.PreOnMouseMove, false, this);
    displayable.removeEvtListener(DvtMouseEvent.MOUSEOVER,   this.PreOnMouseOver, false, this);
    displayable.removeEvtListener(DvtMouseEvent.MOUSEOUT,    this.PreOnMouseOut, false, this);
    displayable.removeEvtListener(DvtMouseEvent.MOUSEDOWN,   this.PreOnMouseDown, false, this);
    displayable.removeEvtListener(DvtMouseEvent.MOUSEUP,     this.PreOnMouseUp, false, this);
    displayable.removeEvtListener(DvtKeyboardEvent.KEYDOWN,     this.OnKeyDown, false, this);
    displayable.removeEvtListener(DvtKeyboardEvent.KEYUP,       this.OnKeyUp, false, this);
  }
  
}

/**
 * Releases all resources owned to prevent memory leaks.
 */
DvtEventManager.prototype.destroy = function()
{   
  if(this.CustomTooltipManager) 
  {
    this.CustomTooltipManager.removeTooltipEventListener(DvtActionTooltipEvent.TOOLTIP_CLOSED_TYPE, this.OnActionTooltipClosed, this);
    this.CustomTooltipManager.removeTooltipEventListener(DvtActionTooltipEvent.TOOLTIP_STARTED_TYPE, this.OnActionTooltipStarted, this);  
  }
}

/**
 * A method called before an event is processed. Sets a touch manager for the event and calls preEventBuble on touch manager object.
 * @param {DvtTouchEvent} event
 * @protected
 */
DvtEventManager.prototype.PreEventBubble = function(event) {
  this.TouchManager.preEventBubble(event);
}

/**
 * Sets the selection handler to use with this event manager.
 * @param {DvtSelectionHandler} handler The selection handler to use.
 */
DvtEventManager.prototype.setSelectionHandler = function(handler) {
  this._selectionHandler = handler;
}

/**
 * Gets the selection handler to use with this event manager.
 * @param {object} logicalObj Logical object used to retrieve the correct selection handler. Optional parameter used for
 * override subclasses like DvtThematicMapEventManager.
 */
DvtEventManager.prototype.getSelectionHandler = function(logicalObj) {
  return this._selectionHandler;
}

/**
 * Sets the marquee handler to use with this event manager.
 * @param {DvtMarqueeHandler} handler The marquee handler to use.
 */
DvtEventManager.prototype.setMarqueeHandler = function(handler) {
  this._marqueeHandler = handler;
}

/**
 * Sets the drag source to use with this event manager.
 * @param {DvtDragSource} dragSource The drag source to use
 */
DvtEventManager.prototype.setDragSource = function(dragSource) {
  this.DragSource = dragSource;
  if (DvtAgent.isTouchDevice())
    this.DragSource.setTouchManager(this.TouchManager);
}

/**
 * Sets the context menu handler to use with this event manager.
 * @param {DvtContextMenuHandler} handler The context menu handler to use.
 */
DvtEventManager.prototype.setContextMenuHandler = function(handler) {
  this.ContextMenuHandler = handler;
}

/**
 * Sets the keyboard handler to use with this event manager. This method is
 * a no-op if we are rendering the component on a touch device.
 * @param {DvtKeyboardHandler} handler The keyboard handler to use.
 */
DvtEventManager.prototype.setKeyboardHandler = function(handler) 
{
  if(!DvtAgent.isTouchDevice())
    this.KeyboardHandler = handler;
}

/**
 * Returns the keyboard handler used by this event manager
 * @return {DvtKeyboardHandler}
 */
DvtEventManager.prototype.getKeyboardHandler = function()
{
  return this.KeyboardHandler;  
}

/**
 * Sets the event manager's keyboard focus on the given DvtKeyboardNavigable,
 * and update the keyboard focus visual feedback.
 * @param {DvtKeyboardNavigable} navigable The DvtKeyboardNavigable to receive keyboard focus
 */
DvtEventManager.prototype.setFocusObj = function(navigable) {
  var curFocus = this.getFocus();
  if (navigable !=  curFocus) {
    this.setFocus(navigable);
    if (curFocus) {
      curFocus.hideKeyboardFocusEffect();
    }
    if (this.ShowKeyboardFocusByDefault()) {
      navigable.showKeyboardFocusEffect();
    }
    
    // set this event manager as the one to receive keyboard events
    if(this._currentKeyboardHandlerIdx > -1 && 
       this._currentKeyboardHandlerIdx < this._keyboardHandlers.length) {
      var handler = this._keyboardHandlers[this._currentKeyboardHandlerIdx];
      if (handler != this) { // Only hide focus effect if the keyboard handler has changed
        handler.hideKeyboardFocusEffect();
      }
    }
    this._updateKeyboardHandlerIdx(this);
  }
};

/**
 * Sets the event manager's keyboard focus on the given DvtKeyboardNavigable
 * @param {DvtKeyboardNavigable} navigable The DvtKeyboardNavigable to receive keyboard focus
 */
DvtEventManager.prototype.setFocus = function(navigable)
{
  if(this.KeyboardHandler)
    this._focusedObj = navigable;
}

/**
 * Returns the DvtKeyboardNavigable item with the current keyboard focus
 * @return {DvtKeyboardNavigable} The DvtKeyboardNavigable with the current keyboard focus
 */
DvtEventManager.prototype.getFocus = function()
{
  return this.KeyboardHandler ? this._focusedObj : null;
}


/**
 * Updates the view when the owning component receives focus 
 */
DvtEventManager.prototype.setFocused = function(isFocused)
{
  var navigable = this.getFocus();
  // don't show keyboard focus effect on touch devices
  if(navigable && this.KeyboardHandler)
  {
    if(!isFocused)
    {
      navigable.hideKeyboardFocusEffect();
    }
    else if( this._shouldDisplayKeyboardFocus &&
             this._currentKeyboardHandlerIdx >=0 &&
             this._currentKeyboardHandlerIdx < this._keyboardHandlers.length &&
             ((this._keyboardHandlers[this._currentKeyboardHandlerIdx] === this))
           )
    {
      // show keyboard focus effect if we receive focus after completing an animation
      // and we had keyboard focus before the animation began
      navigable.showKeyboardFocusEffect();
    }
  }    
  
  if(!isFocused)
    this._shouldDisplayKeyboardFocus = false;
}

/**
 * Returns true if the keyboard focus should be shown by default (when the component has focus), even if the user 
 * has not used the keyboard to intearact with the component
 * 
 * @return {Boolean}
 */
DvtEventManager.prototype.ShowKeyboardFocusByDefault = function() 
{
  return false;
}

/**
 * Specifies whether tooltips are enabled.
 * @param {boolean} tooltipsEnabled
 */
DvtEventManager.prototype.setTooltipsEnabled = function(tooltipsEnabled) {
  this._tooltipsEnabled = tooltipsEnabled;
}

/**
 * Returns true if tooltips are enabled.
 * @return {boolean}
 */
DvtEventManager.prototype.getTooltipsEnabled = function() {
  return this._tooltipsEnabled;
}

/**
 * Returns the logical object corresponding to the specified DvtDisplayable.  All high level event handlers,
 * such as the selection and popup handlers, are designed to react to the logical objects.
 * @param {DvtDisplayable} target The displayable.
 * @param {boolean} ignoreParents (optional) true indicates that parent displayables should not be searched if the 
 *                  target doesn't have its own logical object
 * @return {object} The logical object corresponding to the target.
 * @protected
 */
DvtEventManager.prototype.GetLogicalObject = function(target, ignoreParents) {
  var retObj = this.GetLogicalObjectAndDisplayable(target, ignoreParents);
  if (retObj) {
    return retObj.logicalObject;
  }
  return null;
};

/**
 * Returns the logical object and associated DvtDisplayable corresponding to the specified DvtDisplayable.  
 * All high level event handlers, such as the selection and popup handlers, are designed to react to the 
 * logical objects.
 * @param {DvtDisplayable} target The displayable.
 * @param {boolean} ignoreParents (optional) true indicates that parent displayables should not be searched if the 
 *                  target doesn't have its own logical object
 * @return {object} The logical object and associated DvtDisplayable corresponding to the target.
 * @protected
 */
DvtEventManager.prototype.GetLogicalObjectAndDisplayable = function(target, ignoreParents) {
  //BUG FIX 15851577: the popup handler needs to keep track of the displayable associated with the logical
  //object that launched a mousehover popup in order to dismiss the popup at the right time
  var displayable = target;
  while (displayable) {
    if(displayable._logicalObjects) {
      for(var i=0; i<displayable._logicalObjects.length; i++) {
        var mapping = displayable._logicalObjects[i];
        if(mapping.eventManager == this) {
          var retObj = {};
          retObj.logicalObject = mapping.logicalObject;
          retObj.displayable = displayable;
          return retObj;
        }
      }
    }
    displayable = ignoreParents ? null : displayable.getParent();
  }
  return null;
}

/**
 * Returns the array of showPopupBehaviors for a specified logical object.
 * @param {object} obj The logical target object.
 * @return {array} The array of applicable DvtShowPopupBehaviors
 * @private
 */
DvtEventManager.prototype._getShowPopupBehaviors = function(obj) {
  if(obj && obj.getShowPopupBehaviors)
    return obj.getShowPopupBehaviors();
}

/**
 * Returns the array of clientBehaviors for a specified logical object.
 * @param {object} obj The logical target object.
 * @return {array} The array of applicable DvtClientBehaviors
 * @private
 */
DvtEventManager.prototype._getClientBehaviors = function(obj) {
  if(obj && obj.getClientBehaviors)
    return obj.getClientBehaviors();
}

/**
 * Returns the menu type to display.
 * @param {object} logicalObj Logical object used to retrieve the correct selection handler. 
 * @return {object} The menu type to pass into the context menu handler.
 * @protected
 */
DvtEventManager.prototype.GetContextMenuType = function(logicalObj) {
  // Figure out the selection size, which determines which menu to display
  var selectionHandler = this.getSelectionHandler(logicalObj);
  var selectionSize = selectionHandler ? selectionHandler.getSelection().length : 0;
  if(selectionSize <= 0)
    return DvtContextMenuHandler.TYPE_BODY_CONTEXT_MENU;
  else if(selectionSize == 1)
    return DvtContextMenuHandler.TYPE_CONTEXT_MENU;
  else
    return DvtContextMenuHandler.TYPE_MULTI_SELECT_CONTEXT_MENU;
}

/**
 * Returns the id of the specific context menu to display for the specified logical object.
 * @param {object} obj The logical object
 * @return {object} The menu id to pass into the context menu handler.
 * @private
 */
DvtEventManager.prototype._getContextMenuId = function(obj) {
  if(obj && obj.getContextMenuId)
    return obj.getContextMenuId();
}

/**
 * Returns the tooltip color for the specified object.
 * @param {object} obj The logical object.
 * @param {number} x The relative x coordinate of the event
 * @param {number} y The relative y coordinate of the event
 */
DvtEventManager.prototype.GetTooltipColor = function(obj, x, y) {
  if(obj && obj.getDatatipColor)
    return obj.getDatatipColor();
}

/**
 * Fires the specified event through the callback.
 * @param {object} event
 * @param {object} source The component that is the source of the event, if available.
 */
DvtEventManager.prototype.FireEvent = function(event, source) {
  if(this._callback)
    this._callback.call(this._callbackObj, event, source);
}

/**
 * Creates and fires an instance of DvtComponentUIEvent for the specified object.
 * @param {string} type The type of DvtComponentUIEvent.
 * @param {object} logicalObj The logical object corresponding to the target of the event.
 * @protected
 */
DvtEventManager.prototype.FireUIEvent = function(type, logicalObj) {
  // subclasses must override if the event is to be fired
}

/**
 * Fires a selection event with the current selection state.
 * @param {object} logicalObj Logical object used to retrieve the correct selection handler. 
 * @private
 */
DvtEventManager.prototype.fireSelectionEvent = function(logicalObj) {
  var selectionHandler = this.getSelectionHandler(logicalObj);
  if(!selectionHandler)
    return;
    
  // Get the array of selected ids
  var selectedIds = selectionHandler.getSelectedIds();

  // Create and fire the event
  var selectionEvent = new DvtSelectionEvent(selectedIds);
  this._callback.call(this._callbackObj, selectionEvent);
}

//*******************************************************************************//
//*********************** Begin Event Listeners *********************************//
//*******************************************************************************//

/**
 * Click event handler that accounts for double clicks
 * @protected
 */
DvtEventManager.prototype.PreOnClick = function(event) {
  //BUG FIX #13376229: if ignoring the next click, toggle the flag and return
  if (this._bIgnoreClickAfterDrag && this.IsIgnoreNextClick()) {
    //turn off the flag
    this.SetIgnoreNextClick(false);
    return;
  }
  
  if (this.IsDoubleClickable(event.target)) {
    if (this._clickTimer && this._clickTimer.isRunning()) {
      var clickEvent = this._savedClickEvent;
      if (event.pageX == clickEvent.pageX && event.pageY == clickEvent.pageY) {
        // Same coords, this is a double click, so ignore second click event
        return;
      }
      else {
        // Different coords, so need to process first event
        this._clickTimer.stop();
        this._onClickTimerEnd();
      }
    }
    this._savedClickEvent = event;
    if (!this._clickTimer) {
      this._clickTimer = new DvtTimer(this._context, 250, this._onClickTimerEnd, this, 1);
    }
    this._clickTimer.reset();
    this._clickTimer.start()
  }
  else {
    this._propagateEvent(DvtMouseEvent.CLICK, event, this.OnClick);
  }
}

DvtEventManager.prototype._onClickTimerEnd = function() {
  var clickEvent = this._savedClickEvent;
  this._savedClickEvent = null;
  if (clickEvent) {
    this._propagateEvent(DvtMouseEvent.CLICK, clickEvent, this.OnClick);
  }  
}


/**
 * Click event handler.
 * @param {DvtObj} event The platform specific mouse event
 * @protected
 */
DvtEventManager.prototype.OnClick = function(event) {
  var obj = this.GetLogicalObject(this.GetCurrentTargetForEvent(event));
  this.OnClickInternal(event);
  
  this.ProcessSelectionEventHelper(obj, event.ctrlKey);
  
  // Stop displaying keyboard focus after the user has clicked
  this._shouldDisplayKeyboardFocus = false;

  // Done if there is no object
  if(! obj)
  {
    return;
  }
  
  // BUGFIX 13263165 and 13377513 - update the keyboard focus on mouse click
  if(this.KeyboardHandler && obj.getNextNavigable)  
  {
    var nextFocus = obj.getNextNavigable(event);
    this.setFocusObj(nextFocus);
  }

  // Popup Support for triggerType="click"
  var consumed = null;
  if(this._eventInfo[event]) {
    consumed = this._eventInfo[event]['popupDisplayed'];
  }

  if (!consumed) {
    var behaviors = this._getShowPopupBehaviors(obj);
    if(behaviors) {
      var position = new DvtPoint(event.pageX, event.pageY);
      consumed = this.PopupHandler.processClick(obj, behaviors, position, event);
    }
  
    if (consumed) {
      this._eventInfo[event]['popupDisplayed'] = true;
    }
  }

  // Client Behavior Support for triggerType="click"
  if (!consumed) {
    var clientBehaviors = this._getClientBehaviors(obj);
    if (clientBehaviors) {
      consumed = this.ClientBehaviorHandler.processClick(obj, clientBehaviors);
    }  
  }

  // fire an Action event if logical obj is a command component
  if (! consumed && obj.isCommandComponent && obj.isCommandComponent()) {
    // Create the action event
    var event = new DvtActionEvent(DvtActionEvent.SUBTYPE_ACTION, obj.getId());

    // add the component specific context
    DvtEventManager._addContextInfo(obj, event);

    // fire the action event
    this._callback.call(this._callbackObj, event);
  }
    
  // DvtComponentUIEvent Support
  this.FireUIEvent(DvtComponentUIEvent.TYPE_CLICK, obj);
}

DvtEventManager.prototype.IsDoubleClickable = function(leafTarget) {
  var displayable = leafTarget;
  while (displayable) {
    var logicalObject = this.GetLogicalObject(displayable, true);
    if (logicalObject) {
      if (logicalObject.isDoubleClickable && logicalObject.isDoubleClickable()) {
        return true;
      }
      if (!this.IsPropagationEnabled(DvtMouseEvent.DBLCLICK, null, displayable)) {
        return false;
      }
    }
    displayable = displayable.getParent();
  }
  return false;
}

/**
 * Helper function to process selection events
 * @param {DvtLogicalObject} logicalObj The logical object to process selection on
 * @param {Boolean} isMultiSelect True if we are performing multi-select
 * @private 
 */
DvtEventManager.prototype.ProcessSelectionEventHelper = function(logicalObj, isMultiSelect)
{
  // Selection Support
  var selectionHandler = this.getSelectionHandler(logicalObj);
  if(selectionHandler) {
    var bSelectionChanged = selectionHandler.processClick(logicalObj, isMultiSelect);
    // If the selection has changed, fire an event
    if(bSelectionChanged) 
      this.fireSelectionEvent(logicalObj);
  }  
}

DvtEventManager.prototype.PreOnDblClick = function(event) {
  this._propagateEvent(DvtMouseEvent.DBLCLICK, event, this.OnDblClick);
}

/**
 * Double click event handler.
 * @protected
 */
DvtEventManager.prototype.OnDblClick = function(event) {
  if (this._clickTimer && this._clickTimer.isRunning()) {
    this._clickTimer.stop();
    this._savedClickEvent = null;
  }
  else {
    if (DvtAgent.isPlatformIE()) {
      var obj = this.GetLogicalObject(this.GetCurrentTargetForEvent(event));
      if (!obj) {
        return;
      }
      
      if (!obj.isDoubleClickable || !obj.isDoubleClickable()) {
        // Need to turn this into a single click for IE which only sends out click,dblclick upon a double-click rather
        // than the click,click,dblclick sent out by other browsers
        this.OnClick(event);
        return;
      }
    }
  }
}

DvtEventManager.prototype.PreOnContextMenu = function(event) {
  this._propagateEvent('contextmenu', event, this.OnContextMenu);
}

/**
 * Context Menu event handler.
 * @protected
 */
DvtEventManager.prototype.OnContextMenu = function(event) {
  var obj = this.GetLogicalObject(this.GetCurrentTargetForEvent(event));
  
  // set keyboard focus on the object we are firing the context menu on
  if(obj && obj.getNextNavigable)
    this.setFocus(obj);
  
  this._onContextMenuHelper(event, obj);
}

/**
 * Helper method that does the bulk of the context menu handling
 * 
 * @param {DvtMouseEvent} event
 * @param {Object} obj  The logical object on which the mouse event was fired
 */
DvtEventManager.prototype._onContextMenuHelper = function(event, obj)
{
  this.OnContextMenuInternal(event);
  var popupLaunched = this._processActionPopup(this.GetCurrentTargetForEvent(event),  new DvtPoint(event.pageX, event.pageY));
  if (popupLaunched)
    event.preventDefault();
    
  this.ProcessSelectionEventHelper(obj, event.ctrlKey);
  
  // Context Menu Support
  if(this.ContextMenuHandler) {
    var menuType = this.GetContextMenuType(obj);
    var menuId = this._getContextMenuId(obj);
    this.ContextMenuHandler.prepareMenuItems(event, menuType, menuId);
    var contextMenuEvent = this.ContextMenuHandler.show(event, menuType, menuId); 
    if(contextMenuEvent) {
      // Hide the tooltip before displaying the menu
      this._context.getTooltipManager().hideTooltip();
      
      //BUG FIX 16018606: stop a mouseHover popup when a context menu is displayed
      this.PopupHandler.HidePopup(event);
      
      // Request the context menu be displayed
      this._callback.call(this._callbackObj, contextMenuEvent);
    }
  }
  else {
    // Popup Support for triggerType="contextMenu"
    var consumed = null;
    if(this._eventInfo[event]) {
      consumed = this._eventInfo[event]['popupDisplayed'];
    }
  
    if (!consumed) {
      var behaviors = this._getShowPopupBehaviors(obj);
      if(behaviors) {
        var position = new DvtPoint(event.pageX, event.pageY);
        consumed = this.PopupHandler.processContextMenu(obj, behaviors, position, event);
      }
    
      if (consumed) {
        this._eventInfo[event]['popupDisplayed'] = true;
        event.preventDefault();
      }
    }    
  }
}

/**
 * Keypress down event handler.  Delegates to DvtComponentKeyboardHandlers 
 * until event is consumed.
 * @param {DvtKeyboardEvent} event
 * @return {Boolean} true if this event manager has consumed the event
 * @protected
 */
DvtEventManager.prototype.OnKeyDown = function(event) 
{
  var keyCode = event.keyCode;
  var eventConsumed = false;  

  var i;
  var increment;
  
  // if no current event manager is set to receive keyboard focus, 
  // start at one end of the array and pass event to each event manager until
  // one event manager consumes the event.  that will be the current event manager
  if(this._currentKeyboardHandlerIdx < 0 || 
     this._currentKeyboardHandlerIdx > this._keyboardHandlers.length)
  {    
    // if we get a shift+tab, start from the back of the array
    if(keyCode == DvtKeyboardEvent.TAB && event.shiftKey)
      i = this._keyboardHandlers.length - 1;
    else
      i = 0;
  }
  else
  {
    i = this._currentKeyboardHandlerIdx;
  }

  // if we get a shift+tab, start from the back of the array and move backward
  if(keyCode == DvtKeyboardEvent.TAB && event.shiftKey)
    increment = -1; 
  else
    increment = 1;
 
  for(i; (i >=0 && i<this._keyboardHandlers.length && !eventConsumed); i=i+increment)
  {
    var handler = this._keyboardHandlers[i];
    if(handler=== this)
      eventConsumed = this.ProcessKeyboardEvent(event);
    else
      eventConsumed = handler.handleKeyboardEvent(event);

    if(eventConsumed)
      this._currentKeyboardHandlerIdx = i;    
  }
  
  return eventConsumed;
}


/**
 * @override
 */
DvtEventManager.prototype.handleKeyboardEvent = function(event)
{
  return this.OnKeyDown(event);
}

/**
 * @override
 */
DvtEventManager.prototype.hideKeyboardFocusEffect = function()
{
  var currentNavigable = this.getFocus();

  if(currentNavigable && currentNavigable.isShowingKeyboardFocusEffect())
  {    
    currentNavigable.hideKeyboardFocusEffect();
  }
}

/**
 * Keypress down event handler.  Provides basic keyboard navigation and 
 * triggering of context menus.
 * @param {DvtKeyboardEvent} event
 * @return {Boolean} true if this event manager has consumed the event
 * @protected
 */
DvtEventManager.prototype.ProcessKeyboardEvent = function(event) 
{  
  if(!this.KeyboardHandler)
    return false;

  // clear tooltip if one is shown; tooltip can be shown if mouse is used to make a selection
  // and then we use the keyboard to navigate from the mouse-selected item
  this.hideTooltip();
  
  
  var currentNavigable = this.getFocus();
  var nextNavigable = null;
  
  if(event.keyCode == DvtKeyboardEvent.TAB && currentNavigable &&
     currentNavigable.isShowingKeyboardFocusEffect())
  {
    // handle the case where we tab out of a component
    // don't cancel the event and propoagate it onwards
    currentNavigable.hideKeyboardFocusEffect();
    return false;
  }
  
  if(currentNavigable && this.KeyboardHandler.isContextMenuEvent(event))
  {
    var contextMenuLocation;
    
    if(currentNavigable.getContextMenuLocation)
    {
      contextMenuLocation = currentNavigable.getContextMenuLocation();      
    }
    else
    {
      var bounds = currentNavigable.getKeyboardBoundingBox();
      // adjust location for bidi; use top left corner for bidi, top right corner for non-bidi, 
      if(DvtAgent.isRightToLeft(this._context))
        contextMenuLocation = new DvtPoint(bounds.x, bounds.y);        
      else
        contextMenuLocation = new DvtPoint(bounds.x+bounds.w, bounds.y);
    }
  
    var mouseEvent = this.GenerateMouseEventFromKeyboardEvent(event, this._context.getStage(), contextMenuLocation.x, contextMenuLocation.y);
    // OnContextMenu checks for ctrlKey to perform multi-select before showing context menu
    // However, the keystroke combination for showing the context menu is Ctrl+Alt+M
    // CLEAR the ctrlKey field so that multi-select isn't performed, and send OnContextMenu
    // a mouse event that is equivalent to right-clicking on the navigable with keyboard focus
    // With the mouse, a user could Ctrl+right click a navigbale to multi-select it and then bring up the
    // context menu.  In the keyboard case, the user would first have to multi-select and then bring up the 
    // context menu, in two separate keystrokes
    mouseEvent.ctrlKey = false; 
    this._onContextMenuHelper(mouseEvent, currentNavigable);
    return true;
  }
  

  nextNavigable = this.KeyboardHandler.processKeyDown(event);

  if(nextNavigable)
  {
    // the user has transferred focus via the keyboard, start showing keyboard focus effect
    this._shouldDisplayKeyboardFocus = true;
    if (currentNavigable)
      currentNavigable.hideKeyboardFocusEffect();
    if(this.KeyboardHandler.isSelectionEvent(event))
      this.ProcessSelectionEventHelper(nextNavigable, event.shiftKey);
    else if(this.KeyboardHandler.isMultiSelectEvent(event))
      this.ProcessSelectionEventHelper(nextNavigable, event.ctrlKey);

    nextNavigable.showKeyboardFocusEffect();
    
    // Accessibility Support
    this._fireActiveElementChangeEvent(nextNavigable);
    
    return true;
  }
  
  return false;
}

/**
 * Returns a DvtMouseEvent that wraps the given keyboard event.  The given stageX and stageY coordinates are used to
 * compute the DvtMouseEvent's pageX and pageY fields
 * 
 * @param {DvtKeyboardEvent} event
 * @param {DvtStage} stage
 * @param {Number} stageX
 * @param {Number} stageY
 * @return {DvtMouseEvent}
 * @protected
 */
DvtEventManager.prototype.GenerateMouseEventFromKeyboardEvent = function(event, stage, stageX, stageY)
{
  return DvtSvgEventFactory.generateMouseEventFromKeyboardEvent(event, this._context, DvtMouseEvent.CLICK, stage, stageX, stageY);
}


/**
 * Keypress up event handler.  Empty implementation; subclasses will need to add their own implementation
 * @param {Object} event
 * @protected
 */
DvtEventManager.prototype.OnKeyUp = function(event) {  }

DvtEventManager.prototype.PreOnMouseMove = function(event) {
  this._propagateEvent(DvtMouseEvent.MOUSEMOVE, event, this.OnMouseMove);
}

/**
 * Mouse Move event handler
 * @protected
 */
DvtEventManager.prototype.OnMouseMove = function(event) {
  //BUG FIX #13376229: maintain flag indicating if the mouse is dragged
  if (this._bIgnoreClickAfterDrag && this._bMouseDown) {
    this._bMouseDrag = true;
  }
    
  var pageX = event.pageX;
  var pageY = event.pageY;
  var relPos = this._context.pageToStageCoords(pageX, pageY);
  
  if (this._marqueeHandler) {
    var marqueeEvent = this._marqueeHandler.processDragMove(relPos, event.ctrlKey);
    if (marqueeEvent)
      this._callback.call(this._callbackObj, marqueeEvent);
  }
  
  var target = this.GetCurrentTargetForEvent(event);
  var obj = this.GetLogicalObject(target);
  
  // Return if no object is found
  if(!obj)
    return;
  
  if (!this._eventInfo[event]['tooltipDisplayed']) {
    if (this.IsTooltipShowable(obj, relPos)) {
        // Show and move the tooltip
        if (this._processShowTooltip(target, obj, pageX, pageY)) {
          this._eventInfo[event]['tooltipDisplayed'] = true;
        };
    } else {
        this.hideTooltip();
    }
  }

  var position = new DvtPoint(pageX, pageY);
  // Notify the popup handler of the mouse move
  this.PopupHandler.processMouseMove(position);
  
  // Drag and Drop Support
  if(this.DragSource && !event.dragSourceSet && this.IsDragCandidate(obj)) {
    this.DragSource.setDragCandidate(obj);
    event.dragSourceSet = true;
  }

}

DvtEventManager.prototype.PreOnMouseOver = function(event) {
  this._propagateEvent(DvtMouseEvent.MOUSEOVER, event, this.OnMouseOver);
  this._handlePreOverEvent(event);
}

DvtEventManager.prototype._getDisplayableHierarchy = function(target, filterFunc, filterFuncObj) {
  var hierarchy = [];
  var currentTarget = target;
  while (currentTarget) {
    var bInclude = true;
    if (filterFunc) {
      bInclude = filterFunc.call(filterFuncObj, currentTarget);
    }
    if (bInclude) {
      hierarchy.unshift(currentTarget);
    }
    currentTarget = currentTarget.getParent();
  }
  return hierarchy;
}

DvtEventManager.prototype._getRolloverHierarchy = function(target) {
  return this._getDisplayableHierarchy(target, this._isRolloverType, this);
}
 
 
DvtEventManager.prototype._isRolloverType = function(target) {
  var logicalObject = this.GetLogicalObject(target, true);
  if (logicalObject) {
    for (var i = 0; i < this._rolloverTypes.length; i++) {
      if (logicalObject instanceof this._rolloverTypes[i]) {
        return true;
      }
    }
  }
  return false;
}

DvtEventManager.prototype.addRolloverType = function(type) {
  this._rolloverTypes.push(type);
}

DvtEventManager.prototype.removeRolloverType = function(type) {
  var index = this._rolloverTypes.indexOf(type);
  if (index != -1) {
    this._rolloverTypes.splice(index, 1);
  }
}

DvtEventManager.prototype.OnRollOver = function(event) {
  
}

/**
 * Mouse Over event handler
 * @protected
 */
DvtEventManager.prototype.OnMouseOver = function(event) {
  var currTargetForEvent = this.GetCurrentTargetForEvent(event);
  var logObjAndDisp = this.GetLogicalObjectAndDisplayable(currTargetForEvent);
  var obj = null;
  if (logObjAndDisp) {
    obj = logObjAndDisp.logicalObject;
  }
  var position = new DvtPoint(event.pageX, event.pageY);
  
  // Return if no object is found
  if(!obj)
    return;
    
  // Selection Support
  var selectionHandler = this.getSelectionHandler(obj);
  if(selectionHandler)
    selectionHandler.processMouseOver(obj);
  
  // DvtComponentUIEvent Support
  this.FireUIEvent(DvtComponentUIEvent.TYPE_ROLL_OVER, obj);

  if (!this._eventInfo[event]['popupDisplayed']) {
    // Popup Support for triggerType="hover"
    var behaviors = this._getShowPopupBehaviors(obj);
    if(behaviors) {
      //BUG FIX 15851577: pass the displayable corresponding to the logical object to the popup handler
      //so that it can keep track of when to dismiss a mousehover popup
      if (this.PopupHandler.processMouseOver(obj, behaviors, position, logObjAndDisp.displayable, event)) {
        this._eventInfo[event]['popupDisplayed'] = true;
      }
    }
  }
  
  // Accessibility Support
  this._fireActiveElementChangeEvent(obj, currTargetForEvent);
}

DvtEventManager.prototype.PreOnMouseOut = function(event) {
  this._handlePreOutEvent(DvtMouseEvent.MOUSEOUT, event, this.OnMouseOut);
}

DvtEventManager.prototype.OnRollOut = function(event) {
  
}

/**
 * Mouse Out event handler
 * @protected
 */
DvtEventManager.prototype.OnMouseOut = function(event) {
  var obj = this.GetLogicalObject(this.GetCurrentTargetForEvent(event));
    
  // Return if no object is found
  if(!obj)
    return;
  
  var relatedObj = this.GetLogicalObject(event.relatedTarget);
  if(obj == relatedObj)
    return; // not a mouse out if they correspond to the same object
  
  // Selection Support
  var selectionHandler = this.getSelectionHandler(obj);
  if(selectionHandler)
    selectionHandler.processMouseOut(obj);
  
  // DvtComponentUIEvent Support
  this.FireUIEvent(DvtComponentUIEvent.TYPE_ROLL_OUT, obj);
      
  // BUGFIX 13604291 - only show keyboard focus effect if the component has received a keystroke
  //   if the component has not received a keystroke, hide the keyboard focus effect
  var navigable = this.getFocus();
  if(navigable)
  {
    // some components may use the hover effect to indicate keyboard focus as well.
    // in these cases, do not remove the visual effect when we mouse out of the target
    // with keyboard focus    
    if(obj === navigable)
    {      
      if(this._shouldDisplayKeyboardFocus && !navigable.isShowingKeyboardFocusEffect())
        navigable.showKeyboardFocusEffect();
    }
      
  }
  
  // Bug #12957574: If the mouse has moved off the component, hide the tooltip  
  this.hideTooltip();
  
  // Clear drag source when moving out of component
  if(this.DragSource && !event.dragSourceSet) {
    this.DragSource.setDragCandidate(null);
    event.dragSourceSet = true;
  }
}

DvtEventManager.prototype.PreOnMouseDown = function(event) {
  this._propagateEvent(DvtMouseEvent.MOUSEDOWN, event, this.OnMouseDown);
}


/**
 * Mouse Down event handler
 * @protected
 */
DvtEventManager.prototype.OnMouseDown = function(event) {
  //BUG FIX #13376229: maintain flag indicating if the mouse down
  if (this._bIgnoreClickAfterDrag) {
    this._bMouseDown = true;
  }
  
  var obj = this.GetLogicalObject(this.GetCurrentTargetForEvent(event));
  var relPos = this._context.pageToStageCoords(event.pageX, event.pageY);

  var isPopup = this.isInActionPopup();
  if (isPopup) {
    this.CustomTooltipManager.closeActionTooltip();
  }
  
  if (this._marqueeHandler) {
    var marqueeEvent = this._marqueeHandler.processDragStart(relPos, event.ctrlKey);
    if (marqueeEvent)
      this._callback.call(this._callbackObj, marqueeEvent);
  }
  
   // Drag and Drop Support
  if(this.DragSource && !event.dragSourceSet && this.IsDragCandidate(obj)) {
    this.DragSource.setDragCandidate(obj);
    event.dragSourceSet = true;
  }
}

DvtEventManager.prototype.PreOnMouseUp = function(event) {
  this._propagateEvent(DvtMouseEvent.MOUSEUP, event, this.OnMouseUp);
}

/**
 * Mouse Up event handler
 * @protected
 */
DvtEventManager.prototype.OnMouseUp = function(event) {
  //BUG FIX #13376229: maintain flag indicating if we should ignore the
  //next click event because the mouse was dragged
  if (this._bIgnoreClickAfterDrag && this._bMouseDown && this._bMouseDrag) {
    //turn on the flag
    this.SetIgnoreNextClick(true);
  }
  this._bMouseDown = false;
  this._bMouseDrag = false;
  
  var relPos = this._context.pageToStageCoords(event.pageX, event.pageY);
  
  if (this._marqueeHandler) {
    var marqueeEvent = this._marqueeHandler.processDragEnd(relPos, event.ctrlKey);
    if (marqueeEvent)
      this._callback.call(this._callbackObj, marqueeEvent);
  }

  // no default behavior, subclasses can override
}

// Shows multi-touch tooltips.
DvtEventManager.prototype._processMultiTouchTooltip = function() {
    var tooltipInfoObj = this.TouchManager.getTooltipInfo();
    var touchIds = tooltipInfoObj.touchIds;
    var tooltipTarget = tooltipInfoObj.tooltipTarget;
    
    // If no hints are there, hide the tooltip
    if (touchIds.length == 0 || !tooltipTarget) {
        this.hideTooltip();
        return;
    }
    
    var avgPos = this.TouchManager.calcAveragePosition(touchIds);
    var obj = this.GetLogicalObject(tooltipTarget);
    this._processObjectTooltip(avgPos.x, avgPos.y, obj, null);
}

/**
 * Get the timer to turn off the flag to ignore the next mouse click.
 * @protected
 */
DvtEventManager.prototype.GetIgnoreNextClickOffTimer = function () {
  if (!this._ignoreNextClickOffTimer) {
    this._ignoreNextClickOffTimer = new DvtTimer(this._context, 500, this.HandleIgnoreNextClickOffTimer, this, 1);
  }
  
  return this._ignoreNextClickOffTimer;
};

/**
 * Handle an event from the timer to turn off the flag to ignore the
 * next mouse click.  
 * @protected
 */
DvtEventManager.prototype.HandleIgnoreNextClickOffTimer = function (event) {
  //turn off the flag
  this.SetIgnoreNextClick(false);
};

/**
 * Set the flag to ignore the next mouse click.
 * @protected
 */
DvtEventManager.prototype.SetIgnoreNextClick = function(bIgnoreNextClick) {
  this._bIgnoreNextClick = bIgnoreNextClick;
  
  //if turning on the flag, start the timer to shut it off
  //automatically in case a mouse click is not registered
  //immediately
  if (bIgnoreNextClick)
  {
    this.GetIgnoreNextClickOffTimer().reset();
    this.GetIgnoreNextClickOffTimer().start();
  }
  //if turning off the flag, stop the auto-off timer
  else
  {
    if (this.GetIgnoreNextClickOffTimer().isRunning())
      this.GetIgnoreNextClickOffTimer().stop();
  }
};

/**
 * Determine if the flag to ignore the next mouse click is set.
 * @protected
 */
DvtEventManager.prototype.IsIgnoreNextClick = function() {
  return this._bIgnoreNextClick;
};

/**
 * Touch Start event handler
 * @param {DvtTouchEvent} event
 * @protected
 */
DvtEventManager.prototype.OnTouchStartBubble = function(event) {
    this.PreEventBubble(event);

    if (event.isInitialTouch()) {
      this._popupJustClosed = false;
    }

    // Drag and Drop Support
    if(this.DragSource) {
        var obj = this.GetLogicalObject(event.target);
        if (!event.dragSourceSet && this.IsDragCandidate(obj)) {
            this.DragSource.setDragCandidate(obj);
            event.dragSourceSet = true;
        }
    }

    var isPopup = this.isInActionPopup();
    // Action popups block other types of interactions
    if (isPopup) {
       this.CustomTooltipManager.closeActionTooltip();
       this.TouchManager.resetTouchHold();
    }
    this.HandleImmediateTouchStartInternal(event);
    this.TouchManager.fireLogicalEvents(event);
    this.TouchManager.postEventBubble(event);
    
    this._processMultiTouchTooltip();
}
/**
 * Touch Move event handler
 * @param {DvtTouchEvent} event
 * @protected
 */
DvtEventManager.prototype.OnTouchMoveBubble = function(event) {
  this.PreEventBubble(event);

  if (this.TouchManager) {
        this._prevActionClear = false;
    
        this.HandleImmediateTouchMoveInternal(event);
        this.TouchManager.fireLogicalEvents(event);
        this.TouchManager.postEventBubble(event);

        this._processMultiTouchTooltip();
    }
}

/*
 * Timeout needed to put touch end after an attempt to touch & hold
 */
DvtEventManager.prototype._handleTouchEndTimer = function() {    
    for (var i=0;i<this._touchEndTimer.length;i++) {
        var timerObj = this._touchEndTimer[i];
        timerObj["timer"].stop();
        var event = timerObj["event"];
        if (this.TouchManager) {
            this.HandleImmediateTouchEndInternal(event);
            this.TouchManager.fireLogicalEvents(event);
            this.TouchManager.postEventBubble(event);
        }
    }
    // Clear drag source on touch end timer
    if(this.DragSource && !event.dragSourceSet) {
        this.DragSource.setDragCandidate(null);
        event.dragSourceSet = true;
    }    
    this._touchEndTimer = new Array();
}
/**
 * Touch End event handler
 * @param {DvtTouchEvent} event
 * @protected
 */
DvtEventManager.prototype.OnTouchEndBubble = function(event) {
   this.PreEventBubble(event);
   var timer = new DvtTimer(this._context, 0, this._handleTouchEndTimer, this, 1);
   if (!this._touchEndTimer)
    this._touchEndTimer = new Array();
   this._touchEndTimer.push({"event": event, "timer": timer});
   timer.start();
}

DvtEventManager.prototype.HandleImmediateTouchStartInternal = function(event) {
}

DvtEventManager.prototype.HandleImmediateTouchMoveInternal = function(event) {
}

DvtEventManager.prototype.HandleImmediateTouchEndInternal = function(event) {
}

/**
 * Touch hover start event handler
 * @private
 * @param {DvtComponentTouchEvent} event
 */
DvtEventManager.prototype._preOnComponentTouchHoverStart = function(event) {
  this._propagateEvent(DvtComponentTouchEvent.TOUCH_HOVER_START_TYPE, event, this.OnComponentTouchHoverStart);
}

/**
 * Touch hover start event handler. Subclasses can override.
 * @param {DvtComponentTouchEvent} event
 * @protected
 */
DvtEventManager.prototype.OnComponentTouchHoverStart = function(event) {
  var targetObj = this.GetCurrentTargetForEvent(event);
  var obj = this.GetLogicalObject(targetObj);
    
  var touch = event.touch;
  var touchX = touch.pageX;
  var touchY = touch.pageY;
  var relPos = this._context.pageToStageCoords(touchX, touchY);
    
  if (this._marqueeHandler) {
    var marqueeEvent = this._marqueeHandler.processDragStart(relPos, event.ctrlKey);
    if (marqueeEvent) {
      event.preventDefault();
      this._callback.call(this._callbackObj, marqueeEvent);  
    }
  }   
      
  this.UpdateTouchHoverFeedback(targetObj);

  this.HandleTouchHoverStartInternal(event);
        
  this._processMultiTouchTooltip();
  
  this._prevActionClear = false;
}

/**
 * Touch hover move event handler
 * @private
 * @param {DvtComponentTouchEvent} event
 */
DvtEventManager.prototype._preOnComponentTouchHoverMove = function(event) {
  this._propagateEvent(DvtComponentTouchEvent.TOUCH_HOVER_MOVE_TYPE, event, this.OnComponentTouchHoverMove);   
}

/**
 * Touch hover move event handler. Subclasses can override.
 * @param {DvtComponentTouchEvent} event
 * @protected
 */
DvtEventManager.prototype.OnComponentTouchHoverMove = function(event) {
  var targetObj = this.GetCurrentTargetForEvent(event);
  var touch = event.touch;
  var touchX = touch.pageX;
  var touchY = touch.pageY;
  var relPos = this._context.pageToStageCoords(touchX, touchY);
  var obj = this.GetLogicalObject(targetObj);
    
  if (this._marqueeHandler) {
    var marqueeEvent = this._marqueeHandler.processDragMove(relPos, event.ctrlKey);
    if (marqueeEvent) {
      event.preventDefault();
      this._callback.call(this._callbackObj, marqueeEvent);  
    }
  }
    
  this.UpdateTouchHoverFeedback(targetObj);
 
  this.HandleTouchHoverMoveInternal(event);
    
  var position = new DvtPoint(touch.pageX, touch.pageY);
  // Notify the popup handler of the mouse move
  this.PopupHandler.processMouseMove(position);
}

/**
 * Touch hover end event handler
 * @private
 * @param {DvtComponentTouchEvent} event
 */
DvtEventManager.prototype._preOnComponentTouchHoverEnd = function(event) {
  this._propagateEvent(DvtComponentTouchEvent.TOUCH_HOVER_END_TYPE, event, this.OnComponentTouchHoverEnd);   
}

/**
 * Touch hover end event handler. Subclasses can override.
 * @param {DvtComponentTouchEvent} event
 * @protected
 */
DvtEventManager.prototype.OnComponentTouchHoverEnd = function(event) {
  var targetObj = this.GetCurrentTargetForEvent(event);
  var obj = this.GetLogicalObject(targetObj);

  var touch = event.touch;
  var touchX = touch.pageX;
  var touchY = touch.pageY;
  var relPos = this._context.pageToStageCoords(touchX, touchY);
    
  if (this._marqueeHandler) {
    var marqueeEvent = this._marqueeHandler.processDragEnd(relPos, event.ctrlKey);
    if (marqueeEvent) {
      event.preventDefault();
      this._callback.call(this._callbackObj, marqueeEvent);  
    }
  }

  this.HandleTouchHoverEndInternal(event);

  if (obj && obj.isSelected && obj.isSelected()) {
    // Don't de-select on touch hover 
  } else {
    this._processTouchSelection(obj, event._isCancelEvent, false);
  }

  this.ProcessTouchContextMenu(event, obj);

  this._processActionPopup(targetObj, new DvtPoint(touchX, touchY));
    
  // DvtComponentUIEvent Support
  this.FireUIEvent(DvtComponentUIEvent.TYPE_ROLL_OUT, obj); 
}

/**
 * Touch hover out event handler
 * @private
 * @param {DvtComponentTouchEvent} event
 */
DvtEventManager.prototype._preOnComponentTouchHoverOut = function(event) {
  this._handlePreOutEvent(DvtComponentTouchEvent.TOUCH_HOVER_OUT_TYPE, event, this.OnComponentTouchHoverOut);
}

/**
 * Touch hover out event handler. Subclasses can override.
 * @param {DvtComponentTouchEvent} event
 * @protected
 */
DvtEventManager.prototype.OnComponentTouchHoverOut = function(event) {
  var targetObj = this.GetCurrentTargetForEvent(event);
  var obj = this.GetLogicalObject(targetObj);

  this.HandleTouchHoverOutInternal(event);

  var selectionHandler = this.getSelectionHandler(obj);
  if(selectionHandler)
    selectionHandler.processMouseOut(obj);
    
  // DvtComponentUIEvent Support
  this.FireUIEvent(DvtComponentUIEvent.TYPE_ROLL_OUT, obj);   
}

/**
 * Touch hover over event handler
 * @private
 * @param {DvtComponentTouchEvent} event
 */
DvtEventManager.prototype._preOnComponentTouchHoverOver = function(event) {
  this._propagateEvent(DvtComponentTouchEvent.TOUCH_HOVER_OVER_TYPE, event, this.OnComponentTouchHoverOver);
  this._handlePreOverEvent(event);
}

/**
 * Touch hover over event handler. Subclasses can override.
 * @param {DvtComponentTouchEvent} event
 * @protected
 */
DvtEventManager.prototype.OnComponentTouchHoverOver = function(event) {
  var targetObj = this.GetCurrentTargetForEvent(event);
  var obj = this.GetLogicalObject(targetObj);

  var touch = event.touch;
  var position = new DvtPoint(touch.pageX, touch.pageY);
  
  this.HandleTouchHoverOverInternal(event);

  var selectionHandler = this.getSelectionHandler(obj);
  if(selectionHandler)
    selectionHandler.processMouseOver(obj);
    
  // DvtComponentUIEvent Support
  this.FireUIEvent(DvtComponentUIEvent.TYPE_ROLL_OVER, obj);    
    
  // Popup Support for triggerType="hover"
  var behaviors = this._getShowPopupBehaviors(obj);
  if(behaviors)
    this.PopupHandler.processMouseOver(obj, behaviors, position, event);
}

/**
 * Touch double click event handler.
 * @private
 * @param {DvtComponentTouchEvent} event
 */
DvtEventManager.prototype._preOnComponentTouchDblClick = function(event) {
  this._propagateEvent(DvtComponentTouchEvent.TOUCH_DOUBLE_CLICK_TYPE, event, this.OnComponentTouchDblClick); 
}

/**
 * Touch double click event handler. Subclasses must override.
 * @param {DvtComponentTouchEvent} event
 * @protected
 */
DvtEventManager.prototype.OnComponentTouchDblClick = function(event) {
}

/**
 * Touch click event handler
 * @private
 * @param {DvtComponentTouchEvent} event
 */
DvtEventManager.prototype._preOnComponentTouchClick = function(event) {
  this._propagateEvent(DvtComponentTouchEvent.TOUCH_CLICK_TYPE, event, this.OnComponentTouchClick); 
}

/**
 * Touch click event handler. Subclasses can override.
 * @param {DvtComponentTouchEvent} event Component Touch event
 * @protected
 */
DvtEventManager.prototype.OnComponentTouchClick = function(event) {
  var targetObj = this.GetCurrentTargetForEvent(event);
  var touch = event.touch;
  var dlo = this.GetLogicalObject(targetObj);
  var position = new DvtPoint(touch.pageX, touch.pageY);
  // Popup Support for triggerType="click"
  var consumed = false;
  if(this._eventInfo[event]) {
    consumed = this._eventInfo[event]['popupDisplayed'];
  }
  
  if (!consumed) {
    var behaviors = this._getShowPopupBehaviors(dlo);
    if(behaviors) {
      consumed = this.PopupHandler.processClick(dlo, behaviors, position, event);
    }
  
    if (consumed) {
      this._eventInfo[event]['popupDisplayed'] = true;
    }
  }
  
  if (!consumed) {
    var clientBehaviors = this._getClientBehaviors(dlo);
    if (clientBehaviors) { 
      this.ProcessClientBehaviorForTouch(dlo, clientBehaviors);
    }
  }
  
  // DvtComponentUIEvent Support
  this.FireUIEvent(DvtComponentUIEvent.TYPE_CLICK, dlo);
  
  var done = this.HandleTouchClickInternal(event);
  if (done)
      return;
      
  this._processTouchSelection(dlo, this._popupJustClosed, true);
  
  if (this.CustomTooltipManager.displayActionPopup()) {
      this.UpdateActionTooltipLaunchedFeedback(targetObj, new DvtPoint(touch.pageX, touch.pageY));
      this.CustomTooltipManager.startActionPopupAtPosition(touch.pageX, touch.pageY, targetObj);   
  }
    
  // fire an Action event if logical obj is a command component
  if (dlo && !consumed && dlo.isCommandComponent && dlo.isCommandComponent()) {
    // Create the action event
    var event = new DvtActionEvent(DvtActionEvent.SUBTYPE_ACTION, dlo.getId());

    // add the component specific context
    DvtEventManager._addContextInfo(dlo, event);

    // fire the action event
    this._callback.call(this._callbackObj, event);
  }
     
}

DvtEventManager.prototype._processTouchSelection = function(dlo, preventClear, isTap) {
    var bSelectionChanged = false;
    var selectionHandler = this.getSelectionHandler(dlo);
    if (selectionHandler) {
        if (!dlo || !dlo.isSelectable || !dlo.isSelectable()) {
            if (!preventClear && !this._prevActionClear) {
                // Don't ask for clear selection if popup just closed  
                var showClearDialog = false;
                var allowClear = false;
                // There are two different policies for the clear selection dialog
                // 1) If a tap, show clear selection only for multiple selection when more than 1 is selected
                // 2) If a touch and hold + release, don't attempt a clear or perform a  clear
                if (isTap) {
                    allowClear = true;
                    if (this.isClearMenuAllowed()) {
                        var selType = selectionHandler.getType();
                        if (selType == DvtSelectionHandler.TYPE_MULTIPLE) {
                            if (selectionHandler.getSelectedCount() > 1) {
                                showClearDialog = true;
                            }
                        }
                    }
                }
                if (allowClear) {
                  if (showClearDialog) {
                    this.addClearAllActionItem();
                  } else {
                    bSelectionChanged = selectionHandler.processClick(null, false);
                    // If the selection has changed, fire an event
                    if(bSelectionChanged) 
                      this.fireSelectionEvent(dlo);
                }
              }
            }
        } else {
            // Process click immediately
            bSelectionChanged = selectionHandler.processClick(dlo, true);
            // If the selection has changed, fire an event
            if(bSelectionChanged) 
              this.fireSelectionEvent(dlo);
        }
    }
    this._prevActionClear = false;
}

DvtEventManager.prototype.OnActionTooltipClosed = function(event) {
    var targetObj = event.target;
    var dlo = this.GetLogicalObject(targetObj);
    
    this._popupJustClosed = true;
    this._isInActionPopup = false;     
    var actionPopup =  this.CustomTooltipManager.getActionTooltip();

    if (actionPopup.containsMenuId(DvtEventManager.CLEAR_SELECTION_ACTION_TYPE)) {
        this._prevActionClear = true;
    }
    this.CustomTooltipManager.clearActionTooltip();

    // end start
    this.UpdateActionTooltipClosedFeedback(targetObj);
}

DvtEventManager.prototype.OnActionTooltipStarted = function(event) {
    this._isInActionPopup = true;
}

//*******************************************************************************//
//************************* End Event Listeners *********************************//
//*******************************************************************************//
/*
 * Touch-related actions
 */

DvtEventManager.prototype._processObjectTooltip = function(touchX, touchY, obj, targetObj) {
    this._processShowTooltip(targetObj, obj, touchX, touchY);
}

DvtEventManager.prototype._getTooltipInfo = function(target, obj, x, y) {
    var text = null;
    var isDatatip = false;
    if (obj && obj.getDatatip) {
        text = obj.getDatatip(target, x, y);
        if (text)
            isDatatip = true;
    }

    if(!text && obj && obj.getTooltip) {
       text = obj.getTooltip(target, x, y);

    }
    return {"text" : text, "isDatatip": isDatatip};
}

DvtEventManager.prototype._processShowTooltip = function(target, obj, pageX, pageY) {
  if (this.getTooltipsEnabled()) {
      var relPos = this._context.pageToStageCoords(pageX, pageY);
      var x = relPos.x;
      var y = relPos.y;
      
      var tooltipInfo = this._getTooltipInfo(target, obj, x, y);
      var isDatatip = tooltipInfo["isDatatip"];
      var text = tooltipInfo["text"];
      if(text) {
        this.CustomTooltipManager.clearActionTooltip();
        var borderColor = this.GetTooltipColor(obj, x, y);
        
        var ttm = this._context.getTooltipManager();
        if (isDatatip) {
            ttm.showDatatip(pageX, pageY, text, borderColor);
        } else {
            ttm.showTooltip(pageX, pageY, text, null, true, borderColor);
        }
        
        this.TooltipLaunched(text, borderColor);
        return true;
      } else {
        this.hideTooltip();
      }
  } else {
      this.hideTooltip();
  }
  return false;
}

DvtEventManager.prototype.hideTooltip = function() {
    var tooltipManager = this._context.getTooltipManager();
    if(tooltipManager)
      tooltipManager.hideTooltip();
    
    this.TooltipHidden();
}


DvtEventManager.prototype.ProcessTouchContextMenu = function(event, dlo) {

    if (!this.ContextMenuHandler)
        return;
    var menuType = this.GetContextMenuType(dlo);
    var menuId = this._getContextMenuId(dlo);

    var allowContextMenu = false;
    if (dlo && dlo.isSelected && dlo.isSelected()) {
        allowContextMenu = true;
    } else {
        if (!dlo || !dlo.isSelectable || !dlo.isSelectable()) {
            menuType = DvtContextMenuHandler.TYPE_BODY_CONTEXT_MENU;
        }
        if (menuType == DvtContextMenuHandler.TYPE_BODY_CONTEXT_MENU) {
                allowContextMenu = true;
            }
        }
    if (allowContextMenu) {
        // Call the context menu handler to show the specified menu
        var menuItems = this.ContextMenuHandler.getMenuItems(menuType, menuId);
        if (menuItems) {
          for (var i=0; i<menuItems.length; i++) {
            var menuItem = menuItems[i];
            var actionTooltip = this.CustomTooltipManager.getActionTooltip();
            // Set to default border when there are context menu items launched for multple/body cases and there is no tooltip
            actionTooltip.setTooltipBorderColor(DvtCustomTooltip.DEFAULT_BORDER_COLOR);
            var listener = this.ContextMenuItemListener;
            var ttipItem = new DvtContextMenuTooltipItem(this._context, "item"+i, listener, this, menuItem);
            actionTooltip.addMenuItem(ttipItem);
          }
          return menuItems.length > 0;
        }
    }

    return false;
}

DvtEventManager.prototype._processActionPopup = function(targetObj, position) {
    // Only if action tooltip shown
    if (this.CustomTooltipManager.displayActionPopup()) {    
        this.SetupTouchTooltip(targetObj);     
        this.UpdateActionPopupShownFeedback(targetObj);
        this.CustomTooltipManager.startActionPopupAtPosition(position.x, position.y, targetObj);  
        return true;
    } else {
        this.UpdateActionPopupHiddenFeedback(targetObj);
        return false;
    }
}
/*
 * General  hooks
 */

DvtEventManager.prototype.TooltipLaunched = function(tooltip, borderColor) {
}

DvtEventManager.prototype.TooltipHidden = function() {
}

DvtEventManager.prototype.SetupTouchTooltip = function(targetObj)
{
    var obj = this.GetLogicalObject(targetObj);
    var actionTooltip = this.CustomTooltipManager.getActionTooltip();
    var tooltipBorderColor = actionTooltip.getTooltipBorderColor(); 
    // If border color wasn't overridden, get it here
    if (tooltipBorderColor == null) {
        var borderColor = this.GetTooltipColor(obj);
        actionTooltip.setTooltipBorderColor(borderColor);  
    }
}

/*
 * Mouse-related hooks
 */
DvtEventManager.prototype.OnContextMenuInternal = function(event) {
}

DvtEventManager.prototype.OnClickInternal = function(event) {
}

/*
 * Touch-related hooks
 */
DvtEventManager.prototype.HandleTouchHoverStartInternal = function(event) {
}

DvtEventManager.prototype.HandleTouchHoverMoveInternal = function(event) {
}

DvtEventManager.prototype.HandleTouchHoverEndInternal = function(event) {
} 

DvtEventManager.prototype.HandleTouchHoverOverInternal = function(event) {
}

DvtEventManager.prototype.HandleTouchHoverOutInternal = function(event) {
}

DvtEventManager.prototype.HandleTouchClickInternal = function(event) {
    return false;
}

// Action popup shown for the given target object
DvtEventManager.prototype.UpdateActionPopupShownFeedback = function(targetObj) {
}

// Action popup hidden for the given target object
DvtEventManager.prototype.UpdateActionPopupHiddenFeedback = function(targetObj) {
}

DvtEventManager.prototype.UpdateTouchHoverFeedback = function(targetObj) {
}

DvtEventManager.prototype.UpdateActionTooltipClosedFeedback = function(targetObj) {
}

DvtEventManager.prototype.UpdateActionTooltipLaunchedFeedback = function(targetObj, position) {
}

DvtEventManager.prototype.isInActionPopup = function()
{
    return this._isInActionPopup;
}

DvtEventManager.prototype.IsTooltipShowable = function(obj, pos) {
    if (!obj)
        return true;
    var tooltipRegion = this.GetTooltipsAllowedRegion(obj);
    var allowTooltips = true;
    if (tooltipRegion && !tooltipRegion.containsPoint(pos.x, pos.y)) {
        allowTooltips = false;
    }
    return allowTooltips && this.IsTooltipShowableInternal && 
        this.IsTooltipShowableInternal(obj, pos);
}

DvtEventManager.prototype.IsTooltipShowableInternal = function(obj, pos) {
    return obj.isTooltipShowable ? obj.isTooltipShowable() : true;
}

DvtEventManager.prototype.GetTooltipsAllowedRegion = function(obj) {
    return null;
}

/*
 * Useful functions
 */

/**
 * Returns a localized "Clear Selection" text.
 * @return {string}
 */
DvtEventManager.prototype.GetClearSelectionText = function() {
  return this._bundle.getTranslatedString('CLEAR_SELECTION', null);
}

// Add a clear selection popup menu item
DvtEventManager.prototype.addClearAllActionItem = function() {
    this.addActionTooltipMenuItem(DvtEventManager.CLEAR_SELECTION_ACTION_TYPE, this.GetClearSelectionText(), this._actionTooltipClearListener, this);
    var actionTooltip = this.CustomTooltipManager.getActionTooltip();
    // Override color to always be gray
    if (actionTooltip)
        actionTooltip.setTooltipBorderColor(DvtCustomTooltip.DEFAULT_BORDER_COLOR);
}

DvtEventManager.prototype.isClearMenuAllowed = function()
{
    return true;
}

// Add a menu item to the action tooltip
DvtEventManager.prototype.addActionTooltipMenuItem = function(id, text, listener, obj)
{
    var actionTooltip = this.CustomTooltipManager.getActionTooltip();
    actionTooltip.addMenuItem(new DvtCustomTooltipItem(this._context, id, text, listener, obj));
}

/*
 * Touch-related listeners
 */
// Performed after tapping a context menu item
DvtEventManager.prototype.ContextMenuItemListener = function(evt) {
    var menuItem = evt.menuItem;
    var contextMenuEvent = menuItem.getEvent();
    this._callback.call(this._callbackObj, contextMenuEvent);
}

// Performed after tapping the clear selection option in an action popup
DvtEventManager.prototype._actionTooltipClearListener = function(evt) {
    var targetObj = evt.target; 
    var dlo = this.GetLogicalObject(targetObj);
    var bSelectionChanged = this.getSelectionHandler(dlo).processClick(null, false);
    // If the selection has changed, fire an event
    if(bSelectionChanged) 
      this.fireSelectionEvent(dlo);
}

// Performed after tapping the select option in an action popup
DvtEventManager.prototype._actionTooltipSelectListener = function(evt) {
    var targetObj = evt.target; 
    var dlo = this.GetLogicalObject(targetObj);
    // Always control click for touch
    var bSelectionChanged = this.getSelectionHandler(dlo).processClick(dlo, true);
    
    // If the selection has changed, fire an event
    if(bSelectionChanged) 
      this.fireSelectionEvent(dlo);
}

DvtEventManager.prototype.setTouchRegionBounds = function(bounds) {
    this.TouchManager.setTouchRegionBounds(bounds);
}

/**
 * Stop event propagation
 */
DvtEventManager.consumeEvent = function(event) {
  if (event){
    event.preventDefault();
    //BUG FIX 13381888: stop event propagation when the event is consumed
    event.stopPropagation();
  }
};


// add the component specific context to this event, such as the clientRowKey.
DvtEventManager._addContextInfo = function(target, event) {
  // diagram
  if (target.getContextCallback && target.getContextCallbackObj) {
    var ccb = target.getContextCallback();
    var ccbo = target.getContextCallbackObj();
    if (ccb && ccbo) {
      ccb.call(ccbo, event);
    }
  }
  // graph
  else {
    // store clientRowKey
    event.addParam(DvtBaseComponentEvent.CLIENT_ROW_KEY, target.getId());
  }
}

DvtEventManager.prototype.IsPropagationEnabled = function(eventType, event, displayable) {
  return false;
}

DvtEventManager.prototype.GetCurrentTargetForEvent = function(event) {
  return this._eventInfo[event] ? this._eventInfo[event]['currentTarget'] : event.target;
}

DvtEventManager.prototype._propagateEvent = function(eventType, event, handler) {
  var obj = this.GetLogicalObject(event.target);
  if (!obj) {
    // No logical objects anywhere in the hierarchy, call handler directly
    handler.call(this, event);
  }
  else {
    var displayable = event.target;
    this._eventInfo[event] = {};
    try {
      while (displayable) {
        var logicalObject = this.GetLogicalObject(displayable, true);
        if (logicalObject) {
          this._eventInfo[event]['currentTarget'] = displayable;
          handler.call(this, event);
          if (!this.IsPropagationEnabled(eventType, event, displayable)) {
            return;
          }
        }
        displayable = displayable.getParent();
      }  
    }
    finally {
      delete this._eventInfo[event];
    }
  }
}

DvtEventManager.prototype.ConsumesClick = function(logicalObject) {
  return (logicalObject.isSelectable && logicalObject.isSelectable()) ||
         (logicalObject.isClickEventPropagationStopped && logicalObject.isClickEventPropagationStopped()) ||
         this._hasClickPopup(logicalObject) || this._hasClickClientBehavior(logicalObject);
}

DvtEventManager.prototype._hasClickPopup = function(logicalObject) {
  var behaviors = this._getShowPopupBehaviors(logicalObject);
  if(behaviors) {
    for(var i=0; i<behaviors.length; i++) {
      var behavior = behaviors[i];
      if (behavior && (behavior.getTriggerType() == DvtShowPopupBehavior.TRIGGER_TYPE_ACTION ||
                       behavior.getTriggerType() == DvtShowPopupBehavior.TRIGGER_TYPE_CLICK)) {
        return true;
      }
    }
  }
  return false;
}

/**
 * Adds a DvtComponentKeyboardHandler to process keyboard events initially 
 * received by this event manager.  Handlers are stored in tab index order and 
 * a keyboard event will be passed from one handler to the next until some 
 * handler (which might be this event manager itself) consumes the event or
 * all handlers after or before the current handler in the list have
 * had a chance to process the keyboard event.
 * 
 * @param {DvtComponentKeyboardHandler} handler 
 */
DvtEventManager.prototype.addComponentKeyboardHandler = function(handler)
{
  if(handler) {
    this._keyboardHandlers.push(handler) ;
  }
}

/**
 * Adds a DvtComponentKeyboardHandler to process keyboard events initially 
 * received by this event manager.  Handlers are stored in tab index order and 
 * a keyboard event will be passed from one handler to the next until some 
 * handler (which might be this event manager itself) consumes the event or
 * all handlers after or before the current handler in the list have
 * had a chance to process the keyboard event.
 * 
 * @param {DvtComponentKeyboardHandler} handler
 * @param {Number} index The tab index at which to add this handler
 *                 
 */
DvtEventManager.prototype.addComponentKeyboardHandlerAt = function(handler, index)
{
  // Return immediately if the current index doesn't exist
  if(index > this._keyboardHandlers.length)
    return;

  if(handler) {
    this._keyboardHandlers.splice(index, 0, handler) ;
    // maintain the pointer to the current keyboard handler
    if(index <= this._currentKeyboardHandlerIdx)
      this._currentKeyboardHandlerIdx++;
  }
}

/**
 * Removes the given DvtComponentKeyboardHandler 
 * 
 * @param {DvtComponentKeyboardHandler} handler
 *                 
 */
DvtEventManager.prototype.removeComponentKeyboardHandler = function(handler)
{
  if(handler) {
    var i = this._findHandler(handler);
    
    if(i > -1)
    {
      // if the handler to be removed is the current one and it's the
      // first handler on the list, then let the reference to the current handler point
      // to the first element in the handler list after the current handler is removed
      if(this._currentKeyboardHandlerIdx == i && i == 0)
        this._currentKeyboardHandlerIdx = 0;

      // maintain the pointer to the current keyboard handler
      else if(i <= this._currentKeyboardHandlerIdx)
          this._currentKeyboardHandlerIdx--;
                  
      this._keyboardHandlers.splice(i, 1) ;
    }
  }
}

/**
  * Returns index of specified DvtComponentKeyboardHandler in the internal list,
  * or -1 if not found. 
  * @param {DvtComponentKeyboardHandler} handler
  * @return {Number}
  * @private
  */
DvtEventManager.prototype._findHandler = function(handler)
{
  var  idx = -1 ;
  var length = this._keyboardHandlers.length;

  for(var i=0; i<length; i++)
  {
    if(this._keyboardHandlers[i] === handler)
      idx = i;
  }

  return idx ;
} 

/**
 * Updates the pointer to the current keyboard handler
 * @param {DvtComponentKeyboardHandler} handler
 * @private
 */
DvtEventManager.prototype._updateKeyboardHandlerIdx = function(handler)
{
  var idx = this._findHandler(handler);
  
  if(idx > 0)
    this._currentKeyboardHandlerIdx = idx;
}

DvtEventManager.prototype._hasClickClientBehavior = function(logicalObject) {
  var behaviors = this._getClientBehaviors(logicalObject);
  if(behaviors) {
    for(var i=0; i<behaviors.length; i++) {
      var behavior = behaviors[i];
      if (behavior && (behavior.getTriggerType() == DvtClientBehavior.TRIGGER_TYPE_ACTION ||
                       behavior.getTriggerType() == DvtClientBehavior.TRIGGER_TYPE_CLICK)) {
        return true;
      }
    }
  }
  return false;
}

DvtEventManager.prototype.CreateClientBehaviorHandler = function(context, callback, callbackObj) {
  return new DvtClientBehaviorHandler(context, callback, callbackObj);
}

/**
 * Processes the client behavior event for touch device
 * 
 * @protected
 * @param {object} obj The target of event.
 * @param {array} clientBehaviors The array of applicable client behaviors.
 * @return {boolean} true if a client behavior was triggered, false otherwise
 */
DvtEventManager.prototype.ProcessClientBehaviorForTouch = function(obj, clientBehaviors) {
  return this.ClientBehaviorHandler.processClick(obj, clientBehaviors);
}

DvtEventManager.prototype.IsDragCandidate = function(obj) {
  // subclasses should override
  return true;
}

/**
 * Generates a random ARIA active element ID
 * @return {String}
 */
DvtEventManager._getActiveElementId = function() {
  var ariaIdPrefix = '_dvtActiveElement';
  return ariaIdPrefix + Math.floor(Math.random() * 1000000000);
}

/**
 * Fires an active element change event in order to add aria-activedescendant attribute to the outer div.
 * This is needed by accessibility client in order to determine active SVG element
 * @param {object} obj The logical object corresponding to the targeted displayable.
 * @param {DvtDisplayable} displayable The displayable being targeted.
 */
DvtEventManager.prototype._fireActiveElementChangeEvent = function(obj, displayable) {
  // Find the displayable if needed
  if(!displayable) {
    if (obj.getDisplayable) 
      displayable = obj.getDisplayable();
    else if (obj.getDisplayables) 
      displayable = obj.getDisplayables()[0];
    else 
      displayable = obj;
  }
  
  // Find the displayable with the ARIA tags, by traversing ancestors if needed.  If the logical object has a deferred 
  // aria-label, then it doesn't matter which displayable is used.
  if(obj.getAriaLabel) {
    var ariaLabel = obj.getAriaLabel();
    if(ariaLabel) {
      displayable.setAriaProperty('label', ariaLabel);
      
      // If roles other than 'img' are needed, then introduce an API on the DvtLogicalObject.
      displayable.setAriaRole('img');
    }
  }
  else {
    while (!displayable.getAriaRole() && displayable.getParent()) {
      displayable = displayable.getParent();
    }
  }
  
  // Clear the previous active element
  if (this._prevActiveElement) {
    this._prevActiveElement.setId(null);
    this._prevActiveElement = null;
  }
  
  // Get the ID of the displayable. If it doesn't have an ID, create one for it.
  var id = displayable.getId();
  if (!id) {
    var ariaId = DvtEventManager._getActiveElementId();
    displayable.setId(ariaId);
    id = ariaId;
    this._prevActiveElement = displayable;
  }
  
  // Ensure that aria properties have been written to the DOM
  displayable.applyAriaProperties();
  
  // Create and fire the event
  var changeEvent = new DvtActiveElementChangeEvent(DvtActiveElementChangeEvent.CHANGE, id);
  if (this._callback)
    this._callback.call(this._callbackObj, changeEvent);
}


DvtEventManager.prototype._handlePreOverEvent = function(event) {
  var enteredHierarchy = this._getRolloverHierarchy(event.target);
  var exitedHierarchy = this._getRolloverHierarchy(event.relatedTarget);
  if (enteredHierarchy.length > 0) {
    var enteredObject = enteredHierarchy[enteredHierarchy.length - 1];
    var exitedObject = exitedHierarchy.length == 0 ? null : exitedHierarchy[exitedHierarchy.length - 1];
    if (enteredObject != exitedObject) {
      this._eventInfo[event] = {};
      try {
        this._eventInfo[event]['currentTarget'] = enteredObject;
        this.OnRollOver(event);
      }
      finally {
        delete this._eventInfo[event];
      }      
    }
  }
}

DvtEventManager.prototype._handlePreOutEvent = function(eventType, event, handler) {
  var enteredLogicalObject = this.GetLogicalObject(event.relatedTarget);
  var displayable = event.target;
  this._eventInfo[event] = {};
  try {
    // rollout
    var exitedHierarchy = this._getRolloverHierarchy(event.target);
    var enteredHierarchy = this._getRolloverHierarchy(event.relatedTarget);
    if (exitedHierarchy.length > 0) {
      var exitedObject = exitedHierarchy[exitedHierarchy.length - 1];
      var enteredObject = enteredHierarchy.length == 0 ? null : enteredHierarchy[enteredHierarchy.length - 1];
      if (exitedObject != enteredObject) {
        this._eventInfo[event]['currentTarget'] = exitedObject;
        this.OnRollOut(event);        
      }
    }

    var obj = this.GetLogicalObject(displayable);
    if (!obj) {
      // No logical objects anywhere in the hierarchy, call handler directly
      handler.call(this, event);
    }
    else {
      // mouseout
      
      //BUG FIX 15851577: pass the hierarchy of DvtDisplayables for the relatedTarget to the popup
      //handler so that it can determine whether it needs to dismiss a mousehover popup 
      //(NOTE: do this in PreOnMouseOut so that it only happens once, instead of in OnMouseOut,
      //which gets called multiple times in the loop below)
      
      // Popup Support for triggerType="hover"
      this.PopupHandler.processMouseOut(obj, this._getDisplayableHierarchy(event.relatedTarget), event);
      
      while (displayable) {
        var logicalObject = this.GetLogicalObject(displayable, true);
        if (logicalObject) {
          if (enteredLogicalObject === logicalObject) {
            // Do not mouse out of the new displayable (or its parents)
            break;
          }
          this._eventInfo[event]['currentTarget'] = displayable;
          handler.call(this, event);
          if (!this.IsPropagationEnabled(eventType, event, displayable)) {
            break;
          }
        }
        displayable = displayable.getParent();
      }
    }
  }
  finally {
    delete this._eventInfo[event];
    
    // Clear the cached stage position on mouse out.  The cache makes it significantly cheaper to access the stage
    // position, but it must only be used when the DOM position of the component is not changing.  We make this
    // assumption whenever the user is directly interacting with the component (via mouse or touch).
    if(!(event.relatedTarget instanceof DvtDisplayable))
      this._context.clearStageAbsolutePosition();
  }
}

/**
 * Gets a touch manager object
 * @return {DvtTouchManager} touch manager object
 */
DvtEventManager.prototype.getTouchManager = function () {
  return this.TouchManager;
}

/**
 * Ends a drag without specifying the final mouse/touch coordinate.
 * Used to end touch drag and to end a drag that happens outside the component area (called by AdfDhtmlDvtToolkitPeer).
 * @return {DvtBaseComponentEvent} An event, if fired.
 */
DvtEventManager.prototype.endDrag = function() {
  return null; // subclasses should override
}
/**
 * Interactivity manager for custom tooltips and menus.  The two can be visually combined.
 * @class DvtCustomTooltipManager
 * @constructor
 */
var  DvtCustomTooltipManager = function(context, id) {
  this.Init(context, id);
};

DvtObj.createSubclass(DvtCustomTooltipManager, DvtObj, "DvtCustomTooltipManager");

DvtCustomTooltipManager.ACTION_POPUP_CLASS = "OraDVTContextMenuPopup";

DvtCustomTooltipManager.prototype.Init = function(context, id) {
    this._context = context;
    this._id = id;
    this._actionTooltip = new DvtCustomTooltip(this._context, this._id+"ActionPopup");
}

/*
 * For rendering a rich tooltip
 */
DvtCustomTooltipManager.prototype.GetRichTooltipManager = function() {
    if (!this._RichTooltipManager) {
      var tooltipId = this._id+"Tooltip";
      // TODO: may want to change tooltip managers to have their own impl
      this._RichTooltipManager = this._context.getImplFactory().newRichTooltipManager(tooltipId);
      this._RichTooltipManager.InitializeTooltipElem();
      
      // Attach listeners to action tooltip displayable
      var tooltipContext = this._RichTooltipManager.GetStoredContext();
      if (tooltipContext) {
        var eh = new DvtCustomTooltipEventHandler(tooltipContext, this, null, null);
        eh.addListeners(this._actionTooltip);
      }
    }
    return this._RichTooltipManager;
}

// Clear settings on old action tooltip
DvtCustomTooltipManager.prototype.clearActionTooltip = function() {
    if (this._actionTooltip)
        this._actionTooltip.clearContent();
}

// Retrieve current action tooltip
DvtCustomTooltipManager.prototype.getActionTooltip = function() {
    return this._actionTooltip;
}

// Hide a tooltip that is currently showing
DvtCustomTooltipManager.prototype.hideTooltip = function() {
    this.clearActionTooltip();
    if (this._RichTooltipManager)
      this._RichTooltipManager.hideTooltip();
}

// Closes an action tooltip that was left on screen
DvtCustomTooltipManager.prototype.closeActionTooltip = function() {
    var closedEvent = new DvtActionTooltipEvent(DvtActionTooltipEvent.TOOLTIP_CLOSED_TYPE, this._actionPopupObj);
    this.FireListener(closedEvent);
    this._actionPopupObj = null;
    this.hideTooltip();
}

DvtCustomTooltipManager.prototype.showDatatip = function(x, y, text, borderColor) {
    var actionTooltip = this.getActionTooltip();
    text = DvtTextUtils.formatTextString(text);
    actionTooltip.setTooltipText(text);
    if (borderColor != null)
        actionTooltip.setTooltipBorderColor(borderColor);
    this.GetRichTooltipManager().showRichElement(x, y, actionTooltip, true);
}

DvtCustomTooltipManager.prototype.showTextAtPosition = function(x, y, text, borderColor, useOffset, popupClass) {
    var actionTooltip = this.getActionTooltip();
    text = DvtTextUtils.formatTextString(text);
    actionTooltip.setTooltipText(text);
    if (borderColor != null)
        actionTooltip.setTooltipBorderColor(borderColor);
    this.GetRichTooltipManager().showRichElement(x, y, actionTooltip, useOffset);
}

DvtCustomTooltipManager.prototype.displayActionPopup = function() {
    var actionTooltip = this.getActionTooltip();
    // If no action tooltip initialized with actions (not just tooltips), don't show one
    if (!actionTooltip || !actionTooltip.hasMenuItems())
        return false;
    return true;
}

DvtCustomTooltipManager.prototype.startActionPopupAtPosition = function(pageX, pageY, targetObj, alignment) {
    var actionTooltip = this.getActionTooltip();
    if (!actionTooltip)
        return;

    this.GetRichTooltipManager().showRichElementAtPosition(pageX, pageY, actionTooltip, true, false, DvtCustomTooltipManager.ACTION_POPUP_CLASS);
    
    // Clear the text
    var startEvent = new DvtActionTooltipEvent(DvtActionTooltipEvent.TOOLTIP_STARTED_TYPE, targetObj);
    this.FireListener(startEvent);

    this._actionPopupObj = targetObj;

}

/**
 * Adds an event listener.
 **/
DvtCustomTooltipManager.prototype.addTooltipEventListener = function (type, listener, obj) {
  // Store a reference to the listener
  var listenersArray = this._getListeners(type, true);
  listenersArray.push(listener);
  listenersArray.push(obj);
}

/**
 * Removes an event listener.
 **/
DvtCustomTooltipManager.prototype.removeTooltipEventListener = function (type, listener, obj) {
  // Remove the listener
  var listenersArray = this._getListeners(type, false);
  if (listenersArray !== null) {
    for (var i = 0;i < listenersArray.length;i+=2) {
      if (listenersArray[i] === listener && 
           listenersArray[i+1] === obj) {
        listenersArray.splice(i, 2);
        break;
      }
    }
  }
}

/**
 * Returns the listeners of the given event type
 **/
DvtCustomTooltipManager.prototype._getListeners = function (type, createNew) {
  // First find the object where the listener arrays are stored
  if (!this._listenerObj) {
    if (createNew) {
      this._listenerObj = {
      };
    }
    else {
      return null;
    }
  }

  // Then find the array for this event type, creating if necessary 
  var eventKey = type;
  var listenersArray = this._listenerObj[eventKey];
  if (!listenersArray && createNew) {
    listenersArray = [];
    this._listenerObj[eventKey] = listenersArray;
  }

  return listenersArray;
};

/**
 * Notifies all applicable event listeners of the given event.
 **/
DvtCustomTooltipManager.prototype.FireListener = function (event) {
  var listenersArray = this._getListeners(event.getType(), false);
  if (listenersArray) {
    for (var i = 0;i < listenersArray.length;i+=2) {
      var obj = listenersArray[i+1];
      listenersArray[i].call(obj, event);
    }
  }
};
// Custom tooltip event handler
/**
 * @constructor
 */
var  DvtCustomTooltipEventHandler = function(context, customTooltipManager, callback, callbackObj)
{
   this._customTooltipManager = customTooltipManager;
   this.Init(context, callback, callbackObj);

}

DvtObj.createSubclass(DvtCustomTooltipEventHandler, DvtEventManager, "DvtCustomTooltipEventHandler");

DvtCustomTooltipEventHandler.prototype.OnClickInternal = function(event) {
    var target = event.target;
    this._handleMenuClick(target);
}

DvtCustomTooltipEventHandler.prototype.HandleImmediateTouchStartInternal = function(event, touch) {
    event.blockTouchHold();
}

DvtCustomTooltipEventHandler.prototype.HandleTouchClickInternal = function(evt) {
    var target = evt.target;
    this._handleMenuClick(target);
}

DvtCustomTooltipEventHandler.prototype._handleMenuClick = function(targetObj) {
    var actionObj = this._customTooltipManager._actionPopupObj;
    var menuItem = targetObj._menu;
    if (menuItem) {
        var fireAction = true;
        if (menuItem instanceof DvtContextMenuTooltipItem && menuItem._menuItem.isDisabled()) {
            fireAction = false;
        }
        if (fireAction) {
            // Close before menu item event fired since listener may need restored component visual state
            this._customTooltipManager.closeActionTooltip();
            menuItem.FireActionTooltipItem(actionObj);
        }
    }
}
/*--------------------------------------------------------------------*/
/*   DvtCustomTooltip              Action tooltip Component           */
/*--------------------------------------------------------------------*/
/**
  * @constructor
  *  Action tooltip component.
  *  @extends DvtObj
  *  @class DvtCustomTooltip  Creates an action tooltip component.
  */
var   DvtCustomTooltip = function(context, id)
{
    this._Init(context, id);
}  

DvtObj.createSubclass(DvtCustomTooltip, DvtContainer, "DvtCustomTooltip");

DvtCustomTooltip.DEFAULT_BORDER_COLOR = "gray";
DvtCustomTooltip.DEFAULT_BACKGROUND_COLOR = "#ffffff";

DvtCustomTooltip.TOOLTIP_ONLY = "tooltipOnly";
DvtCustomTooltip.MENU_ONLY = "menuOnly";
DvtCustomTooltip.MENU_AND_TOOLTIP = "menuAndTooltip";
DvtCustomTooltip.EMPTY = "empty";

DvtCustomTooltip.MENU_PADDING_LEFT = 21;
DvtCustomTooltip.MENU_PADDING_RIGHT = 10;

DvtCustomTooltip.prototype._Init = function(context, id)
{

    this._context = context;
    if (! this.getImpl()) {
     this.setImpl(context.getImplFactory().newContainer("customTT")) ;
    }
    DvtCustomTooltip.superclass.Init.call(this, context) ;

    this._tooltipText = null;
    this._tooltipBorderColor = null;
    this._menuFontSize = 11;
    this._tooltipFill = new DvtSolidFill(DvtCustomTooltip.DEFAULT_BACKGROUND_COLOR);    
    this._fontSize = 11; // TODO: This shouldn't be hard coded, but this maintains the existing behavior
    this._includePointer = false;//true;
    this._pointerLocation = new DvtPoint(0,0);
}

DvtCustomTooltip.prototype.setIncludePointer = function(includePointer)
{
    this._includePointer = includePointer;
}

DvtCustomTooltip.prototype.getRootDisplayable = function()
{
    return this;
}

DvtCustomTooltip.prototype.UpdateTooltipSize = function(width, height)
{
    this._displayWidth = width;
    this._displayHeight = height;
}

DvtCustomTooltip.prototype.getDisplayWidth = function() {
   return this._displayWidth;
}

DvtCustomTooltip.prototype.getDisplayHeight = function() {
   return this._displayHeight;
}

DvtCustomTooltip.prototype.clearContent = function() {
    this.clearMenuItems();
    this.setTooltipBorderColor(null);  
    this.setTooltipText(null);
}

DvtCustomTooltip.prototype.setMenuFontSize = function(font) {
    this._menuFontSize = font;
}

DvtCustomTooltip.prototype.setTooltipBorderColor = function(color) {
    this._tooltipBorderColor = color;
}

DvtCustomTooltip.prototype.getTooltipBorderColor = function() {
    return this._tooltipBorderColor;
}

DvtCustomTooltip.prototype.setTooltipFill = function(tooltipFill) {
    this._tooltipFill = tooltipFill;
}

DvtCustomTooltip.prototype.setTooltipText = function(text) {
    this._tooltipText = text;
}

DvtCustomTooltip.prototype.getTooltipText = function() {
    return this._tooltipText;
}

DvtCustomTooltip.prototype.addMenuItem = function(menuItem) {
    this.getMenuItems().push(menuItem);
}

DvtCustomTooltip.prototype.hasMenuItems = function() {
    var menuItems = this.getMenuItems();
    return menuItems && menuItems.length > 0;
}

DvtCustomTooltip.prototype.hasTooltip = function() {
    return false;
}

DvtCustomTooltip.prototype.clearMenuItems = function() {
    if (this._menuItems) {
        this._menuItems = [];
    }
}

DvtCustomTooltip.prototype.getMenuItems = function() {
    if (!this._menuItems)
        this._menuItems = new Array();
    return this._menuItems;
}

DvtCustomTooltip.prototype.containsMenuId = function(id) {
    var menuItems = this.getMenuItems();
    for (var i=0; i<menuItems.length; i++) {
        var menuItem = menuItems[i];
        if (menuItem.getId() == id) {
            return true;
        }
    }
    return false;
}

DvtCustomTooltip.prototype.getTooltipType = function() {
    var hasMenuItems = this.hasMenuItems();
    var hasTooltip = this.hasTooltip();
    if (hasMenuItems && hasTooltip) {
        return DvtCustomTooltip.MENU_AND_TOOLTIP;
    }
    if (hasMenuItems) {
        return DvtCustomTooltip.MENU_ONLY;
    }
    if (hasTooltip) {
        return DvtCustomTooltip.TOOLTIP_ONLY;
    }
    return DvtCustomTooltip.EMPTY;
}

/**
 * Renders this action tooltip.
 */
DvtCustomTooltip.prototype.Render = function() {

    var parent = this.getRootDisplayable();
    //parent.setPixelHinting(true);
    // First clear old drawables    
    parent.removeChildren();

    var type = this.getTooltipType();
    if (type == DvtCustomTooltip.EMPTY) {
        return;
    }
    
    // Constants
    var padding = 4;
    var menuItemPadding = 5;
    var tooltipBorderWidth = 2;

    if (this._includePointer) {
        tooltipBorderWidth = 3;
        padding = 10;
    }
            
    // Temp variables
    var hasMenuItems = this.hasMenuItems();
    var hasTooltip = this.hasTooltip();
    var topTextY = padding + tooltipBorderWidth/2;
    var runningHeight = 0;
    var maxWidth = 0;
    
    if (type == DvtCustomTooltip.TOOLTIP_ONLY) {
        parent.setAlpha(0.9);
    } else {
        parent.setAlpha(1);
    }

    if (hasTooltip) {
        
        var cursorText = new DvtMultilineText(this._context, 0, 0);
        parent.addChild(cursorText);
        cursorText.alignBaseline();
        cursorText.setMaxWidth(100000000);
        cursorText.setMouseEnabled(true);

        // There is a bug in Firefox and IE9 with aligning to top in SVG.
        // Wait until a feasible fix is in the toolkit for alignTop API.  For now the baseline is used.
        //  cursorText.alignTop();
        cursorText.alignBaseline();
        cursorText.alignLeft();
        
        cursorText.setTranslateY(this._fontSize + padding+tooltipBorderWidth/2);

        this._cursorText = cursorText;
    
        this._cursorText.removeChildren();
        this._cursorText.setText(this._tooltipText);
    
        var textDimensions = this._cursorText.getDimensions();
        var textHeight = textDimensions.h;
        var textWidth = textDimensions.w;
        maxWidth = Math.max(textWidth, maxWidth);
        runningHeight += textHeight;
    }

    var textItems = new Array();
    var textWidths = new Array();
    
    if (type == DvtCustomTooltip.MENU_AND_TOOLTIP) {
        runningHeight += menuItemPadding;
    } else if (type == DvtCustomTooltip.MENU_ONLY) {
        runningHeight += menuItemPadding/2;        
    }
    
    if (hasMenuItems) {


        var menuItems = this.getMenuItems();
        for (var i=0; i<menuItems.length; i++) {
            var menuItem = menuItems[i];

            var text = new DvtOutputText(this._context, menuItem.getText(), 0, 0, null); 
            text.alignBaseline();
            text.setFontSize(this._menuFontSize);
            
            if (menuItem instanceof DvtContextMenuTooltipItem) {
                if (menuItem._menuItem.isDisabled()) {
                    text.setAlpha(0.5);                
                }
            }

            text._menu = menuItem;
            
            var dimensions = text.measureDimensions();
            dimensions.y = topTextY+runningHeight;
            var textWidth = dimensions.w;
            textWidths.push(dimensions);
            maxWidth = Math.max(textWidth + DvtCustomTooltip.MENU_PADDING_LEFT + DvtCustomTooltip.MENU_PADDING_RIGHT, maxWidth);
            text.setY(dimensions.y);
            runningHeight += dimensions.h;
    
            if (i < menuItems.length - 1) {
                runningHeight += menuItemPadding;
            }
            
            textItems.push(text);        
            text.alignLeft();
            text.alignTop();
        }

    }
    if (type == DvtCustomTooltip.MENU_ONLY || type == DvtCustomTooltip.MENU_AND_TOOLTIP) {
        runningHeight += menuItemPadding/2;        
    }
    
    var contentWidth = maxWidth + 2*padding;
    var tooltipWidth = contentWidth + tooltipBorderWidth;
    var tooltipHeight = topTextY + runningHeight + padding + tooltipBorderWidth/2; 
    
    if (this._cursorText)
        this._cursorText.setTranslateX(padding + tooltipBorderWidth/2);

    var pointerWidth = 12;
    var isRightPointer = (this._pointerLocation.x > tooltipWidth);
    var pointerOffsetX = -this._pointerLocation.x;
    var pointerOffsetY = this._pointerLocation.y;

    if (this._includePointer) {

        if (tooltipHeight/2 < pointerWidth)
            pointerWidth = tooltipHeight/3;

        var newTooltipHeight = tooltipHeight + tooltipBorderWidth;
        newTooltipHeight = Math.max(pointerOffsetY + tooltipBorderWidth, newTooltipHeight);
        var transX;
        if (isRightPointer) {
            this.UpdateTooltipSize(this._pointerLocation.x, newTooltipHeight);
            transX = tooltipBorderWidth/2;
        } else {
            this.UpdateTooltipSize(tooltipWidth+pointerOffsetX+tooltipBorderWidth, newTooltipHeight);
            transX = tooltipBorderWidth/2 + pointerOffsetX;
        }
        parent.setTranslate(transX, tooltipBorderWidth/2);
    } else {
        this.UpdateTooltipSize(tooltipWidth + tooltipBorderWidth, tooltipHeight + tooltipBorderWidth);
        parent.setTranslate(tooltipBorderWidth/2, tooltipBorderWidth/2);
    }

        
    // Add background panels
    var backgroundPanel = new DvtRect(this._context, 0, 0, tooltipWidth, tooltipHeight);
    if (this._includePointer) {

        var radius = 5;
        var beginArrowY = tooltipHeight/2; 

        if (isRightPointer) {
            //this._pointerStartOffset;
            var p1 = new DvtPoint(0, 0);
            var p2 = new DvtPoint(tooltipWidth, 0);
            var p3 = new DvtPoint(tooltipWidth, beginArrowY);
            var p4 = new DvtPoint(this._pointerLocation.x, pointerOffsetY);
            var p5 = new DvtPoint(tooltipWidth, beginArrowY + pointerWidth);
            var p6 = new DvtPoint(tooltipWidth, tooltipHeight);
            var p7 = new DvtPoint(0, tooltipHeight);
    
            var cmd = DvtPathUtils.moveTo(p1.x + radius,p1.y) + 
                DvtPathUtils.lineTo(p2.x - radius,p2.y) + 
                DvtPathUtils.arcTo(radius,radius,Math.PI/2, 1, p2.x, p2.y + radius) + 
                DvtPathUtils.lineTo(p3.x,p3.y) + 
                DvtPathUtils.lineTo(p4.x,p4.y) + 
                DvtPathUtils.lineTo(p5.x,p5.y) + 
                DvtPathUtils.lineTo(p6.x,p6.y - radius) + 
                DvtPathUtils.arcTo(radius,radius,Math.PI/2, 1, p6.x - radius, p6.y) + 
                DvtPathUtils.lineTo(p7.x + radius,p7.y) + 
                DvtPathUtils.arcTo(radius,radius,Math.PI/2, 1, p7.x, p7.y - radius) + 
                DvtPathUtils.lineTo(0,radius) + 
                DvtPathUtils.arcTo(radius,radius,Math.PI/2, 1, radius, 0) + 
                DvtPathUtils.closePath();
             backgroundPanel = new DvtPath(this._context, cmd, null);
        } else {
            //this._pointerStartOffset;
            var p1 = new DvtPoint(0, 0);
            var p2 = new DvtPoint(tooltipWidth, 0);
            var p3 = new DvtPoint(tooltipWidth, tooltipHeight);
            var p4 = new DvtPoint(0, tooltipHeight);
            var p5 = new DvtPoint(0, beginArrowY + pointerWidth);
            var p6 = new DvtPoint(-pointerOffsetX, pointerOffsetY);
            var p7 = new DvtPoint(0, beginArrowY);
    
            var cmd = DvtPathUtils.moveTo(p1.x + radius,p1.y) + 
                DvtPathUtils.lineTo(p2.x - radius,p2.y) + 
                DvtPathUtils.arcTo(radius,radius,Math.PI/2, 1, p2.x, p2.y + radius) + 
                DvtPathUtils.lineTo(p3.x,p3.y - radius) + 
                DvtPathUtils.arcTo(radius,radius,Math.PI/2, 1, p3.x - radius, p3.y) + 
                DvtPathUtils.lineTo(p4.x + radius,p4.y) + 
                DvtPathUtils.arcTo(radius,radius,Math.PI/2, 1, p4.x, p4.y - radius) + 
                DvtPathUtils.lineTo(p5.x,p5.y) + 
                DvtPathUtils.lineTo(p6.x,p6.y) + 
                DvtPathUtils.lineTo(p7.x,p7.y) + 
                DvtPathUtils.lineTo(0,radius) + 
                DvtPathUtils.arcTo(radius,radius,Math.PI/2, 1, radius, 0) + 
                DvtPathUtils.closePath();
             backgroundPanel = new DvtPath(this._context, cmd, null);
        }
    }

    if (hasTooltip) {
        var borderColor = this._tooltipBorderColor;
        if (!borderColor) {
            borderColor = DvtCustomTooltip.DEFAULT_BACKGROUND_COLOR;
        }
        backgroundPanel.setSolidStroke(borderColor, 1, tooltipBorderWidth);
    } else {
        backgroundPanel.setSolidStroke("rgb(229,232,238)");
    }
    
    if (!this._tooltipFill)
        this._tooltipFill = new DvtSolidFill(DvtCustomTooltip.DEFAULT_BACKGROUND_COLOR);
    backgroundPanel.setFill(this._tooltipFill);
    parent.addChildAt(backgroundPanel, 0);

    var dividerWidth = contentWidth*0.95;
    var dividerX = (tooltipWidth - dividerWidth)/2;
    // Add text items
    for (var i=0; i<textItems.length; i++) {
        var textItem = textItems[i];
        parent.addChild(textItem);
        var textWidth = textWidths[i].w;
        if (textItem._menu) {
            // Menus have target areas
            var hitAreaRect = new DvtRectangle(0, textWidths[i].y - menuItemPadding/2, tooltipWidth, textWidths[i].h + menuItemPadding); 
            //hitAreaRect = DvtGeomUtils.getSpecificPaddedRectangle(hitAreaRect, 4, 4, 10, 10);
            var hitTarget = new DvtRect(this._context, hitAreaRect.x, hitAreaRect.y, hitAreaRect.w, hitAreaRect.h);
            hitTarget.setInvisibleFill();

            hitTarget._menu = textItem._menu;
            parent.addChild(hitTarget);

            if (i == 0 && hasTooltip) {
                var fill = new DvtSolidFill("gray", 1);
                // show division between menu and tooltip
                this.renderDivider(parent, dividerX, textWidths[i].y - menuItemPadding, dividerWidth, fill);
            } else if (i > 0) {
                var menuItemObj = textItem._menu._menuItem;
                
                var prevItem = textItems[i-1];

                if (prevItem._menu instanceof DvtContextMenuTooltipItem) {
                    //Separators between context menu items
                    if (menuItemObj.hasSeparatorBefore()) {
                        var fill = new DvtSolidFill("gray", 0.5);
                        this.renderDivider(parent, dividerX, textWidths[i].y - menuItemPadding/2, dividerWidth, fill);
                    }
                } else {
                    // First context menu item, show a division between this and built in actions
                    //var fill = new DvtSolidFill("gray", 1);
                    //this.renderDivider(parent, dividerX, textWidths[i].y - menuItemPadding/2, dividerWidth, fill);
                }
            }
        }
        textItem.setTranslateX(DvtCustomTooltip.MENU_PADDING_LEFT);
    }
}

DvtCustomTooltip.prototype.renderDivider = function(parent, x, y, width, fill) {
    var divider = new DvtRect(this._context, x, y, width, 1);
    divider.setFill(fill);
    parent.addChild(divider);
}

/*--------------------------------------------------------------------*/
/*   DvtCustomTooltipItem              Action tooltip item            */
/*--------------------------------------------------------------------*/
/**
  *  Logical action tooltip item.  No dependency on drawables
  *  @extends DvtObj
  *  @class DvtCustomTooltipItem  Creates an action tooltip item.
  *  @constructor  
  */
var   DvtCustomTooltipItem = function(context, id, text, listener, listenerObj)
{
    this.Init(context, id, text, listener, listenerObj);
}  

DvtObj.createSubclass(DvtCustomTooltipItem, DvtObj, "DvtCustomTooltipItem");

DvtCustomTooltipItem.prototype.Init = function(context, id, text, listener, listenerObj) {
    this._context = context;
    this._id = id;
    this._text = text;
    this._listener = listener;
    this._listenerObj = listenerObj;
}

DvtCustomTooltipItem.prototype.getId = function() {
    return this._id;
}

DvtCustomTooltipItem.prototype.getText = function() {
    return this._text;
}

DvtCustomTooltipItem.prototype.FireActionTooltipItem = function(target) {
    if (this._listenerObj && this._listener) {
        var evt = new Object();
        evt.target = target;
        evt.menuItem = this._menuItem;
        this._menuItemTimer = new DvtTimer(this._context, 1, this._handleMenuTimer, this);
        // store event on timer temporarily
        this._menuItemTimer.evt = evt;
        this._menuItemTimer.start();
    }
}

// Timer handler for menu item listener
DvtCustomTooltipItem.prototype._handleMenuTimer = function() {
    if (this._menuItemTimer) {
        this._menuItemTimer.stop();
    }
    this._listener.call(this._listenerObj, this._menuItemTimer.evt);
}

/**
 * @constructor
 */
var   DvtContextMenuTooltipItem = function(context, id, listener, listenerObj, menuItem)
{
    this.Init(context, id, listener, listenerObj, menuItem);
}  

DvtObj.createSubclass(DvtContextMenuTooltipItem, DvtCustomTooltipItem, "DvtContextMenuTooltipItem");

DvtContextMenuTooltipItem.prototype.Init = function(context, id, listener, listenerObj, menuItem) {
    DvtContextMenuTooltipItem.superclass.Init.call(this, context, id, menuItem.getText(), listener, listenerObj);
    this._menuItem = menuItem;
}
/**
 * @constructor
 */
var DvtBaseScroller= function(context, w, h, id)
{

  this.Init(context, w, h, id);
}

DvtObj.createSubclass(DvtBaseScroller, DvtContainer, "DvtBaseScroller");

// The type of upState to display
DvtBaseScroller.TYPE_DISABLED = 0;
DvtBaseScroller.TYPE_ENABLED = 1;
DvtBaseScroller.TYPE_ACTIVE = 2;

// Width and Height of the scroller symbol
DvtBaseScroller.SYMBOL_WIDTH = 11;
DvtBaseScroller.SYMBOL_HEIGHT = 5;
DvtBaseScroller.BUTTON_CORNER_RADIUS = 0;

DvtBaseScroller.UP_BORDER_COLOR = "#858585";
DvtBaseScroller.UP_FILL_COLOR = "#FFFFFF";
DvtBaseScroller.OVER_BORDER_COLOR = "#7BA0D9";
DvtBaseScroller.OVER_FILL_COLORS = ["#BFD8FB", "#FFFFFF"];
DvtBaseScroller.OVER_FILL_ALPHAS = [100, 100];
DvtBaseScroller.OVER_FILL_RATIOS = [0, 255];
    
DvtBaseScroller.DOWN_BORDER_COLOR = "#69849E";
DvtBaseScroller.DOWN_FILL_COLORS= ["#ACB9CA", "#7488A5"];
DvtBaseScroller.DOWN_FILL_ALPHAS = [100, 100];
DvtBaseScroller.DOWN_FILL_RATIOS = [0, 255];
    
DvtBaseScroller.SYMBOL_BORDER_COLOR_UP = "#46566C"; 
DvtBaseScroller.SYMBOL_BORDER_COLOR_OVER = "#858585";     
DvtBaseScroller.SYMBOL_BORDER_COLOR_DOWN = "#858585";  
DvtBaseScroller.SYMBOL_BORDER_COLOR_DISABLED = "#999999"; 
DvtBaseScroller.SYMBOL_FILL_COLOR_UP = "#625D5D"; //0x333333
DvtBaseScroller.SYMBOL_FILL_COLOR_OVER = "#46566C";     
DvtBaseScroller.SYMBOL_FILL_COLOR_DOWN = "#FFFFFF"; 
DvtBaseScroller.SYMBOL_FILL_COLOR_UP_DISABLED = "#999999"; 

DvtBaseScroller.prototype.Init = function(context, w, h, id){
    this._context = context;
    
    var container = new DvtContainer(context, "legendScroller_" + id);
    var impl = container.getImpl();
    DvtBaseScroller.superclass.Init.call(this, context, null, impl.getId());
    
    this._width = w;
    this._height = h;

    
    if (DvtAgent.isTouchDevice()) {
        var back = this._createTouchArea();
        this.addChild(back);      
    }

    this.drawUpState();
    
}


DvtBaseScroller.prototype.addMouseEventHandlers = function(){
    this.addEvtListener(DvtMouseEvent.MOUSEOUT, this.mouseOutHandler, false, this);
    this.addEvtListener(DvtMouseEvent.MOUSEOVER, this.mouseOverHandler, false, this);
}

DvtBaseScroller.prototype.mouseOverHandler = function(event){
    if(this._upStateType == DvtBaseScroller.TYPE_ENABLED)
        this.drawOverState();
}
DvtBaseScroller.prototype.mouseOutHandler = function(event){
    if(this._upStateType == DvtBaseScroller.TYPE_ENABLED)
        this.drawUpState();
}

DvtBaseScroller.prototype.drawUpState = function(){
    if(this._upStateType == DvtBaseScroller.TYPE_ENABLED){
        return this.drawEnabledState();
    }
    else if(this._upStateType == DvtBaseScroller.TYPE_ACTIVE){
        return this.drawActiveState();
    }
    else
        return this.drawDisabledState();
}

DvtBaseScroller.prototype.drawEnabledState = function(){
    if(this._upStateType !== DvtBaseScroller.TYPE_DISABLED){
        if(!this._button){
            this._button = this._drawButtonShape();
            this.addChild(this._button);
        }
        if(!this._upButton){
          this._upButton = this._drawUpButtonShape();
          this.addChild(this._upButton);
        }
        if(!this._pointer){
          this._pointer = this._drawSymbol();
          this.addChild(this._pointer);
        }
    }
      

    this._button.setAlpha(0.001);
    this._upButton.setAlpha(1);
    
    // Although the button is invisible when first loading
    // We still need to set the fill or stroke, so it can respond to mouse event
    this._button.setInvisibleFill();
    
    var buttonStroke = new DvtSolidStroke(DvtBaseScroller.UP_BORDER_COLOR, 1);
    this._upButton.setStroke(buttonStroke);
    
    var pointerStroke = new DvtSolidStroke(DvtBaseScroller.SYMBOL_BORDER_COLOR_UP, 1);
    var pointerFill = new DvtSolidFill(DvtBaseScroller.SYMBOL_FILL_COLOR_UP, 1);
    this._pointer.setFill(pointerFill);
    this._pointer.setStroke(pointerStroke);
    
    return;
}

DvtBaseScroller.prototype.drawActiveState = function(){
    if(this._upStateType !== DvtBaseScroller.TYPE_DISABLED){
        if(!this._button){
            this._button = this._drawButtonShape();
            this.addChild(this._button);
        }
        if(!this._upButton){
          this._upButton = this._drawUpButtonShape();
          this.addChild(this._upButton);
        }
        if(!this._pointer){
          this._pointer = this._drawSymbol();
          this.addChild(this._pointer);
        }
        
        this._upButton.setAlpha(0.001);
        this._button.setAlpha(1);
        
        var buttonStroke = new DvtSolidStroke(DvtBaseScroller.UP_BORDER_COLOR, 1);
        var buttonFill = new DvtSolidFill(DvtBaseScroller.UP_FILL_COLOR, 1);
        this._button.setStroke(buttonStroke);
        this._button.setFill(buttonFill);
        
        var pointerStroke = new DvtSolidStroke(DvtBaseScroller.SYMBOL_BORDER_COLOR_UP, 1);
        var pointerFill = new DvtSolidFill(DvtBaseScroller.SYMBOL_FILL_COLOR_UP, 1);
        this._pointer.setFill(pointerFill);
        this._pointer.setStroke(pointerStroke);
    }
    
    return;
}

DvtBaseScroller.prototype.drawDisabledState = function(){
    if(!this._button){
        this._button = this._drawButtonShape();
        this.addChild(this._button);
    }
    if(!this._upButton){
      this._upButton = this._drawUpButtonShape();
      this.addChild(this._upButton);
    }
    if(!this._pointer){
      this._pointer = this._drawSymbol();
      this.addChild(this._pointer);
    }
    
    this._button.setAlpha(0.001);
    this._upButton.setAlpha(1);
    
    var buttonStroke = new DvtSolidStroke(DvtBaseScroller.SYMBOL_FILL_COLOR_UP_DISABLED, 1);
    this._upButton.setStroke(buttonStroke);
    
    var pointerStroke = new DvtSolidStroke(DvtBaseScroller.SYMBOL_BORDER_COLOR_DISABLED, 1);
    var pointerFill = new DvtSolidFill(DvtBaseScroller.SYMBOL_FILL_COLOR_UP_DISABLED, 1);
    this._pointer.setFill(pointerFill);
    this._pointer.setStroke(pointerStroke);
    
    return;
}

DvtBaseScroller.prototype.drawOverState = function(){
    if(this._upStateType !== DvtBaseScroller.TYPE_DISABLED){
        if(!this._button){
            this._button = this._drawButtonShape();
            this.addChild(this._button);
        }
        if(!this._upButton){
          this._upButton = this._drawUpButtonShape();
          this.addChild(this._upButton);
        }
        if(!this._pointer){
          this._pointer = this._drawSymbol();
          this.addChild(this._pointer);
        }
    
        this._upButton.setAlpha(0.001);
        this._button.setAlpha(1);
          
        var buttonFill = new DvtLinearGradientFill(90, DvtBaseScroller.OVER_FILL_COLORS);
        var buttonStroke = new DvtSolidStroke(DvtBaseScroller.OVER_BORDER_COLOR, 1);
        this._button.setFill(buttonFill);
        this._button.setStroke(buttonStroke);
        
        var pointerStroke = new DvtSolidStroke(DvtBaseScroller.SYMBOL_BORDER_COLOR_OVER, 1);
        var pointerFill = new DvtSolidFill(DvtBaseScroller.SYMBOL_FILL_COLOR_OVER, 1);
        this._pointer.setFill(pointerFill);
        this._pointer.setStroke(pointerStroke);
    }
    return;
}
/*--------------------------------------------------------------------*/
/*  init()                                                            */
/*--------------------------------------------------------------------*/
/**
 *    Implementation of DvtDetObj.init()
 */
DvtBaseScroller.prototype.init = function()
{

}

DvtBaseScroller.prototype._drawSymbol = function(){

}

DvtBaseScroller.prototype._drawUpButtonShape = function(){

}

DvtBaseScroller.prototype._drawButtonShape = function(){
    var buttonCmds = DvtPathUtils.moveTo(DvtBaseScroller.BUTTON_CORNER_RADIUS, 0)+
    DvtPathUtils.lineTo(this._width - DvtBaseScroller.BUTTON_CORNER_RADIUS, 0)+
    DvtPathUtils.quadTo(this._width, 0, this._width, DvtBaseScroller.BUTTON_CORNER_RADIUS)+
      DvtPathUtils.lineTo(this._width, DvtBaseScroller.BUTTON_CORNER_RADIUS)+
      DvtPathUtils.lineTo(this._width, this._height - DvtBaseScroller.BUTTON_CORNER_RADIUS)+
      DvtPathUtils.quadTo(this._width, this._height, this._width - DvtBaseScroller.BUTTON_CORNER_RADIUS, this._height)+
      DvtPathUtils.lineTo(this._width - DvtBaseScroller.BUTTON_CORNER_RADIUS, this._height)+
      DvtPathUtils.lineTo(DvtBaseScroller.BUTTON_CORNER_RADIUS, this._height)+
      DvtPathUtils.quadTo(0, this._height, 0, this._height - DvtBaseScroller.BUTTON_CORNER_RADIUS)+
      DvtPathUtils.lineTo(0, this._height - DvtBaseScroller.BUTTON_CORNER_RADIUS)+
      DvtPathUtils.lineTo(0, DvtBaseScroller.BUTTON_CORNER_RADIUS)+
      DvtPathUtils.quadTo(0, 0, DvtBaseScroller.BUTTON_CORNER_RADIUS, 0)+
      DvtPathUtils.lineTo(DvtBaseScroller.BUTTON_CORNER_RADIUS, 0);
    DvtPathUtils.closePath();
    var button = new DvtPath(this._context, buttonCmds);
    button.setCursor(DvtSelectionEffectUtils.getSelectingCursor());
    button.setPixelHinting(true);
    return button;
}

DvtBaseScroller.prototype.setUpStateType = function(type){
    this._upStateType = type;
    if(type == DvtBaseScroller.TYPE_DISABLED){
        this.drawDisabledState();
    } else {
        this.drawUpState();
    }
}
var DvtUpScroller = function(context, w, h, id) {
    DvtUpScroller.superclass.Init.call(this, context, w, h, id);
}

DvtObj.createSubclass(DvtUpScroller, DvtBaseScroller, "DvtUpScroller");

DvtUpScroller.prototype._drawSymbol = function(){
    // Position container
    var symbolX = (this._width/2) - (DvtBaseScroller.SYMBOL_WIDTH/2);
    var symbolY = (this._height/2) - (DvtBaseScroller.SYMBOL_HEIGHT/2);


    // Arrow
    var pointerCmds = DvtPathUtils.moveTo(symbolX + DvtBaseScroller.SYMBOL_WIDTH/2, symbolY) + 
              DvtPathUtils.lineTo(symbolX+DvtBaseScroller.SYMBOL_WIDTH, symbolY + DvtBaseScroller.SYMBOL_HEIGHT) + 
              DvtPathUtils.lineTo(symbolX, symbolY+DvtBaseScroller.SYMBOL_HEIGHT) + 
              DvtPathUtils.lineTo(symbolX+DvtBaseScroller.SYMBOL_WIDTH/2, symbolY);
              DvtPathUtils.closePath();
    var pointer = new DvtPath(this._context, pointerCmds);
    var dataCursorArrowFill = new DvtSolidFill("rgb(193, 194, 211)", 1);
    pointer.setFill(dataCursorArrowFill);
    this._pointer = pointer;
    pointer.setCursor(DvtSelectionEffectUtils.getSelectingCursor());
    return pointer;
}

DvtUpScroller.prototype._drawUpButtonShape = function(){
        var buttonCmds = DvtPathUtils.moveTo(0, this._height)+
        DvtPathUtils.lineTo(this._width, this._height)+
        DvtPathUtils.moveTo(0, 0);
    DvtPathUtils.closePath();
    var button = new DvtPath(this._context, buttonCmds);
    var buttonFill = new DvtSolidFill("rgb(19, 180, 200)", 1);
    button.setFill(buttonFill);
    var buttonStroke = new DvtSolidStroke("rgb(19, 180, 200)", 1);
    button.setStroke(buttonStroke);
    button.setPixelHinting(true);
    return button;
}

DvtUpScroller.prototype._createTouchArea = function(){
    var back = new DvtRect(this._context, 0, -15, this._width, this._height + 15);
    back.setInvisibleFill();
    return back;
}
var DvtDownScroller = function(context, w, h, id) {
    DvtDownScroller.superclass.Init.call(this, context, w, h, id);
}

DvtObj.createSubclass(DvtDownScroller, DvtBaseScroller, "DvtDownScroller");

DvtDownScroller.prototype._drawSymbol = function(){
    // Position container
    var symbolX = (this._width/2) - (DvtBaseScroller.SYMBOL_WIDTH/2);
    var symbolY = (this._height/2) - (DvtBaseScroller.SYMBOL_HEIGHT/2);


    // Arrow
    var pointerCmds = DvtPathUtils.moveTo(symbolX, symbolY) + 
              DvtPathUtils.lineTo(symbolX+DvtBaseScroller.SYMBOL_WIDTH, symbolY) + 
              DvtPathUtils.lineTo(symbolX+DvtBaseScroller.SYMBOL_WIDTH/2, symbolY+DvtBaseScroller.SYMBOL_HEIGHT) + 
              DvtPathUtils.lineTo(symbolX, symbolY);
              DvtPathUtils.closePath();
    var pointer = new DvtPath(this._context, pointerCmds);
    var dataCursorArrowFill = new DvtSolidFill("rgb(193, 194, 211)", 1);
    pointer.setFill(dataCursorArrowFill);
    this._pointer = pointer;
    pointer.setCursor(DvtSelectionEffectUtils.getSelectingCursor());
    return pointer;
}

DvtDownScroller.prototype._drawUpButtonShape = function(){
        var buttonCmds = DvtPathUtils.moveTo(0, 0)+
        DvtPathUtils.lineTo(this._width, 0)+
        DvtPathUtils.moveTo(0, 0);
    DvtPathUtils.closePath();
    var button = new DvtPath(this._context, buttonCmds);
    var buttonFill = new DvtSolidFill("rgb(19, 180, 200)", 1);
    button.setFill(buttonFill);
    var buttonStroke = new DvtSolidStroke("rgb(19, 180, 200)", 1);
    button.setStroke(buttonStroke);
    button.setPixelHinting(true);
    return button;
}

DvtDownScroller.prototype._createTouchArea = function(){
    var back = new DvtRect(this._context, 0, 0, this._width, this._height + 15);
    back.setInvisibleFill();
    return back;
}
/**
 * Class representing a scrollable legend.
 * @param {DvtContext} context
 * @param {Number} x
 * @param {Number} y
 * @param {Number} w
 * @param {Number} h
 * @param {Number} legendHeight
 * @param {Object} handle
 * @param {Number} numItems
 * @class 
 * @constructor
 * @extends {DvtRect}
 * @implements {DvtAutomationContainer}
 */

var DvtScrollableLegend = function (context, x, y, w, h, legendHeight, handle, numItems) {
  this.Init(context, x, y, w, h, legendHeight, handle, numItems);
}

DvtObj.createSubclass(DvtScrollableLegend, DvtRect, "DvtScrollableLegend");

DvtScrollableLegend.VERTICAL_GAP = 4;
DvtScrollableLegend.SCROLLER_HEIGHT = 10;
DvtScrollableLegend.HORIZONTAL_SCROLLER_PADDING = 2;
DvtScrollableLegend.VERTICAL_SCROLLER_PADDING = 2;
DvtScrollableLegend.SCROLL_ACCELERATION_PER_SECOND = 7;
DvtScrollableLegend.MAX_SCROLL_VELOCITY_PER_SECOND = 30;

// for automation purposes
DvtScrollableLegend._TEST_ID_THIS = 0;
DvtScrollableLegend._TEST_ID_SCROLL_BUTTON_TOP = 1;
DvtScrollableLegend._TEST_ID_SCROLL_BUTTON_BOTTOM = 2;

DvtScrollableLegend.prototype.Init = function (context, x, y, w, h, legendHeight, handle, numItems) {
  this._context = context;
  DvtScrollableLegend.superclass.Init.call(this, context, x, y, w, h, "scrollableLegend");
  this.setFill(null);
  this._width = w;
  this._height = h;
  this._x = x;
  this._y = y;
  this._legendHeight = legendHeight;
  this._topScroller = null;
  this._bottomScroller = null;
  this._legendHandle = null;
  this._overlay = null;
  this._legendHandleMaxY = 0;
  this._legendHandleMinY = 0;
  this._legendItemSpace = 0;
  this._legendViewableHeight = 0;
  /** 
   * The array of logical objects for this legend.
   * @private 
   */
  this._peers = [];

  this._topScroller = new DvtUpScroller(context, (this._width - 2 * DvtScrollableLegend.HORIZONTAL_SCROLLER_PADDING), DvtScrollableLegend.SCROLLER_HEIGHT, "top");

  this._topScroller.setTranslate(x + DvtScrollableLegend.HORIZONTAL_SCROLLER_PADDING, y + DvtScrollableLegend.VERTICAL_GAP);
  this.addChild(this._topScroller);

  this._bottomScroller = new DvtDownScroller(context, (this._width - 2 * DvtScrollableLegend.HORIZONTAL_SCROLLER_PADDING), DvtScrollableLegend.SCROLLER_HEIGHT, "bottom");

  this._bottomScroller.setTranslate(x + DvtScrollableLegend.HORIZONTAL_SCROLLER_PADDING, y + h - DvtScrollableLegend.SCROLLER_HEIGHT - DvtScrollableLegend.VERTICAL_GAP);
  this.addChild(this._bottomScroller);

  this._maskTopY = y + DvtScrollableLegend.SCROLLER_HEIGHT + DvtScrollableLegend.VERTICAL_SCROLLER_PADDING + DvtScrollableLegend.VERTICAL_GAP;
  this._maskBottomY = y + h - DvtScrollableLegend.SCROLLER_HEIGHT - DvtScrollableLegend.VERTICAL_SCROLLER_PADDING - DvtScrollableLegend.VERTICAL_GAP;
  this._legendViewableHeight = this._maskBottomY - this._maskTopY;

  this._bottomScrollTimer = new DvtTimer(context, 50, this.scrollDown, this);
  this._topScrollTimer = new DvtTimer(context, 50, this.scrollUp, this);

  this._handle = handle;

  if (!DvtAgent.isTouchDevice()) {
    // Touch is handled in MEH
    this._topScroller.addMouseEventHandlers();
    this._bottomScroller.addMouseEventHandlers();
    this._topScroller.addEvtListener(DvtMouseEvent.MOUSEDOWN, this.onStartTopScroller, false, this);
    this._topScroller.addEvtListener(DvtMouseEvent.MOUSEUP, this.onStopTopScroller, false, this);
    this._topScroller.addEvtListener(DvtMouseEvent.CLICK, this.onClickTopScroller, false, this);
    this._bottomScroller.addEvtListener(DvtMouseEvent.MOUSEDOWN, this.onStartBottomScroller, false, this);
    this._bottomScroller.addEvtListener(DvtMouseEvent.MOUSEUP, this.onStopBottomScroller, false, this);
    this._bottomScroller.addEvtListener(DvtMouseEvent.CLICK, this.onClickBottomScroller, false, this);
  }
  else {
    if (this._handle) {
      this._handle.addEvtListener(DvtTouchEvent.TOUCHSTART, this._touchHandler, false, this);
      this._handle.addEvtListener(DvtTouchEvent.TOUCHMOVE, this._touchHandler, false, this);
      this._handle.addEvtListener(DvtTouchEvent.TOUCHEND, this._touchHandler, false, this);
      this._topScroller.addEvtListener(DvtTouchEvent.TOUCHSTART, this._touchTopHandler, false, this);
      this._topScroller.addEvtListener(DvtTouchEvent.TOUCHMOVE, this._touchTopHandler, false, this);
      this._topScroller.addEvtListener(DvtTouchEvent.TOUCHEND, this._touchTopHandler, false, this);
      this._bottomScroller.addEvtListener(DvtTouchEvent.TOUCHSTART, this._touchBottomHandler, false, this);
      this._bottomScroller.addEvtListener(DvtTouchEvent.TOUCHMOVE, this._touchBottomHandler, false, this);
      this._bottomScroller.addEvtListener(DvtTouchEvent.TOUCHEND, this._touchBottomHandler, false, this);
    }
  }

  if (this._handle) {
    this._handle.moveY(this._maskTopY - this._y);
    this._topScroller.setUpStateType(DvtBaseScroller.TYPE_DISABLED);
    this._bottomScroller.setUpStateType(DvtBaseScroller.TYPE_ENABLED);
    this._legendHandleMaxY = this._handle._y;
    this._legendHandleMinY = (this._legendHandleMaxY - this._legendHeight) + (this._maskBottomY - this._maskTopY);
    this._handle.setClipRect(new DvtRectangle(this._x, this._maskTopY, this._width, this._maskBottomY - this._maskTopY));
  }

  this._legendItemSpace = (this._legendHeight) / (numItems == 0 ? 1 : numItems);
}

/**
 * Registers the object peer with the legend.  The peer must be registered to participate
 * in interactivity.
 * @param {DvtLegendObjPeer} peer
 */
DvtScrollableLegend.prototype.__registerObject = function(peer) {
  this._peers.push(peer);
}

/**
 * Processes a category rollover event. If the event is for a logical object associated with this scrollable legend, 
 * the legend will scroll it into view.
 * @param {object} event
 */
DvtScrollableLegend.prototype.processCategoryRollover = function(event) {
  var category = event.getCategory();
  category = category[0] ? category[0] : category;
  for (var i = 0; i < this._peers.length; i++) {
    var obj = this._peers[i];
    if (obj && obj.getCategories && DvtArrayUtils.getIndex(obj.getCategories(), category) > -1) {
      this.scrollIntoView(i);
      break;
    }
  }
}

DvtScrollableLegend.prototype.scrollLegend = function (diff) {
  if (diff != 0) {
    this._handle.moveY(diff);

    // Set enabled/disabled for the scroller buttons
    if (this.isTopScrollerDisabled())
      this._topScroller.setUpStateType(DvtBaseScroller.TYPE_DISABLED);
    else 
      this._topScroller.setUpStateType(DvtBaseScroller.TYPE_ENABLED);

    if (this.isBottomScrollerDisabled())
      this._bottomScroller.setUpStateType(DvtBaseScroller.TYPE_DISABLED);
    else 
      this._bottomScroller.setUpStateType(DvtBaseScroller.TYPE_ENABLED);
  }
}

DvtScrollableLegend.prototype.onStartTopScroller = function (event) {
  this.processStartTopScroller();
  if (event)
    event.preventDefault();
}

DvtScrollableLegend.prototype.processStartTopScroller = function () {
  // Shade the background of the scrollable legend
  if (!DvtAgent.isTouchDevice()) {
    this._topScroller.drawActiveState();
  }

  this._prevTime = new Date().getTime();
  this._currTime = this._prevTime;
  this._velocity = 0;
  this._topScrollTimer.start();
}

DvtScrollableLegend.prototype.onStopTopScroller = function (event) {
  this.processStopTopScroller();
  if (event)
    event.preventDefault();
}

DvtScrollableLegend.prototype.processStopTopScroller = function () {
  // Remove the shading of the background of the scrollable legend
  if (DvtAgent.isTouchDevice()) {
    this._topScroller.drawUpState();
  }
  else {
    this._topScroller.drawOverState();
  }
  this._topScrollTimer.stop();
}

DvtScrollableLegend.prototype.onClickTopScroller = function (event) {
  this.processClickTopScroller();
  if (event)
    event.preventDefault();
}

DvtScrollableLegend.prototype.processClickTopScroller = function () {
  var diff = this._legendHandleMaxY - this._handle._y;
  if (diff > this._legendItemSpace) {
    this.scrollLegend(this._legendItemSpace);
  }
  else {
    this.scrollLegend(diff);
  }
  this.onStopTopScroller(null);
}

DvtScrollableLegend.prototype.onStartBottomScroller = function (event) {
  this.processStartBottomScroller();
  if (event)
    event.preventDefault();
}

DvtScrollableLegend.prototype.processStartBottomScroller = function () {
  if (!DvtAgent.isTouchDevice()) {
    this._bottomScroller.drawActiveState();
  }
  this._prevTime = new Date().getTime();
  this._currTime = this._prevTime;
  this._velocity = 0;

  this._bottomScrollTimer.start();
}

DvtScrollableLegend.prototype.onStopBottomScroller = function (event) {
  this.processStopBottomScroller();
  if (event)
    event.preventDefault();
}

DvtScrollableLegend.prototype.processStopBottomScroller = function () {
  if (DvtAgent.isTouchDevice()) {
    this._bottomScroller.drawUpState();
  }
  else {
    this._bottomScroller.drawOverState();
  }
  this._bottomScrollTimer.stop();
}

DvtScrollableLegend.prototype.onClickBottomScroller = function (event) {
  this.processClickBottomScroller();
  if (event)
    event.preventDefault();
}

DvtScrollableLegend.prototype.processClickBottomScroller = function () {
  var diff = this._legendHandleMinY - this._handle._y;
  if (Math.abs(diff) > this._legendItemSpace) {
    this.scrollLegend( - this._legendItemSpace);
  }
  else {
    this.scrollLegend(diff);
  }

  this.onStopBottomScroller(null);
}

DvtScrollableLegend.prototype.processScrollerStart = function (targetObj) {
  if (targetObj) {
    var searchArray = new Array();
    searchArray.push(targetObj);
    var parentObj = targetObj.getParent();
    if (parentObj)
      searchArray.push(parentObj);
    for (var i = 0;i < searchArray.length;i++) {
      var searchObj = searchArray[i];
      if (searchObj instanceof DvtDownScroller) {
        this.processStartBottomScroller();
        return true;
      }
      else if (searchObj instanceof DvtUpScroller) {
        this.processStartTopScroller();
        return true;
      }
    }
  }
  return false;
}

DvtScrollableLegend.prototype.processScrollerEnd = function (targetObj) {
  if (targetObj) {
    var searchArray = new Array();
    searchArray.push(targetObj);
    var parentObj = targetObj.getParent();
    if (parentObj)
      searchArray.push(parentObj);
    for (var i = 0;i < searchArray.length;i++) {
      var searchObj = searchArray[i];
      if (searchObj instanceof DvtDownScroller) {
        this.processStopBottomScroller();
        return true;
      }
      else if (searchObj instanceof DvtUpScroller) {
        this.processStopTopScroller();
        return true;
      }
    }
  }
  return false;
}

DvtScrollableLegend.prototype.isTopScrollerDisabled = function () {
  if (this._handle._y >= this._legendHandleMaxY)
    return true;
  else 
    return false;
}

DvtScrollableLegend.prototype.isBottomScrollerDisabled = function () {
  if (this._handle._y <= this._legendHandleMinY)
    return true;
  else 
    return false;
}

DvtScrollableLegend.prototype.scrollDown = function () {
  if (this._handle._y > this._legendHandleMinY) {
    this._prevTime = this._currTime;
    this._currTime = new Date().getTime();
    var elapsed = this._currTime - this._prevTime;
    var acceleration = DvtScrollableLegend.SCROLL_ACCELERATION_PER_SECOND * (elapsed / 1000);
    this._velocity = Math.min(DvtScrollableLegend.MAX_SCROLL_VELOCITY_PER_SECOND, this._velocity + acceleration);
    var diff = Math.max(this._legendHandleMinY - this._handle._y,  - this._velocity);
    this.scrollLegend(diff);
  }
  else {
    this.onStopBottomScroller(null);
  }
}

DvtScrollableLegend.prototype.scrollUp = function () {
  if (this._handle._y < this._legendHandleMaxY) {
    this._prevTime = this._currTime;
    this._currTime = new Date().getTime();
    var elapsed = this._currTime - this._prevTime;
    var acceleration = DvtScrollableLegend.SCROLL_ACCELERATION_PER_SECOND * (elapsed / 1000);
    this._velocity = Math.min(DvtScrollableLegend.MAX_SCROLL_VELOCITY_PER_SECOND, this._velocity + acceleration);
    var diff = Math.min(this._legendHandleMaxY - this._handle._y, this._velocity);
    this.scrollLegend(diff);
  }
  else {
    this.onStopTopScroller(null);
  }
}

DvtScrollableLegend.prototype.scrollIntoView = function (idx) {
  if (idx < 0) {
    return;
  }

  var diff = 0;
  var targetY = this._legendHandleMaxY - (idx * this._legendItemSpace);

  if (targetY <= this._handle._y - this._legendViewableHeight + 1) {
    diff = (targetY + this._legendViewableHeight) - this._handle._y - this._legendItemSpace;
    this.scrollLegend(diff);
  }
  else if (targetY > this._handle._y) {
    diff = targetY - this._handle._y - this._legendItemSpace;
    this.scrollLegend(diff);

    //scroll up one more notch if necessary
    diff = this._legendHandleMaxY - this._handle._y;
    if (diff > this._legendItemSpace) {
      this.scrollLegend(this._legendItemSpace);
    }
    else {
      this.scrollLegend(diff);
    }
  }
}

/**
 * Handler for the touch event
 * @param {DvtTouchEvent} event Touch event
 * @private
 */
DvtScrollableLegend.prototype._touchHandler = function (event) {
  this.getTouchManager().processAssociatedTouchDefault(event, this);
}

/**
 * Handler for the touch event for the top scroller
 * @param {DvtTouchEvent} event Touch event
 * @private
 */
DvtScrollableLegend.prototype._touchTopHandler = function (event) {
  this.getTouchManager().processAssociatedTouch(event, this._topScroller, this.OnTouchStartTopScroller, this);
}

/**
 * Handler for the touch event for the bottom scroller
 * @param {DvtTouchEvent} event Touch event
 * @private
 */
DvtScrollableLegend.prototype._touchBottomHandler = function (event) {
  this.getTouchManager().processAssociatedTouch(event, this._bottomScroller, this.OnTouchStartBottomScroller, this);
}

/**
 * Handler for the touch start event for the top scroller
 * @param {DvtTouchEvent} event Touch event
 * @param {DvtTouch} touch Touch Object
 */
DvtScrollableLegend.prototype.OnTouchStartTopScroller = function (event, touch) {
  this.processStartTopScroller();
  this.getTouchManager().saveProcessedTouch(touch.identifier, this._topScroller, this._topScroller, "scrollablelegendtop", "scrollablelegendtop", null, this.OnTouchEndTopScroller, this);
  event.blockTouchHold();
}

DvtScrollableLegend.prototype.OnTouchEndTopScroller = function (event, touch) {
  this.processStopTopScroller();
}

/**
 * Handler for the touch start event for the bottom scroller
 * @param {DvtTouchEvent} event Touch event
 * @param {DvtTouch} touch Touch Object
 */
DvtScrollableLegend.prototype.OnTouchStartBottomScroller = function (event, touch) {
  this.processStartBottomScroller();
  this.getTouchManager().saveProcessedTouch(touch.identifier, this._bottomScroller, this._bottomScroller, "scrollablelegendbottom", "scrollablelegendbottom", null, this.OnTouchEndBottomScroller, this);
  event.blockTouchHold();
}

DvtScrollableLegend.prototype.OnTouchEndBottomScroller = function (event, touch) {
  this.processStopBottomScroller();
}

/**
 * Processes "touchstart" event
 * @param {DvtTouchEvent} event Touch event
 * @param {DvtTouch} touch Touch object
 */
DvtScrollableLegend.prototype.immediateTouchAttempted = function (event, touch) {
  var tm = this.getTouchManager();

  var touchX = touch.pageX;
  var touchY = touch.pageY;
  var relPos = this.getCtx().pageToStageCoords(touchX, touchY);
  var legendRect = new DvtRectangle(this._x, this._y, this._width, this._height);
  var stagePoint = this.localToStage(new DvtPoint(legendRect.x, legendRect.y));
  legendRect.x = stagePoint.x;
  legendRect.y = stagePoint.y;
  if (legendRect.containsPoint(relPos.x, relPos.y)) {
      this._prevTouchY = relPos.y;
      tm.saveProcessedTouchDefault(touch.identifier, this, this, "scrollablelegend", "scrollablelegend", this);
      // BUG #12883879: Still allow touch and hold to be performed on legend
      //event.blockTouchHold();
  }
}

DvtScrollableLegend.prototype.immediateTouchMoved = function (event, touch) {
  var touchX = touch.pageX;
  var touchY = touch.pageY;
  var relPos = this.getCtx().pageToStageCoords(touchX, touchY);
  var relX = relPos.x;
  var relY = relPos.y;
  var diffY = (relY - this._prevTouchY);
  if (this._handle._y + diffY < this._legendHandleMinY)
    diffY = 0;
  if (this._handle._y + diffY > this._legendHandleMaxY)
    diffY = 0;
  this.scrollLegend(diffY);
  this._prevTouchY = relY;
  event.preventDefault();

}

DvtScrollableLegend.prototype.immediateTouchEnded = function (event, touch) {

  //var handled = legend.processScrollerEnd(targetObj);
}

/**
 * @override
 */
DvtScrollableLegend.prototype.dispatchTestEvent = function(subId, eventType, params) 
{
  // implementation of interface DvtAutomationContainer
  var subComponent;

  if(subId <= DvtScrollableLegend._TEST_ID_THIS)
    subComponent = this;
  else if(subId == DvtScrollableLegend._TEST_ID_SCROLL_BUTTON_TOP)
    subComponent = this._topScroller;
  else if(subId == DvtScrollableLegend._TEST_ID_SCROLL_BUTTON_BOTTOM)
    subComponent = this._bottomScroller;

  if(subComponent && subComponent instanceof DvtDisplayable)
    subComponent.dispatchDisplayableEvent(eventType, params);
              
};

/**
 * Gets a touch manager object
 * @return {DvtTouchManager} touch manager object
 */
DvtScrollableLegend.prototype.getTouchManager = function () {
  return this._touchManager;  
}

/**
 * Sets a touch manager object
 * @param {DvtTouchManager} touch manager object
 */
DvtScrollableLegend.prototype.setTouchManager = function (touchManager) {
  this._touchManager = touchManager;  
}
/**
  *  Handle.
  *  @extends DvtContainer
  *  @class DvtHandle  handle. 
  *  @constructor  
  */
var   DvtHandle = function(context, sId, boundRect, clipRect, clipId) {
    this.Init(context, sId, boundRect, clipRect, clipId);
}

DvtObj.createSubclass(DvtHandle, DvtContainer, "DvtHandle");



/**
 *    @protected
 */
DvtHandle.prototype.Init = function(context, sId, boundRect, clipRect, clipId) {

    DvtHandle.superclass.Init.call(this, context, null, sId);
    this.Id = sId;
    this._x = 0;
    this._y = 0;
    this._boundRect = boundRect;
    this._clipRect = this._normalizeRect(clipRect);
    this._clipId = clipId;
}

/**
 * getId - returns this handle ID
 */
DvtHandle.prototype.getId = function() {
    return this.Id;
}

/**
 * getBoundingPoints - returns the bounding points for this handle
 *
 */
DvtHandle.prototype.getBoundingPoints = function() {
    return this._boundRect;
}

/**
 * getClipRect - returns the clipping rect for this handle
 *
 */
DvtHandle.prototype.getClipRect = function() {
    return this._clipRect;
}

/**
 * setClipRect - sets the clipRect on this handle
 *
 */
DvtHandle.prototype.setClipRect = function(clipRect) {
    this._clipRect = this._normalizeRect(clipRect);
}

DvtHandle.prototype.getX = function() {
    return this._x;
}

DvtHandle.prototype.getY = function() {
    return this._y;
}

DvtHandle.prototype.moveX = function(nx) {

    this._x += nx;

    if (this._boundRect != null) {
        this._boundRect[0] += nx;
        this._boundRect[2] += nx;
    }
    
    // Bug #12826435: Translate the container instead of all the children indiv
    var oldX = this.getTranslateX();
    this.setTranslateX(oldX + nx);

    // TODO: preClippingSanityCheck();
    // TODO: updateBackgroundEraser();
}


DvtHandle.prototype.moveY = function(ny) {

    this._y += ny;

    if (this._boundRect != null) {
        this._boundRect[1] += ny;
        this._boundRect[3] += ny;
    }
    
    // Bug #12826435: Translate the container instead of all the children indiv
    
    var oldY = this.getTranslateY();
    this.setTranslateY(oldY + ny);

    // TODO: preClippingSanityCheck();
    // TODO: updateBackgroundEraser();
}


DvtHandle.prototype.render = function() {
    if (this._clipRect) {
        var cp = new DvtClipPath(this._clipId);
        cp.addRect(this._clipRect.x, this._clipRect.y, this._clipRect.w, this._clipRect.h);
        this.setClipPath(cp);
    }
}


DvtHandle.prototype._normalizeRect = function(rect) {

    // for some reason the clipRect may be defined "backward" with height
    // (and width ?) < 0, if so, normalize it
    if (rect && rect.w < 0) {
        rect.w = -rect.w;
        rect.x -= rect.w;
    }
    if (rect && rect.h < 0) {
        rect.h = -rect.h;
        rect.y -= rect.h;
    }
    return rect;
}
/**
 *  A static class for DnD support.
 *  @class DvtDnDUtils
 */
var DvtDnDUtils = function () {
};

DvtObj.createSubclass(DvtDnDUtils, DvtObj, "DvtDnDUtils");

/**
 * Returns a {DvtRectangle} representing the drag feedback bounds.
 * @param {object} displayables The DvtDisplayable or array of DvtDisplayables to display for drag feedback.
 * @param {DvtDisplayable} targetCoordinateSpace The displayable defining the coordinate space of the resulting bounds.  The
 *                                               parent coordinate space is used if none is provided.
 */
DvtDnDUtils.getDragFeedbackBounds = function (displayables, targetCoordinateSpace) {
  if (!displayables)
    return null;

  var bounds = null;
  if (!(displayables instanceof Array)) {
    // for simple objects, just return the object bounds
    // TODO: eventually should ensure that bounds are in container coordinates
    bounds = displayables.getDimensions(targetCoordinateSpace ? targetCoordinateSpace : displayables.getParent());
  }
  else if (displayables.length > 0) {
    // TODO: eventually should ensure that bounds are in container coordinates
    // for arrays, initialize bounds based on the first object
    bounds = displayables[0].getDimensions(targetCoordinateSpace ? targetCoordinateSpace : displayables[0].getParent());

    // ... and adjust it to acommodate other objects in the collection
    for (var i = 1;i < displayables.length;i++) {
      var obj = displayables[i];
      var objBounds = obj.getDimensions(targetCoordinateSpace ? targetCoordinateSpace : obj.getParent());

      if (objBounds.x < bounds.x) {
        bounds.w += (bounds.x - objBounds.x);
        bounds.x = objBounds.x;
      }
      if (objBounds.y < bounds.y) {
        bounds.h += (bounds.y - objBounds.y);
        bounds.y = objBounds.y;
      }
      if ((objBounds.x + objBounds.w) > (bounds.x + bounds.w)) {
        bounds.w = objBounds.x + objBounds.w - bounds.x;
      }
      if ((objBounds.y + objBounds.h) > (bounds.y + bounds.h)) {
        bounds.h = objBounds.y + objBounds.h - bounds.y;
      }
    }
  }
  return bounds;
}
/**
 * Abstract class for XML parser.  
 * @extends DvtObj
 * @class DvtXmlParser
 * @constructor
 * 
 * @param {DvtContext}  context  platform specific context object
 */
var DvtXmlParser = function(context) {
  if (!this._impl) {
    this._impl = context.getImplFactory().newParser();
  }
};

DvtObj.createSubclass(DvtXmlParser, DvtObj, "DvtXmlParser");

/**
 * Parses the XML string and returns the root node.
 * @param {string} xmlString the XML string to parse
 * @return {DvtXmlNode} the root node of the XML document
 */
DvtXmlParser.prototype.parse = function(xmlString) {
  if (this._impl && this._impl.parse) {
    return this._impl.parse(xmlString);
  }
  
  return null;
}
/**
 * Abstract class for XML node.  Subclasses should override to provide support
 * for different platforms.
 * @extends DvtObj
 * @class DvtXmlNode
 * @constructor
 */
var DvtXmlNode = function() {}

DvtObj.createSubclass(DvtXmlNode, DvtObj, "DvtXmlNode");

/**
 * Returns the value for the given attribute in this XML node.
 * @param {string} attr the attribute to look for
 * @return {string} the value of the attribute, if available
 */
DvtXmlNode.prototype.getAttr = function(attr) {
  return null; // subclasses should override
}

/**
 * Returns an Array containing the child elements of this node.  Only nodes that
 * are XML elements are returned.  Text nodes are ignored.
 * @return {array} an Array containing all child elements of this node.
 */
DvtXmlNode.prototype.getChildNodes = function() {
  return new Array(); // subclasses shoudl override
}

/**
 * Returns the child element of this node. Only nodes that
 * are XML elements are returned.  Text nodes are ignored.
 * @return {DvtXmlNode} the first child element
 */
DvtXmlNode.prototype.getChild = function(i) {
  var children = this.getChildNodes();
  if(children != null && children.length > i)
    return children[i];
  else
    return null;
}

/**
 * Returns the first child element of this node. Only nodes that
 * are XML elements are returned.  Text nodes are ignored.
 * @return {DvtXmlNode} the first child element
 */
DvtXmlNode.prototype.getFirstChild = function() {
  return this.getChild(0);
}

/**
 * Returns the name of this node.
 * @return {string} the name of the node
 */
DvtXmlNode.prototype.getName = function() {
  return null; //subclasses should override
};

/**
 * Returns the attributes of this node as an array of 
 * {name:, value:} pairs.
 * @return {array} the attributes of the node
 */
DvtXmlNode.prototype.getAttributes = function() {
  return null; //subclasses should override
};


/**
 * Returns an Array containing the children of this node. 
 * @return {array} an Array containing all child elements and text nodes of this node.
 */
DvtXmlNode.prototype.getAllChildNodes = function() {
  return new Array(); // subclasses shoudl override
}


/**
 * Returns the value of this node.
 * @return {string} the value of the node
 */
DvtXmlNode.prototype.getNodeValue = function() {
  return null; //subclasses should override
};

/**
 * Returns the textContent of this node.
 * @return {string} the textContent of the node
 */
DvtXmlNode.prototype.getTextContent = function() {
  return null; //subclasses should override
};

/**
 * Returns a node list of all child element nodes whose tagName match the speccified name.
 * @return {string} the name of the node
 */
DvtXmlNode.prototype.getElementsByTagName = function(name) {
  return null; //subclasses should override
};

/**
 * Context Menu Handler implementation for HTML context menus.
 * @class DvtHtmlContextMenuHandler
 * @constructor
 */
var DvtHtmlContextMenuHandler = function() {
	this.Init();
};

DvtObj.createSubclass(DvtHtmlContextMenuHandler, DvtObj, "DvtHtmlContextMenuHandler");

DvtHtmlContextMenuHandler.prototype.Init = function()
{
}

DvtHtmlContextMenuHandler.prototype.setObj = function(obj)
{
	this._obj = obj;
}

DvtHtmlContextMenuHandler.prototype.prepareMenuItems = function(event, menuType, menuId) {
    //Nothing
}

DvtHtmlContextMenuHandler.prototype.getMenuEvent = function(xmlNodes, event, menuType, menuId) {
  var nativeEvent = event.getNativeEvent();
  // Look through all context menu definitions for the right context menu to show
  for(var i=0; i<xmlNodes.length; i++) {
    var xmlNode = xmlNodes[i];
    
    if(menuType == xmlNode.getAttr(DvtContextMenuHandler._ATTR_MENU_CONTAINER_TYPE)) {
      // Match found.  This implementation will fire a showPopupEvent.
      var popupId = xmlNode.getAttr(DvtContextMenuHandler._ATTR_MENU_CONTAINER_POPUP_ID);
      return new DvtContextMenuEvent(nativeEvent, popupId);
    }
  }
  return null;
}
/**
 * @param {DvtContext} context
 * @param {string} domElementId
 * @constructor
 * @extends DvtTooltipManager
 * @class DvtHtmlTooltipManager
 */
var DvtHtmlTooltipManager = function(context, domElementId) {
    this.Init(context, domElementId);
};

DvtObj.createSubclass(DvtHtmlTooltipManager, DvtTooltipManager, "DvtHtmlTooltipManager");

/** @private */
DvtHtmlTooltipManager._TOOLTIP_DIV_ID = "_dvtTooltip";

DvtHtmlTooltipManager.SHOW_DELAY = 500;  // in ms
DvtHtmlTooltipManager.HIDE_DELAY = 5000; // in ms
DvtHtmlTooltipManager.TRANSITION_DURATION = 250;  // in ms

DvtHtmlTooltipManager.BG_COLOR = "#c1ccd7";
DvtHtmlTooltipManager.BORDER_COLOR = "#9ba2b0";
DvtHtmlTooltipManager.FONT_COLOR = "#383a47";

DvtHtmlTooltipManager.UNSTYLED_POPUP_CLASS = "OraDVTUnstyledPopup";
DvtHtmlTooltipManager.DATATIP_POPUP_CLASS = "OraDVTDatatipPopup";
DvtHtmlTooltipManager.TOOLTIP_POPUP_CLASS = "OraDVTTooltipPopup";

DvtHtmlTooltipManager.BORDER_BUFFER = 2;            // Buffer for border
DvtHtmlTooltipManager.TOOLTIP_ABOVE_OFFSET = 10;    // Adjustment for tooltip position when above mouse

/**
 * @param {DvtContext} context
 * @param {string} domElementId
 */ 
DvtHtmlTooltipManager.prototype.Init = function(context, domElementId) 
{
  this._context = context;
  
  // if a dom element is specified, it will override the default tooltip div
  this._domElementId = (domElementId ? domElementId : DvtHtmlTooltipManager._TOOLTIP_DIV_ID);
  this._isTooltip = true;
}

/**
 * Displays a datatip.
 * @param {number} x The pageX coordinate at which to display the datatip.
 * @param {number} y The pageY coordinate at which to display the datatip.
 * @param {string} text The string to show in the datatip.
 * @param {string} borderColor The border color for the datatip.
 * @param {boolean} [useOffset] false to prevent offsets from being applied. Offsets will be applied otherwise.
 * @param 
 */
DvtHtmlTooltipManager.prototype.showDatatip = function(x, y, text, borderColor, useOffset)
{
  // If useOffset not specified, then apply offsets
  if(useOffset == null)
    useOffset = true;

  this._isTooltip = false;
  this._showTextAtPosition(x, y, text, borderColor, useOffset, DvtHtmlTooltipManager.DATATIP_POPUP_CLASS);
}

/**
 * Helper to display a datatip or tooltip.
 * @param {number} x The pageX coordinate at which to display the tooltip.
 * @param {number} y The pageY coordinate at which to display the tooltip.
 * @param {string} text The string to show in the tooltip.
 * @param {string} borderColor The border color for the tooltip.
 * @param {boolean} useOffset True if offsets should be applied to the coordinates.
 * @param {string} popupClass The style class to use for the outer tooltip div.
 * @private
 */
DvtHtmlTooltipManager.prototype._showTextAtPosition = function(x, y, text, borderColor, useOffset, popupClass)
{
  // Make replacements on the text string as needed
  if(text) {
    // Make all brackets consistent to simplify later searches
    text = text.replace(/(<|&#60;)/g, '&lt;');
    text = text.replace(/(>|&#62;)/g, '&gt;');
    
    // Support a subset of HTML tags, including bold and italic
    text = text.replace(/&lt;b&gt;/g, '<b>');
    text = text.replace(/&lt;\/b&gt;/g, '<\/b>'); 
    text = text.replace(/&lt;i&gt;/g, '<i>');
    text = text.replace(/&lt;\/i&gt;/g, '<\/i>'); 
  
    // Replace logical newlines sequences
    text = text.replace(/\n/g, '<br>'); 
    text = text.replace(/&lt;br&gt;/g, '<br>');
    text = text.replace(/&lt;br\/&gt;/g, '<br>');
    
    // Prevent text from wrapping by replacing spaces with non-breaking spaces
    text = text.replace(/ /g, '&nbsp;');
  }
    
  // Make sure the popup class is defined
  if(!popupClass)
    popupClass = DvtHtmlTooltipManager.UNSTYLED_POPUP_CLASS;

  // Create the tooltip element
  var tooltipElem = document.createElement("span");
  tooltipElem.style.visibility = "inherit";  
  tooltipElem.style.width = null;
  tooltipElem.style.height = null;
  
  // Set the text
  tooltipElem.innerHTML = text;
  
  // Apply the border on the outer element
  var outerElem = this.GetTooltipElem();
  outerElem.style.borderColor = borderColor;
  
  // Position the outer element and add the tooltip
  outerElem.className = popupClass;
  outerElem.innerHTML = "";
  outerElem.appendChild(tooltipElem);
  this.PostElement(outerElem, x, y, true, useOffset);
}

/**
 * Performs a bunch of processing for an assembled tooltip or datatip.
 * @param {object} tooltip The outer DOM element of the tooltip.
 * @param {number} x The pageX coordinate at which to display the tooltip.
 * @param {number} y The pageY coordinate at which to display the tooltip.
 * @param {boolean} noEvents True if this tooltip should not recieve mouse events.
 * @param {boolean} useOffset True if this tooltip should be offset from the x and y coordinates.
 * @protected
 */
DvtHtmlTooltipManager.prototype.PostElement = function(tooltip, x, y, noEvents, useOffset) {
  // Block mouse events if the tip is not interactive
  tooltip.style["pointer-events"] = noEvents ? "none" : "auto";

  // Clear the width and height. This allows _positionTip to get the accurate tooltip size
  tooltip.style.width = null;
  tooltip.style.height = null;
  
  // Add offsets to the tip position as needed
  if(useOffset) {
    var offsets = this._getOffsets(tooltip);
    this.positionTip(x+offsets.x, y+offsets.y, x, y);
  } 
  else
    this.positionTip(x, y, x, y);

  // Make the tooltip visible
  tooltip.style.visibility = "visible";
}

/**
 * @override
 */
DvtHtmlTooltipManager.prototype.hideTooltip = function()
{
  this.clearTooltip();
  this._tooltipDisplayed = false;
  this._timerIsRunning = false;

  var tooltip = document.getElementById(this._domElementId);
  if(tooltip) {
    tooltip.style.visibility='hidden';
    tooltip.style.width = '0px';
    tooltip.style.height = '0px';
    if (!DvtAgent.isRightToLeft(this._context))    
      tooltip.style.left = '0px';
    else
      tooltip.style.left = tooltip.style.right;
    tooltip.style.top = '0px';
  }
};

/**
 * Retrieves the outer DOM element of the tooltip.
 * @return {object}
 * @protected
 */
DvtHtmlTooltipManager.prototype.GetTooltipElem = function() {
  // Retrieve the tooltip element and create if it doesn't exist.
  var tooltip = document.getElementById(this._domElementId);
  if(!tooltip)
    tooltip = this.InitializeTooltipElem();

  return tooltip;
}

/**
 * Initializes the outer DOM element of the tooltip.
 * @return {object} The outer DOM element.
 * @protected
 */
DvtHtmlTooltipManager.prototype.InitializeTooltipElem = function() {
  var tooltip = document.createElement("div");
  tooltip.id = this._domElementId;
  tooltip.style.visibility = "hidden";
  document.body.appendChild(tooltip);
  this.InitContent(tooltip);
  return tooltip;
}

/**
 * TODO JSDoc
 * @protected
 */
DvtHtmlTooltipManager.prototype.InitContent = function(tooltip) {
}

/**
 * @override
 */
DvtHtmlTooltipManager.prototype.showTooltip = function(x, y, text, shape, bTrackMouse, borderColor)
{

  if (! text || text.length == 0)
    return;

  this._shape = shape;
  this._x = x;
  this._y = y;
  this._text = text;

  //TODO: trackMouse is not working!
  this._trackMouse = bTrackMouse;

  if (this._timerIsRunning)
    return;
  
  var tooltipElem = document.createElement("span");
  tooltipElem.className = "OraDVTTooltipText";
  tooltipElem.innerHTML = text;
  tooltipElem.style.color = DvtHtmlTooltipManager.FONT_COLOR;
  
  if (! borderColor) {
    borderColor = DvtHtmlTooltipManager.BORDER_COLOR;
  }
  var outerElem = this.GetTooltipElem();
  outerElem.style.borderColor = borderColor;
  
  if (DvtAgent.isTouchDevice() || (this._tooltipDisplayed && this._trackMouse)) {
      this._displayTooltip(this._x, this._y, this._text, this._borderColor);
  } else {
      // Tooltips fade-in and remove themselves after a delay.
      this._timerIsRunning = true;
      this._showTimerId = window.setTimeout(DvtObj.createCallback(this, this._handleShowTimer), DvtHtmlTooltipManager.SHOW_DELAY);
  }
}


/**
 * Clears the currently displayed tooltip.
 * @export
 */
DvtHtmlTooltipManager.prototype.clearTooltip = function()
{
  if (this._showTimerId) {
    window.clearTimeout(this._showTimerId);

    this._showTimerId = undefined;
    this._x = undefined;
    this._y = undefined;
    this._text = undefined;

    this._trackMouse = undefined;
    this._shape = undefined;
  }
  if (this._hideTimerId) {
    window.clearTimeout(this._hideTimerId);
    this._hideTimerId = undefined;
  }
}

/**
 * TODO JSDoc
 * @private
 */
DvtHtmlTooltipManager.prototype._handleShowTimer = function(event)
{
  this._timerIsRunning = false;
  this._displayTooltip(this._x, this._y, this._text, this._borderColor);
  this._tooltipDisplayed = true;
}

/**
 * TODO JSDoc
 * @private
 */
DvtHtmlTooltipManager.prototype._displayTooltip = function(x, y, text, borderColor) 
{
  this._isTooltip = true;
  this._showTextAtPosition(x, y, text, borderColor, true, DvtHtmlTooltipManager.TOOLTIP_POPUP_CLASS);
}

/**
 * TODO JSDoc
 * TODO This should return DvtDimension, not DvtPoint
 * @private
 */
DvtHtmlTooltipManager.prototype._getOffsets = function(tooltip)
{
  var tooltipBounds = this.getTooltipBounds(tooltip);
  if(DvtAgent.isTouchDevice()) {
    return new DvtPoint(0 - tooltipBounds.w/2, -30 - tooltipBounds.h);
  } 
  else {
    var yOffset = -12 - tooltipBounds.h;
    var xOffset = 12;
    if (this._isTooltip) {
      yOffset = 22;
      xOffset = 0;
    }
    var bBidi = DvtAgent.isRightToLeft(this._context);
    if (bBidi) {
      xOffset = -xOffset - tooltipBounds.w;          
    }

    return new DvtPoint(xOffset, yOffset);
  }
}

/**
 * Returns an approximation of the tooltip bounds.
 * @return {DvtRectangle}
 */
DvtHtmlTooltipManager.prototype.getTooltipBounds = function()
{
  var tooltip = this.GetTooltipElem();
  
  // Fix for 17898759: The offset height can be incorrect if the tooltip div inherits from the HTML body.  Set to auto 
  // temporarily to prevent this.
  var tempHeight = tooltip.style.height;
  tooltip.style.height = "auto";
  var ret = new DvtRectangle(parseInt(tooltip.style.left), parseInt(tooltip.style.top), tooltip.offsetWidth, tooltip.offsetHeight);
  tooltip.style.height = tempHeight;
  return ret;
}

/**
 * Positions the tip based on the mouse position in relation to the tooltip size.
 * @param {number} x The coordinate at which to display the tooltip with offsets.
 * @param {number} y The coordinate at which to display the tooltip with offsets.
 */
DvtHtmlTooltipManager.prototype.positionTip = function(x, y)
{
  var tooltip = this.GetTooltipElem();
  var tooltipDimensions = this.getTooltipBounds();
  var tooltipWidth = tooltipDimensions.w;
  var tooltipHeight = tooltipDimensions.h;

  // Calculate the bounds of the browser viewport, within which we'll position the tooltip
  var viewportBounds = new DvtRectangle(window.pageXOffset + DvtHtmlTooltipManager.BORDER_BUFFER, 
                                        window.pageYOffset + DvtHtmlTooltipManager.BORDER_BUFFER, 
                                        window.innerWidth - 2*DvtHtmlTooltipManager.BORDER_BUFFER, 
                                        window.innerHeight - 2*DvtHtmlTooltipManager.BORDER_BUFFER);
  
  // X Position
  var tooltipX = x;
  if(x + tooltipWidth > viewportBounds.x + viewportBounds.w)
    tooltipX = viewportBounds.x + viewportBounds.w - tooltipWidth;
  else if(x < viewportBounds.x)
    tooltipX = viewportBounds.x;
  
  // Y Position
  var tooltipY = y;
  if(y < viewportBounds.y)
    tooltipY = viewportBounds.y;
  else if(y + tooltipHeight > viewportBounds.y + viewportBounds.h) 
    tooltipY = viewportBounds.y + viewportBounds.h - tooltipHeight;
  
  // Apply the calculated positions
  tooltip.style.left = tooltipX + 'px';
  tooltip.style.top = tooltipY + 'px';
}
/**
 * Utility class for providing keyboard listeners to add to HTML divs
 * @class DvtHtmlKeyboardListenerUtils
 */
var DvtHtmlKeyboardListenerUtils = function() {};

DvtObj.createSubclass(DvtHtmlKeyboardListenerUtils, DvtObj, "DvtHtmlKeyboardListenerUtils");

//FIX BUG 16901294: for editable DvtText, ignore events from the HTML textArea
/**
 * Field to look for on event target to see if events from that target should be ignored.
 */
DvtHtmlKeyboardListenerUtils.ATTR_IGNORE_EVENTS_FROM_TARGET = "_dvtIgnoreEventsFromTarget";

/**
 * @param {Boolean} useCapture True if the listener is to be used in the event capture phase, 
 *                             false if the listener is to be used in the event bubble phase
 * @return {function} A function that can be used as an event listener during the bubble or capture phase
 */
DvtHtmlKeyboardListenerUtils.getListener = function(useCapture)
{
  if(useCapture)
    return DvtHtmlKeyboardListenerUtils._captureListener;
  else
    return DvtHtmlKeyboardListenerUtils._bubbleListener;  
}


/**
 * The event listener that is called by the implementation object's bubble phase listeners.
 * This function will wrap the event and delegate to the real event listeners.  
 * @param {object} event the DOM event object
 * @this {object} the platform object actively processing the event object with an event listener
 * @private
 */
DvtHtmlKeyboardListenerUtils._bubbleListener = function(event)
{
  //FIX BUG 16901294: for editable DvtText, ignore events from the HTML textArea
  if (DvtHtmlKeyboardListenerUtils._checkIgnoreTarget(event)) {
    return;
  }
  if(this._obj && this._obj instanceof Array)
  {
    var i;
    var svgObj;
    var dvtEvent;
    var length = this._obj.length;
    for(i=0; i<length; i++)
    {
      svgObj = this._obj[i];
      dvtEvent = DvtSvgEventFactory.newEvent(event, svgObj.getObj().getCtx());
      svgObj.getObj().FireListener(dvtEvent, false);
    }
  }  
}


/**
 * The event listener that is called by the implementation object's capture phase listeners.
 * This function will wrap the event and delegate to the real event listeners.  
 * @param {object} event the DOM event object
 * @this {object} the platform object actively processing the event object with an event listener
 * @private
 */
DvtHtmlKeyboardListenerUtils._captureListener = function(event)
{
  //FIX BUG 16901294: for editable DvtText, ignore events from the HTML textArea
  if (DvtHtmlKeyboardListenerUtils._checkIgnoreTarget(event)) {
    return;
  }
  if(this._obj && this._obj instanceof Array)
  {
    var i;
    var svgObj;
    var dvtEvent;
    var length = this._obj.length;
    for(i=0; i<length; i++)
    {
      svgObj = this._obj[i];
      dvtEvent = DvtSvgEventFactory.newEvent(event, svgObj.getObj().getCtx());
      svgObj.getObj().FireListener(dvtEvent, true);
    }
  }  
}

/**
 * Check whether the event should be ignored by the toolkit.
 * @param {object} event the DOM event object
 * @private
 */
DvtHtmlKeyboardListenerUtils._checkIgnoreTarget = function(event) {
  //FIX BUG 16901294: for editable DvtText, ignore events from the HTML textArea
  if (event && event.target && event.target[DvtHtmlKeyboardListenerUtils.ATTR_IGNORE_EVENTS_FROM_TARGET]) {
    return true;
  }
  return false;
};
/**
 * Wrapper class providing XML parsing functionality using the DOM.
 * @class DvtDomXmlParser
 * @extends DvtXmlParser
 * @constructor
 */
var DvtDomXmlParser = function() {
  this._parser = new DOMParser();
}

DvtObj.createSubclass(DvtDomXmlParser, DvtObj, "DvtDomXmlParser");

/**
 * Parses the XML string and returns the root node.
 * @param {string} xmlString the XML string to parse
 * @return {DvtDomXmlNode} the root node of the XML document
 */
DvtDomXmlParser.prototype.parse = function(xmlString) {
  var xmlDoc = this._parser.parseFromString(xmlString, "text/xml");
  var root = xmlDoc.documentElement;
  return new DvtDomXmlNode(root);
}
/**
 * Wrapper class providing access to DOM XML Nodes.
 * @extends DvtXmlNode
 * @class DvtDomXmlNode
 * @constructor
 * @param {Node} node the DOM Node object
 */
var DvtDomXmlNode = function(node) {
  this._node = node;
}

// Make DvtDomXmlNode a subclass of DvtXmlNode
DvtObj.createSubclass(DvtDomXmlNode, DvtXmlNode, "DvtDomXmlNode");

/**
 * @override
 */
DvtDomXmlNode.prototype.getAttr = function(attr) {
  return this._node.getAttribute(attr);
}

/**
 * @override
 */
DvtDomXmlNode.prototype.getChildNodes = function() {
  var ret = new Array();
  
  // Loop through the children of this node.  
  // Note: Using nextSibling because w3schools.com says it's faster than 
  //       childNodes for looping through the children.
  var child = this._node.firstChild;
  while(child != null) {
    if(child.nodeType == 1) // Element
      ret.push(new DvtDomXmlNode(child));
      
    child = child.nextSibling;  
  }
  
  return ret;
}

/**
  * @override
  */
DvtDomXmlNode.prototype.getName = function() {
  return this._node.nodeName;
};

/**
  * @override
  */
DvtDomXmlNode.prototype.getAttributes = function() {
  var array = [];
  var numAttrs = this._node.attributes.length;
  for (var i = 0; i < numAttrs; i++)
  {
    var attr = this._node.attributes[i];
    if (attr.name && typeof attr.value != 'undefined' && attr.value != null )
    {
      array.push({name:attr.name, value:attr.value});
    }
  }
  return array;
};


/**
 * @override
 * @return {array} an Array containing all child elements and text nodes of this node.
 */
DvtDomXmlNode.prototype.getAllChildNodes = function() {
  var ret = new Array();
  
  // Loop through the children of this node.  
  // Note: Using nextSibling because w3schools.com says it's faster than 
  //       childNodes for looping through the children.
  var child = this._node.firstChild;
  while(child != null) {
    ret.push(new DvtDomXmlNode(child));
    child = child.nextSibling;  
  }
  
  return ret;
}


/**
  * @override
  */
DvtDomXmlNode.prototype.getNodeValue = function() {
  return this._node.nodeValue;
};

/**
  * @override
  */
DvtDomXmlNode.prototype.getTextContent = function() {
  return this._node.textContent;
};

/**
  * @override
  */
DvtDomXmlNode.prototype.getElementsByTagName = function(name) {
  var ret = [];
  var nodes = this._node.getElementsByTagName(name);
  if (nodes) {
    for (var i = 0; i < nodes.length; i++) {
        ret.push(new DvtDomXmlNode(nodes[i]));
    }
  }
  return ret;
};

/**
 * A component level selection event.
 * @param {array} selection The array of currently selected ids for the component.
 * @class
 * @constructor
 * @export
 */
var DvtSelectionEvent = function(selection) {
  this.Init(selection);
}

DvtObj.createSubclass(DvtSelectionEvent, DvtBaseComponentEvent, "DvtSelectionEvent");

/**
 * @export
 */
DvtSelectionEvent.TYPE = "selection";

/**
 * @param {array} selection The array of currently selected ids for the component.
 * @override
 */
DvtSelectionEvent.prototype.Init = function(selection) {
  DvtSelectionEvent.superclass.Init.call(this, DvtSelectionEvent.TYPE);
  this._selection = selection;
};

/**
 * Returns the array of currently selected ids for the component.
 * @return {array} The array of currently selected ids for the component.
 * @export
 */
DvtSelectionEvent.prototype.getSelection = function() {
  return this._selection;
}
/**
 * A component level value change event.
 * @param {object} oldValue The old value.
 * @param {object} newValue The old value.
 * @param {boolean} bComplete True if the value change interaction is complete.
 * @class
 * @constructor
 * @export
 */
var DvtValueChangeEvent = function(oldValue, newValue, bComplete) {
  var type = (bComplete === false) ? DvtValueChangeEvent.TYPE_INPUT : DvtValueChangeEvent.TYPE;
  this.Init(type);
  this._oldValue = oldValue;
  this._newValue = newValue;
}

DvtObj.createSubclass(DvtValueChangeEvent, DvtBaseComponentEvent, "DvtValueChangeEvent");

/**
 * @export
 * Event type for completion of a value change interaction.
 */
DvtValueChangeEvent.TYPE = "valueChange";

/**
 * @export
 * Event type for an intermediate value change interaction.
 */
DvtValueChangeEvent.TYPE_INPUT = "valueChangeInput";

/**
 * Returns the old value.
 * @return {object} The old value.
 * @export
 */
DvtValueChangeEvent.prototype.getOldValue = function() {
  return this._oldValue;
}

/**
 * Returns the new value.
 * @return {object} The new value.
 * @export
 */
DvtValueChangeEvent.prototype.getNewValue = function() {
  return this._newValue;
}
/**
 * A component level selection event.
 * @param {object} context Component specific context about this event, such as the clientRowKey.
 * @param {DvtShowPopupBehavior} showPopupBehavior The showPopupBehavior that was triggered.
 * @param {DvtRectangle} launcherBounds The bounding box of the object that triggered the popup, 
 *                                      relative to the component's top left coordinates.
 * @param {string} launcherId The component that launched the popup.  This may be different
 *                            than the component that owns the showPopupBehavior.
 *                                      
 * @class
 * @constructor
 * @export
 */
var DvtShowPopupEvent = function(showPopupBehavior, launcherBounds, launcherId) {
  this.Init(DvtShowPopupEvent.TYPE);
  this._showPopupBehavior = showPopupBehavior;
  this._launcherBounds = launcherBounds;
  this._launcherId = launcherId;
}

DvtObj.createSubclass(DvtShowPopupEvent, DvtBaseComponentEvent, "DvtShowPopupEvent");

/**
 * @export
 */
DvtShowPopupEvent.TYPE = "showPopup";

/**
 * Returns the showPopupBehavior that was triggered.
 * @return {DvtShowPopupBehavior} The showPopupBehavior that was triggered.
 * @export
 */
DvtShowPopupEvent.prototype.getShowPopupBehavior = function() {
  return this._showPopupBehavior;
}

/**
 * Returns the bounding box of the object that triggered the popup, relative to the component's
 * top left coordinates.
 * @return {DvtRectangle} The bounding box of the object that triggered the popup, relative 
 *                        to the component's top left coordinates.
 * @export
 */
DvtShowPopupEvent.prototype.getLauncherBounds = function() {
  return this._launcherBounds;
}

/**
 * Returns the component that launched the popup.  This may be different than the component 
 * that owns the showPopupBehavior.
 * @return {string} The component that launched the popup.
 * @export
 */
DvtShowPopupEvent.prototype.getLauncherId = function() {
  return this._launcherId;
}

/**
 * Set the component that launched the popup.  This may be different than the component 
 * that owns the showPopupBehavior.
 * @param {string} The component that launched the popup.
 * @export
 */
DvtShowPopupEvent.prototype.setLauncherId = function(launcherId) {
  this._launcherId = launcherId;
}
/**
 * A component level hide popup event.
 * @param {string} popupId The id of the popup to be hidden.
 * @param {Object} relatedTarget The related target of the event that triggered the hide popup event.
 * @class
 * @constructor
 * @export
 */
var DvtHidePopupEvent = function(popupId, relatedTarget) {
  this.Init(DvtHidePopupEvent.TYPE);
  this._popupId = popupId;
  this._relatedTarget = relatedTarget;
}

DvtObj.createSubclass(DvtHidePopupEvent, DvtBaseComponentEvent, "DvtHidePopupEvent");

/**
 * @export
 */
DvtHidePopupEvent.TYPE = "hidePopup";

/**
 * Returns the id of the popup to be hidden.
 * @return {string} popupId The id of the popup to be hidden.
 * @export
 */
DvtHidePopupEvent.prototype.getPopupId = function() {
  return this._popupId;
}

/**
 * Returns the related target of the event that triggered the hide popup event.
 * @return {Object} The related target
 */
DvtHidePopupEvent.prototype.getRelatedTarget = function() {
  return this._relatedTarget;
}
/**
 * A component client behavior event.
 * @param {DvtClientBehavior} clientHeavior The clientBehavior that was triggered.
 *                                      
 * @class
 * @constructor
 * @export
 */
var DvtClientBehaviorEvent = function(clientBehavior) {
  this.Init(DvtClientBehaviorEvent.TYPE);
  this._clientBehavior = clientBehavior;
}

DvtObj.createSubclass(DvtClientBehaviorEvent, DvtBaseComponentEvent, "DvtClientBehaviorEvent");

/**
 * @export
 */
DvtClientBehaviorEvent.TYPE = "clientBehavior";

/**
 * Returns the clientBehavior that was triggered.
 * @return {DvtClientBehavior} The clientBehavior that was triggered.
 * @export
 */
DvtClientBehaviorEvent.prototype.getClientBehavior = function() {
  return this._clientBehavior;
}
/**
 * Event that is fired when interacting with a component.  This event provides context about the objects that were the
 * target of the interaction.
 * @param {string} eventType
 * @param {object} params A component specific object map describing the target of the event.
 * @class
 * @constructor
 * @export
 */
var DvtComponentUIEvent = function(eventType, params) {
  DvtComponentUIEvent.superclass.Init.call(this, eventType);
  
  /**
   * The object describing the target of the event.
   * @type {object}
   */
  this['params'] = params ? params : {};
}

DvtObj.createSubclass(DvtComponentUIEvent, DvtBaseComponentEvent, "DvtComponentUIEvent");

/**
 * @const
 * @export
 */
DvtComponentUIEvent.TYPE_CLICK = "click";

/**
 * @const
 * @export
 */
DvtComponentUIEvent.TYPE_ROLL_OUT = "rollOut";

/**
 * @const
 * @export
 */
DvtComponentUIEvent.TYPE_ROLL_OVER = "rollOver";
/**
 * A component level context menu event.
 * @param {object} nativeEvent The native event that triggered the context menu.
 * @param {string} menuId The client id of the context menu that is being requested.
 * @class
 * @constructor
 * @export
 */
var DvtContextMenuEvent = function(nativeEvent, menuId) {
  this.Init(DvtContextMenuEvent.TYPE);
  this._nativeEvent = nativeEvent;
  this._menuId = menuId;
}

DvtObj.createSubclass(DvtContextMenuEvent, DvtBaseComponentEvent, "DvtContextMenuEvent");

/**
 * @export
 */
DvtContextMenuEvent.TYPE = "contextMenu";

/**
 * Returns the native event that triggered the context menu.
 * @return {object} The native event that triggered the context menu.
 * @export
 */
DvtContextMenuEvent.prototype.getNativeEvent = function() {
  return this._nativeEvent;
}

/**
 * Returns the client id of the context menu that is being requested.
 * @return {string} The client id of the context menu that is being requested.
 * @export
 */
DvtContextMenuEvent.prototype.getMenuId = function() {
  return this._menuId;
}
/**
 * A component level event for selection of a context menu item.
 * @param {string} menuType The type of context menu being requested, such as bodyContextMenu.
 * @param {string} clientId The id for a commandMenuItem.
 * @param {string} destination The destination for a goMenuItem.
 * @param {string} targetFrame The targetFrame for a goMenuItem.
 * @class
 * @constructor
 * @export
 */
var DvtContextMenuSelectEvent = function(menuType, clientId, destination, targetFrame) {
  this.Init(DvtContextMenuSelectEvent.TYPE);
  this._menuType = menuType;
  this._clientId = clientId;
  this._destination = destination;
  this._targetFrame = targetFrame;
}

DvtObj.createSubclass(DvtContextMenuSelectEvent, DvtBaseComponentEvent, "DvtContextMenuSelectEvent");

/**
 * @export
 */
DvtContextMenuSelectEvent.TYPE = "contextMenuSelect";

/**
 * Returns the type of context menu being requested, such as bodyContextMenu.
 * @return {string} The type of context menu being requested, such as bodyContextMenu.
 * @export
 */
DvtContextMenuSelectEvent.prototype.getMenuType = function() {
  return this._menuType;
}

/**
 * Returns the id for a commandMenuItem.
 * @return {string} The id for a commandMenuItem.
 * @export
 */
DvtContextMenuSelectEvent.prototype.getClientId = function() {
  return this._clientId;
}

/**
 * Returns the destination for a goMenuItem.
 * @return {string} The destination for a goMenuItem.
 * @export
 */
DvtContextMenuSelectEvent.prototype.getDestination = function() {
  return this._destination;
}

/**
 * Returns the targetFrame for a goMenuItem.
 * @return {string} The targetFrame for a goMenuItem.
 * @export
 */
DvtContextMenuSelectEvent.prototype.getTargetFrame = function() {
  return this._targetFrame;
}
/**
 * A component level drill replace event.
 * @param {string} id The id of the data item that was drilled.
 * @class
 * @constructor
 * @export
 */
var DvtDrillReplaceEvent = function(id) {
  this.Init(DvtDrillReplaceEvent.TYPE);
  this._id = id;
}

DvtObj.createSubclass(DvtDrillReplaceEvent, DvtBaseComponentEvent, "DvtDrillReplaceEvent");

/**
 * @export
 */
DvtDrillReplaceEvent.TYPE = "drillReplace";

/**
 * Returns the id of the data item that was drilled.
 * @return {string} The id of the data item that was drilled.
 * @export
 */
DvtDrillReplaceEvent.prototype.getId = function() {
  return this._id;
}
/**
 * @constructor
 * A component level rollover behavior event.
 * @type {string} type The type of event, either roll over or roll out.
 * @type {string} category The category that is the target of the event.
 * @class
 * @constructor
 * @extends DvtBaseComponentEvent
 * @export
 */
var DvtCategoryRolloverEvent = function(type, category) {
  this.Init(type);
  this._category = category;
}

DvtObj.createSubclass(DvtCategoryRolloverEvent, DvtBaseComponentEvent, "DvtCategoryRolloverEvent");

/**
 * @export
 */
DvtCategoryRolloverEvent.TYPE_OVER = "categoryRollOver";

/**
 * @export
 */
DvtCategoryRolloverEvent.TYPE_OUT = "categoryRollOut";

/**
 * Returns the category that is target of the event.
 * @return {string}
 * @export
 */
DvtCategoryRolloverEvent.prototype.getCategory = function() {
  return this._category;
}
/**
 * A component level hide and show behavior event.
 * @type {string} type The type of event, either hide or show.
 * @type {string} category The category that is the target of the event.
 * @constructor
 * @class
 * @extends DvtBaseComponentEvent
 * @export
 */
var DvtCategoryHideShowEvent = function(type, category) {
  this.Init(type);
  this._category = category;
}

DvtObj.createSubclass(DvtCategoryHideShowEvent, DvtBaseComponentEvent, "DvtCategoryHideShowEvent");

/**
 * @export
 */
DvtCategoryHideShowEvent.TYPE_HIDE = "hideCategory";

/**
 * @export
 */
DvtCategoryHideShowEvent.TYPE_SHOW = "showCategory";

/**
 * Returns the category that is target of the event.
 * @return {string}
 * @export
 */
DvtCategoryHideShowEvent.prototype.getCategory = function() {
  return this._category;
}
/**
 * A pan event.
 * @param {string}  subType  subtype of the event; one of the constants 
 *        defined in this class
 * @param {number}  newX  new x-coord
 * @param {number}  newY  new y-coord
 * @param {number}  oldX  old x-coord
 * @param {number}  oldY  old y-coord
 * @param {DvtAnimator}  animator  optional animator used to animate the zoom
 * @class
 * @constructor
 */
var DvtPanEvent = function(subType, newX, newY, oldX, oldY, animator) {
  this.Init(DvtPanEvent.TYPE);
  this.type = this.getType();
  this._subtype = subType;
  this._newX = newX;
  this._newY = newY;
  this._oldX = oldX;
  this._oldY = oldY;
  this._animator = animator;
};

DvtObj.createSubclass(DvtPanEvent, DvtBaseComponentEvent, "DvtPanEvent");

DvtPanEvent.TYPE = "dvtPan";

DvtPanEvent.SUBTYPE_DRAG_PAN_BEGIN = "dragPanBegin";
DvtPanEvent.SUBTYPE_DRAG_PAN_END = "dragPanEnd";
DvtPanEvent.SUBTYPE_PANNED = "panned";
DvtPanEvent.SUBTYPE_PANNING = "panning";
DvtPanEvent.SUBTYPE_ELASTIC_ANIM_BEGIN = "elasticAnimBegin";
DvtPanEvent.SUBTYPE_ELASTIC_ANIM_END = "elasticAnimEnd";

/**
 * 
 */
DvtPanEvent.prototype.getSubType = function() {
  return this._subtype;
};

/**
 * 
 */
DvtPanEvent.prototype.getNewX = function() {
  return this._newX;
};

/**
 * 
 */
DvtPanEvent.prototype.getNewY = function() {
  return this._newY;
};

/**
 * 
 */
DvtPanEvent.prototype.getOldX = function() {
  return this._oldX;
};

/**
 * 
 */
DvtPanEvent.prototype.getOldY = function() {
  return this._oldY;
};

/**
 * 
 */
DvtPanEvent.prototype.getAnimator = function() {
  return this._animator;
};
/**
 * A zoom event.
 * @param {string}  subType  subtype of the event; one of the constants 
 *        defined in this class
 * @param {number}  newZoom  new zoom factor
 * @param {number}  oldZoom  old zoom factor
 * @param {DvtAnimator}  animator  optional animator used to animate the zoom
 * @param {DvtRectangle}  zoomToFitBounds  bounds to use for zoom-to-fit
 * @param {DvtPoint}  centerPoint  center of zoom
 * @param {number}  tx  the horizontal translation applied after the zoom
 * @param {number}  ty  the vertical translation applied after the zoom
 * @class
 * @constructor
 */
var DvtZoomEvent = function(subType, newZoom, oldZoom, animator, zoomToFitBounds, centerPoint, tx, ty) {
  this.Init(DvtZoomEvent.TYPE);
  this.type = this.getType();
  this._subtype = subType;
  this._newZoom = newZoom;
  this._oldZoom = oldZoom;
  this._animator = animator;
  this._zoomToFitBounds = zoomToFitBounds;
  this._centerPoint = centerPoint;
  this._tx = tx;
  this._ty = ty;
};

DvtObj.createSubclass(DvtZoomEvent, DvtBaseComponentEvent, "DvtZoomEvent");

DvtZoomEvent.TYPE = "dvtZoom";

/**
 * Zoomed event - component might need to rerender on this event
 * @const
 */
DvtZoomEvent.SUBTYPE_ZOOMED = "zoomed";
/**
 * Zooming event - used to notify a component of zooming event 
 * @const
 */
DvtZoomEvent.SUBTYPE_ZOOMING = "zooming";
/**
 * ZoomEnd event - it is the end of the zoom event. The difference between "zoomed" and "zoomEnd" is on touch device.
 * A component gets "zoomed" events for appropriate "touchmove" events. When all touches are released on "touchend"  the component will get "zoomEnd" notification.
 * @const
 */
DvtZoomEvent.SUBTYPE_ZOOM_END = "zoomEnd";
DvtZoomEvent.SUBTYPE_DRAG_ZOOM_BEGIN = "dragZoomBegin";
DvtZoomEvent.SUBTYPE_DRAG_ZOOM_END = "dragZoomEnd";
DvtZoomEvent.SUBTYPE_ZOOM_AND_CENTER = "zoomAndCenter";
DvtZoomEvent.SUBTYPE_ZOOM_TO_FIT_CALC_BOUNDS = "zoomToFitCalcBounds";
DvtZoomEvent.SUBTYPE_ZOOM_TO_FIT_BEGIN = "zoomToFitBegin";
DvtZoomEvent.SUBTYPE_ZOOM_TO_FIT_END = "zoomToFitEnd";
DvtZoomEvent.SUBTYPE_ELASTIC_ANIM_BEGIN = "elasticAnimBegin";
DvtZoomEvent.SUBTYPE_ELASTIC_ANIM_END = "elasticAnimEnd";

/**
 * Subtype representing a zoom event fired before the SUBTYPE_ZOOMING event to give components a chance adjust the
 * pan constraints
 * 
 * @const
 */
DvtZoomEvent.SUBTYPE_ADJUST_PAN_CONSTRAINTS = "adjustPanConstraints";

/**
 * 
 */
DvtZoomEvent.prototype.getSubType = function() {
  return this._subtype;
};

/**
 * 
 */
DvtZoomEvent.prototype.getNewZoom = function() {
  return this._newZoom;
};

/**
 * 
 */
DvtZoomEvent.prototype.getOldZoom = function() {
  return this._oldZoom;
};

/**
 * 
 */
DvtZoomEvent.prototype.getAnimator = function() {
  return this._animator;
};

/**
 * 
 */
DvtZoomEvent.prototype.setZoomToFitBounds = function(bounds) {
  this._zoomToFitBounds = bounds;
};

/**
 * 
 */
DvtZoomEvent.prototype.getZoomToFitBounds = function() {
  return this._zoomToFitBounds;
};

/**
 * 
 */
DvtZoomEvent.prototype.getCenterPoint = function() {
  return this._centerPoint;
};

/**
 * Gets the horizontal translation applied after the zoom
 * 
 * @return {number} the horizontal translation applied after the zoom
 */
DvtZoomEvent.prototype.getTx = function() {
  return this._tx;
}

/**
 * Gets the vertical translation applied after the zoom
 * 
 * @return {number} the vertical translation applied after the zoom
 */
DvtZoomEvent.prototype.getTy = function() {
  return this._ty;
}
/**
 * An action event.
 * ActionEvent is generated by a AfCommandButton, AfCommandLink,  AfCommandImageLink or
 * AfCommandMenuItem when it is clicked
 * @param {string}  commandId
 * @param {string}  clientId
 * @class
 * @constructor
 * @export
 */
var DvtActionEvent = function(actionEventType, commandId, clientId) {
  this.Init(DvtActionEvent.TYPE);
  this.type = this.getType();
  this._subtype = actionEventType;
  this._commandId = commandId;
  this._clientId = clientId;
};

DvtObj.createSubclass(DvtActionEvent, DvtBaseComponentEvent, "DvtActionEvent");

/**
 * @export
 */
DvtActionEvent.TYPE = "dvtAct";

/**
 * @export
 */
DvtActionEvent.SUBTYPE_ACTION = "action";
//DvtActionEvent.SUBTYPE_NAVIGATE_UP = "navigateUp";
DvtActionEvent.SUBTYPE_SET_ANCHOR = "setAnchor";


DvtActionEvent.prototype.getSubType = function() {
  return this._subtype;
};

DvtActionEvent.prototype.getCommandId = function() {
  return this._commandId;
};

/**
 * @export
 */
DvtActionEvent.prototype.getClientId = function() {
  return this._clientId;
};

DvtActionEvent.prototype.setClientId = function(clientId) {
  this._clientId = clientId;
};

// Copyright (c) 2011, 2013, Oracle and/or its affiliates. 
// All rights reserved. 
var DvtEventDispatcher = {};

DvtObj.createSubclass(DvtEventDispatcher, DvtObj, "DvtEventDispatcher");

/**
 * Dispatches the event to the callback function.
 * @param {object} callback The function that should be called to dispatch component events.
 * @param {object} callbackObj The object context for the callback function
 * @param {object} component The component firing the event
 * @param {object} event The event to be dispatched.
 * @protected
 */
DvtEventDispatcher.dispatchEvent = function(callback, callbackObj, component, event) {
  if (!callback)
    return;
  else if (callback && callback.call) 
    callback.call(callbackObj, event, component);
  else {
    // THIS CODE PATH WILL NOT WORK AFTER JS OBFUSCATION!!!

    // Create the string to be called
    var result = callback + "(event, component)";
    
    // Evaluate the javascript string.  The callback is defined by the peer,
    // and never is the result of user input, so there is no security hole
    // in using eval here.
    eval(result);
  }
};
/**
 * A component level isolate event.
 * @param {array} isolatedRows The array of currently disclosed ids for the component.
 * @class
 * @constructor
 * @export
 */
var DvtIsolateEvent = function(isolatedRows) {
  this.Init(DvtIsolateEvent.TYPE);
  this._isolatedRows = isolatedRows;
}

DvtObj.createSubclass(DvtIsolateEvent, DvtBaseComponentEvent, "DvtIsolateEvent");

/**
 * @export
 */
DvtIsolateEvent.TYPE = "isolate";

/**
 * Returns the array of currently isolated ids for the component.
 * @return {array} The array of currently isolated ids for the component.
 * @export
 */
DvtIsolateEvent.prototype.getIsolatedRows = function() {
  return this._isolatedRows;
}
/**
 * A component level log event.
 * @param {string} logType the type of this log event: either DvtLogEvent.PERFORMANCE or DvtLogEvent.LOG
 * @param {int} level the level of this log event
 * @param {string} message the message to be logged
 * @class
 * @constructor
 * @export
 */
var DvtLogEvent = function(logType, level, message) {
  this.Init(DvtLogEvent.TYPE);
  this._logType = logType;
  this._level = level;
  this._message = message;
}

DvtObj.createSubclass(DvtLogEvent, DvtBaseComponentEvent, "DvtLogEvent");

/**
 * @export
 */
DvtLogEvent.TYPE = "log";

/**
 * @export
 */
DvtLogEvent.PERFORMANCE = "performance";

/**
 * @export
 */
DvtLogEvent.LOG = "log";


/**
 * Returns the type of this log event: either DvtLogEvent.PERFORMANCE or DvtLogEvent.LOG
 * @return {string} the type of this log event
 * @export
 */
DvtLogEvent.prototype.getLogType = function() {
  return this._logType;
}

/**
 * Returns the level of this log event
 * @return {int} the level of this log event
 * @export
 */
DvtLogEvent.prototype.getLevel = function() {
  return this._level;
}

/**
 * Returns the message to be logged
 * @return {string} the message to be logged
 * @export
 */
DvtLogEvent.prototype.getMessage = function() {
  return this._messaage;
}
/**
 * A component level set property event.
 * @class
 * @constructor
 * @export
 */
var DvtSetPropertyEvent = function() {
  this.Init(DvtSetPropertyEvent.TYPE);
}

DvtObj.createSubclass(DvtSetPropertyEvent, DvtBaseComponentEvent, "DvtSetPropertyEvent");

/**
 * @export
 */
DvtSetPropertyEvent.TYPE = "dvtSetPropertyEvent";
/**
 * @constructor
 * @export
 */
var DvtActiveElementChangeEvent = function(subtype, id) {
  this.Init(DvtActiveElementChangeEvent.TYPE);
  this._subtype = subtype;
  this._id = id;
}

DvtObj.createSubclass(DvtActiveElementChangeEvent, DvtBaseComponentEvent, "DvtActiveElementChangeEvent");

/**
 * @export
 */
DvtActiveElementChangeEvent.TYPE = "activeElementChangeEvent";

/**
 * @export
 */
DvtActiveElementChangeEvent.CHANGE = "change";

/**
 * @export
 */
DvtActiveElementChangeEvent.prototype.getId = function() {
  return this._id;
}
// Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
/*-------------------------------------------------------------------------*/
/*  DvtToolkitUtils()                                                          */
/*-------------------------------------------------------------------------*/

// SVG Utilities for Drawing

/**
 * @class
 * @export
 */
var DvtToolkitUtils = new Object();

DvtObj.createSubclass(DvtToolkitUtils, DvtObj, "DvtToolkitUtils");

DvtToolkitUtils.SVG_NS   = "http://www.w3.org/2000/svg";
DvtToolkitUtils.XLINK_NS = "http://www.w3.org/1999/xlink";

/**
 * Creates and returns a new SVG document with the specified id.
 * @param {string} id The id for the new SVG document.
 * @return A new SVG document.
 * @export
 */
DvtToolkitUtils.createSvgDocument = function(id) {
  var svg = document.createElementNS(DvtToolkitUtils.SVG_NS, "svg");
  DvtToolkitUtils.setAttrNullNS(svg, "id", id);
  DvtToolkitUtils.setAttrNullNS(svg, "width", "100%");
  DvtToolkitUtils.setAttrNullNS(svg, "height", "100%");
  return svg;
}

/**
 * Returns the drag feedback for the specified objects.
 * @param {object} displayables The DvtDisplayable or array of DvtDisplayables to display for drag feedback.
 * @return {object} An object containing drag feedback information.
 */
DvtToolkitUtils.getDragFeedback = function (displayables, targetCoordinateSpace) { 
  // Wrap in an array if not already wrapped.
  if (!(displayables instanceof Array)) {
    displayables = [displayables];
  }
  var bounds = DvtDnDUtils.getDragFeedbackBounds(displayables, targetCoordinateSpace);
  var svg = DvtToolkitUtils._getDragFeedbackSVG(displayables, bounds);

  var feedback = new Object();
  feedback.width = bounds.w + DvtDragSource.DRAG_FEEDBACK_MARGIN * 2;
  feedback.height = bounds.h + DvtDragSource.DRAG_FEEDBACK_MARGIN * 2;
  if (svg)
    feedback.svg = svg;

  return feedback;
}

/**
 * Returns an svg string representing the drag over feedback.
 * @param {object} displayables The DvtDisplayable or array of DvtDisplayables to display for drag feedback.
 * @param {DvtRectangle} bounds The bounds for the drag feedback displayables, used to translate the feedback to 0.
 * @private
 */
DvtToolkitUtils._getDragFeedbackSVG = function(displayables, bounds) {
  /// BUG #12805155: A new svg document must be created programmatically and appended to the wrapping div later on.
  //  This is necessary for Safari 5.0 and earlier, as well as iOS.  innerHTML should not be used.
  var svgElem = DvtToolkitUtils.createSvgDocument("dnd");
  
  // Create a group element to apply the top level translate to show the drag feedback at (0, 0)
  var tx = DvtDragSource.DRAG_FEEDBACK_MARGIN - bounds.x;
  var ty = DvtDragSource.DRAG_FEEDBACK_MARGIN - bounds.y;
  var translate = "translate(" + tx + "," + ty + ")";
  var container = DvtSvgShapeUtils.createElement("g");
  DvtToolkitUtils.setAttrNullNS(container, 'transform', translate) ;
  DvtToolkitUtils.appendChildElem(svgElem, container);
  
  // Loop through and add the displayables
  for (var i = 0;i < displayables.length;i++) {
    
    var src = displayables[i];
    // Clone the selected node and add
    var elem = src.getImpl().getElem();
    var clone = elem.cloneNode(true);
    
    // Remove filters if present, since these effects overflow the bounds and look broken
    if(DvtToolkitUtils.getAttrNullNS(clone, 'filter'))
      DvtToolkitUtils.setAttrNullNS(clone, 'filter', null);
    
    var cloneContainer = DvtSvgShapeUtils.createElement("g");
    DvtToolkitUtils.appendChildElem(container, cloneContainer);
    var pathToStage = src.getPathToStage();
    var mat = null;
    for (var j=1; j<pathToStage.length; j++) {
      if (!mat)
        mat = pathToStage[j].getMatrix();
      else {
        mat = mat.clone();
        mat.concat(pathToStage[j].getMatrix());
      }
    }
    if (mat) {
      var sMat = 'matrix(' + mat.getA() + ',' + mat.getC() + ',' + mat.getB() + ',' + mat.getD() + ',' + mat.getTx() + ',' + mat.getTy() + ')';
      DvtToolkitUtils.setAttrNullNS(cloneContainer, 'transform', sMat);
    }
    DvtToolkitUtils.appendChildElem(cloneContainer, clone);
  }
  
  return svgElem;
}

/**
 * Add an event listener to a DOM element.
 * @param {object} elem DOM element
 * @param {string} type type of event
 * @param {function} listener the listener function
 * @param {boolean} useCapture true if the listener operates in the capture phase, false otherwise
 */
DvtToolkitUtils.addDomEventListener = function(elem, type, listener, useCapture) {
  if (elem && elem.addEventListener) {
    elem.addEventListener(type, listener, useCapture);
  }
}

/**
 * Remove an event listener from a DOM element.
 * @param {object} elem DOM element
 * @param {string} type type of event
 * @param {function} listener the listener function
 * @param {boolean} useCapture true if the listener operates in the capture phase, false otherwise
 */
DvtToolkitUtils.removeDomEventListener = function(elem, type, listener, useCapture) {
  if (elem && elem.removeEventListener) {
    elem.removeEventListener(type, listener, useCapture);
  }
}

/**
 * Wrapper for appendChild method
 * @param {object} parent DOM element
 * @param {object} child DOM element added to parent
 * @return {object} the appended element (child)
 */
DvtToolkitUtils.appendChildElem = function(parent,child) {
  return parent.appendChild(child);
}

/**
 * Wrapper for getAttributeNS method
 * @param {object} elem DOM element
 * @param {string} namespace Namespace to use
 * @param {string} name Attribute name to get
 * @return {string} Value associated with given name
 */
DvtToolkitUtils.getAttrNS = function(elem,namespace,name) {
  return elem.getAttributeNS(namespace,name);
}

/**
 * Wrapper for getAttributeNS method
 * @param {object} elem DOM element
 * @param {string} name Attribute name to get
 * @return {string} Value associated with given name
 */
DvtToolkitUtils.getAttrNullNS = function(elem,name) {
  return elem.getAttributeNS(null, name);
}

/**
 * Wrapper for hasAttributeNS method
 * @param {object} elem DOM element
 * @param {string} namespace The namespace of the attribute.
 * @param {string} name the name of the attribute.
 * @return {boolean} true if the element has the specified attribute.
 */
DvtToolkitUtils.hasAttrNS = function(elem, namespace, name) {
  return elem.hasAttributeNS(namespace, name);
}

/**
 * Wrapper for hasAttributeNS method
 * @param {object} elem DOM element
 * @param {string} name the name of the attribute.
 * @return {boolean} true if the element has the specified attribute.
 */
DvtToolkitUtils.hasAttrNullNS = function(elem, name) {
  return DvtToolkitUtils.hasAttrNS(elem, null, name);
}

/**
 * Wrapper for setAttributeNS method.  When the value of the attribute matches the default value, the DOM will not be 
 * updated unless the attribute has already been set to a different value.
 * @param {object} elem DOM element
 * @param {string} namespace The namespace of the attribute.
 * @param {string} name the name of the attribute.
 * @param {string} value The value of the attribute.
 * @param {string} [defaultValue] The default value of the attribute, which can be provided to optimize performance.
 */
DvtToolkitUtils.setAttrNS = function(elem, namespace, name, value, defaultValue) {
  // Note: We're not strict about value or defaultValue being String types, since browser implementations are not. The
  //       code in this function should always assume that users may pass objects that would be converted to Strings.

  // If defaultValue specified and value matches default, optimize the DOM calls
  if(defaultValue != null && value == defaultValue) {
    if(DvtToolkitUtils.hasAttrNS(elem, namespace, name))
      DvtToolkitUtils.removeAttrNS(elem, namespace, name);
    
    // DOM no longer has attribute, so it will default.
    return;
  }
  
  // Otherwise set the attribute
  elem.setAttributeNS(namespace, name, value);
}

/**
 * Wrapper for setAttributeNS method.  When the value of the attribute matches the default value, the DOM will not be 
 * updated unless the attribute has already been set to a different value.
 * @param {object} elem DOM element
 * @param {string} name the name of the attribute.
 * @param {string} value The value of the attribute.
 * @param {string} [defaultValue] The default value of the attribute, which can be provided to optimize performance.
 */
DvtToolkitUtils.setAttrNullNS = function(elem, name, value, defaultValue) {
  DvtToolkitUtils.setAttrNS(elem, null, name, value, defaultValue);
}

/**
 * Remove an attribute from a DOM element.
 * @param {object} elem DOM element
 * @param {string} namespace Namespace to use
 * @param {string} name Attribute name to remove
 */
DvtToolkitUtils.removeAttrNS = function(elem, namespace, name) {
  elem.removeAttributeNS(namespace, name);
}

/**
 * Remove an attribute from a DOM element, using a null namespace.
 * @param {object} elem DOM element
 * @param {string} name Attribute name to remove
 */
DvtToolkitUtils.removeAttrNullNS = function(elem, name) {
  DvtToolkitUtils.removeAttrNS(elem, null, name);
}
/**
 * Utility resource bundle.
 * @class
 * @constructor
 * @extends {DvtUtilBundle}
 */
var DvtUtilBundle = function() {}

DvtObj.createSubclass(DvtUtilBundle, DvtBundle, "DvtUtilBundle");

DvtUtilBundle["_defaults"] = {
  'SCALING_SUFFIX_THOUSAND': 'K',
  'SCALING_SUFFIX_MILLION': 'M',
  'SCALING_SUFFIX_BILLION': 'B',
  'SCALING_SUFFIX_TRILLION': 'T',
  'SCALING_SUFFIX_QUADRILLION': 'Q',
  
  'MONTH_SHORT_JANUARY': 'Jan',
  'MONTH_SHORT_FEBRUARY': 'Feb',
  'MONTH_SHORT_MARCH': 'Mar',
  'MONTH_SHORT_APRIL': 'Apr',
  'MONTH_SHORT_MAY': 'May',
  'MONTH_SHORT_JUNE': 'Jun',
  'MONTH_SHORT_JULY': 'Jul',
  'MONTH_SHORT_AUGUST': 'Aug',
  'MONTH_SHORT_SEPTEMBER': 'Sep',
  'MONTH_SHORT_OCTOBER': 'Oct',
  'MONTH_SHORT_NOVEMBER': 'Nov',
  'MONTH_SHORT_DECEMBER': 'Dec',
  
  'CLEAR_SELECTION': 'Clear Selection'
}

/**
 * @override
 */
DvtUtilBundle.prototype.GetDefaultStringForKey = function(key) {
  return DvtUtilBundle["_defaults"][key];
}

/**
 * @override
 */
DvtUtilBundle.prototype.GetBundlePrefix = function() {
  return "DvtUtilBundle";
}
// Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.
/**
 * Document APIs.
 * @class DvtSvgDocumentUtils
 */
var DvtSvgDocumentUtils = function(){};

DvtObj.createSubclass(DvtSvgDocumentUtils, DvtObj, "DvtSvgDocumentUtils");

// TODO JSDoc
// Return displayable
DvtSvgDocumentUtils.elementFromPoint = function(posX, posY) {
  var domObj = document.elementFromPoint(posX, posY);
  while (domObj) {
    if (domObj._obj && domObj._obj.getObj && domObj._obj.getObj()) {
        return domObj._obj.getObj();
    }
    domObj = domObj.parentNode;
  }
  return null;
};

/**
 * Wrapper for the elementFromPoint function that uses clientX and clientY coordinates 
 * from the touch to find a corresponding displayable object
 * @param {DvtTouch} touch The touch being passed in to evaluate the element it corresponds to
 * @return {DvtDisplayable} displayable The dom object the touch corresponds to
 */
DvtSvgDocumentUtils.elementFromTouch = function(touch) {
  return this.elementFromPoint(touch.clientX, touch.clientY);
}

/**
 * Returns true if SVG filters are supported.
 * @return {boolean}
 */
DvtSvgDocumentUtils.isFilterSupported = function(stage) {
  // Filters not supported in IE, Safari < 6, Android
  return !DvtAgent.isPlatformIE() && 
         !(DvtAgent.isBrowserSafari() && DvtAgent.getVersion() < 536) &&
         !(DvtAgent.isTouchDevice() && !DvtAgent.isBrowserSafari());
}

DvtSvgDocumentUtils.isStrokeTimeoutRequired = function() {
    return DvtAgent.isBrowserChrome() && !DvtAgent.isEnvironmentTest();
}

/*
 * Whether or not events in SVG are received on regions that are visually clipped such that they are not visible
 */
DvtSvgDocumentUtils.isEventAvailableOutsideClip = function() {
    return DvtAgent.isBrowserSafari();
}

/*
 * Bug #12805402: In Firefox 4, horizontal/vertical polylines must be bent by 0.01 pixes to show up when fitlers are used
 */
DvtSvgDocumentUtils.isFilterStraightLineAdjustmentNeeded = function() {
    return DvtAgent.isPlatformGecko();
}

/**
 * Work around bug 16575172, where removing filters from children or 
 * removing children that have filters can leave behind rendering artifacts 
 * in Firefox.
 * @param displayable The displayable to refresh.
 */
DvtSvgDocumentUtils.fixGeckoContainerForFilter = function(displayable) {
  if (displayable && DvtAgent.isPlatformGecko()) {
    var elem = displayable.getImpl().getElem();
    if (elem) {
      var transformAttr = DvtToolkitUtils.getAttrNullNS(elem, 'transform');
      //error message logged to Firefox console if transformAttr is null,
      //so initialize it to identity matrix instead
      if (!transformAttr) {
        transformAttr = "matrix(1 0 0 1 0 0)";
      }
      DvtToolkitUtils.setAttrNullNS(elem, 'transform', transformAttr);
    }
  }
}

/**
 * Cancel a DOM event.
 * 
 * @param {object}  e  event object to cancel
 */
DvtSvgDocumentUtils.cancelDomEvent = function(e)
{
  //if (!e)
  //{
  //  e = window.event;
  //}
  if (e)
  {
    if (e.stopPropagation)
      e.stopPropagation();
    if (e.preventDefault)
      e.preventDefault();
    e.cancelBubble = true;
    e.cancel = true;
    e.returnValue = false;
  }
}
/**
 * DvtSvgImageLoader.loadImage("pic.png", function(image) {
 *   alert(image.width);
 *   alert(image.height);
 * });
 * 
 */

/*
 * DvtSvgImageLoader
 */
var DvtSvgImageLoader = { _cache: {} };

DvtObj.createSubclass(DvtSvgImageLoader, DvtObj, "DvtSvgImageLoader");

/**
 * Copied from AdfIEAgent and AdfAgent
 * Adds an event listener that fires in the non-Capture phases for the specified
 * eventType.  There is no ordering guaranteee, nor is there a guarantee
 * regarding the number of times that an event listener will be called if
 * it is added to the same element multiple times.
 */
DvtSvgImageLoader.addBubbleEventListener = function(element, type, listener) 
{
  if (window.addEventListener) {
    DvtToolkitUtils.addDomEventListener(element, type, listener, false);
    return true;
  } 
  // Internet Explorer
  else if (window.attachEvent) {
    element.attachEvent("on" + type, listener);
    return true;
  }
  else {
    return false;
  }
};


/**
 * @this {DvtSvgImageLoader}
 * Load an image.
 * 
 * @param src URL of the image to load
 * @param onComplete function to call when the image is loaded
 * 
 * @return image if image is already loaded
 *         otherwise null
 */
DvtSvgImageLoader.loadImage = function(src, onComplete) {
  //first look for a cached copy of the image
  var entry = this._cache[src];

  //if cached image found, use it
  if (entry) {
    // if image is loading, add listener to queue
    if (entry._image) {
      DvtSvgImageLoader._addListenerToQueue(entry._listeners, onComplete);
    }
    // if image is loaded, call onComplete function
    else {
      if (onComplete) {
        onComplete(entry);
      }
      // no handler, just return image width and height
      return entry;
    }
  }
  //if cached image not found, load the new image
  else {
    this.loadNewImage(src, onComplete);
  }
  return null;
};

/**
 * @this {DvtSvgImageLoader}
 * Load a new image.
 * 
 * @param src URL of the image to load
 * @param onComplete function to call when the image is loaded 
 */
DvtSvgImageLoader.loadNewImage = function(src, onComplete) {

  // create img element
  var image = document.createElement('img');

  // add a new entry to the image cached
  // depending on the state, entry value contains different attributes
  // when image is loading, entry contains image element and listeners
  // when image is loaded, entry contains image width and height
  var newEntry = {
    _listeners:[], 
    url: src,
    _image: image
  };
  if (onComplete) {
//    newEntry._listeners.push(onComplete);
    DvtSvgImageLoader._addListenerToQueue(newEntry._listeners, onComplete);
  }

  this._cache[src] = newEntry;

  DvtSvgImageLoader.addBubbleEventListener(image, 'load', function(e) {
      // copy width and height to entry and delete image element
      newEntry.width = image.width;
      newEntry.height = image.height;
      delete newEntry._image;

      // notify all listeners image loaded and delete all listeners
      var i;
      var len = newEntry._listeners.length;
      for (i = 0; i < len; i++) {
        // if there is a listener
        if (newEntry._listeners[i]) {
        newEntry._listeners[i](newEntry);
        }
      }
      delete newEntry._listeners;
    });

  image.src = src;

};


// add a listener to the queue only if it doesn't already exist
DvtSvgImageLoader._addListenerToQueue = function(queue, listener) {
  if (listener) {
    for (var i = 0; i < queue.length; i++) {
      if (queue[i] === listener)
        return;
    }
    queue.push(listener);
  }
};

/**
 * @constructor
 * Wrapper class providing access to SVG Events.
 * @extends DvtObj
 * @class DvtSvgBaseEvent
 * <p>The supported fields are:
 * <ul>
 * <li>target</li>
 * <li>type</li>
 * </ul>
 * <p>
 */
var DvtSvgBaseEvent = function(event) {
  this.Init(event);
}

DvtObj.createSubclass(DvtSvgBaseEvent, DvtObj, "DvtSvgBaseEvent");

/**
 * @protected
 * @param {MouseEvent} the DOM Mouse Event
 */
DvtSvgBaseEvent.prototype.Init = function(event) {
  // Save the event
  this._event = event;
  this._isPropagationStopped = false;

  // Find the DvtObj corresponding to the event target
  this.target = DvtSvgBaseEvent.FindDisplayable(event.target);

  this.type = event.type;
}

// TODO JSDoc
DvtSvgBaseEvent.prototype.getNativeEvent = function() {
  return this._event;
}

DvtSvgBaseEvent.prototype.preventDefault = function() {
    this._event.preventDefault();
} 

DvtSvgBaseEvent.prototype.stopPropagation = function() {
    if (this._event.stopPropagation)
      this._event.stopPropagation();
    this._event.cancelBubble = true;
    this._event.cancel = true;
    this._event.returnValue = false;
    this._isPropagationStopped = true;
} 

DvtSvgBaseEvent.prototype.isPropagationStopped = function() {
  return this._isPropagationStopped;
} 

/**
 * Given an SVG DOM target, returns the corresponding DvtDisplayable.
 * @return {DvtDisplayable} The corresponding displayable, if any.
 */
DvtSvgBaseEvent.FindDisplayable = function(target) {
  while(target) {
    // If this object has a displayable, return it
    if(target._obj && target._obj.getObj && target._obj.getObj())
      return target._obj.getObj();
    else // Otherwise look at the parent
      target = target.parentNode;
  }
  
  // Displayable not found, return null
  return null;
}
var DvtSvgEventFactory = new Object();

DvtObj.createSubclass(DvtSvgEventFactory, DvtObj, "DvtSvgEventFactory");

// Note: this doesn't need to live in the factory because it will always be called
// by impl specific code looking to wrap the event.
// TODO JSDoc
DvtSvgEventFactory.newEvent = function(nativeEvent, context) {
  // TODO detect the event type and perform wrapping as needed
  var eventType = nativeEvent.type;
  if (eventType == DvtTouchEvent.TOUCHSTART || eventType == DvtTouchEvent.TOUCHMOVE || eventType == DvtTouchEvent.TOUCHEND || eventType == DvtTouchEvent.TOUCHCANCEL) {
      return new DvtSvgTouchEvent(nativeEvent, context);
  } 
  else if(eventType == DvtKeyboardEvent.KEYDOWN || eventType == DvtKeyboardEvent.KEYUP) {
      return new DvtSvgKeyboardEvent(nativeEvent);
  }  
  else {
      // TODO check for type
      //BUG FIX 14187937: if the native event is the same as the last one, return the stored logical event,
      //otherwise create a new logical event and store the pair of events
      if (context._nativeEvent != nativeEvent) {
        context._nativeEvent = nativeEvent;
        context._logicalEvent = new DvtSvgMouseEvent(nativeEvent);
      }
      return context._logicalEvent;
  }
};

/**
 * Returns a DvtSvgMouseEvent that wraps the given keyboard event.  The given stageX and stageY coordinates are used to
 * compute the DvtSvgMouseEvent's pageX and pageY fields
 * 
 * @param {DvtKeyboardEvent} keyboardEvent
 * @param {DvtContext} context
 * @param {String} eventType
 * @param {DvtStage} stage
 * @param {Number} stageX
 * @param {Number} stageY
 * @return {DvtSvgMouseEvent}
 */
DvtSvgEventFactory.generateMouseEventFromKeyboardEvent = function(keyboardEvent, context, eventType, stage, stageX, stageY)
{
  var nativeEvent = null;
  
  if (document.createEvent) 
  {
    nativeEvent = document.createEvent("MouseEvents");
    
    var pageCoord = context.stageToPageCoords(stageX, stageY);
    
    nativeEvent.initMouseEvent(eventType, true, true, window, 1, pageCoord.x, pageCoord.y, pageCoord.x, pageCoord.y,
                         keyboardEvent.ctrlKey, keyboardEvent.altKey, keyboardEvent.shiftKey, keyboardEvent.metaKey,
                         0, null);
  }    
  
  if(nativeEvent)
  {
    var mouseEvent = DvtSvgEventFactory.newEvent(nativeEvent, context);
    mouseEvent.target = keyboardEvent.target;
    return mouseEvent;
  }
  else
    return null;
}
/**
 * @constructor
 * Wrapper class providing access to SVG Keyboard Events.
 * @extends DvtKeyboardEvent
 * @class DvtSvgKeyboardEvent
 * <p>The supported fields are:
 * <ul>
 * <li>altKey</li>
 * <li>ctrlKey</li>
 * <li>shiftKey</li>
 * <li>charCode</li>
 * <li>keyCode</li>
 * </ul>
 * <p>
 */
// TODO: add support for a source and target fields
var DvtSvgKeyboardEvent = function(event) {
  this.Init(event);
}

DvtObj.createSubclass(DvtSvgKeyboardEvent, DvtKeyboardEvent, "DvtSvgKeyboardEvent");


/**
 * @protected
 * @param {KeyboardEvent} the DOM Keyboard Event
 */
DvtSvgKeyboardEvent.prototype.Init = function(event) {
  DvtSvgKeyboardEvent.superclass.Init.call( this, 
                                            event.type, 
                                            event.bubbles,
                                            event.cancelable,
                                            event.view,
                                            event.charCode,
                                            event.keyCode,
                                            event.keyLocation,
                                            event.ctrlKey,
                                            event.altKey,
                                            event.shiftKey,
                                            event.repeat,
                                            event.locale );
                                            
  // TODO - what about event.target?                                            
  this._event = event;
}

/**
 * @override
 */
DvtSvgKeyboardEvent.prototype.getNativeEvent = function()
{
  return this._event;
}

/**
 * @override
 */
DvtSvgKeyboardEvent.prototype.preventDefault = function() {
    this._event.preventDefault();
} 

/**
 * @override
 */
DvtSvgKeyboardEvent.prototype.stopPropagation = function() {
    if (this._event.stopPropagation)
      this._event.stopPropagation();
    this._event.cancelBubble = true;
    this._event.cancel = true;
    this._event.returnValue = false;
} 
/**
 * @constructor
 * Wrapper class providing access to SVG Mouse Events.
 * @extends DvtSvgBaseEvent
 * @class DvtSvgMouseEvent
 * <p>The supported fields are:
 * <ul>
 * <li>ctrlKey</li>
 * <li>relatedTarget</li>
 * <li>target</li>
 * <li>type</li>
 * </ul>
 * <p>
 */
var DvtSvgMouseEvent = function(event) {
  this.Init(event);
}

DvtObj.createSubclass(DvtSvgMouseEvent, DvtSvgBaseEvent, "DvtSvgMouseEvent");

/**
 * @protected
 * @param {MouseEvent} the DOM Mouse Event
 */
DvtSvgMouseEvent.prototype.Init = function(event) {

  DvtSvgMouseEvent.superclass.Init.call(this, event);
  
  // Find the DvtObj corresponding to the event target
  if(event.relatedTarget != null)
    this.relatedTarget = DvtSvgBaseEvent.FindDisplayable(event.relatedTarget);  
  
  // Copy the remaining information
  this.button = event.button;
  this.ctrlKey = event.ctrlKey || event.metaKey;
  this.shiftKey = event.shiftKey;
  this.pageX = event.pageX;
  this.pageY = event.pageY;
  //Bug 17369581: Flag indicates if the event is modified for Internet Explorer
  this._isEventModifiedForIE = false;

  if (event.wheelDelta != null)
    this.wheelDelta = event.wheelDelta/40;
  else if(event.deltaY != null) {
    this.deltaMode = event.deltaMode;
    this.deltaY = event.deltaY;
    
    // Approximate the wheel delta from the deltaY and deltaMode
    if(event.deltaMode == event.DOM_DELTA_LINE)
      this.wheelDelta = -event.deltaY;
    else if(event.deltaMode == event.DOM_DELTA_PIXEL)
      this.wheelDelta = -event.deltaY/15;  
  }
  else
    this.wheelDelta = event.detail;
};

/**
 * Modify the event for IE with the new event type and new target element
 * 
 * @public
 * @param {string} newType  New Mouse Event type
 * @param {DOMElement} newTargetElement  New SVG DOM Target Element
 */
DvtSvgMouseEvent.prototype.modifyEventForIE = function(newType, newTargetElement) {
  //Bug 17369581: Set the event type as newType, relatedTarget as current target and target as displayable of newTargetElement
  //This will target the event to newTargetElement and change the event type 
  //Modify the event target only once because every DvtSvgMouseEvent instance has unique native event.
  //Doing this more than once will make relatedTarget and target same as displayable of newTargetElement
  if(!this._isEventModifiedForIE) {
    this.type = newType;
    this.relatedTarget = this.target;
    this.target = DvtSvgBaseEvent.FindDisplayable(newTargetElement);
    this._isEventModifiedForIE = true;
  }
};

/**
 * @constructor
 * Wrapper class providing access to SVG Touch Events.
 * @extends DvtSvgBaseEvent
 * @class DvtSvgTouchEvent
 * <p>The supported fields are:
 * <ul>
 * <li>touches</li>
 * <li>targetTouches</li>
 * <li>changedTouches</li>
 * <li>target</li>
 * <li>type</li>
 * </ul>
 * <p>
 */
var DvtSvgTouchEvent = function(event, context) {
  this.Init(event, context);
}

DvtObj.createSubclass(DvtSvgTouchEvent, DvtSvgBaseEvent, "DvtSvgTouchEvent");

/**
 * @protected
 * @param {TouchEvent} the DOM Touch Event
 * @param {DvtContext} context 
 */
DvtSvgTouchEvent.prototype.Init = function(event, context) {

  DvtSvgTouchEvent.superclass.Init.call(this, event);
  // Convert touchcancel to touchend
  if (event.type == DvtTouchEvent.TOUCHCANCEL) {
      this.type = DvtTouchEvent.TOUCHEND;
  }
  this._nativeTouches = event.touches;
  this._nativeTargetTouches = event.targetTouches;
  this._nativeChangedTouches = event.changedTouches;
  this.touches = DvtSvgTouchEvent.createTouchArray(event.touches);
  this.targetTouches = DvtSvgTouchEvent.createTouchArray(event.targetTouches);
  this.changedTouches = DvtSvgTouchEvent.createTouchArray(event.changedTouches);
  this._context = context;
  this._touchManager = null;
}

DvtSvgTouchEvent.prototype.blockTouchHold = function() {
  this._event._touchHoldBlocked = true;
}

DvtSvgTouchEvent.prototype.isInitialTouch = function() {
   return (this.touches.length - this.changedTouches.length) == 0;
}

DvtSvgTouchEvent.prototype.isTouchHoldBlocked = function() {
  return (this._event._touchHoldBlocked) ? true : false;
}

DvtSvgTouchEvent.createTouchArray = function(nativeTouchArray) {
  var touches = new Array();
  for (var i=0; i<nativeTouchArray.length; i++) {
      var nativeTouch = nativeTouchArray[i];
      var touch = new DvtTouch(nativeTouch);
      touches.push(touch);
  }
  return touches;
}

/**
 * Prevents further propagation of the current event
 */
DvtSvgTouchEvent.prototype.stopPropagation = function() {
    DvtSvgTouchEvent.superclass.stopPropagation.call(this);
    if (this._touchManager)
      this._touchManager.postEventBubble(this);
}

/**
 * Sets a touch manager object
 * @param {DvtTouchManager} touch manager object for the event
 */
DvtSvgTouchEvent.prototype.setTouchManager = function (touchManager) {
  this._touchManager = touchManager;
}
// Used for rendering SVG content in to an HTML div wrapper
/**
 * @param {DvtContext} context
 * @param {string} domElementId
 * @constructor
 */
var DvtHtmlRichTooltipManager = function(context, domElementId) {
    this.Init(context, domElementId);
};

DvtObj.createSubclass(DvtHtmlRichTooltipManager, DvtHtmlTooltipManager, "DvtHtmlRichTooltipManager");

/**
 * @param {DvtContext} context
 * @param {string} domElementId
 */
DvtHtmlRichTooltipManager.prototype.Init = function(context, domElementId) 
{
  this._storedContexts = new Object();
  DvtHtmlRichTooltipManager.superclass.Init.call(this, context, domElementId);
}

DvtHtmlRichTooltipManager.prototype.InitContent = function(tooltip) {
      // For an svg custom tooltip, the context is the new svg context for the svg document overlay.
      tooltip.innerHTML = "";
      var context = new DvtContext(tooltip, "DvtCustomTooltip");
      this._storedContexts[this._domElementId] = context;
}

DvtHtmlRichTooltipManager.prototype.GetStoredContext = function() {
    return this._storedContexts[this._domElementId];
}

DvtHtmlRichTooltipManager.prototype.showRichElement = function(x, y, renderable, useOffset)
{
    this.showRichElementAtPosition(x, y, renderable, useOffset, false, DvtHtmlTooltipManager.UNSTYLED_POPUP_CLASS);
};

DvtHtmlRichTooltipManager.prototype.showRichElementAtPosition = function(x, y, renderable, useOffset, noEvents, popupClass) {

    var tooltip = this.GetTooltipElem();
    
    if (!popupClass)
      popupClass = DvtHtmlTooltipManager.UNSTYLED_POPUP_CLASS;
      
    tooltip.className = popupClass;
    
    var context = this.GetStoredContext();
    if (context){
      var stage = context.getStage();
      stage.removeChildren();
      var rootDisplayable = renderable.getRootDisplayable();
      stage.addChild(rootDisplayable);
      
      if (renderable && renderable.Render) {
          renderable.Render();
      }
      
      var svg = stage.getImpl().getSVGRoot();
      DvtToolkitUtils.setAttrNullNS(svg, "width", renderable.getDisplayWidth());
      DvtToolkitUtils.setAttrNullNS(svg, "height", renderable.getDisplayHeight());
      
      this.PostElement(tooltip, x, y, noEvents, useOffset);
    }
}

DvtHtmlRichTooltipManager.prototype.hideTooltip = function()
{
    DvtHtmlRichTooltipManager.superclass.hideTooltip.call(this);
    var context = this.GetStoredContext();
    if (context) {
        var stage = context.getStage();
        stage.removeChildren();
    }
}
// Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.
/**
  * A factory class for SVG to create object implementations.
  * @extends DvtObj
  * @class DvtSvgImplFactory  A factory class to create SVG implementation objects.
  * @constructor  Creates SVG implementation objects.
  */
var DvtSvgImplFactory = function(context) {
  this._context = context;
}

DvtObj.createSubclass(DvtSvgImplFactory, DvtObj, "DvtSvgImplFactory");

/**
 *  Returns a new SVG <defs> element
 *  @private  
 */
DvtSvgImplFactory.prototype.newDefs = function() {
  return DvtSvgShapeUtils.createElement('defs') ;
}

/**
 * Obtain imageLoader singleton
 * @override
 */
DvtSvgImplFactory.prototype.getImageLoader = function () {
  if (DvtAgent.isEnvironmentBrowser())
    return DvtSvgImageLoader;
  else
    return DvtJavaImageLoader;
}

/**
 * @override
 */
DvtSvgImplFactory.prototype.getDocumentUtils = function () {
  return DvtSvgDocumentUtils;
}

/**
 * @override
 */
DvtSvgImplFactory.prototype.newParser = function() {
  if (DvtAgent.isEnvironmentBrowser())
    return new DvtDomXmlParser();
  else
    return new DvtJavaXmlParser();
}

/**
 * @override
 */
DvtSvgImplFactory.prototype.newContextMenuHandler = function () {
  return new DvtHtmlContextMenuHandler();
}

/**
 * @override
 */
DvtSvgImplFactory.prototype.newTooltipManager = function (id) {
  return new DvtHtmlTooltipManager(this._context, id);
}

/**
 * @override
 */
DvtSvgImplFactory.prototype.newRichTooltipManager = function (id) {
  return new DvtHtmlRichTooltipManager(this._context, id);
}
// Copyright (c) 2011, 2012, Oracle and/or its affiliates. 
// All rights reserved. 
/**
 * @constructor
 */
var DvtSvgFilterContext = function()
{
  this.Init();
};

DvtObj.createSubclass(DvtSvgFilterContext, DvtObj, "DvtSvgFilterContext");

DvtSvgFilterContext.prototype.Init = function()
{
  this._regionPctRect = new DvtRectangle(-10, -10, 120, 120);
  this._counter = 0;
  this._resultIdsUnder = [];
  this._resultIdsOver = [];
};

DvtSvgFilterContext.prototype.getRegionPctRect = function()
{
  return this._regionPctRect;
};

DvtSvgFilterContext.prototype.getResultIdsUnder = function()
{
  return this._resultIdsUnder;
};

DvtSvgFilterContext.prototype.getResultIdsOver = function()
{
  return this._resultIdsOver;
};

DvtSvgFilterContext.prototype.createResultId = function(id)
{
  if (!id)
  {
    id = "filtRes";
  }
  return (id + (this._counter++));
};
// Copyright (c) 2011, 2014, Oracle and/or its affiliates. All rights reserved.

/**
  *   Static SVG filter routines.
  *   @class DvtSvgFilterUtils 
  *   @constructor
  */
var  DvtSvgFilterUtils = function()
{} ;

DvtObj.createSubclass(DvtSvgFilterUtils, DvtObj, "DvtSvgFilterUtils");

DvtSvgFilterUtils._counter = 0;

DvtSvgFilterUtils.createFilter = function(effects, svgDisplayable)
{
  var filt = DvtSvgShapeUtils.createElement('filter', DvtSvgFilterUtils.CreateFilterId());
  var filtContext = new DvtSvgFilterContext();
  for (var i = 0; i < effects.length; i++)
  {
    var effect = effects[i];
    if (effect)
    {
      DvtSvgFilterUtils.CreateFilterPrimitives(filt, effect, svgDisplayable, filtContext);
    }
  }
  
  // BUG #12805402: When bounding box of svg element has zero height or width, userSpaceOnUse must be used
  // Otherwise, the element will disappear
  var userSpaceOnUse = false;
  if (svgDisplayable) {
      var boundsRect = svgDisplayable.getElem().getBBox();
      if (boundsRect) {
          var width = boundsRect.width;
          var height = boundsRect.height;
          if (height == 0 || width == 0) {
            var stroke;
            //if displayable is not a shape, for example a container, then it doesn't have a stroke
            if (svgDisplayable.getStroke) {
              stroke = svgDisplayable.getStroke();
            }
            var adjustWidth = 10;
            if (stroke) {
                adjustWidth = stroke.getWidth();
            }
            var x = boundsRect.x;
            var y = boundsRect.y;
    
            // Firefox 4 requires the line to be bend slightly when feColorMatrix is used
            if (DvtSvgDocumentUtils.isFilterStraightLineAdjustmentNeeded()) {
                if (svgDisplayable instanceof DvtPolyline) {
                   var points = DvtArrayUtils.copy(svgDisplayable.getPoints());
                   if (width == 0) {
                       points[0] = points[0]+0.01;
                   }
                   if (height == 0) {
                       points[1] = points[1]+0.01;
                   }
        
                   var bentPoints = DvtSvgShapeUtils.convertPointsArray(points);
                   DvtToolkitUtils.setAttrNullNS(svgDisplayable.getElem(), 'points', bentPoints) ;
                }
            }
    
            if (height == 0) {
                height = 2*adjustWidth;
                y -= adjustWidth;
            }
            if (width == 0) {
                width = 2*adjustWidth;
                x -= adjustWidth;
            }
    
            DvtToolkitUtils.setAttrNullNS(filt, 'x', x) ;
            DvtToolkitUtils.setAttrNullNS(filt, 'y', y) ;
            DvtToolkitUtils.setAttrNullNS(filt, 'width', width) ;
            DvtToolkitUtils.setAttrNullNS(filt, 'height', height) ;
            DvtToolkitUtils.setAttrNullNS(filt, 'filterUnits', 'userSpaceOnUse') ;
            userSpaceOnUse = true;
          }
      }
  }
  if (!userSpaceOnUse) {
      if (filtContext.getRegionPctRect().x != -10 && filtContext.getRegionPctRect().x != "Infinity" && filtContext.getRegionPctRect().x != "-Infinity")
      {
        DvtToolkitUtils.setAttrNullNS(filt, 'x', filtContext.getRegionPctRect().x + '%') ;
      }
      if (filtContext.getRegionPctRect().y != -10 && filtContext.getRegionPctRect().y != "Infinity" && filtContext.getRegionPctRect().y != "-Infinity")
      {
        DvtToolkitUtils.setAttrNullNS(filt, 'y', filtContext.getRegionPctRect().y + '%') ;
      }
      if (filtContext.getRegionPctRect().w != 120 && filtContext.getRegionPctRect().w != "Infinity" && filtContext.getRegionPctRect().w != "-Infinity")
      {
        DvtToolkitUtils.setAttrNullNS(filt, 'width', filtContext.getRegionPctRect().w + '%') ;
      }
      if (filtContext.getRegionPctRect().h != 120 && filtContext.getRegionPctRect().h != "Infinity" && filtContext.getRegionPctRect().h != "-Infinity")
      {
        DvtToolkitUtils.setAttrNullNS(filt, 'height', filtContext.getRegionPctRect().h + '%') ;
      }
        
  }

  
  var numResultsUnder = filtContext.getResultIdsUnder().length;
  var numResultsOver = filtContext.getResultIdsOver().length;
  var elemMN;
  var j;
  
  var elemM  = DvtSvgShapeUtils.createElement('feMerge') ;
  if (numResultsUnder > 0)
  {
    for (j = 0; j < numResultsUnder; j++)
    {
      elemMN = DvtSvgShapeUtils.createElement('feMergeNode') ;
      DvtToolkitUtils.setAttrNullNS(elemMN, 'in', filtContext.getResultIdsUnder()[j]) ;
      DvtToolkitUtils.appendChildElem(elemM, elemMN) ;
    }
  }
  elemMN = DvtSvgShapeUtils.createElement('feMergeNode') ;
  DvtToolkitUtils.setAttrNullNS(elemMN, 'in', 'SourceGraphic') ;
  DvtToolkitUtils.appendChildElem(elemM, elemMN) ;
  if (numResultsOver > 0)
  {
    for (j = 0; j < numResultsOver; j++)
    {
      elemMN = DvtSvgShapeUtils.createElement('feMergeNode') ;
      DvtToolkitUtils.setAttrNullNS(elemMN, 'in', filtContext.getResultIdsOver()[j]) ;
      DvtToolkitUtils.appendChildElem(elemM, elemMN) ;
    }
  }
  DvtToolkitUtils.appendChildElem(filt, elemM) ;
  
  return filt;
};

DvtSvgFilterUtils.CreateFilterPrimitives = function(filter, effect, svgDisplayable, filtContext)
{
  if (effect instanceof DvtShadow)
  {
    DvtSvgShadowUtils.createFilterPrimitives(filter, effect, svgDisplayable, filtContext);
  }
  else if (effect instanceof DvtGlow)
  {
    DvtSvgGlowUtils.createFilterPrimitives(filter, effect, svgDisplayable, filtContext);
  }
  
  return null;
};

DvtSvgFilterUtils.CreateFilterId = function()
{
  return ("filt" + (DvtSvgFilterUtils._counter++));
};
// Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved.
/*---------------------------------------------------------------------------*/
/*   DvtSvgGlowUtils    A static class for SVG glow effect property          */
/*                      manipulation.                                        */
/*---------------------------------------------------------------------------*/
/**
  *   DvtSvgGlowUtils    A static class for SVG glow effect property manipulation.
  *   @class DvtSvgGlowUtils 
  *   @constructor
  */
var  DvtSvgGlowUtils = function()
{} ;

DvtObj.createSubclass(DvtSvgGlowUtils, DvtObj, "DvtSvgGlowUtils");

/**
  *  Static method to create an SVG filter element and apply glow properties to it.
  *  @param {DvtGlow}  glow  DvtGlow object
  *  @param {DvtSvgDisplayable}  svgDisplayable  display object to apply glow to
  *  @returns an SVG  &lt;filter&gt; element
  */
DvtSvgGlowUtils.createFilter = function(glow, svgDisplayable)
{
   //  The following outer glow filter is created:

   //   <filter id="dg1">
   //     <feColorMatrix type="matrix" values="0 0 0 red 0
   //                                          0 0 0 green 0
   //                                          0 0 0 blue 0
   //                                          0 0 0 alpha 0"/>
   //     <feGaussianBlur stdDeviation="6 6" result="blur1"/>
   //     <feMerge>
   //       <feMergeNode in="blur1"/>
   //       <feMergeNode in="SourceGraphic"/>
   //     </feMerge>
   //   </filter>
   
   
   //   The following inner glow filter is created:
   
   //   <filter id="dg1">
   //     <feGaussianBlur stdDeviation="3" result="blur1"/>
   //     <feComposite operator="in" in="SourceGraphic" in2="blur1" result="comp1"/>
   //     <feComposite operator="in" in2="comp1" result="comp2"/>
   //     <feFlood in="comp2" flood-opacity="1" flood-color="rgb(255,255,255)" result="flood1"/>
   //     <feBlend mode="normal" in="comp2" in2="flood1" result="blend1"/>
   //     <feComposite operator="in" in="blend1" in2="SourceGraphic" result="comp3"/>
   //   </filter>
   
   var filt = DvtSvgGlowUtils.CreateFilterElem(glow);
   var filtContext = new DvtSvgFilterContext();
   
   DvtSvgGlowUtils.createFilterPrimitives(filt, glow, svgDisplayable, filtContext);
   
  var elemM  = DvtSvgShapeUtils.createElement('feMerge') ;
  var elemMN;
  if (filtContext.getResultIdsUnder().length > 0)
  {
    elemMN = DvtSvgShapeUtils.createElement('feMergeNode') ;
    DvtToolkitUtils.setAttrNullNS(elemMN, 'in', filtContext.getResultIdsUnder()[0]) ;
    DvtToolkitUtils.appendChildElem(elemM, elemMN) ;
  }
  elemMN = DvtSvgShapeUtils.createElement('feMergeNode') ;
  DvtToolkitUtils.setAttrNullNS(elemMN, 'in', 'SourceGraphic') ;
  DvtToolkitUtils.appendChildElem(elemM, elemMN) ;
  if (filtContext.getResultIdsOver().length > 0)
  {
    elemMN = DvtSvgShapeUtils.createElement('feMergeNode') ;
    DvtToolkitUtils.setAttrNullNS(elemMN, 'in', filtContext.getResultIdsOver()[0]) ;
    DvtToolkitUtils.appendChildElem(elemM, elemMN) ;
  }
  DvtToolkitUtils.appendChildElem(filt, elemM) ;
   
   if (filtContext.getRegionPctRect().x != -10)
  {
    DvtToolkitUtils.setAttrNullNS(filt, 'x', filtContext.getRegionPctRect().x + '%') ;
  }
  if (filtContext.getRegionPctRect().y != -10)
  {
    DvtToolkitUtils.setAttrNullNS(filt, 'y', filtContext.getRegionPctRect().y + '%') ;
  }
  if (filtContext.getRegionPctRect().w != 120)
  {
    DvtToolkitUtils.setAttrNullNS(filt, 'width', filtContext.getRegionPctRect().w + '%') ;
  }
  if (filtContext.getRegionPctRect().h != 120)
  {
    DvtToolkitUtils.setAttrNullNS(filt, 'height', filtContext.getRegionPctRect().h + '%') ;
  }
   
   return filt;
};

DvtSvgGlowUtils.createFilterPrimitives = function(filt, effect, svgDisplayable, filtContext)
{
  if (effect._bInner)
  {
    DvtSvgGlowUtils.CreateInnerFilterPrimitives2(filt, effect, filtContext);
  }
  else
  {
    var boundsRect = svgDisplayable.getDimensions(svgDisplayable.getParent());
    DvtSvgGlowUtils.CreateOuterFilterPrimitives(filt, effect, filtContext, boundsRect);
  }
};

/**
  * @protected
  */
DvtSvgGlowUtils.CreateFilterElem = function(glow)
{
  var filt = DvtSvgShapeUtils.createElement('filter', glow._Id) ;
  return filt;
};

/**
  * @protected
  */
DvtSvgGlowUtils.CreateOuterFilterPrimitives = function(filt, glow, filtContext, boundsRect)
{
  var rgba  = glow._rgba ;
  var red   = DvtColorUtils.getRed(rgba)/255 ;
  var green = DvtColorUtils.getGreen(rgba)/255 ;
  var blue  = DvtColorUtils.getBlue(rgba)/255 ;
  var alpha = DvtColorUtils.getAlpha(rgba) ;
  var strength = glow._strength;
  //adjust blur values so that SVG behaves more like Flash
  var blurX = glow._blurX / 3;
  var blurY = glow._blurY / 3;

  //if we have a boundsRect, increase the size of the filter so
  //that the glow has room to display outside the shape
  if (boundsRect)
  {
    var xRatio = (2 * blurX / boundsRect.w) * 100;
    var yRatio = (2 * blurY / boundsRect.h) * 100;
    if (filtContext.getRegionPctRect().x > -xRatio)
    {
      filtContext.getRegionPctRect().x = -xRatio;
    }
    if (filtContext.getRegionPctRect().y > -yRatio)
    {
      filtContext.getRegionPctRect().y = -yRatio;
    }
    if (filtContext.getRegionPctRect().w < (100 + 2 * xRatio))
    {
      filtContext.getRegionPctRect().w = (100 + 2 * xRatio);
    }
    if (filtContext.getRegionPctRect().h < (100 + 2 * yRatio))
    {
      filtContext.getRegionPctRect().h = (100 + 2 * yRatio);
    }
  }

  var elemCM  = DvtSvgShapeUtils.createElement('feColorMatrix') ;
  DvtToolkitUtils.setAttrNullNS(elemCM, 'in', 'SourceGraphic') ;
  DvtToolkitUtils.setAttrNullNS(elemCM, 'type', 'matrix') ;
  DvtToolkitUtils.setAttrNullNS(elemCM, 'values', '0 0 0 ' + red   + ' 0 ' +
                                       '0 0 0 ' + green + ' 0 ' +
                                       '0 0 0 ' + blue  + ' 0 ' +
                                       '0 0 0 ' + alpha + ' 0') ;
  
  var elemGB  = DvtSvgShapeUtils.createElement('feGaussianBlur') ;
  DvtToolkitUtils.setAttrNullNS(elemGB, 'stdDeviation', blurX + " " + blurY) ;
  var elemGBResult = filtContext.createResultId('blur');
  DvtToolkitUtils.setAttrNullNS(elemGB, 'result', elemGBResult) ;
  
  //attempt to use the glow strength as multiplier for alpha
  //value in blur filter
  var elemCT;
  var elemCTResult;
  if (strength != 1) {
    //BUG FIX 14394122: use feComponentTransfer instead of feColorMatrix,
    //because Chrome has issues rendering the color matrix
    elemCT = DvtSvgShapeUtils.createElement('feComponentTransfer');
    DvtToolkitUtils.setAttrNullNS(elemCT, 'in', elemGBResult) ;
    elemCTResult = filtContext.createResultId('compTran');
    DvtToolkitUtils.setAttrNullNS(elemCT, 'result', elemCTResult) ;
    
    var elemFA = DvtSvgShapeUtils.createElement('feFuncA');
    DvtToolkitUtils.setAttrNullNS(elemFA, 'type', 'linear') ;
    DvtToolkitUtils.setAttrNullNS(elemFA, 'slope', "" + strength) ;
    DvtToolkitUtils.appendChildElem(elemCT, elemFA);
  }
  
  if (elemCTResult) {
    filtContext.getResultIdsUnder().push(elemCTResult);
  }
  else {
    filtContext.getResultIdsUnder().push(elemGBResult);
  }

  DvtToolkitUtils.appendChildElem(filt, elemCM) ;
  DvtToolkitUtils.appendChildElem(filt, elemGB) ;
  if (elemCT) {
    DvtToolkitUtils.appendChildElem(filt, elemCT) ;
  }
};

/**
  * @protected
  */
/*DvtSvgGlowUtils.CreateInnerFilterPrimitives = function(filt, glow, filtContext)
{
  var red   = DvtColorUtils.getRed(glow._rgba) ;
  var green = DvtColorUtils.getGreen(glow._rgba) ;
  var blue  = DvtColorUtils.getBlue(glow._rgba) ;
  var alpha = DvtColorUtils.getAlpha(glow._rgba) ;
  var rgb = DvtColorUtils.makeRGB(red, green, blue);
  
  //filtContext.getRegionPctRect().x = 0;
  //filtContext.getRegionPctRect().y = 0;
  //filtContext.getRegionPctRect().width = 100;
  //filtContext.getRegionPctRect().height = 100;
  
  var elemGB  = DvtSvgShapeUtils.createElement('feGaussianBlur') ;
  DvtToolkitUtils.setAttrNullNS(elemGB, 'in', 'SourceGraphic') ;
  DvtToolkitUtils.setAttrNullNS(elemGB, 'stdDeviation', glow._blurX + " " + glow._blurY) ;
  var elemGBResult = filtContext.createResultId('blur');
  DvtToolkitUtils.setAttrNullNS(elemGB, 'result', elemGBResult) ;
  
  var elemC1  = DvtSvgShapeUtils.createElement('feComposite') ;
  DvtToolkitUtils.setAttrNullNS(elemC1, 'operator', 'in') ;
  DvtToolkitUtils.setAttrNullNS(elemC1, 'in', 'SourceGraphic') ;
  DvtToolkitUtils.setAttrNullNS(elemC1, 'in2', elemGBResult) ;
  //if we add elemC2 below back in, then change the result
  //of this feComposite back to 'comp1'
  var elemC1Result = filtContext.createResultId('comp');
  /DvtToolkitUtils.setAttrNullNS(/elemC1, 'result', elemC1Result) ;
  var elemC2Result = filtContext.createResultId('comp');
  DvtToolkitUtils.setAttrNullNS(elemC1, 'result', elemC2Result) ;
  
  //can add this filter back in in order to strengthen the effect
  //(that's what it appears to do...)
  //var elemC2  = DvtSvgShapeUtils.createElement('feComposite') ;
  //DvtToolkitUtils.setAttrNullNS(elemC2, 'operator', 'in') ;
  //DvtToolkitUtils.setAttrNullNS(elemC2, 'in2', elemC1Result) ;
  //DvtToolkitUtils.setAttrNullNS(elemC2, 'result', elemC2Result) ;
  
  var elemF1  = DvtSvgShapeUtils.createElement('feFlood') ;
  DvtToolkitUtils.setAttrNullNS(elemF1, 'in', elemC2Result) ;
  DvtToolkitUtils.setAttrNullNS(elemF1, 'flood-opacity', alpha) ;
  DvtToolkitUtils.setAttrNullNS(elemF1, 'flood-color', rgb) ;
  var elemF1Result = filtContext.createResultId('flood');
  DvtToolkitUtils.setAttrNullNS(elemF1, 'result', elemF1Result) ;
  
  var elemB1  = DvtSvgShapeUtils.createElement('feBlend') ;
  DvtToolkitUtils.setAttrNullNS(elemB1, 'mode', 'normal') ;
  DvtToolkitUtils.setAttrNullNS(elemB1, 'in', elemC2Result) ;
  DvtToolkitUtils.setAttrNullNS(elemB1, 'in2', elemF1Result) ;
  var elemB1Result = filtContext.createResultId('blend');
  DvtToolkitUtils.setAttrNullNS(elemB1, 'result', elemB1Result) ;
  
  var elemC3  = DvtSvgShapeUtils.createElement('feComposite') ;
  DvtToolkitUtils.setAttrNullNS(elemC3, 'operator', 'in') ;
  DvtToolkitUtils.setAttrNullNS(elemC3, 'in', elemB1Result) ;
  DvtToolkitUtils.setAttrNullNS(elemC3, 'in2', 'SourceGraphic') ;
  //var elemC3Result = filtContext.createResultId('comp');
  //DvtToolkitUtils.setAttrNullNS(elemC3, 'result', elemC3Result) ;
  
  DvtToolkitUtils.appendChildElem(filt, elemGB) ;
  DvtToolkitUtils.appendChildElem(filt, elemC1) ;
  //DvtToolkitUtils.appendChildElem(filt, elemC2) ;
  DvtToolkitUtils.appendChildElem(filt, elemF1) ;
  DvtToolkitUtils.appendChildElem(filt, elemB1) ;
  DvtToolkitUtils.appendChildElem(filt, elemC3) ;
};*/

/**
  * @protected
  */
DvtSvgGlowUtils.CreateInnerFilterPrimitives2 = function(filt, glow, filtContext)
{
  var red   = DvtColorUtils.getRed(glow._rgba) ;
  var green = DvtColorUtils.getGreen(glow._rgba) ;
  var blue  = DvtColorUtils.getBlue(glow._rgba) ;
  var alpha = DvtColorUtils.getAlpha(glow._rgba) ;
  var rgb = DvtColorUtils.makeRGB(red, green, blue);
  var strength = glow._strength;
  //adjust blur values so that SVG behaves more like Flash
  //NOTE: changed to factor of 2 for graph selection, because 
  //then the two inner glows use blurs of 1 and 2 instead of 
  //0.5 and 1 (SVG appears to treat 0.5 and 1 the same)
  var blurX = glow._blurX / 2;//4;
  var blurY = glow._blurY / 2;//4;
  
  var elemF1  = DvtSvgShapeUtils.createElement('feFlood') ;
  DvtToolkitUtils.setAttrNullNS(elemF1, 'in', 'SourceGraphic') ;
  DvtToolkitUtils.setAttrNullNS(elemF1, 'flood-opacity', alpha) ;
  DvtToolkitUtils.setAttrNullNS(elemF1, 'flood-color', rgb) ;
  var elemF1Result = filtContext.createResultId('flood');
  DvtToolkitUtils.setAttrNullNS(elemF1, 'result', elemF1Result) ;
  
  var elemC1  = DvtSvgShapeUtils.createElement('feComposite') ;
  DvtToolkitUtils.setAttrNullNS(elemC1, 'operator', 'out') ;
  DvtToolkitUtils.setAttrNullNS(elemC1, 'in', elemF1Result) ;
  DvtToolkitUtils.setAttrNullNS(elemC1, 'in2', 'SourceGraphic') ;
  var elemC1Result = filtContext.createResultId('comp');
  DvtToolkitUtils.setAttrNullNS(elemC1, 'result', elemC1Result) ;
  
  var elemGB  = DvtSvgShapeUtils.createElement('feGaussianBlur') ;
  DvtToolkitUtils.setAttrNullNS(elemGB, 'in', elemC1Result) ;
  DvtToolkitUtils.setAttrNullNS(elemGB, 'stdDeviation', blurX + " " + blurY) ;
  var elemGBResult = filtContext.createResultId('blur');
  DvtToolkitUtils.setAttrNullNS(elemGB, 'result', elemGBResult) ;
  
  //attempt to use the glow strength as multiplier for alpha
  //value in blur filter
  var elemCT;
  var elemCTResult;
  if (strength != 1) {
    //BUG FIX 14394122: use feComponentTransfer instead of feColorMatrix,
    //because Chrome has issues rendering the color matrix
    elemCT = DvtSvgShapeUtils.createElement('feComponentTransfer');
    DvtToolkitUtils.setAttrNullNS(elemCT, 'in', elemGBResult) ;
    elemCTResult = filtContext.createResultId('compTran');
    DvtToolkitUtils.setAttrNullNS(elemCT, 'result', elemCTResult) ;
    
    var elemFA = DvtSvgShapeUtils.createElement('feFuncA');
    DvtToolkitUtils.setAttrNullNS(elemFA, 'type', 'linear') ;
    DvtToolkitUtils.setAttrNullNS(elemFA, 'slope', "" + strength) ;
    DvtToolkitUtils.appendChildElem(elemCT, elemFA);
  }
  
  var elemC2  = DvtSvgShapeUtils.createElement('feComposite') ;
  //DvtToolkitUtils.setAttrNullNS(elemC2, 'operator', 'atop') ;
  DvtToolkitUtils.setAttrNullNS(elemC2, 'operator', 'in');
  if (elemCTResult) {
    DvtToolkitUtils.setAttrNullNS(elemC2, 'in', elemCTResult) ;
  }
  else {
    DvtToolkitUtils.setAttrNullNS(elemC2, 'in', elemGBResult) ;
  }
  DvtToolkitUtils.setAttrNullNS(elemC2, 'in2', 'SourceGraphic') ;
  var elemC2Result = filtContext.createResultId('comp');
  DvtToolkitUtils.setAttrNullNS(elemC2, 'result', elemC2Result) ;
  
  filtContext.getResultIdsOver().push(elemC2Result);
  
  //if elemC2 above uses operator='in' instead of 'atop', 
  //then can do one of these afterwards to get same result:
  //var elemM  = DvtSvgShapeUtils.createElement('feMerge') ;
  //var elemMN1 = DvtSvgShapeUtils.createElement('feMergeNode') ;
  //DvtToolkitUtils.setAttrNullNS(elemMN1, 'in', 'SourceGraphic') ;
  //var elemMN2 = DvtSvgShapeUtils.createElement('feMergeNode') ;
  //DvtToolkitUtils.setAttrNullNS(elemMN2, 'in', elemC2Result) ;
  //OR
  //var elemC3  = DvtSvgShapeUtils.createElement('feComposite') ;
  //DvtToolkitUtils.setAttrNullNS(elemC3, 'operator', 'atop') ;
  //DvtToolkitUtils.setAttrNullNS(elemC3, 'in', elemC2Result) ;
  //DvtToolkitUtils.setAttrNullNS(elemC3, 'in2', 'SourceGraphic') ;
  
  DvtToolkitUtils.appendChildElem(filt, elemF1) ;
  DvtToolkitUtils.appendChildElem(filt, elemC1) ;
  DvtToolkitUtils.appendChildElem(filt, elemGB) ;
  if (elemCT) {
    DvtToolkitUtils.appendChildElem(filt, elemCT);
  }
  DvtToolkitUtils.appendChildElem(filt, elemC2) ;
  
  //DvtToolkitUtils.appendChildElem(filt, elemM) ;
  //DvtToolkitUtils.appendChildElem(elemM, elemMN1) ;
  //DvtToolkitUtils.appendChildElem(elemM, elemMN2) ;
  //OR
  //DvtToolkitUtils.appendChildElem(filt, elemC3) ;
};
// Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
/*---------------------------------------------------------------------------*/
/*    DvtSvgGradientUtils    A static class for SVG gradient property manip- */
/*                           ulation.                                        */
/*---------------------------------------------------------------------------*/
/**
  *   DvtSvgGradientUtils    A static class for SVG gradient property manipulation.
  *   @class DvtSvgGradientUtils 
  *   @constructor
  */
var  DvtSvgGradientUtils = function()
{} ;

DvtObj.createSubclass(DvtSvgGradientUtils, DvtObj, "DvtSvgGradientUtils");

/**
  *  Static method to create an SVG element and apply gradient properties to it.
  *  @param {Object}  Either a DvtGradientFill or DvtGradientStroke derivative to apply.
  */
DvtSvgGradientUtils.createElem = function(grad, id)
{
   var bLinear = ((grad instanceof DvtLinearGradientFill) || (grad instanceof DvtLinearGradientStroke));
   var elemGrad = DvtSvgShapeUtils.createElement((bLinear? 'linearGradient' : 'radialGradient'), id) ;

   var i ;
   var arColors = grad.getColors() ;
   var arAlphas = grad.getAlphas() ;
   var arStops  = grad.getStops() ;
   var arBounds = grad.getBounds() ;
   var len      = arColors.length ;

   for (i = 0; i < len; i++) {
      var elem = DvtSvgShapeUtils.createElement('stop') ;
      DvtToolkitUtils.setAttrNullNS(elem, 'offset', '' + (arStops[i] * 100) + '%') ;
      var color = arColors[i];
      if (color) {
        var alpha = arAlphas[i];
        // Workaround for Safari where versions < 5.1 show rgba values as black
        if (DvtAgent.isBrowserSafari() && color.indexOf("rgba") !==  - 1) {
          DvtToolkitUtils.setAttrNullNS(elem, 'stop-color', DvtColorUtils.getRGB(color));
          // Use alpa in rgba value as a multiplier to the alpha set on the object as this is what svg does.
          if (alpha != null)
            DvtToolkitUtils.setAttrNullNS(elem, 'stop-opacity', DvtColorUtils.getAlpha(color) * alpha);
          else 
            DvtToolkitUtils.setAttrNullNS(elem, 'stop-opacity', DvtColorUtils.getAlpha(color));
        }
        else {
          DvtToolkitUtils.setAttrNullNS(elem, 'stop-color', color);
          if (alpha != null)
            DvtToolkitUtils.setAttrNullNS(elem, 'stop-opacity', alpha);
        }
      }
      DvtToolkitUtils.appendChildElem(elemGrad, elem) ;
   }

   //  If no gradient bounding box specified, will use the object's boundary box.

   var bUseObjBBox = (! arBounds ||
                    ((arBounds[0]==0) && (arBounds[1]==0) && (arBounds[2]==0) && (arBounds[3]==0)) );

   //  The angle of rotation for SVG is clockwise, so must convert from the standard
   //  anti-clockwise convention used by the middle-tier xml. Rotation is
   //  at the mid-point of the bounding box.

   if (bLinear) {
     var  angle = grad.getAngle() ;

     var  x1 = '0%' ;
     var  y1 = '0%' ;
     var  x2 = '100%' ;
     var  y2 = '0%' ;

     var setGradientVector = true;
      
     if (bUseObjBBox) {

       // Set gradient vector for gradientUnits = "objectBoundingBox"
       // (the default value for gradientUnits).

       if (angle === 45) {
         y1 = '100%' ;
         x2 = '100%' ;
       }
       else if (angle === 90) {
         y1 = '100%' ;
         x2 = '0%' ;
       }
       else if (angle === 135) {
         x1 = '100%' ;
         x2 = '0%' ;
         y2 = '100%' ;
       }
       else if (angle === 270) {
         x2 = '0%' ;
         y2 = '100%' ;
       }
       else if (angle !== 0) {
         angle = -angle ;
         DvtToolkitUtils.setAttrNullNS(elemGrad, 'gradientTransform', 'rotate(' + angle + ' ' + '.5 .5)' ) ;
         setGradientVector = false;  // no need to change the default gradient vector, since we are rotating the 
                                     // gradient via gradientTransform
       }
     } 
     else  {

      //  Apply specified bounding box

      // use gradientUnits = "userSpaceOnUse"; for when we want to account for bounding box
      // first rotate the gradient by the specified angle
      // then scale this gradient to the width and bounds specifed in arBounds
      // then translate the gradient
      // note that if the width and height of the gradient are not equal, then the actual angle of the
      // gradient is different from the specified angle argument
      // However, this is the same behavior as how Flash processes the bounding box argument
      // Finally, note that in SVG, the order of transform operations is right to left

      DvtToolkitUtils.setAttrNullNS(elemGrad, 'gradientUnits', 'userSpaceOnUse') ;

      // set gradient vector to span the middle of the unit square
      x1 = '0';
      y1 = '0.5';
      x2 = '1';
      y2 = '0.5';

      var scaleX     = arBounds[2];
      var scaleY     = arBounds[3];
      var translateX = arBounds[0];
      var translateY = arBounds[1];
        
      angle = -angle;
      var rotateTransformStr = 'rotate(' + angle + ' ' + '.5 .5)'
      var scaleTransformStr = 'scale('+ scaleX + ' ' + scaleY + ')';
      var translateTransformStr = 'translate(' + translateX + ' ' + translateY + ')';
      var boundingBoxTransformStr = scaleTransformStr + ' ' + rotateTransformStr;
      
      if (translateX != 0 || translateY != 0) {
        boundingBoxTransformStr = translateTransformStr + ' ' + boundingBoxTransformStr;
      } 
        
      // in the case of a bounding box, to set up the gradient, we need both gradientTransform and
      // a gradient vector centered in the unit square

      DvtToolkitUtils.setAttrNullNS(elemGrad, 'gradientTransform', boundingBoxTransformStr ) ;
     }

     if(setGradientVector)   {
       DvtToolkitUtils.setAttrNullNS(elemGrad, 'x1', x1) ;
       DvtToolkitUtils.setAttrNullNS(elemGrad, 'y1', y1) ;
       DvtToolkitUtils.setAttrNullNS(elemGrad, 'x2', x2) ;
       DvtToolkitUtils.setAttrNullNS(elemGrad, 'y2', y2) ;
     }
   }
   else {    //  Radial gradient

     if (! bUseObjBBox) {

       DvtToolkitUtils.setAttrNullNS(elemGrad, 'gradientUnits', 'userSpaceOnUse') ;

       DvtToolkitUtils.setAttrNullNS(elemGrad, 'cx', grad.getCx()) ;
       DvtToolkitUtils.setAttrNullNS(elemGrad, 'cy', grad.getCy()) ;
       DvtToolkitUtils.setAttrNullNS(elemGrad, 'fx', grad.getCx()) ;
       DvtToolkitUtils.setAttrNullNS(elemGrad, 'fy', grad.getCy()) ;
       DvtToolkitUtils.setAttrNullNS(elemGrad, 'r',  grad.getRadius()) ;
    }
   }
   return elemGrad ;
};
// Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.
/*---------------------------------------------------------------------------*/
/*    DvtSvgImageFillUtils    A static class for SVG image fill property     */
/*                           manipulation.                                   */
/*---------------------------------------------------------------------------*/
/**
  *   A static class for SVG image fill property manipulation.
  *   @class DvtSvgImageFillUtils
  *   @constructor
  */
var  DvtSvgImageFillUtils = function()
{} ;

DvtObj.createSubclass(DvtSvgImageFillUtils, DvtObj, "DvtSvgImageFillUtils");

/**
  *  Static method to create an SVG element and apply image fill properties 
  *  to it.
  *  @param {DvtImageFill}
  */
DvtSvgImageFillUtils.createElem = function(imageFill, id)
{
   /* Example:
      <defs>
        <pattern id="img1" patternUnits="userSpaceOnUse" width="20" height="20" >
          <image xlink:href="400.png" x="0" y="0"  width="20" height="20" />
        </pattern>
      </defs>

      <rect x="0" y="0" height="100" width="100" fill="url(#img1)"/>
   */

   var elemPat = DvtSvgShapeUtils.createElement("pattern", id) ;
   var elemImg  = DvtSvgShapeUtils.createElement("image", id);

   var src = imageFill.getSrc() ;
   var bound = imageFill.getBound() ;
   var repeat = imageFill.getRepeat();

   if (bound) {
      DvtToolkitUtils.setAttrNullNS(elemPat, 'x', bound.x);
      DvtToolkitUtils.setAttrNullNS(elemPat, 'y', bound.y);

      DvtToolkitUtils.setAttrNullNS(elemImg, "x", bound.x);
      DvtToolkitUtils.setAttrNullNS(elemImg, "y", bound.y);

      DvtToolkitUtils.setAttrNullNS(elemPat, 'width', bound.w);
      DvtToolkitUtils.setAttrNullNS(elemPat, 'height', bound.h);

      DvtToolkitUtils.setAttrNullNS(elemImg, "width", bound.w);
      DvtToolkitUtils.setAttrNullNS(elemImg, "height", bound.h);
      DvtToolkitUtils.setAttrNullNS(elemPat, "patternUnits", "userSpaceOnUse");

      /*
      // tile the background image
      if (! repeat || repeat != "no-repeat") {
      }
      // stretch out the background image
      else {
        DvtToolkitUtils.setAttrNullNS(elemPat, "patternUnits", "objectBoundingBox");
        DvtToolkitUtils.setAttrNullNS(elemPat, 'width', "100%");
        DvtToolkitUtils.setAttrNullNS(elemPat, 'height', "100%");
      }
      */

      if (src) {
         DvtToolkitUtils.setAttrNS(elemImg, DvtImage.XLINK_NS, 'xlink:href', src) ;
      }
   }

   DvtToolkitUtils.appendChildElem(elemPat, elemImg) ;

   return elemPat ;
};
// Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved.
/*---------------------------------------------------------------------------*/
/*    DvtSvgPatternFillUtils    A static class for SVG pattern fill property */
/*                              manipulation.                                */
/*---------------------------------------------------------------------------*/
/**
  *   A static class for creating SVG pattern fills.
  *   @class DvtSvgPatternFillUtils
  *   @constructor
  */
var  DvtSvgPatternFillUtils = function()
{} ;

DvtObj.createSubclass(DvtSvgPatternFillUtils, DvtObj, "DvtSvgPatternFillUtils");

/**   @private @final @type String  */
DvtSvgPatternFillUtils._SM_WIDTH       = 8 ;
/**   @private @final @type String  */
DvtSvgPatternFillUtils._SM_HEIGHT      = 8 ;
/**   @private @final @type String  */
DvtSvgPatternFillUtils._LG_WIDTH       = 16 ;
/**   @private @final @type String  */
DvtSvgPatternFillUtils._LG_HEIGHT      = 16 ;

/**
  *  Static method to create an SVG pattern element.
  *  @param {DvtPatternFill}  patternFill  pattern fill object
  *  @param {string}  id  pattern identifier
  */
DvtSvgPatternFillUtils.createElem = function(patternFill, id)
{
  var elemPat = DvtSvgShapeUtils.createElement("pattern", id) ;

  var pattern = patternFill.getPattern();
  var bSmall = DvtSvgPatternFillUtils.IsSmallPattern(pattern);
  var ww;
  var hh;
  if (bSmall)
  {
    ww = DvtSvgPatternFillUtils._SM_WIDTH ;
    hh = DvtSvgPatternFillUtils._SM_HEIGHT ;
  }
  else
  {
    ww = DvtSvgPatternFillUtils._LG_WIDTH ;
    hh = DvtSvgPatternFillUtils._LG_HEIGHT ;
  }

  DvtToolkitUtils.setAttrNullNS(elemPat, "x", 0);
  DvtToolkitUtils.setAttrNullNS(elemPat, "y", 0);
  DvtToolkitUtils.setAttrNullNS(elemPat, "width", ww);
  DvtToolkitUtils.setAttrNullNS(elemPat, "height", hh);
  DvtToolkitUtils.setAttrNullNS(elemPat, "patternUnits", "userSpaceOnUse");
  var mat = patternFill.getMatrix();
  if (mat) {
    var sMat = 'matrix(' + mat.getA() + ',' + mat.getC() + ',' + mat.getB() + ',' + mat.getD() + ',' + mat.getTx() + ',' + mat.getTy() + ')';
    DvtToolkitUtils.setAttrNullNS(elemPat, "patternTransform", sMat);
  }
  
  DvtSvgPatternFillUtils.CreatePatternElems(patternFill, elemPat);

  return elemPat ;
};

/**
  * Determine if the pattern is large or small.
  * 
  * @param {string}  pattern  constant representing the pattern
  * @protected
  */
DvtSvgPatternFillUtils.IsSmallPattern = function(pattern)
{
  return (pattern.charAt(0) === 's');
};

/**
  * Determine if the pattern is large or small.
  * 
  * @param {DvtPatternFill}  patternFill  pattern fill object
  * @param {object}  parentElem  parent pattern DOM element
  * @protected
  */
DvtSvgPatternFillUtils.CreatePatternElems = function(patternFill, parentElem)
{
  var rightX ;
  var bottomY ;
  var w ;
  var h ;
  var halfW ;  
  var halfH ; 
  var elem ;

  var pattern = patternFill.getPattern();
  var sColor = patternFill.getColor();
  var color = DvtColorUtils.getRGB(sColor);
  var alpha = DvtColorUtils.getAlpha(sColor);
  var sBackgroundColor = patternFill.getBackgroundColor();
  var backgroundColor = DvtColorUtils.getRGB(sBackgroundColor);
  var backgroundAlpha = DvtColorUtils.getAlpha(sBackgroundColor);
  
  var bSmall = DvtSvgPatternFillUtils.IsSmallPattern(pattern);
  if (bSmall)
  {
    rightX  = DvtSvgPatternFillUtils._SM_WIDTH  ;
    bottomY = DvtSvgPatternFillUtils._SM_HEIGHT  ;
    w       = DvtSvgPatternFillUtils._SM_WIDTH ;
    h       = DvtSvgPatternFillUtils._SM_HEIGHT ;
  }
  else
  {
    rightX  = DvtSvgPatternFillUtils._LG_WIDTH  ;
    bottomY = DvtSvgPatternFillUtils._LG_HEIGHT  ;
    w       = DvtSvgPatternFillUtils._LG_WIDTH ;
    h       = DvtSvgPatternFillUtils._LG_HEIGHT ;
  }
  
  //if a background color is specified, then fill a rect with that color
  //before drawing the pattern elements on top of it
  if (backgroundColor && (backgroundAlpha > 0))
  {
    elem = DvtSvgShapeUtils.createElement("rect");
    
    DvtToolkitUtils.setAttrNullNS(elem, "stroke", backgroundColor);
    DvtToolkitUtils.setAttrNullNS(elem, "stroke-opacity", backgroundAlpha);
    DvtToolkitUtils.setAttrNullNS(elem, "stroke-width", 1);
    DvtToolkitUtils.setAttrNullNS(elem, "fill", backgroundColor);
    DvtToolkitUtils.setAttrNullNS(elem, "fill-opacity", backgroundAlpha);
    
    DvtToolkitUtils.setAttrNullNS(elem, "x", 0);
    DvtToolkitUtils.setAttrNullNS(elem, "y", 0);
    DvtToolkitUtils.setAttrNullNS(elem, "width", rightX);
    DvtToolkitUtils.setAttrNullNS(elem, "height", bottomY);
    
    DvtToolkitUtils.appendChildElem(parentElem, elem);
  }

  if (pattern === DvtPatternFill.SM_DIAG_UP_LT || 
      pattern === DvtPatternFill.LG_DIAG_UP_LT)
  {
    elem = DvtSvgShapeUtils.createElement("path");
    DvtToolkitUtils.setAttrNullNS(elem, "stroke", color);
    DvtToolkitUtils.setAttrNullNS(elem, "stroke-opacity", alpha);
    DvtToolkitUtils.setAttrNullNS(elem, "stroke-width", 1);
    DvtToolkitUtils.setAttrNullNS(elem, "stroke-linecap", "square");
    
    DvtToolkitUtils.setAttrNullNS(elem, "d", DvtPathUtils.moveTo(0, -h/2) + DvtPathUtils.lineTo(3*w/2, h) + 
                                   DvtPathUtils.moveTo(-w/2, 0) + DvtPathUtils.lineTo(w/2, h)); 
    
    DvtToolkitUtils.appendChildElem(parentElem, elem);
  }
  else if (pattern === DvtPatternFill.SM_DIAG_UP_RT || 
           pattern === DvtPatternFill.LG_DIAG_UP_RT)
  {
    elem = DvtSvgShapeUtils.createElement("path");
    DvtToolkitUtils.setAttrNullNS(elem, "stroke", color);
    DvtToolkitUtils.setAttrNullNS(elem, "stroke-opacity", alpha);
    DvtToolkitUtils.setAttrNullNS(elem, "stroke-width", 1);
    DvtToolkitUtils.setAttrNullNS(elem, "stroke-linecap", "square");
    
    DvtToolkitUtils.setAttrNullNS(elem, "d", DvtPathUtils.moveTo(-w/2, h) + DvtPathUtils.lineTo(w, -h/2) + 
                                   DvtPathUtils.moveTo(0, 3*h/2) + DvtPathUtils.lineTo(3*w/2, 0)); 
    
    DvtToolkitUtils.appendChildElem(parentElem, elem);
  }
  else if (pattern === DvtPatternFill.SM_CROSSHATCH || 
           pattern === DvtPatternFill.LG_CROSSHATCH)
  {
    //use path instead of two lines because it's more compact (uses one
    //DOM element instead of two)
    elem = DvtSvgShapeUtils.createElement("path");

//  g.lineStyle((bSmall? 1 : 2), color) ;
    DvtToolkitUtils.setAttrNullNS(elem, "stroke", color);
    DvtToolkitUtils.setAttrNullNS(elem, "stroke-opacity", alpha);
    DvtToolkitUtils.setAttrNullNS(elem, "stroke-width", 1);
    
    DvtToolkitUtils.setAttrNullNS(elem, "d", "M0,0" + 
                                   "L" + rightX + "," + bottomY + 
                                   "M" + rightX + ",0" + 
                                   "L0," + bottomY);
    
    DvtToolkitUtils.appendChildElem(parentElem, elem);
  }
  else if (pattern === DvtPatternFill.SM_CHECK || 
           pattern === DvtPatternFill.LG_CHECK)
  {
    halfW = w/2 ;  
    halfH = h/2 ;  
    
    //use path instead of two rects because it's more compact (uses one
    //DOM element instead of two)
    elem = DvtSvgShapeUtils.createElement("path");
    
    DvtToolkitUtils.setAttrNullNS(elem, "stroke", color);
    DvtToolkitUtils.setAttrNullNS(elem, "stroke-opacity", alpha);
    DvtToolkitUtils.setAttrNullNS(elem, "stroke-width", 1);
    DvtToolkitUtils.setAttrNullNS(elem, "fill", color);
    DvtToolkitUtils.setAttrNullNS(elem, "fill-opacity", alpha);
    
    DvtToolkitUtils.setAttrNullNS(elem, "d", "M" + halfW + ",0" + 
                                   "L" + w + ",0" + 
                                   "L" + w + "," + halfH + 
                                   "L" + halfW + "," + halfH + "Z" + 
                                   "M0," + halfH + 
                                   "L" + halfW + "," + halfH + 
                                   "L" + halfW + "," + h + 
                                   "L0," + h + "Z");
    
    DvtToolkitUtils.appendChildElem(parentElem, elem);
  }
  else if (pattern === DvtPatternFill.SM_TRIANGLE_CHECK || 
           pattern === DvtPatternFill.LG_TRIANGLE_CHECK)
  {
    elem = DvtSvgShapeUtils.createElement("polygon");
    
    DvtToolkitUtils.setAttrNullNS(elem, "stroke", color);
    DvtToolkitUtils.setAttrNullNS(elem, "stroke-opacity", alpha);
    DvtToolkitUtils.setAttrNullNS(elem, "stroke-width", 1);
    DvtToolkitUtils.setAttrNullNS(elem, "fill", color);
    DvtToolkitUtils.setAttrNullNS(elem, "fill-opacity", alpha);
    
    DvtToolkitUtils.setAttrNullNS(elem, "points", "0," + bottomY + " " + 
                                        rightX + ",0 " + 
                                        rightX + "," + bottomY);
    
    DvtToolkitUtils.appendChildElem(parentElem, elem);
  }
  else if (pattern === DvtPatternFill.SM_DIAMOND_CHECK || 
           pattern === DvtPatternFill.LG_DIAMOND_CHECK)
  {
    halfW = w/2 ;  
    halfH = h/2 ;  
    
    elem = DvtSvgShapeUtils.createElement("polygon");
    
    DvtToolkitUtils.setAttrNullNS(elem, "stroke", color);
    DvtToolkitUtils.setAttrNullNS(elem, "stroke-opacity", alpha);
    DvtToolkitUtils.setAttrNullNS(elem, "stroke-width", 1);
    DvtToolkitUtils.setAttrNullNS(elem, "fill", color);
    DvtToolkitUtils.setAttrNullNS(elem, "fill-opacity", alpha);
    
    DvtToolkitUtils.setAttrNullNS(elem, "points", "0," + halfH + " " + 
                                        halfW + ",0 " + 
                                        rightX + "," + halfW + " " + 
                                        halfW + "," + bottomY);
    
    DvtToolkitUtils.appendChildElem(parentElem, elem);
  }
};
// Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.
/*---------------------------------------------------------------------------*/
/*   DvtSvgShadowUtils    A static class for SVG drop shadow property manip- */
/*                        ulation.                                           */
/*---------------------------------------------------------------------------*/
/**
  *  A static class for SVG drop shadow property manipulation.
  *  @class DvtSvgShadowUtils
  *  @constructor
  */
var  DvtSvgShadowUtils = function()
{} ;

DvtObj.createSubclass(DvtSvgShadowUtils, DvtObj, "DvtSvgShadowUtils");

/**
 * @private
 * @final
 */
DvtSvgShadowUtils.RADS_PER_DEGREE = (Math.PI / 180);


/**
  *  Static method to create an SVG filter element and apply shadow properties to it.
  *  @param {DvtShadow}
  *  @returns {DOM_Element}  An SVG  &lt;filter&gt; element
  */
DvtSvgShadowUtils.createFilter = function(shadow, displayable)
{
   //  The following filter is created:

   //   <filter id="ds1">
   //     <feColorMatrix type="matrix" values="0 0 0 red 0
   //                                          0 0 0 green 0
   //                                          0 0 0 blue 0
   //                                          0 0 0 alpha 0">
   //     </feColorMatrix>
   //     <feGaussianBlur stdDeviation="5.166666666666666" result="blur1"></feGaussianBlur>
   //     <feOffset dx="5.75" dy="5.75" in="blur1" result="offset"></feOffset>
   //     <feMerge>
   //       <feMergeNode in="offset"></feMergeNode>
   //       <feMergeNode in="SourceGraphic"></feMergeNode>
   //     </feMerge>
   //   </filter>

   var filt ;

   if (! shadow.isLocked()) {
     var filtContext = new DvtSvgFilterContext();
     filt = DvtSvgShapeUtils.createElement('filter', shadow._Id) ;
     DvtSvgShadowUtils.createFilterPrimitives(filt, shadow, displayable, filtContext);
     
     var elemM  = DvtSvgShapeUtils.createElement('feMerge') ;
     var elemMN1 = DvtSvgShapeUtils.createElement('feMergeNode') ;
     DvtToolkitUtils.setAttrNullNS(elemMN1, 'in', filtContext.getResultIdsUnder()[0]) ;
     var elemMN2 = DvtSvgShapeUtils.createElement('feMergeNode') ;
     DvtToolkitUtils.setAttrNullNS(elemMN2, 'in', 'SourceGraphic') ;
     
     DvtToolkitUtils.appendChildElem(filt, elemM) ;
     DvtToolkitUtils.appendChildElem(elemM, elemMN1) ;
     DvtToolkitUtils.appendChildElem(elemM, elemMN2) ;
   }
   
   return filt;
};

DvtSvgShadowUtils.createFilterPrimitives = function(filt, shadow, svgDisplayable, filtContext)
{
   //BUG FIX #12407873: create inner shadow if necessary
   if (shadow._bInner)
   {
     DvtSvgShadowUtils.CreateInnerFilterPrimitives(filt, shadow, svgDisplayable, filtContext);
   }
   else
   {
     DvtSvgShadowUtils.CreateOuterFilterPrimitives(filt, shadow, svgDisplayable, filtContext);
   }
};

/**
 * @protected
 */
DvtSvgShadowUtils.CreateOuterFilterPrimitives = function(filt, shadow, svgDisplayable, filtContext)
{
   //if (! shadow.isLocked()) {

     var rgba  = shadow._rgba ;
     var red   = DvtColorUtils.getRed(rgba)/255 ;
     var green = DvtColorUtils.getGreen(rgba)/255 ;
     var blue  = DvtColorUtils.getBlue(rgba)/255 ;
     var alpha = DvtColorUtils.getAlpha(rgba) ;
     var strength = shadow._strength;
     
     var origBlurX = shadow._blurX;
     var origBlurY = shadow._blurY;
     //adjust blur values so that SVG behaves more like Flash
     //BUG FIX #12661565: only calculate blur if blur is not set to 0
     var blurX = 0;
     var blurY = 0;
     if (shadow._blurX > 0)
     {
       blurX = Math.max(shadow._blurX / 3, 1);
     }
     if (shadow._blurY > 0)
     {
       blurY = Math.max(shadow._blurY / 3, 1);
     }
     var distance = shadow._distance;
     var angleDegs = shadow._angle;
     
     var angleRads = angleDegs * DvtSvgShadowUtils.RADS_PER_DEGREE;
     var dx = Math.cos(angleRads) * distance;
     var dy = Math.sin(angleRads) * distance;

     //BUG FIX #12427741: 
     //if we have a boundsRect, increase the size of the filter so
     //that the shadow has room to display outside the shape
     var boundsRect = svgDisplayable.getDimensions(svgDisplayable.getParent());
     if (boundsRect)
     {
       //try to optimize based on how much of the shadow falls
       //on each side of the bounding box
       var absDistance = Math.abs(distance);
       //use two times the blur by default, because using it directly
       //still clips the shadow
       var padLeft = 2 * origBlurX;
       var padRight = 2 * origBlurX;
       var padTop = 2 * origBlurY;
       var padBottom = 2 * origBlurY;
       if (distance > 0)
       {
         padLeft -= absDistance;
         padTop -= absDistance;
         padRight += absDistance;
         padBottom += absDistance;
       }
       else if (distance < 0)
       {
         padLeft += absDistance;
         padTop += absDistance;
         padRight -= absDistance;
         padBottom -= absDistance;
       }
       if (padLeft < 0)
       {
         padLeft = 0;
       }
       if (padTop < 0)
       {
         padTop = 0;
       }
       if (padRight < 0)
       {
         padRight = 0;
       }
       if (padBottom < 0)
       {
         padBottom = 0;
       }
       var ratioLeft = (padLeft / boundsRect.w) * 100;
       var ratioRight = (padRight / boundsRect.w) * 100;
       var ratioTop = (padTop / boundsRect.h) * 100;
       var ratioBottom = (padBottom / boundsRect.h) * 100;
       if (filtContext.getRegionPctRect().x > -ratioLeft)
       {
         filtContext.getRegionPctRect().x = -ratioLeft;
       }
       if (filtContext.getRegionPctRect().y > -ratioTop)
       {
         filtContext.getRegionPctRect().y = -ratioTop;
       }
       if (filtContext.getRegionPctRect().w < (100 + ratioLeft + ratioRight))
       {
         filtContext.getRegionPctRect().w = (100 + ratioLeft + ratioRight);
       }
       if (filtContext.getRegionPctRect().h < (100 + ratioTop + ratioBottom))
       {
         filtContext.getRegionPctRect().h = (100 + ratioTop + ratioBottom);
       }
     }
     // The bounding box does not take into accoutn stroke-width. Need to adjust for DvtLine objects
     if (svgDisplayable instanceof DvtPolyline) {
         var strokeWidth = svgDisplayable.getStroke().getWidth();
         // If stroke is wider than 1 pixel, adjust y coordinate and height of shadow bounding box
         if (strokeWidth > 1) {
             filtContext.getRegionPctRect().h = filtContext.getRegionPctRect().h + strokeWidth;
             filtContext.getRegionPctRect().y = filtContext.getRegionPctRect().y - strokeWidth;
         }
     }

     var elemCM  = DvtSvgShapeUtils.createElement('feColorMatrix') ;
     DvtToolkitUtils.setAttrNullNS(elemCM, 'in', 'SourceGraphic') ;
     DvtToolkitUtils.setAttrNullNS(elemCM, 'type', 'matrix') ;
     DvtToolkitUtils.setAttrNullNS(elemCM, 'values', '0 0 0 ' + red   + ' 0 ' +
                                          '0 0 0 ' + green + ' 0 ' +
                                          '0 0 0 ' + blue  + ' 0 ' +
                                          '0 0 0 ' + alpha*strength + ' 0') ;
     //var elemCMResult = filtContext.createResultId('colorMatrix');
     //DvtToolkitUtils.setAttrNullNS(elemCM, 'result', elemCMResult) ;

     var elemGB  = DvtSvgShapeUtils.createElement('feGaussianBlur') ;
     //include both numbers for stdDev when necessary
     var stdDev = blurX;
     if (blurX !== blurY)
     {
       stdDev += " " + blurY;
     }
     DvtToolkitUtils.setAttrNullNS(elemGB, 'stdDeviation', stdDev) ;
     var elemGBResult = filtContext.createResultId('blur');
     DvtToolkitUtils.setAttrNullNS(elemGB, 'result', elemGBResult) ;

     var elemO  = DvtSvgShapeUtils.createElement('feOffset') ;
     DvtToolkitUtils.setAttrNullNS(elemO, 'dx', dx) ;
     DvtToolkitUtils.setAttrNullNS(elemO, 'dy', dy) ;
     DvtToolkitUtils.setAttrNullNS(elemO, 'in', elemGBResult) ;
     var elemOResult = filtContext.createResultId('offset');
     DvtToolkitUtils.setAttrNullNS(elemO, 'result', elemOResult) ;
     
     filtContext.getResultIdsUnder().push(elemOResult);

     DvtToolkitUtils.appendChildElem(filt, elemCM) ;
     DvtToolkitUtils.appendChildElem(filt, elemGB) ;
     DvtToolkitUtils.appendChildElem(filt, elemO) ;


// TDO <feMorphology operator="erode" in="blurred" radius="3" result="eroded"/>
   //}
};

/**
 * @protected
 */
DvtSvgShadowUtils.CreateInnerFilterPrimitives = function(filt, shadow, svgDisplayable, filtContext)
{
   var rgba  = shadow._rgba ;
   var red   = DvtColorUtils.getRed(rgba)/255 ;
   var green = DvtColorUtils.getGreen(rgba)/255 ;
   var blue  = DvtColorUtils.getBlue(rgba)/255 ;
   var rgb   = DvtColorUtils.makeRGB(red, green, blue);
   var alpha = DvtColorUtils.getAlpha(rgba) ;
   
   var origBlurX = shadow._blurX;
   var origBlurY = shadow._blurY;
   //adjust blur values so that SVG behaves more like Flash
   var blurX = Math.max(shadow._blurX / 2, 1);
   var blurY = Math.max(shadow._blurY / 2, 1);
   var distance = shadow._distance;
   var angleDegs = shadow._angle;
   var strength = shadow._strength;
   
   var angleRads = angleDegs * DvtSvgShadowUtils.RADS_PER_DEGREE;
   var dx = Math.cos(angleRads) * distance;
   var dy = Math.sin(angleRads) * distance;
  
   var elemF1  = DvtSvgShapeUtils.createElement('feFlood') ;
   DvtToolkitUtils.setAttrNullNS(elemF1, 'in', 'SourceGraphic') ;
   DvtToolkitUtils.setAttrNullNS(elemF1, 'flood-opacity', alpha) ;
   DvtToolkitUtils.setAttrNullNS(elemF1, 'flood-color', rgb) ;
   var elemF1Result = filtContext.createResultId('flood');
   DvtToolkitUtils.setAttrNullNS(elemF1, 'result', elemF1Result) ;
   
   var elemC1  = DvtSvgShapeUtils.createElement('feComposite') ;
   DvtToolkitUtils.setAttrNullNS(elemC1, 'operator', 'out') ;
   DvtToolkitUtils.setAttrNullNS(elemC1, 'in', elemF1Result) ;
   DvtToolkitUtils.setAttrNullNS(elemC1, 'in2', 'SourceGraphic') ;
   //var elemC1Result = filtContext.createResultId('comp');
   //DvtToolkitUtils.setAttrNullNS(elemC1, 'result', elemC1Result) ;

/*
   var elemCM  = DvtSvgShapeUtils.createElement('feColorMatrix') ;
   DvtToolkitUtils.setAttrNullNS(elemCM, 'in', 'SourceGraphic') ;
   DvtToolkitUtils.setAttrNullNS(elemCM, 'type', 'matrix') ;
   DvtToolkitUtils.setAttrNullNS(elemCM, 'values', '0 0 0 ' + red   + ' 0 ' +
                                        '0 0 0 ' + green + ' 0 ' +
                                        '0 0 0 ' + blue  + ' 0 ' +
                                        '0 0 0 ' + alpha + ' 0') ;
   //var elemCMResult = filtContext.createResultId('colorMatrix');
   //DvtToolkitUtils.setAttrNullNS(elemCM, 'result', elemCMResult) ;
*/

   var elemGB  = DvtSvgShapeUtils.createElement('feGaussianBlur') ;
   //include both numbers for stdDev when necessary
   var stdDev = blurX;
   if (blurX !== blurY)
   {
     stdDev += " " + blurY;
   }
   DvtToolkitUtils.setAttrNullNS(elemGB, 'stdDeviation', stdDev) ;
   var elemGBResult = filtContext.createResultId('blur');
   DvtToolkitUtils.setAttrNullNS(elemGB, 'result', elemGBResult) ;
   
   //attempt to use the shadow strength as multiplier for alpha
   //value in blur filter
   var elemCM2  = DvtSvgShapeUtils.createElement('feColorMatrix') ;
   DvtToolkitUtils.setAttrNullNS(elemCM2, 'in', elemGBResult) ;
   DvtToolkitUtils.setAttrNullNS(elemCM2, 'type', 'matrix') ;
   DvtToolkitUtils.setAttrNullNS(elemCM2, 'values', '1 0 0 0 0 ' +
                                        '0 1 0 0 0 ' +
                                        '0 0 1 0 0 ' +
                                        '0 0 0 ' + strength + ' 0') ;
   var elemCM2Result = filtContext.createResultId('colMat');
   DvtToolkitUtils.setAttrNullNS(elemCM2, 'result', elemCM2Result) ;

   var elemO  = DvtSvgShapeUtils.createElement('feOffset') ;
   DvtToolkitUtils.setAttrNullNS(elemO, 'dx', dx) ;
   DvtToolkitUtils.setAttrNullNS(elemO, 'dy', dy) ;
   DvtToolkitUtils.setAttrNullNS(elemO, 'in', elemCM2Result) ;
   var elemOResult = filtContext.createResultId('offset');
   DvtToolkitUtils.setAttrNullNS(elemO, 'result', elemOResult) ;
   
   var elemC2  = DvtSvgShapeUtils.createElement('feComposite') ;
   DvtToolkitUtils.setAttrNullNS(elemC2, 'operator', 'in') ;
   DvtToolkitUtils.setAttrNullNS(elemC2, 'in', elemOResult) ;
   DvtToolkitUtils.setAttrNullNS(elemC2, 'in2', 'SourceGraphic') ;
   var elemC2Result = filtContext.createResultId('comp');
   DvtToolkitUtils.setAttrNullNS(elemC2, 'result', elemC2Result) ;
   
   filtContext.getResultIdsOver().push(elemC2Result);

   DvtToolkitUtils.appendChildElem(filt, elemF1) ;
   DvtToolkitUtils.appendChildElem(filt, elemC1) ;
   //DvtToolkitUtils.appendChildElem(filt, elemCM) ;
   DvtToolkitUtils.appendChildElem(filt, elemGB) ;
   DvtToolkitUtils.appendChildElem(filt, elemCM2) ;
   DvtToolkitUtils.appendChildElem(filt, elemO) ;
   DvtToolkitUtils.appendChildElem(filt, elemC2) ;
};
/**
 * Base attribute groups handler.
 * @class
 * @constructor
 */
var DvtAttrGroups = function() {}

DvtObj.createSubclass(DvtAttrGroups, DvtObj, "DvtAttrGroups");

/**
 * Returns the mapping for the specified group or value.
 * @param {object} value The group or value whose mapping will be retrieved.
 * @return {object} The corresponding value along the ramp.
 */
DvtAttrGroups.prototype.get = function(value) {
  // subclasses must override
};
/**
 * Discrete attribute groups handler.
 * @class
 * @constructor
 * @extends {DvtAttrGroups}
 */
var DvtDiscreteAttrGroups = function() {
  this._results = new Array();
}

DvtObj.createSubclass(DvtDiscreteAttrGroups, DvtAttrGroups, "DvtDiscreteAttrGroups");

/**
 * Adds a mapping to this object.
 * @param {string} group The id for the group.
 * @param {string} groupLabel The label for the group.
 * @param {object} params
 */
DvtDiscreteAttrGroups.prototype.add = function(group, groupLabel, params) {
  this._results.push({group: group, groupLabel: groupLabel, params: params});
}

/**
 * Returns the mapping for the specified group.
 * @param {object} group The group whose mapping will be retrieved.
 * @return {object} The parameters object
 */
DvtDiscreteAttrGroups.prototype.get = function(group) {
  if(value === null)
    return null;

  // Loop through the results to find the mapping
  for(var i=0; i<this._results.length; i++) {
    if(this._results[i].group == group)
      return this._results[i].params;
  }
  
  // Otherwise not found
  return null;
};

/**
 * Returns the array of mapping objects.  Each object contains the mapped value, the
 * group id, and the group label.
 * @return {array} An array of objects with value, group, and groupLabel fields.
 */
DvtDiscreteAttrGroups.prototype.getMappingsArray = function() {
  return this._results.slice(0);
}
/**
 * Continuous attribute groups handler.
 * @param {number} minValue The minimum bounds for use in mapping values.
 * @param {number} maxValue The maximum bounds for use in mapping values.
 * @param {string} minLabel The label for the minimum bounds.
 * @param {string} maxLabel The label for the maximum bounds.
 * @param {array} ramp The ramp for use in mapping values.
 * @class
 * @constructor
 * @extends {DvtAttrGroups}
 */
var DvtContinuousAttrGroups = function(minValue, maxValue, minLabel, maxLabel, ramp) {
  this._minValue = minValue;
  this._maxValue = maxValue;
  this._minLabel = minLabel ? minLabel : this._minValue;
  this._maxLabel = maxLabel ? maxLabel : this._maxValue;
  this._ramp = ramp;
  
  // Cache the range for performance
  this._range = this._maxValue - this._minValue;
}

DvtObj.createSubclass(DvtContinuousAttrGroups, DvtAttrGroups, "DvtContinuousAttrGroups");

/**
 * Returns the mapping for the specified value.
 * @param {object} value The value whose mapping will be retrieved.
 * @return {object} The corresponding value along the ramp.
 */
DvtContinuousAttrGroups.prototype.get = function(value) {
  if(isNaN(value) || value === null)
    return null;

  // Calculate the ratio along the ramp
  var ratio = (value - this._minValue)/this._range;
  ratio = Math.max(Math.min(ratio, 1), 0);
  
  // Find the surrounding object mappings
  var index = ratio * (this._ramp.length-1);
  if(index === Math.round(index))
    return this._ramp[index];
  else {
    // Index falls between two values
    var a = this._ramp[Math.floor(index)];
    var b = this._ramp[Math.ceil(index)];
    return this._calcValue(a, b, index - Math.floor(index));
  }
};

/**
 * Returns the ramp used for mapping values.
 * @return {array}
 */
DvtContinuousAttrGroups.prototype.getRamp = function() {
  return this._ramp.slice(0);
}

/**
 * Returns the label for the minimum bounds.
 * @return {string}
 */
DvtContinuousAttrGroups.prototype.getMinLabel = function() {
  return this._minLabel;
}

/**
 * Returns the label for the maximum bounds.
 * @return {string}
 */
DvtContinuousAttrGroups.prototype.getMaxLabel = function() {
  return this._maxLabel;
}

/**
 * Returns the value between the specified parameters at the specified percent.
 * @param {object} a
 * @param {object} b
 * @param {number} percent The percent between a and b.
 * @return {object} The value at the specified percent between a and b.
 */
DvtContinuousAttrGroups.prototype._calcValue = function(a, b, percent) {
  // Note: Only color is supported by continuous attribute groups in this release.
  return DvtColorUtils.interpolateColor(a, b, percent);
}
/**
 * Legend rendering utilities for attribute groups components.
 * @class
 */
var DvtLegendAttrGroupsRenderer = function() {}

DvtObj.createSubclass(DvtLegendAttrGroupsRenderer, DvtObj, "DvtLegendAttrGroupsRenderer");

DvtLegendAttrGroupsRenderer._LEGEND_MAX_HEIGHT = 0.4; 
DvtLegendAttrGroupsRenderer._CONTINUOUS_GROUP_GAP = 1; // gap between continuous item and rest of component
DvtLegendAttrGroupsRenderer._CONTINUOUS_ITEM_WIDTH = 50; 
DvtLegendAttrGroupsRenderer._CONTINUOUS_ITEM_HEIGHT = 10;
DvtLegendAttrGroupsRenderer._CONTINUOUS_ITEM_GAP = 5; 
DvtLegendAttrGroupsRenderer._LABEL_SIZE = 11;
DvtLegendAttrGroupsRenderer._LABEL_COLOR = "#636363";
DvtLegendAttrGroupsRenderer._LABEL_VALUE_COLOR = "#333333";

/**
 * Performs layout and rendering for an attribute groups object.
 * @param {DvtContext} context
 * @param {DvtEventManager} eventManager
 * @param {DvtContainer} container The legend container.
 * @param {number} availWidth The available horizontal space.
 * @param {number} availHeight The available vertical space.
 * @param {DvtAttrGroups} attrGroups An attribute groups describing the colors.
 * @return {DvtDisplayable} The rendered contents.
 */
DvtLegendAttrGroupsRenderer.renderAttrGroups = function(context, eventManager, container, availWidth, availHeight, attrGroups, styles) {  
  var colorContainer = null;
  if (attrGroups) {
	  if(attrGroups instanceof DvtContinuousAttrGroups) 
	    colorContainer = DvtLegendAttrGroupsRenderer._renderAttrGroupsContinuous(context, eventManager, container, availWidth, availHeight, attrGroups, styles);
	  else if(attrGroups instanceof DvtDiscreteAttrGroups) 
	    colorContainer = DvtLegendAttrGroupsRenderer._renderAttrGroupsDiscrete(context, eventManager, container, availWidth, availHeight, attrGroups, styles); 
  }
  return colorContainer;
}

/**
 * Performs layout and rendering for continuous attribute groups.
 * @param {DvtContext} context
 * @param {DvtEventManager} eventManager
 * @param {DvtContainer} container The legend container.
 * @param {number} availWidth The available horizontal space.
 * @param {number} availHeight The available vertical space.
 * @param {DvtAttrGroups} attrGroups An attribute groups describing the colors.
 * @return {DvtDisplayable} The rendered contents.
 */
DvtLegendAttrGroupsRenderer._renderAttrGroupsContinuous = function(context, eventManager, container, availWidth, availHeight, attrGroups, styles) { 
  // Create a container for this item
  var isRTL = DvtAgent.isRightToLeft(context);
  var labelY = DvtLegendAttrGroupsRenderer._CONTINUOUS_ITEM_HEIGHT/2 + DvtLegendAttrGroupsRenderer._CONTINUOUS_GROUP_GAP;
  var colorContainer = new DvtContainer(context);
  container.addChild(colorContainer);
  
  // Min Label
  var minLabelStr = attrGroups.getMinLabel();
  var minLabel = new DvtOutputText(context, minLabelStr, 0, labelY);
  minLabel.setCSSStyle(styles.labelStyle);
  minLabel.alignMiddle();
  colorContainer.addChild(minLabel);
  
  // Gradient
  var gradientRect = new DvtRect(context, 0, DvtLegendAttrGroupsRenderer._CONTINUOUS_GROUP_GAP, DvtLegendAttrGroupsRenderer._CONTINUOUS_ITEM_WIDTH, DvtLegendAttrGroupsRenderer._CONTINUOUS_ITEM_HEIGHT); 
  var ramp = isRTL ? attrGroups.getRamp().slice().reverse() : attrGroups.getRamp();
  gradientRect.setFill(new DvtLinearGradientFill(0, ramp));
  if(styles.borderColor)
    gradientRect.setSolidStroke(styles.borderColor);
    
  colorContainer.addChild(gradientRect);
  var gradientWidth = DvtLegendAttrGroupsRenderer._CONTINUOUS_ITEM_WIDTH + DvtLegendAttrGroupsRenderer._CONTINUOUS_ITEM_GAP;
  
  // Max Label
  var maxLabelStr = attrGroups.getMaxLabel();
  var maxLabel = new DvtOutputText(context, maxLabelStr, 0, labelY);
  maxLabel.setCSSStyle(styles.labelStyle);
  maxLabel.alignMiddle();
  colorContainer.addChild(maxLabel);
  
  // Position the labels and the rectangle
  if(isRTL) {
    // BIDI
    var maxLabelWidth = maxLabel.measureDimensions().w + DvtLegendAttrGroupsRenderer._CONTINUOUS_ITEM_GAP;
    gradientRect.setTranslateX(maxLabelWidth);
    minLabel.setX(maxLabelWidth + gradientWidth);
  }
  else {
    // Non-BIDI
    var minLabelWidth = minLabel.measureDimensions().w + DvtLegendAttrGroupsRenderer._CONTINUOUS_ITEM_GAP
    gradientRect.setTranslateX(minLabelWidth);
    maxLabel.setX(minLabelWidth + gradientWidth);
  }
  
  // Add a tooltip to the gradient rectangle
  var tooltip = minLabelStr + " - " + maxLabelStr;
  eventManager.associate(gradientRect, new DvtSimpleObjPeer(tooltip));
  
  // If there isn't enough space for all the content, drop the labels
  if(colorContainer.getDimensions().w > availWidth) {
    colorContainer.removeChild(minLabel);
    colorContainer.removeChild(maxLabel);
    gradientRect.setTranslateX(0);
  }
  
  // Return the contents
  return colorContainer;
}

/**
 * Performs layout and rendering for discrete attribute groups.
 * @param {DvtContext} context
 * @param {DvtEventManager} eventManager
 * @param {DvtContainer} container The legend container.
 * @param {number} availWidth The available horizontal space.
 * @param {number} availHeight The available vertical space.
 * @param {DvtAttrGroups} attrGroups An attribute groups describing the colors.
 * @return {DvtDisplayable} The rendered contents.
 */
DvtLegendAttrGroupsRenderer._renderAttrGroupsDiscrete = function(context, eventManager, container, availWidth, availHeight, attrGroups, styles) {  
  // Iterate through the attribute group mappings to build up the legend items array.
  var items = [];
  var mappings = attrGroups.getMappingsArray();
  for(var i=0; i<mappings.length; i++) {
    var mapping = mappings[i];
    items.push({'text': mapping.groupLabel, 'color': mapping.params.color, 'pattern': mapping.params.pattern, 'borderColor': styles.borderColor});
  }
  
  // Create the legend data object and legend
  var legendOptions = {'sections': [{'items': items}], 
                       'orientation': 'horizontal',
                       'layout': {'outerGapWidth': 0, 'outerGapHeight': 0}, 
                       'textStyle': styles.labelStyle.toString()};
  var component = DvtLegend.newInstance(context);
  component.setId(null);
  container.addChild(component);
  
  // Layout the legend and get the preferred size
  var maxLegendHeight = availHeight * DvtLegendAttrGroupsRenderer._LEGEND_MAX_HEIGHT;
  var preferredDims = component.getPreferredSize(legendOptions, availWidth, maxLegendHeight);
  component.render(legendOptions, availWidth, preferredDims.h);
  
  // Add a transparent background for the legend so that calling getDimensions on it
  // will return the full size with the gaps.
  var actualDims = component.getDimensions();
  var rect = new DvtRect(context, 0, 0, actualDims.w, preferredDims.h);
  rect.setInvisibleFill();
  component.addChildAt(rect, 0);
  
  // Return the contents
  return component;
}
/**
 * A component level breadcrumb drill event.
 * @param {string} id The id of the data item that was drilled.
 * @class
 * @constructor
 */
var DvtBreadcrumbsDrillEvent = function(id) {
  this.Init(DvtBreadcrumbsDrillEvent.TYPE);
  this._id = id;
}

DvtObj.createSubclass(DvtBreadcrumbsDrillEvent, DvtBaseComponentEvent, "DvtBreadcrumbsDrillEvent");

DvtBreadcrumbsDrillEvent.TYPE = "breadcrumbsDrill";

/**
 * Returns the id of the item that was drilled.
 * @return {string} The id of the item that was drilled.
 */
DvtBreadcrumbsDrillEvent.prototype.getId = function() {
  return this._id;
}
// Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.

/**
 * Breadcrumbs component.
 * @param {DvtContext} context The rendering context.
 * @param {string} callback The function that should be called to dispatch component events.
 * @param {object} callbackObj The optional object instance on which the callback function is defined.
 * @param {object} options The object containing options specifications for this component.
 * @class
 * @constructor
 * @extends {DvtContainer}
 * @implements {DvtComponentKeyboardHandler}
 */
var DvtBreadcrumbs = function(context, callback, callbackObj, options) {
  this.Init(context, callback, callbackObj, options);
}

DvtObj.createSubclass(DvtBreadcrumbs, DvtContainer, "DvtBreadcrumbs");

/**
 * Initializes the component.
 * @param {DvtContext} context The rendering context.
 * @param {string} callback The function that should be called to dispatch component events.
 * @param {object} callbackObj The optional object instance on which the callback function is defined.
 * @param {object} options The object containing options specifications for this component.
 * @protected
 */
DvtBreadcrumbs.prototype.Init = function(context, callback, callbackObj, options) {
  DvtBreadcrumbs.superclass.Init.call(this, context);
  this.setOptions(options);
  
  // Create the event handler and add event listeners
  this._eventHandler = new DvtBreadcrumbsEventManager(this, context, callback, callbackObj);
  this._eventHandler.addListeners(this);
  
  // Make sure the object has an id for clipRect naming
  this.setId("breadcrumbs" + 1000 + Math.floor(Math.random()*1000000000));
  
  // index of the breadcrumb with keyboard focus. index is used to find the
  // Object stored in the _data object's item field 
  this._curCrumbIdx = -1;
  
  // the DvtRect we use to show which breadcrumb has keyboard focus
  this._keyboardFocusRect = null;
  this._crumbs = null;
}

/**
 * Specifies the non-data options for this component.
 * @param {object} options The object containing options specifications for this component.
 * @protected
 */
DvtBreadcrumbs.prototype.setOptions = function(options) {
  this._options = DvtBreadcrumbsDefaults.calcOptions(options);
}

/**
 * Renders the component with the specified data.  If no data is supplied to a component
 * that has already been rendered, the component will be re-rendered to the specified size.
 * @param {object} data The object containing data for this component.
 * @param {number} width The width of the component.
 * @param {number} height The height of the component.
 */
DvtBreadcrumbs.prototype.render = function(data, width) 
{  
  // Update if new data has been provided. Clone to avoid modifying the provided object.
  this._data = data ? DvtJSONUtils.clone(data) : this._data; 

  // Clear previous contents
  this.removeChildren();
  this.SetCrumbs(null);

  // Render the contents
  DvtBreadcrumbsRenderer.render(this, this, width);
}

/**
 * Returns the data object for the component.
 * @return {object} The object containing data for this component.
 */
DvtBreadcrumbs.prototype.__getData = function() {
  return this._data ? this._data : {};
}

/**
 * Returns the evaluated options object, which contains the user specifications
 * merged with the defaults.
 * @return {object} The options object.
 */
DvtBreadcrumbs.prototype.__getOptions = function() {
  return this._options;
}

/**
 * Returns the DvtEventManager for this component.
 * @return {DvtEventManager}
 */
DvtBreadcrumbs.prototype.__getEventManager = function() {
  return this._eventHandler;
}

/**
 * @override
 */
DvtBreadcrumbs.prototype.handleKeyboardEvent = function(event) 
{
  var eventConsumed = true;
  var keyCode = event.keyCode;
  
  if(keyCode == DvtKeyboardEvent.TAB)
  {
    var prevCrumbIdx = this._curCrumbIdx;
    this._curCrumbIdx = this._updateCrumbIndex(this._curCrumbIdx, !event.shiftKey);
    this._updateKeyboardFocusEffect(prevCrumbIdx, this._curCrumbIdx);

    if(this._curCrumbIdx < 0 || this._curCrumbIdx == this._data.items.length-1)
    {
      // tabbing out of the breadcrumbs, make sure tab event get propagated
      // beyond the breadcrumbs
      eventConsumed = false;
    }
  }  
  else if(keyCode == DvtKeyboardEvent.ENTER)
  {
    // simulate a click on the current breadcrumb
    var mouseEvent = this._eventHandler.GenerateMouseEventFromKeyboardEvent(
                     event, this.getCtx().getStage(), 0, 0);
    mouseEvent.target = this.getCrumb(this._curCrumbIdx);
    this._eventHandler.OnClick(mouseEvent);
  }
  
  // keystrokes are consumed by default, unless we tab out of the breadcrumbs
  if(eventConsumed)
    event.preventDefault();
  
  return eventConsumed;
}


/**
 * @override
 */
DvtBreadcrumbs.prototype.hideKeyboardFocusEffect = function()  
{
  var prevCrumbIdx = this._curCrumbIdx;
  this._curCrumbIdx = -1;
  this._updateKeyboardFocusEffect(prevCrumbIdx, this._curCrumbIdx);
}
 
 
 
/**
 * Updates which breadcrumb has keyboard focus. 
 * @param {Number} curIndex The index in the _data object's item array indicating
 *        the current breadcrumb
 * @param (Boolean} bForward True if we are tabbing forward, false if we are
 *        shift-tabbing backwards
 * @return {Number} The index in the _data object's item array indicating
 *        which item has keyboard focus
 * @private
 */
DvtBreadcrumbs.prototype._updateCrumbIndex = function(curIndex, bForward) 
{
  if(bForward)
  {
    if(curIndex < 0 || curIndex >= this._data.items.length-1)
      // will always have at least two breadcrumbs since last crumb is not
      // drillable
      return 0;
    else
      return ++curIndex;
  }
  else
  {
    if(curIndex < 0 || curIndex >= this._data.items.length-1)
      // will always have at least two breadcrumbs since last crumb is not
      // drillable
      return this._data.items.length - 2;
    return --curIndex;
  }
}

/**
 * Updates the visual keyboard focus effect
 * @param {Number} prevIdx The index in the _data object's item array 
 *        indicating the prev breadcrumb
 * @param (Number} nextIdx The index in the _data object's item array 
 *        indicating the next breadcrumb
 * @private
 */
DvtBreadcrumbs.prototype._updateKeyboardFocusEffect = function (prevIdx, nextIdx)
{
  // find the DvtText objects corresponding to the prev and next breadcrumbs
  var labelObj = null;
  var prevKeyboardFocusRect = this._keyboardFocusRect;
  var nextKeyboardFocusRect = null;  

  // find the next breadcrumb to apply focus effect to
  var nextCrumbObj = this.getCrumb(nextIdx);
  if(nextCrumbObj)
  {
    var peer = this._eventHandler.GetLogicalObject(nextCrumbObj)
    if(peer && peer.isDrillable && peer.isDrillable())
    {
      // create a new focus effect rectangle for the next breadcrumb
      var context = this.getCtx();
      var bounds = nextCrumbObj.getDimensions();
      var matrix = nextCrumbObj.getMatrix();
      nextKeyboardFocusRect = new DvtKeyboardFocusEffect(context, this, bounds, matrix);
      this._keyboardFocusRect = nextKeyboardFocusRect;
    }
    else
    {
      // we hit the last breadcrumb, which is not drillable. so this tab
      // takes us out of the breadcrumbs
      // clear the reference to the focus rectangle; the focus rectangle 
      // is actually removed from the container at the end of this method
      this._keyboardFocusRect = null;          
    }    
  }

  if(prevKeyboardFocusRect)
    prevKeyboardFocusRect.hide();
  
  if(nextKeyboardFocusRect)
    nextKeyboardFocusRect.show();
}


/**
 * Returns the physical object corresponding to the breadcrumb with 
 * keyboard focus
 * @param {Number} crumbIdx The index of the breadcrumb of interest
 * @return {DvtButton} 
 */
DvtBreadcrumbs.prototype.getCrumb = function(crumbIdx)
{
  var crumbs = this.GetCrumbs();
  if(crumbIdx < 0 || !crumbs || crumbIdx >= crumbs.length)
    return null;
  return crumbs[crumbIdx];
}

/**
 * Sets an array of breadcrumbs
 * @param {array} crumbs
 * @protected
 */
DvtBreadcrumbs.prototype.SetCrumbs = function(crumbs) {
  this._crumbs = crumbs;
}

/**
 * Gets an array of breadcrumbs
 * @return {array}
 * @protected
 */
DvtBreadcrumbs.prototype.GetCrumbs = function() {
  return this._crumbs;
}
/**
 * Default values and utility functions for breadcrumb versioning.
 * @class
 */
var DvtBreadcrumbsDefaults = new Object();

DvtObj.createSubclass(DvtBreadcrumbsDefaults, DvtObj, "DvtBreadcrumbsDefaults");

/**
 * Defaults for version 1.
 */ 
DvtBreadcrumbsDefaults.VERSION_1 = {
  'labelStyle': "font-size: 11px; color: #003286;",
  'disabledLabelStyle': "font-size: 11px;",

  //*********** Internal Attributes *************************************************//
  __labelGap: 2,
  __labelSeparator: ">"
};

/**
 * Combines the user options with the defaults for the specified version.  Returns the
 * combined options object.  This object will contain internal attribute values and
 * should be accessed in internal code only.
 * @param {object} userOptions The object containing options specifications for this component.
 * @return {object} The combined options object.
 */
DvtBreadcrumbsDefaults.calcOptions = function(userOptions) {
  var defaults = DvtBreadcrumbsDefaults._getDefaults(userOptions);
  
  // Use defaults if no overrides specified
  if(!userOptions)
    return defaults;
  else // Merge the options object with the defaults
    return DvtJSONUtils.merge(userOptions, defaults);
}

/**
 * Returns the default options object for the specified version of the component.
 * @param {object} userOptions The object containing options specifications for this component.
 * @private
 */
DvtBreadcrumbsDefaults._getDefaults = function(userOptions) {
  // Note: Version checking will eventually get added here
  // Note: Future defaults objects are deltas on top of previous objects
  return DvtJSONUtils.clone(DvtBreadcrumbsDefaults.VERSION_1);
}

/**
 * Scales down gap sizes based on the size of the component.
 * @param {object} options The object containing options specifications for this component.
 * @param {Number} defaultSize The default gap size.
 * @return {Number} 
 */
DvtBreadcrumbsDefaults.getGapSize = function(options, defaultSize) {
  return Math.ceil(defaultSize * options['layout']['gapRatio']);
}
/**
 * Event Manager for DvtBreadcrumbs.
 */
var DvtBreadcrumbsEventManager = function(breadcrumbs, context, callback, callbackObj) {
  this.Init(context, callback, callbackObj);
  this._breadcrumbs = breadcrumbs;
};

DvtObj.createSubclass(DvtBreadcrumbsEventManager, DvtEventManager, "DvtBreadcrumbsEventManager");

/**
 * @override
 */
DvtBreadcrumbsEventManager.prototype.OnClick = function(event) {
  DvtBreadcrumbsEventManager.superclass.OnClick.call(this, event);
  var obj = this.GetLogicalObject(event.target);
  this._processBreadcrumbs(obj);
}

/**
 * @override
 */
DvtBreadcrumbsEventManager.prototype.HandleTouchClickInternal = function(event) {
  var targetObj = event.target;        
  var obj = this.GetLogicalObject(targetObj);
  this._processBreadcrumbs(obj);
}

/**
 * Processes a possible drill event on a breadcrumb.
 * @param {obj} The logical object which was clicked or tapped.
 * @private
 */
DvtBreadcrumbsEventManager.prototype._processBreadcrumbs = function(obj) {
  if(obj && obj instanceof DvtBreadcrumbsPeer && obj.isDrillable()) {
    // Create the event and fire to callbacks
    var event = new DvtBreadcrumbsDrillEvent(obj.getId());
    this.FireEvent(event, this._breadcrumbs);
  }
}
/**
 * Simple logical object for drilling and tooltip support.
 * @param {string} id The id of the associated breadcrumb.
 * @param {string} tooltip The tooltip to display.
 * @class
 * @constructor
 * @implements {DvtTooltipSource}
 */
var DvtBreadcrumbsPeer = function(id, tooltip) {
  this.Init(tooltip);
  this._id = id;
  this._bDrillable = false;
}

DvtObj.createSubclass(DvtBreadcrumbsPeer, DvtSimpleObjPeer, "DvtBreadcrumbsPeer");

/**
 * Returns the id of the associated breadcrumb.
 * @return {string}
 */
DvtBreadcrumbsPeer.prototype.getId = function() {
  return this._id;
}

/**
 * Returns true if the associated breadcrumb is drillable.
 * @return {boolean}
 */
DvtBreadcrumbsPeer.prototype.isDrillable = function() {
  return this._bDrillable;
}

/**
 * Specifies whether the associated breadcrumb is drillable.
 * @param {boolean} drillable
 */
DvtBreadcrumbsPeer.prototype.setDrillable = function(drillable) {
  this._bDrillable = drillable;
}
/**
 * Renderer for DvtBreadcrumbs.
 * @class
 */
var DvtBreadcrumbsRenderer = new Object();

DvtObj.createSubclass(DvtBreadcrumbsRenderer, DvtObj, "DvtBreadcrumbsRenderer");

/**
 * @private
 */
DvtBreadcrumbsRenderer._TOUCH_BUFFER = 3;

/**
 * Renders the breadcrumbs in the specified area.
 * @param {DvtBreadcrumbs} breadcrumbs The breadcrumbs being rendered.
 * @param {DvtContainer} container The container to render into.
 * @param {number} width The width of the component.
 */
DvtBreadcrumbsRenderer.render = function(breadcrumbs, container, width) {
  var context = breadcrumbs.getCtx();
  var dataItems = breadcrumbs.__getData().items ? breadcrumbs.__getData().items : [];
  var options = breadcrumbs.__getOptions();
  var eventManager = breadcrumbs.__getEventManager();
  
  // Create all of the labels
  var labels = [];
  var peers = [];
  for(var i=0; i<dataItems.length; i++) {
    var dataItem = dataItems[i];
    if(dataItem) {
      // If the item does not have text, use "" as a placeholder to indicate text was missing
      var textStr = dataItem.text ? dataItem.text : "";
    
      // Create the text element
      var label = DvtBreadcrumbsRenderer._createLabel(context, textStr, options, i < dataItems.length-1);
      labels.push(label);
      
      // Create peer for interactivity support
      var peer = new DvtBreadcrumbsPeer(dataItem.id); 
      eventManager.associate(label, peer);
      peers.push(peer);
      
      // All except the last label are drillable
      if(i < dataItems.length-1) {
        label.setCursor("pointer");
        peer.setDrillable(true);
      }
    }
  }
  breadcrumbs.SetCrumbs(labels);
  
  // Position the labels
  if(DvtAgent.isRightToLeft(context))
    DvtBreadcrumbsRenderer._positionLabelsBidi(breadcrumbs, container, width, labels, peers);
  else
    DvtBreadcrumbsRenderer._positionLabels(breadcrumbs, container, width, labels, peers);
}

/**
 * Create a state for a label button.
 * @param {DvtContext} context The DvtContext to use.
 * @param {string} text The text for the label.
 * @param {DvtCSSStyle} cssStyle Style object for the label.
 * @return {DvtRect}
 * @private
 */
DvtBreadcrumbsRenderer._createButtonState = function(context, text, cssStyle) {
  var dvtText = new DvtOutputText(context, text, 0, 0);
  dvtText.setMouseEnabled(false);
  dvtText.setCSSStyle(cssStyle);
  
  var padTop = cssStyle.getPadding(DvtCSSStyle.PADDING_TOP);
  var padRight = cssStyle.getPadding(DvtCSSStyle.PADDING_RIGHT);
  var padBottom = cssStyle.getPadding(DvtCSSStyle.PADDING_BOTTOM);
  var padLeft = cssStyle.getPadding(DvtCSSStyle.PADDING_LEFT);
  
  var labelDims = DvtDisplayableUtils.getDimensionsForced(context, dvtText);
  var state = new DvtRect(context, 0, 0, labelDims.w + padLeft + padRight, labelDims.h + padTop + padBottom);
  state.setInvisibleFill();
  state.setCSSStyle(cssStyle);
  dvtText.setTranslate(padLeft, padTop);
  state.addChild(dvtText);
  
  return state;
};

/**
 * Create the label object, which could be a DvtButton, DvtRect, or DvtText.
 * @param {DvtContext} context The DvtContext to use.
 * @param {string} textStr The text string for the label.
 * @param {object} options Options for the breadcrumbs.
 * @param {boolean} bEnabled Flag indicating if this label is enabled or not.
 * @return {object}
 * @private
 */
DvtBreadcrumbsRenderer._createLabel = function(context, textStr, options, bEnabled) {
  var label;
  if (bEnabled && (options.labelStyleOver || options.labelStyleDown)) {
      var enaCss = new DvtCSSStyle(options.labelStyle);
      var ovrCss = new DvtCSSStyle(options.labelStyleOver);
      var dwnCss = new DvtCSSStyle(options.labelStyleDown);
      
      var ena = DvtBreadcrumbsRenderer._createButtonState(context, textStr, enaCss);
      var ovr = DvtBreadcrumbsRenderer._createButtonState(context, textStr, ovrCss);
      var dwn = DvtBreadcrumbsRenderer._createButtonState(context, textStr, dwnCss);
      
      label = new DvtButton(context, ena, ovr, dwn);
  }
  else {
    var labelStyle = bEnabled ? options.labelStyle : options.disabledLabelStyle;
    var cssStyle = new DvtCSSStyle(labelStyle);
    if (cssStyle.getPadding(DvtCSSStyle.PADDING_LEFT) || cssStyle.getPadding(DvtCSSStyle.PADDING_RIGHT) || cssStyle.getPadding(DvtCSSStyle.PADDING_TOP) || cssStyle.getPadding(DvtCSSStyle.PADDING_BOTTOM)) {
      label = DvtBreadcrumbsRenderer._createButtonState(context, textStr, cssStyle);
    }
    else {
      label = new DvtOutputText(context, textStr, 0, 0);
      label.setCSSStyle(cssStyle);
    }
  }
  return label;
};

/**
 * Get the label text string.
 * @param {object} label The label object, which could be a DvtButton, DvtRect, or DvtText.
 * @return {string}
 * @private
 */
DvtBreadcrumbsRenderer._getLabelTextString = function(label) {
  if (label instanceof DvtButton) {
    var ena = label.upState;
    var text = ena.getChildAt(0);
    return text.getTextString();
  }
  else if (label instanceof DvtRect) {
    var text = label.getChildAt(0);
    return text.getTextString();
  }
  
  return label.getTextString();
};

/**
 * Truncates the breadcrumb labels.
 * @param {object} label The label object, which could be a DvtButton, DvtRect, or DvtText.
 * @param {number} maxWidth The maximum label width.
 * @private
 */
DvtBreadcrumbsRenderer._truncateLabels = function(label, maxWidth) {
  if (label instanceof DvtButton) {
    var ena = label.upState;
    var text = ena.getChildAt(0);
    DvtTextUtils.fitText(text, Math.max(maxWidth - text.getTranslateX(), 0), Infinity, text.getParent());
    var ovr = label.overState;
    text = ovr.getChildAt(0);
    DvtTextUtils.fitText(text, Math.max(maxWidth - text.getTranslateX(), 0), Infinity, text.getParent());
    var dwn = label.downState;
    text = dwn.getChildAt(0);
    DvtTextUtils.fitText(text, Math.max(maxWidth - text.getTranslateX(), 0), Infinity, text.getParent());
    return;
  }
  else if (label instanceof DvtRect) {
    var text = label.getChildAt(0);
    DvtTextUtils.fitText(text, Math.max(maxWidth - text.getTranslateX(), 0), Infinity, text.getParent());
    return;
  }
  
  DvtTextUtils.fitText(label, maxWidth, Infinity, label.getParent());
}

/**
 * Positions the labels into the given container.
 * @param {DvtBreadcrumbs} breadcrumbs The breadcrumbs being rendered.
 * @param {DvtContainer} container The container in which the labels will be added.
 * @param {number} availWidth The available width for positioning.
 * @param {array} labels The array of DvtText labels.
 * @param {array} peers The array of peers corresponding to the labels.  The last label will never have a peer.
 * @private
 */
DvtBreadcrumbsRenderer._positionLabels = function(breadcrumbs, container, availWidth, labels, peers) {
  var options = breadcrumbs.__getOptions();
  var eventManager = breadcrumbs.__getEventManager();
  
  var arDims = [];
  var maxHeight = 0;
  for(var i=0; i<labels.length; i++) {
    container.addChild(labels[i]);
    var dims = labels[i].getDimensions();
    arDims[i] = dims;
    maxHeight = Math.max(dims.h, maxHeight);
    container.removeChild(labels[i]);
  }

  var x = 0;
  for(var i=0; i<labels.length; i++) {
    // Add and position the label, then calculate the space for the next one
    container.addChild(labels[i]);
    var dims = arDims[i];
    labels[i].setTranslate(x, .5 * (maxHeight - dims.h));
    
    // Add a buffer to make the objects easier to interact with on touch devices
    if(DvtAgent.isTouchDevice()) { 
      var rect = new DvtRect(container.getCtx(), -DvtBreadcrumbsRenderer._TOUCH_BUFFER, -DvtBreadcrumbsRenderer._TOUCH_BUFFER, 
                             dims.w + 2*DvtBreadcrumbsRenderer._TOUCH_BUFFER, dims.h + 2*DvtBreadcrumbsRenderer._TOUCH_BUFFER);
      rect.setInvisibleFill();
      labels[i].addChild(rect);
      if(i < peers.length) 
        eventManager.associate(rect, peers[i]);
    }
    
    // Truncate if needed
    if(x + dims.w > availWidth) {
      var labelString = DvtBreadcrumbsRenderer._getLabelTextString(labels[i]);
      DvtBreadcrumbsRenderer._truncateLabels(labels[i], availWidth - x);
      
      // Add a tooltip
      if(i < peers.length) 
        peers[i].setTooltip(labelString);
      else 
        eventManager.associate(labels[i], new DvtSimpleObjPeer(labelString));
        
      // No more space, all done
      return;
    }
    else // Update the x
      x += dims.w + options.__labelGap;
    
      // Add a separator if there are more labels
    if(i < labels.length - 1) {
        var separator = DvtBreadcrumbsRenderer._newSeparator(breadcrumbs);
        container.addChild(separator);
        var sepDims = separator.getDimensions();
        separator.setTranslate(x, .5 * (maxHeight - sepDims.h));
        
        // Check that there is enough space
        var separatorWidth = sepDims.w;
      if(x + separatorWidth > availWidth) {
        container.removeChild(separator);
        return;
      }
        
        x += separatorWidth + options.__labelGap;
      }
    }
  }

/**
 * Positions the labels into the given container for BIDI locales
 * @param {DvtBreadcrumbs} breadcrumbs The breadcrumbs being rendered.
 * @param {DvtContainer} container The container in which the labels will be added.
 * @param {number} availWidth The available width for positioning.
 * @param {array} labels The array of DvtText labels.
 * @param {array} peers The array of peers corresponding to the labels.  The last label will never have a peer.
 * @private
 */
DvtBreadcrumbsRenderer._positionLabelsBidi = function(breadcrumbs, container, availWidth, labels, peers) {
  var options = breadcrumbs.__getOptions();
  var eventManager = breadcrumbs.__getEventManager();

  var x = availWidth;
  for(var i=0; i<labels.length; i++) {
    // Add and position the label, then calculate the space for the next one
    container.addChild(labels[i]);
    var dims = labels[i].getDimensions();
    
    // Add a buffer to make the objects easier to interact with on touch devices
    if(DvtAgent.isTouchDevice()) {
      var rect = new DvtRect(container.getCtx(), -DvtBreadcrumbsRenderer._TOUCH_BUFFER, -DvtBreadcrumbsRenderer._TOUCH_BUFFER, 
                             dims.w + 2*DvtBreadcrumbsRenderer._TOUCH_BUFFER, dims.h + 2*DvtBreadcrumbsRenderer._TOUCH_BUFFER);
      rect.setInvisibleFill();
      labels[i].addChild(rect);
      if(i < peers.length) 
        eventManager.associate(rect, peers[i]);
    }
    
    // Truncate if needed
    if(x - dims.w < 0) {
      var labelString = DvtBreadcrumbsRenderer._getLabelTextString(labels[i]);
      DvtBreadcrumbsRenderer._truncateLabels(labels[i], x);
      labels[i].setTranslateX(0);
      
      // Add a tooltip
      if(i < peers.length) 
        peers[i].setTooltip(labelString);
      else 
        eventManager.associate(labels[i], new DvtSimpleObjPeer(labelString));
      
      // No more space, all done
      return;
    }
    else {
      // Position and update the x
      labels[i].setTranslateX(x - dims.w);
      x -= (dims.w + options.__labelGap);
    }
    
    // Add a separator if there are more labels
    if(i < labels.length - 1) {
      var separator = DvtBreadcrumbsRenderer._newSeparator(breadcrumbs);
      container.addChild(separator);
      
      // Check that there is enough space
      var separatorWidth = separator.getDimensions().w;
      if(x - separatorWidth < 0) {
        container.removeChild(separator);
        return;
      }
      else {
        // Enough space, position 
        separator.setTranslateX(x - separatorWidth);
        x -= separatorWidth + options.__labelGap;
      }
    }
  }
}

/**
 * Creates and returns a new separator for breadcrumb labels.
 * @param {DvtContext} context
 * @param {DvtBreadcrumbs} breadcrumbs The breadcrumbs being rendered.
 * @return {DvtText}
 * @private
 */
DvtBreadcrumbsRenderer._newSeparator = function(breadcrumbs) {
  var options = breadcrumbs.__getOptions();
  var label = new DvtOutputText(breadcrumbs.getCtx(), options.__labelSeparator, 0, 0);
  label.setCSSStyle(new DvtCSSStyle(options.labelStyle));
  return label;
}
/**
 * @constructor
 */
var DvtPanelDrawerEvent = function (subtype, activePanel) {
    this.Init(DvtPanelDrawerEvent.TYPE);
    this._subtype = subtype;
    this._activePanel = activePanel;
}

DvtObj.createSubclass(DvtPanelDrawerEvent, DvtBaseComponentEvent, "DvtPanelDrawerEvent");

DvtPanelDrawerEvent.TYPE = "dvtPanelDrawerEvent";
DvtPanelDrawerEvent.SUBTYPE_HIDE = "hide";
DvtPanelDrawerEvent.SUBTYPE_SHOW = "show";

DvtPanelDrawerEvent.prototype.getSubType = function() {
  return this._subtype;
}

/**
 * @return {string} The id of the active panel
 */
DvtPanelDrawerEvent.prototype.getActivePanel = function () {
  return this._activePanel;
}
// Copyright (c) 2012, 2014, Oracle and/or its affiliates. All rights reserved.
/**
 * @constructor
 */
var DvtPanelDrawer = function(context, callback, callbackObj, sid) {
  this.Init(context, callback, callbackObj, sid);
};

DvtObj.createSubclass(DvtPanelDrawer, DvtContainer, "DvtPanelDrawer");

DvtPanelDrawer.DIR_LEFT = "left";
DvtPanelDrawer.DIR_RIGHT = "right";

DvtPanelDrawer.DOCK_TOP = "top";
DvtPanelDrawer.DOCK_BOTTOM = "bottom";

//DvtPanelDrawer styles
/**
 * Vertical space for the first tab
 * @const
 */
DvtPanelDrawer._FIRST_TAB_SPACING = 15;
/**
 * Vertical space for between tabs
 * @const
 */
DvtPanelDrawer._INTER_TAB_SPACING = 0;
/**
 * Tab size vertical and horizontal
 * @const
 */
DvtPanelDrawer._TAB_SIZE = 42;
/**
 * Tab corner radius
 * @const
 */
DvtPanelDrawer._TAB_CORNER_RADIUS = 2;
/**
 * Tab default background color
 * @const
 */
DvtPanelDrawer._BACKGROUND_COLOR = "#ffffff";
/**
 * Tab default border color
 * @const
 */
DvtPanelDrawer._BORDER_COLOR = "#bbc7d0";
/**
 * Tab default animation duration
 * @const
 */
DvtPanelDrawer._ANIM_DURATION = .25;
/**
 * Content padding
 * @const
 */
DvtPanelDrawer._CONTENT_PADDING = 10;
/**
 * Scrollbar content padding
 * @const
 */
DvtPanelDrawer._SCROLLBAR_CONTENT_PADDING = 10;

DvtPanelDrawer._BACKGROUND_ALPHA = 1;
DvtPanelDrawer._BACKGROUND_ALPHA_DE_EMPHASIZED = 1;
DvtPanelDrawer._BACKGROUND_ALPHA_ROLLOVER = 1;

DvtPanelDrawer._BORDER_ALPHA = 1;
DvtPanelDrawer._BORDER_ALPHA_DE_EMPHASIZED = 1;

DvtPanelDrawer._TAB_BACKGROUND_COLOR_INACTIVE = "#dee4e7";
DvtPanelDrawer._TAB_BORDER_COLOR_INACTIVE = "#c1cede";

//factor to use for increasing width of content so that bounce animation
//doesn't appear to detach panelDrawer from edge of component
DvtPanelDrawer._BOUNCE_WIDTH_FACTOR = 1.25;
DvtPanelDrawer._DEFAULT_SKIN = "alta";

/**
 * The DvtPanelDrawer tab's image size
 * @const
 */
DvtPanelDrawer.IMAGE_SIZE = 24;
/**
 * The DvtPanelDrawer legend key
 * @const
 */
DvtPanelDrawer.PANEL_LEGEND = "legend";
/**
 * The DvtPanelDrawer palette key
 * @const
 */
DvtPanelDrawer.PANEL_PALETTE = "palette";
/**
 * The DvtPanelDrawer search key
 * @const
 */
DvtPanelDrawer.PANEL_SEARCH = "search";
/**
 * The DvtPanelDrawer overview key
 * @const
 */
DvtPanelDrawer.PANEL_OVERVIEW = "overview";
/**
 * The DvtPanelDrawer enabled search icon key
 * @const
 */
DvtPanelDrawer.PANEL_SEARCH_ICON_ENA = "searchEna";
/**
 * The DvtPanelDrawer hover search icon key
 * @const
 */
DvtPanelDrawer.PANEL_SEARCH_ICON_OVR = "searchOvr";
/**
 * The DvtPanelDrawer active search icon key
 * @const
 */
DvtPanelDrawer.PANEL_SEARCH_ICON_DWN = "searchDwn";
/**
 * The DvtPanelDrawer serach tooltip key
 * @const
 */
DvtPanelDrawer.PANEL_SEARCH_TIP = "searchTip";
/**
 * The DvtPanelDrawer enabled palette icon key
 * @const
 */
DvtPanelDrawer.PANEL_PALETTE_ICON_ENA = "paletteEna";
/**
 * The DvtPanelDrawer hover palette icon key
 * @const
 */
DvtPanelDrawer.PANEL_PALETTE_ICON_OVR = "paletteOvr";
/**
 * The DvtPanelDrawer active palette icon key
 * @const
 */
DvtPanelDrawer.PANEL_PALETTE_ICON_DWN = "paletteDwn";
/**
 * The DvtPanelDrawer palette tooltip key
 * @const
 */
DvtPanelDrawer.PANEL_PALETTE_TIP = "paletteTip";
/**
 * The DvtPanelDrawer enabled legend icon key
 * @const
 */
DvtPanelDrawer.PANEL_LEGEND_ICON_ENA = "legendEna";
/**
 * The DvtPanelDrawer hover legend icon key
 * @const
 */
DvtPanelDrawer.PANEL_LEGEND_ICON_OVR = "legendOvr";
/**
 * The DvtPanelDrawer active legend icon key
 * @const
 */
DvtPanelDrawer.PANEL_LEGEND_ICON_DWN = "legendDwn";
/**
 * The DvtPanelDrawer legend tooltip key
 * @const
 */
DvtPanelDrawer.PANEL_LEGEND_TIP = "legendTip";
/**
 * The DvtPanelDrawer enabled overview icon key
 * @const
 */
DvtPanelDrawer.PANEL_OVERVIEW_ICON_ENA = "overviewEna";
/**
 * The DvtPanelDrawer hover overview icon key
 * @const
 */
DvtPanelDrawer.PANEL_OVERVIEW_ICON_OVR = "overviewOvr";
/**
 * The DvtPanelDrawer active overview icon key
 * @const
 */
DvtPanelDrawer.PANEL_OVERVIEW_ICON_DWN = "overviewDwn";
/**
 * The DvtPanelDrawer overview tooltip key
 * @const
 */
DvtPanelDrawer.PANEL_OVERVIEW_TIP = "overviewTip";


// TODO: refactor these so they're not duplicated across the subcomponent and panzoomcanvas features
/**
 * @const
 */
DvtPanelDrawer.BG_ALPHA = "backgroundAlpha"; // DvtPanZoomControlPanel.BG_ALPHA
/**
 * @const
 */
DvtPanelDrawer.TAB_BG_COLOR_INACTIVE = "tab-color-inactive"; // DvtAbstractComponent.TAB_BG_COLOR_INACTIVE
/**
 * @const
 */
DvtPanelDrawer.TAB_BORDER_COLOR_INACTIVE = "tab-border-color-inactive"; // DvtAbstractComponent.TAB_BORDER_COLOR_INACTIVE

//TO DO: fire state changes to callback

/**
 * A helper method called by the constructor to initialize this component
 * @param {DvtContext} context An object maintaining application specific context, as well as well as providing 
 *                             access to platform specific data and objects, such as the factory
 * @param {function} callback The function to call for communicating with the parent object
 * @param {DvtObj} callbackObj The object to call the callback function on
 * @param {String} sid The id for this component
 * @protected
 */
DvtPanelDrawer.prototype.Init = function(context, callback, callbackObj, sid) {
  DvtPanelDrawer.superclass.Init.call(this, context, null, "panelDrawer" + sid);

  this._sid = sid;
  this._eventManager = new DvtPanelDrawerEventManager(context, callback, callbackObj);
  this._eventManager.addListeners(this);
  this._eventManager.addRolloverType(DvtPanelDrawer);
  this._eventManager.associate(this, this);
  this._callback = callback;
  this._callbackObj = callbackObj;
  
  this._panels = {};
  this._panelOrder = [];
  this._maxWidth = Number.MAX_VALUE;
  this._maxHeight = Number.MAX_VALUE;
  this._minWidth = 5;
  this._minHeight = 0;
  this._displayedPanelId;
  this._oldDisplayedPanelId;
  this._bDisclosed = false;
  this._bTransition = false;
  this._contentPane;
  this._activeContent;
  this._expandedContent;
  this._expandedContentPanel;
  this._contentClipPath;
  this._expandedBorder;
  this._expandedBorderResizable;
  this._tabs = {};
  this._discloseDirection = DvtPanelDrawer.DIR_LEFT;
  this._dockSide = DvtPanelDrawer.DOCK_TOP;
  this._isFixed = false;
  
  this._styleMap = null;
  if (callbackObj)
    this._styleMap = callbackObj.getControlPanelStyleMap();  
  
  this._bgAlpha = DvtStyleUtils.getStyle(this._styleMap, DvtPanelDrawer.BG_ALPHA, DvtPanelDrawer._BACKGROUND_ALPHA);
  this._borderColor = DvtStyleUtils.getStyle(this._styleMap, DvtCSSStyle.BORDER_COLOR, DvtPanelDrawer._BORDER_COLOR);
  this._borderRadius = parseInt(DvtStyleUtils.getStyle(this._styleMap, DvtCSSStyle.BORDER_RADIUS, DvtPanelDrawer._TAB_CORNER_RADIUS));
  this._bgColor = DvtStyleUtils.getStyle(this._styleMap, DvtCSSStyle.BACKGROUND_COLOR, DvtPanelDrawer._BACKGROUND_COLOR);

  this._bgInactiveColor = DvtStyleUtils.getStyle(this._styleMap, DvtPanelDrawer.TAB_BG_COLOR_INACTIVE, DvtPanelDrawer._TAB_BACKGROUND_COLOR_INACTIVE);
  this._borderInactiveColor = DvtStyleUtils.getStyle(this._styleMap, DvtPanelDrawer.TAB_BORDER_COLOR_INACTIVE, DvtPanelDrawer._TAB_BORDER_COLOR_INACTIVE);
    
  //in webkit, the clipping path doesn't always appear to take effect,
  //especially during animation, and in Firefox it seems to show the whole 
  //component for a moment before taking effect sometimes
  //NOTE: don't defer, because we workaround the problem by toggling
  //between two different clipPath ids instead of always resetting the
  //same one
  this._bDeferPanelVisibility = false;
  
  this._scrollEnabled = true;
};

DvtPanelDrawer.prototype.addPanel = function(panel, upState, overState, downState, tooltip, id) {
  this._panels[id] = {'panel':panel, 'iconUp':upState, 'iconOver':overState, 'iconDown':downState, 'tooltip':tooltip};
  this._panelOrder.push(id);
  
  this._minHeight = DvtPanelDrawer._FIRST_TAB_SPACING + this._panelOrder.length * (DvtPanelDrawer._TAB_SIZE + DvtPanelDrawer._INTER_TAB_SPACING);
};

/**
 * Returns whether this panel drawer is fixed or collapsible
 * @return {boolean} 
 */
DvtPanelDrawer.prototype.isFixed = function() {
  return this._isFixed;
};

/**
 * Sets whether this panel drawer is fixed or collapsible
 * @param {boolean} bFixed Whether the DvtPanelDrawer is fixed
 */
DvtPanelDrawer.prototype.setFixed = function(bFixed) {
  this._isFixed = bFixed;
};

DvtPanelDrawer.prototype.setMaxWidth = function(width) {
  this._maxWidth = width;
};

DvtPanelDrawer.prototype.getMaxWidth = function() {
  return this._maxWidth;
};

DvtPanelDrawer.prototype.getMaxContentWidth = function() {
  return this._maxWidth - (2*DvtPanelDrawer._CONTENT_PADDING + DvtScrollableContainer.DEFAULT_ALTA_SCROLLBAR_WIDTH + DvtPanelDrawer._SCROLLBAR_CONTENT_PADDING);
};

DvtPanelDrawer.prototype.setMaxHeight = function(height) {
  this._maxHeight = height;
};

DvtPanelDrawer.prototype.getMaxHeight = function() {
  return this._maxHeight;
};

DvtPanelDrawer.prototype.getMaxContentHeight = function() {
  return this._maxHeight - (2*DvtPanelDrawer._CONTENT_PADDING + DvtScrollableContainer.DEFAULT_ALTA_SCROLLBAR_WIDTH + DvtPanelDrawer._SCROLLBAR_CONTENT_PADDING);
};

DvtPanelDrawer.prototype.setDiscloseDirection = function(dir) {
  this._discloseDirection = dir;
};

DvtPanelDrawer.prototype.getDiscloseDirection = function() {
  return this._discloseDirection;
};

DvtPanelDrawer.prototype.setDockSide = function(dockSide) {
  this._dockSide = dockSide;
};

DvtPanelDrawer.prototype.getDockSide = function() {
  return this._dockSide;
};

DvtPanelDrawer.prototype.GetPanel = function(id) {
  return this._panels[id]['panel'];
};

DvtPanelDrawer.prototype.GetIcon = function(id) {
  return this._panels[id]['icon'];
};

DvtPanelDrawer.prototype.GetTooltip = function(id) {
  return this._panels[id]['tooltip'];
};

DvtPanelDrawer.prototype.GetTab = function(id) {
  return this._tabs[id];
};

/**
 * Sets the id of an active panel
 * @param {string} id Active panel id
 * @param {boolean} bImmediate True to change panels state immediately (no animation)
 * @param {function} onEnd A function to call at the end of animation
 */
DvtPanelDrawer.prototype.setDisplayedPanelId = function(id, bImmediate, onEnd) {
  this._oldDisplayedPanelId = this._displayedPanelId;
  this._displayedPanelId = id;
  if (this.isDisclosed()) {
    this.ChangeTabsState();
    this.ChangePanels(id, bImmediate, onEnd);
  }
  this._oldDisplayedPanelId = null;
};

DvtPanelDrawer.prototype.getDisplayedPanelId = function() {
  var panelId = this._displayedPanelId;
  if (!panelId && this._panelOrder.length > 0) {
    return this._panelOrder[0];
  }
  return panelId;
};

/**
 * Either expands or collapses the PanelDrawer
 * 
 * @param {boolean} bDisclosed Determines action of PanelDrawer (true => expand, false => collapse)
 * @param {boolean} bImmediate Determines whether or not to animate (true => no animation, false => animation)
 * @param {function} onEnd Function to be called following animation
 */
DvtPanelDrawer.prototype.setDisclosed = function(bDisclosed, bImmediate, onEnd) {
  // skip if already transitioning
  if (!this._bTransition) {
    this._bTransition = true;
    var oldDisclosed = this._bDisclosed;
    this._bDisclosed = bDisclosed;
    if (oldDisclosed != bDisclosed) {
      if (bDisclosed) {
        this.DoExpand(bImmediate, onEnd);
      }
      else {
        this.DoCollapse(bImmediate, onEnd);
      }
    }
  }
};

DvtPanelDrawer.prototype.isDisclosed = function() {
  return this._bDisclosed;
};

/**
 * Renders this panel drawer
 */
DvtPanelDrawer.prototype.renderComponent = function() {
  if (!this._contentPane) {
    this._contentPane = new DvtContainer(this.getCtx(), "pd_contentPane");
    this.addChild(this._contentPane);
    this._activeContent = new DvtContainer(this.getCtx(), "pdcp_activeContent");
    this._contentPane.addChild(this._activeContent);
  }
  this.RenderTabs();  
};

/**
 * Draws the tabs for each panel in The DvtPanelDrawer in the non disclosed state. 
 * No tabs are drawn if the DvtPanelDrawer has fixed state and is in non disclosed state.
 * @protected
 */
DvtPanelDrawer.prototype.RenderTabs = function() {
  if (!this.isFixed()) {
    var currX = -DvtPanelDrawer._TAB_SIZE;
    if (this.getDiscloseDirection() == DvtPanelDrawer.DIR_RIGHT) {
      currX = 0;
    }
    var currY = DvtPanelDrawer._FIRST_TAB_SPACING;
    if (this.getDockSide() == DvtPanelDrawer.DOCK_TOP) {
      for (var i = 0; i < this._panelOrder.length; i++) {
        var panelId = this._panelOrder[i];
        var tab = this.RenderTab(panelId);
        tab.setTranslate(currX, currY);
          currY += (DvtPanelDrawer._TAB_SIZE + DvtPanelDrawer._INTER_TAB_SPACING);
      }
    }
    else if (this.getDockSide() == DvtPanelDrawer.DOCK_BOTTOM) {
      currY = -DvtPanelDrawer._FIRST_TAB_SPACING - DvtPanelDrawer._TAB_SIZE;
      for (var i = this._panelOrder.length - 1; i >= 0; i--) {
        var panelId = this._panelOrder[i];
        var tab = this.RenderTab(panelId);
        tab.setTranslate(currX, currY);
        currY -= (DvtPanelDrawer._TAB_SIZE + DvtPanelDrawer._INTER_TAB_SPACING);
      }
    }
  }
};

DvtPanelDrawer.prototype.GetTabPathCommands = function() {
  var arPoints;
  switch (this.getDiscloseDirection()) {
    case DvtPanelDrawer.DIR_RIGHT:
      arPoints = ["M", 0, 0, 
                  "L", DvtPanelDrawer._TAB_SIZE - this._borderRadius, 0, 
                  "A", this._borderRadius, this._borderRadius, 0, 0, 1, DvtPanelDrawer._TAB_SIZE, this._borderRadius,
                  "L", DvtPanelDrawer._TAB_SIZE, DvtPanelDrawer._TAB_SIZE - this._borderRadius, 
                  "A", this._borderRadius, this._borderRadius, 0, 0, 1, DvtPanelDrawer._TAB_SIZE - this._borderRadius, DvtPanelDrawer._TAB_SIZE,
                  "L", 0, DvtPanelDrawer._TAB_SIZE];
      break;
    case DvtPanelDrawer.DIR_LEFT:
    default:
      arPoints = ["M", DvtPanelDrawer._TAB_SIZE, 0, 
                  "L", this._borderRadius, 0, 
                  "A", this._borderRadius, this._borderRadius, 0, 0, 0, 0, this._borderRadius,
                  "L", 0, DvtPanelDrawer._TAB_SIZE - this._borderRadius, 
                  "A", this._borderRadius, this._borderRadius, 0, 0, 0, this._borderRadius, DvtPanelDrawer._TAB_SIZE,
                  "L", DvtPanelDrawer._TAB_SIZE, DvtPanelDrawer._TAB_SIZE];
      break;
  }
  return arPoints;
};

/**
 * Renders panel drawer tab
 * @param {string} panelId Id of the rendered tab
 * @protected
 */
DvtPanelDrawer.prototype.RenderTab = function(panelId) {
  var arPoints = this.GetTabPathCommands();
  var closedPath = arPoints;
  var strokeWidth = 1;
  
  var tab = new DvtPath(this.getCtx(), closedPath, "pdcp_tab_" + panelId);
  tab.setPixelHinting(true);
  tab.setCursor(DvtSelectionEffectUtils.getSelectingCursor());
  this._contentPane.addChildAt(tab, 0);
  tab.setSolidFill(this._bgInactiveColor, this._bgAlpha);
  tab.setSolidStroke(this._borderInactiveColor, DvtPanelDrawer._BORDER_ALPHA, strokeWidth);
  
  var panelObj = this._panels[panelId];
  
  var upState = new DvtPath(this.getCtx(), closedPath);
  upState.setInvisibleFill();
  //temporarily add icon to tab to get dimensions
  tab.addChild(panelObj['iconUp']);
  var iconDims = panelObj['iconUp'].getDimensions();
  panelObj['iconUp'].setTranslate(.5 * (DvtPanelDrawer._TAB_SIZE - (iconDims.x + iconDims.w)), .5 * (DvtPanelDrawer._TAB_SIZE - (iconDims.y + iconDims.h)));
  upState.addChild(panelObj['iconUp']);
  var overState = new DvtPath(this.getCtx(), closedPath);
  overState.setInvisibleFill();
  //temporarily add icon to tab to get dimensions
  tab.addChild(panelObj['iconOver']);
  iconDims = panelObj['iconOver'].getDimensions();
  panelObj['iconOver'].setTranslate(.5 * (DvtPanelDrawer._TAB_SIZE - (iconDims.x + iconDims.w)), .5 * (DvtPanelDrawer._TAB_SIZE - (iconDims.y + iconDims.h)));
  overState.addChild(panelObj['iconOver']);
  var downState = new DvtPath(this.getCtx(), closedPath);
  downState.setInvisibleFill();
  //temporarily add icon to tab to get dimensions
  tab.addChild(panelObj['iconDown']);
  iconDims = panelObj['iconDown'].getDimensions();
  panelObj['iconDown'].setTranslate(.5 * (DvtPanelDrawer._TAB_SIZE - (iconDims.x + iconDims.w)), .5 * (DvtPanelDrawer._TAB_SIZE - (iconDims.y + iconDims.h)));
  downState.addChild(panelObj['iconDown']);
  
  var icon = new DvtButton(this.getCtx(), upState, overState, downState);
  icon.setToggleEnabled(true);
  icon.setCursor(DvtSelectionEffectUtils.getSelectingCursor());
  panelObj['icon'] = icon;
  
  tab.addChild(icon);
  iconDims = icon.getDimensions();
  icon.setTranslate(.5 * (DvtPanelDrawer._TAB_SIZE - (iconDims.x + iconDims.w)), .5 * (DvtPanelDrawer._TAB_SIZE - (iconDims.y + iconDims.h)));
  
  this._tabs[panelId] = tab;
  
  var thisRef = this;
  var proxy = {};
  proxy.HandleClick = function(event) {
    thisRef.HandleTabClick(panelId);
  };
  proxy.getTooltip = function() {
    return thisRef.GetTooltip(panelId);
  };
  this._eventManager.associate(tab, proxy);

  this.addAccessibilityAttributes(tab, this.GetTooltip(panelId));
  return tab;
};

/**
 * Tab click handler
 * @param {string} panelId Id of the clicked panel
 * @protected
 */
DvtPanelDrawer.prototype.HandleTabClick = function(panelId) {
  this._oldDisplayedPanelId = this.getDisplayedPanelId();
  this._displayedPanelId = panelId;

  var thisRef = this;
  var hideTooltipFunc = function() {
    var tooltipManager = thisRef.getCtx().getTooltipManager();
    if (tooltipManager) {
      tooltipManager.hideTooltip();
    }
  }
  //drawer is collapsed
  if (!this.isDisclosed()) {
    this.setDisclosed(true, false, hideTooltipFunc);
    this.ApplyAlphasRollover();
  }
  //drawer is expanded, but need to collapse
  else if (this._oldDisplayedPanelId == panelId) {
    this.setDisclosed(false, false, hideTooltipFunc);
  }
  //drawer is expanded, but need to change panels
  else {
    this.ChangeTabsState();
    this.ChangePanels(panelId, false);
  }
  this._oldDisplayedPanelId = null;
  
  this.FireListener(new DvtPanelDrawerEvent(this.isDisclosed() ? DvtPanelDrawerEvent.SUBTYPE_SHOW : DvtPanelDrawerEvent.SUBTYPE_HIDE,
                                            this._displayedPanelId));
};

DvtPanelDrawer.prototype.ChangePanels = function(panelId, bImmediate, onEnd) {
  var anim = null;
  if (!bImmediate) {
    anim = new DvtAnimator(this.getCtx(), DvtPanelDrawer._ANIM_DURATION);
  }
  if (this._oldDisplayedPanelId) {
    var oldPanel = this.GetPanel(this._oldDisplayedPanelId);
    if (oldPanel) {
      this._expandedContentPanel.removeChild(oldPanel);
    }
  }
  this.DisplayPanel(panelId, anim);
  if (anim) {
    this.ApplyAlphasRollover();
    if (onEnd) {
      DvtPlayable.appendOnEnd(anim, onEnd);
    }
    anim.play();
  }
  else if (onEnd) {
    onEnd();
  }
};

/**
 * Expands panel drawer active tab.
 * @param {boolean} bImmediate Immediate expand, does not use animation
 * @param {function} onEnd A function to call at the end of animation
 * @protected
 */
DvtPanelDrawer.prototype.DoExpand = function(bImmediate, onEnd) {
  //if deferring panel display, initially hide the panel
  var panel = this.GetPanel(this.getDisplayedPanelId());
  if (panel && this._bDeferPanelVisibility) {
    panel.setVisible(false);
  }
  
  this.DisplayPanel(this.getDisplayedPanelId());
  //width has been increased to account for bounce animation, so calculate original width
  var destX = -((1 / DvtPanelDrawer._BOUNCE_WIDTH_FACTOR) * this._expandedContent.getWidth());
  if (this.getDiscloseDirection() == DvtPanelDrawer.DIR_RIGHT) {
    destX = -destX;
    //since we're increasing width, need to offset x by amount of padding when panelDrawer is
    //on left edge of component
    this._expandedContent.setX(((1 / DvtPanelDrawer._BOUNCE_WIDTH_FACTOR) - 1) * this._expandedContent.getWidth());
  }
  
  if (!bImmediate) {
    var anim = new DvtAnimator(this.getCtx(), DvtPanelDrawer._ANIM_DURATION);
    //bounce anim at end
    anim.setEasing(DvtEasing.backOut);
    anim.addProp(DvtAnimator.TYPE_NUMBER, this._contentPane, this._contentPane.getTranslateX, this._contentPane.setTranslateX, destX);
    
    //if deferring panel display, make the panel visible at the end
    if (panel && this._bDeferPanelVisibility) {
      var func = function() {
        panel.setVisible(true);
        if (onEnd) {
          onEnd();
        }
      };
      DvtPlayable.appendOnEnd(anim, func);
    }
    else if (onEnd) {
      DvtPlayable.appendOnEnd(anim, onEnd);      
    }
    
    if (anim) {
      var thisRef = this;
      DvtPlayable.appendOnEnd(anim, function() { thisRef._bTransition = false; });
      anim.play();
    }
  }
  else {
    this._contentPane.setTranslateX(destX);
    //if deferring panel display, make the panel visible
    if (panel && this._bDeferPanelVisibility) {
      panel.setVisible(true);
    }
    if (onEnd) {
      onEnd();
    }
    this._bTransition = false;
  }
  this.ChangeTabsState();
};

/**
 * Collapses panel drawer.
 * @param {boolean} bImmediate True for immediate collapse (no animation)
 * @param {function} onEnd A function to call at the end of animation
 * @protected
 */
DvtPanelDrawer.prototype.DoCollapse = function(bImmediate, onEnd) {
  if (!bImmediate) {
    var anim = new DvtAnimator(this.getCtx(), DvtPanelDrawer._ANIM_DURATION);
    //bounce anim at beginning
    anim.setEasing(DvtEasing.backIn);
    anim.addProp(DvtAnimator.TYPE_NUMBER, this._contentPane, this._contentPane.getTranslateX, this._contentPane.setTranslateX, 0);
    DvtPlayable.appendOnEnd(anim, this.RemoveExpandedContent, this);
    DvtPlayable.appendOnEnd(anim, this.ChangeTabsState, this);
    if (onEnd) {
      DvtPlayable.appendOnEnd(anim, onEnd);
    }
    var thisRef = this;
    DvtPlayable.appendOnEnd(anim, function() { thisRef._bTransition = false; });
    anim.play();
  }
  else {
    this._contentPane.setTranslateX(0);
    this.RemoveExpandedContent();
    if (onEnd) {
      onEnd();
    }
    this.ChangeTabsState();
    this._bTransition = false;
  }
  
};

/**
 * Removes the expanded content from this panel drawer
 */
DvtPanelDrawer.prototype.RemoveExpandedContent = function() {
  if (this._expandedContent) {
    //can't set clipPath to null because error is thrown
    //clear clip path first
    //this._setContentClipPath(null);
    this._contentClipPath = null;
    
    // do not destroy the panels themselves so remove them before destroying their container
    this._expandedContentPanel.removeChildren();
    this._activeContent.removeAllDrawEffects();
    this._expandedContent.destroy();
    this._activeContent.removeChild(this._expandedContent);
    this._expandedContent = null;
    this._expandedContentPanel = null;
    this._expandedBorder = null;
    this._expandedBorderResizable = null;
  }
};

/**
 * Displays the specified panel in this panel drawer
 * @param {string} id the id of the panel to display
 * @param {DvtAnimator} anim the animator used to display the transition animation, optional
 * @param {function} onEnd the function to be called after the panel has been displayed, optional
 */
DvtPanelDrawer.prototype.DisplayPanel = function(id, anim, onEnd) {
  if (!this._expandedContent) {
    this._expandedContent = new DvtRect(this.getCtx(), 0, 0, 1, 1, "pdcp_expandedContent");
    this._activeContent.addChild(this._expandedContent);
    this._expandedContent.setSolidFill(this._bgColor, this._bgAlpha);
    
    var maxWidth = (this._maxWidth == Number.MAX_VALUE) ? null : this._maxWidth - 2*DvtPanelDrawer._CONTENT_PADDING;
    var maxHeight = (this._maxHeight == Number.MAX_VALUE) ? null : this._maxHeight - 2*DvtPanelDrawer._CONTENT_PADDING;
    this._expandedContentPanel = new DvtScrollableContainer(this._context, 0, 0, maxWidth, maxHeight, 
                                                            DvtPanelDrawer._SCROLLBAR_CONTENT_PADDING,
                                                            "pdcp_expandedContentPanel" + this._sid);
    if (!this._scrollEnabled) {
      this._expandedContentPanel.setHorizontalScrollingEnabled(false);
      this._expandedContentPanel.setVerticalScrollingEnabled(false);
    }
      
    this._expandedContentPanel.setSkinName(DvtPanelDrawer._DEFAULT_SKIN);
    this._expandedContentPanel.setStyleMap(this._styleMap);
    this._expandedContent.addChild(this._expandedContentPanel);
    this._expandedContentPanel.setTranslate(DvtPanelDrawer._CONTENT_PADDING, DvtPanelDrawer._CONTENT_PADDING);
  }
  
  var panel = this.GetPanel(id);
  if (panel) {
    this._expandedContentPanel.addChild(panel);
    if (anim && this._bDeferPanelVisibility) {
      panel.setVisible(false);
      var thisRef = this;
      var func = function() {
        panel.setVisible(true);
      };
      DvtPlayable.appendOnEnd(anim, func);
    }
    
    //remove the resize listener from the old displayed panel
    if (this._oldDisplayedPanelId) {
      var oldPanel = this.GetPanel(this._oldDisplayedPanelId);
      if (oldPanel) {
        oldPanel.removeEvtListener(DvtResizeEvent.RESIZE_EVENT, this.HandlePanelResize, false, this);
      }
    }
    //add the resize listener to the new displayed panel
    panel.addEvtListener(DvtResizeEvent.RESIZE_EVENT, this.HandlePanelResize, false, this);
  }
  
  if (!this._expandedBorder) {
    this._expandedBorder = new DvtPath(this.getCtx(), ["M", 0, 0, "L", 1, 1], "pdcp_expandedBorder");
    this._expandedBorderResizable = new DvtPath(this.getCtx(), ["M", 0, 0, "L", 1, 1], "pdcp_expandedBorderResizable");
    this._expandedContent.addChild(this._expandedBorder);
    this._expandedContent.addChild(this._expandedBorderResizable);
    this._expandedBorder.setSolidStroke(this._borderColor, DvtPanelDrawer._BORDER_ALPHA);
    this._expandedBorder.setFill(null);
    this._expandedBorderResizable.setSolidStroke(this._borderColor, DvtPanelDrawer._BORDER_ALPHA);    
    this._expandedBorderResizable.setFill(null);
    this._expandedBorder.setPixelHinting(true);
    this._expandedBorderResizable.setPixelHinting(true);
  }
  
  this.RefreshExpandedSize(id, anim);
  
  if (onEnd) {
    if (anim) {
      DvtPlayable.appendOnEnd(anim, onEnd);
    }
    else {
      onEnd();
    }
  }
};

DvtPanelDrawer.prototype.HandlePanelResize = function(event) {
  var anim = new DvtAnimator(this.getCtx(), DvtPanelDrawer._ANIM_DURATION);
  this._expandedContentPanel.refresh();
  var resizeWidth = event.getWidth();
  var resizeHeight = event.getHeight();
  var sbPadding = this._expandedContentPanel.getScrollbarWidth() + DvtPanelDrawer._SCROLLBAR_CONTENT_PADDING;
  if (this._expandedContentPanel.hasHorizontalScrollbar())
    resizeHeight += sbPadding;
  if (this._expandedContentPanel.hasVerticalScrollbar())
    resizeWidth += sbPadding;
  var ecw = this.GetExpandedContentWidth(resizeWidth);
  var ech = this.GetExpandedContentHeight(resizeHeight);
  var xx = event.getX() ? event.getX() : 0;
  var yy = event.getY() ? event.getY() : 0;
  this._refreshPanelSize(this.getDisplayedPanelId(), anim, ecw, ech, xx, yy);
  anim.play();
};

DvtPanelDrawer.prototype.RefreshExpandedSize = function(id, anim) {
  var panel = this.GetPanel(id);
  
  var ecw = 2 * DvtPanelDrawer._CONTENT_PADDING;
  var ech = 2 * DvtPanelDrawer._CONTENT_PADDING;
  var xx = 0;
  var yy = 0;
  if (panel) {
    var dims = this._expandedContentPanel.getDimensions();
    ecw = this.GetExpandedContentWidth(dims.w);
    ech = this.GetExpandedContentHeight(dims.h);
    xx = dims.x;
    yy = dims.y;
  }
  this._refreshPanelSize(id, anim, ecw, ech, xx, yy);
};

/**
 * Update a panel's size based on the given parameters
 * @param {String} id The id for the panel to update
 * @param {DvtAnimator} anim The animator to use for the size update
 * @param {Number} ecw The content width
 * @param {Number} ech The content height
 * @param {Number} xx The content x coordinate
 * @param {Number} yy  The content y coordinate
 * @private
 */
DvtPanelDrawer.prototype._refreshPanelSize = function(id, anim, ecw, ech, xx, yy) {
  var panel = this.GetPanel(id);
  
  //if base panel is not positioned at origin, adjust it
//  if (xx != 0) {
    if (anim) {
      anim.addProp(DvtAnimator.TYPE_NUMBER, panel, panel.getTranslateX, panel.setTranslateX, -xx);
    }
    else {
      panel.setTranslateX(-xx);
    }
//  }
//  if (yy != 0) {
    if (anim) {
      anim.addProp(DvtAnimator.TYPE_NUMBER, panel, panel.getTranslateY, panel.setTranslateY, -yy);
    }
    else {
      panel.setTranslateY(-yy);
    }
//  }
  
//  var currWidth = this._expandedContent.getWidth();
//  var currHeight = this._expandedContent.getHeight();
  
  var clipRect = new DvtRectangle(DvtPanelDrawer._CONTENT_PADDING, DvtPanelDrawer._CONTENT_PADDING, 
                                  ecw-2*DvtPanelDrawer._CONTENT_PADDING, ech-2*DvtPanelDrawer._CONTENT_PADDING);
  
  //increase width so that bounce animation doesn't detach panelDRrawer from edge of component
  var expandedContentWidth = DvtPanelDrawer._BOUNCE_WIDTH_FACTOR * ecw;
  if (anim) {
    anim.addProp(DvtAnimator.TYPE_NUMBER, this._expandedContent, this._expandedContent.getWidth, this._expandedContent.setWidth, expandedContentWidth);
    anim.addProp(DvtAnimator.TYPE_NUMBER, this._expandedContent, this._expandedContent.getHeight, this._expandedContent.setHeight, ech);
    
    //setting clipPath isn't working correctly; it doesn't animate
    if (this._bDeferPanelVisibility) {
      var thisRef = this;
      var func = function() {
        thisRef._setContentClipPath(clipRect);
      };
      DvtPlayable.appendOnEnd(anim, func);
    }
    else {
      anim.addProp(DvtAnimator.TYPE_RECTANGLE, this, this._getContentClipPath, this._setContentClipPath, clipRect);
    }
    
    //if we have an animation, then animate the translate change because
    //we must be changing tabs in an already-expanded drawer
    if (this.getDiscloseDirection() == DvtPanelDrawer.DIR_LEFT) {
      anim.addProp(DvtAnimator.TYPE_NUMBER, this._contentPane, this._contentPane.getTranslateX, this._contentPane.setTranslateX, -ecw);
    }
    else if (this.getDiscloseDirection() == DvtPanelDrawer.DIR_RIGHT) {
      anim.addProp(DvtAnimator.TYPE_NUMBER, this._contentPane, this._contentPane.getTranslateX, this._contentPane.setTranslateX, ecw);
      anim.addProp(DvtAnimator.TYPE_NUMBER, this._expandedBorder, this._expandedBorder.getTranslateX, this._expandedBorder.setTranslateX, ecw);
      anim.addProp(DvtAnimator.TYPE_NUMBER, this._expandedBorderResizable, this._expandedBorderResizable.getTranslateX, this._expandedBorderResizable.setTranslateX, ecw);
      
      anim.addProp(DvtAnimator.TYPE_NUMBER, this._expandedContent, this._expandedContent.getTranslateX, this._expandedContent.setTranslateX, -ecw);
    }
    if (this.getDockSide() == DvtPanelDrawer.DOCK_BOTTOM) {
      anim.addProp(DvtAnimator.TYPE_NUMBER, this._expandedBorder, this._expandedBorder.getTranslateY, this._expandedBorder.setTranslateY, ech);
      anim.addProp(DvtAnimator.TYPE_NUMBER, this._expandedBorderResizable, this._expandedBorderResizable.getTranslateY, this._expandedBorderResizable.setTranslateY, ech);
      
      anim.addProp(DvtAnimator.TYPE_NUMBER, this._expandedContent, this._expandedContent.getTranslateY, this._expandedContent.setTranslateY, -ech);
    }
  }
  else {
    this._expandedContent.setWidth(expandedContentWidth);
    this._expandedContent.setHeight(ech);
    if (this.getDiscloseDirection() == DvtPanelDrawer.DIR_RIGHT) {
      this._expandedContent.setTranslateX(-ecw);
      this._expandedBorder.setTranslateX(ecw);
      this._expandedBorderResizable.setTranslateX(ecw);
    }
    if (this.getDockSide() == DvtPanelDrawer.DOCK_BOTTOM) {
      this._expandedContent.setTranslateY(-ech);
      this._expandedBorder.setTranslateY(ech);
      this._expandedBorderResizable.setTranslateY(ech);
    }
    
    //setting clipPath isn't working correctly; it doesn't animate
    this._setContentClipPath(clipRect);
    
    //don't change the translate if we're not animating it because 
    //we must be expanding and that will be handled by the expand itself
  }
  
  var tab = this.GetTab(id);
  var borderPath;
  
  //render corner line from tab to corner, and then to edge of component
  var edgeX = ecw;
  if (this.getDiscloseDirection() == DvtPanelDrawer.DIR_RIGHT)
    edgeX = -ecw;
      
  if (this.getDockSide() == DvtPanelDrawer.DOCK_TOP) {
    if (tab) {
      //render line from top to start of first tab
      borderPath = ["M", 0, 0, "L", 0, tab.getTranslateY(), "M", 0, tab.getTranslateY() + DvtPanelDrawer._TAB_SIZE];
      //render line from bottom of tab to bottom of last tab
      var lastPanelId = this._panelOrder[this._panelOrder.length - 1];
      var lastTab = this.GetTab(lastPanelId);
      borderPath.push("L", 0, lastTab.getTranslateY() + DvtPanelDrawer._TAB_SIZE);
      this._expandedBorder.setCommands(borderPath);

      //increase width so that bounce animation doesn't detach panelDRrawer from edge of component
      edgeX *= DvtPanelDrawer._BOUNCE_WIDTH_FACTOR;
      borderPath = ["M", 0, lastTab.getTranslateY() + DvtPanelDrawer._TAB_SIZE, "L", 0, ech, "L", edgeX, ech];
    } else {
      borderPath = ["M", 0, 0, "L", 0, ech, "L", edgeX, ech];
      this._expandedBorder.setCommands(borderPath);
    }
  }
  else if (this.getDockSide() == DvtPanelDrawer.DOCK_BOTTOM) {
    if (tab) {
      //render line from bottom to bottom of tab
      borderPath = ["M", 0, 0, "L", 0, tab.getTranslateY() + DvtPanelDrawer._TAB_SIZE, "M", 0, tab.getTranslateY()];
      //render line from top of tab to top of first tab
      var firstPanelId = this._panelOrder[0];
      var firstTab = this.GetTab(firstPanelId);
      borderPath.push("L", 0, firstTab.getTranslateY());
      this._expandedBorder.setCommands(borderPath);
      
      //increase width so that bounce animation doesn't detach panelDRrawer from edge of component
      edgeX *= DvtPanelDrawer._BOUNCE_WIDTH_FACTOR;
      borderPath = ["M", 0, firstTab.getTranslateY(), "L", 0, -ech, "L", edgeX, -ech];
    } else {
      borderPath = ["M", 0, 0, "L", 0, -ech, "L", edgeX, -ech];
      this._expandedBorder.setCommands(borderPath);
    }
  }
  
  if (anim) {
    anim.addProp(DvtAnimator.TYPE_PATH, this._expandedBorderResizable, this._expandedBorderResizable.getCommands, this._expandedBorderResizable.setCommands, borderPath);
  }
  else {
    this._expandedBorderResizable.setCommands(borderPath);
  }
  
};

DvtPanelDrawer.prototype._setContentClipPath = function(rect) {
  if (this._expandedContentPanel) {
    if (rect) {
      //need to change id of clipPath in order for Chrome to update
      var clipPath = new DvtClipPath("pdcp" + this._sid);
      clipPath.addRect(rect.x, rect.y, rect.w, rect.h);
      
      this._expandedContentPanel.setClipPath(clipPath);
    }
  }
  this._contentClipPath = rect;
};

DvtPanelDrawer.prototype._getContentClipPath = function() {
  return this._contentClipPath;
};

DvtPanelDrawer.prototype.GetExpandedContentWidth = function(preferredWidth) {
  var ww = preferredWidth + 2 * DvtPanelDrawer._CONTENT_PADDING;
  if ((this._minWidth || this._minWidth == 0) && ww < this._minWidth) {
    ww = this._minWidth;
  }
  if (this._maxWidth && ww > this._maxWidth) {
    ww = this._maxWidth;
  }
  return ww;
};

DvtPanelDrawer.prototype.GetExpandedContentHeight = function(preferredHeight) {
  var hh = preferredHeight + 2 * DvtPanelDrawer._CONTENT_PADDING;
  if ((this._minHeight || this._minHeight == 0) && hh < this._minHeight) {
    hh = this._minHeight;
  }
  if (this._maxHeight && hh > this._maxHeight) {
    hh = this._maxHeight;
  }
  return hh;
};

DvtPanelDrawer.prototype.ApplyFillAlpha = function(alpha) {
  if (this._expandedContent) {
    var fill = this._expandedContent.getFill().clone();
    fill.setAlpha(alpha);
    this._expandedContent.setFill(fill);
  }
  for (var panelId in this._tabs) {
    var tab = this._tabs[panelId];
    if (tab) {
      var fill = tab.getFill().clone();
      fill.setAlpha(alpha);
      tab.setFill(fill);
    }
  }
};

DvtPanelDrawer.prototype.ApplyStrokeAlpha = function(alpha) {
  if (this._expandedBorder) {
    var stroke = this._expandedBorder.getStroke().clone();
    stroke.setAlpha(alpha);
    this._expandedBorder.setStroke(stroke);
  }
  if (this._expandedBorderResizable) {
    var stroke = this._expandedBorderResizable.getStroke().clone();
    stroke.setAlpha(alpha);
    this._expandedBorderResizable.setStroke(stroke);
  }
  for (var panelId in this._tabs) {
    var tab = this._tabs[panelId];
    if (tab) {
      var stroke = tab.getStroke().clone();
      stroke.setAlpha(alpha);
      tab.setStroke(stroke);
    }
  }
};

/**
 * De-emphasize the panel, for example while dragging other content
 * around in the window.
 */
DvtPanelDrawer.prototype.deEmphasizeStart = function() {
  //disable interaction
  this.setMouseEnabled(false);
  this.ApplyFillAlpha(DvtPanelDrawer._BACKGROUND_ALPHA_DE_EMPHASIZED);
  this.ApplyStrokeAlpha(DvtPanelDrawer._BORDER_ALPHA_DE_EMPHASIZED);
  if (this._expandedContentPanel) {
    this._expandedContentPanel.setAlpha(DvtPanelDrawer._BACKGROUND_ALPHA_DE_EMPHASIZED);
  }
  for (var panelId in this._tabs) {
    var icon = this.GetIcon(panelId);
    if (icon) {
      icon.setAlpha(DvtPanelDrawer._BACKGROUND_ALPHA_DE_EMPHASIZED);
    }
  }
};

/**
 * Stop de-emphasizing the panel.  
 */
DvtPanelDrawer.prototype.deEmphasizeEnd = function() {
  //enable interaction
  this.setMouseEnabled(true);
  
  this.ApplyFillAlpha(this._bgAlpha);
  this.ApplyStrokeAlpha(DvtPanelDrawer._BORDER_ALPHA);
  if (this._expandedContentPanel) {
    this._expandedContentPanel.setAlpha(1);
  }
  for (var panelId in this._tabs) {
    var icon = this.GetIcon(panelId);
    if (icon) {
      icon.setAlpha(1);
    }
  }
  
  //change alphas based on whether the mouse is currently over
  //the panel
  //TO DO:
  var bMouseOver = false;//this.hitTestPoint(stage.mouseX, stage.mouseY, true);
  if (bMouseOver) {
    this.HandleRollOver(null);
  }
  else {
    this.HandleRollOut(null);
  }
};

/**
 * Handle mouse roll over on the panel.
 * 
 * @param event MouseEvent
 */
DvtPanelDrawer.prototype.HandleRollOver = function(event) {
  //this.ApplyAlphasForMouse();
  this.ApplyAlphasRollover();
};

/**
 * Handle mouse roll out on the panel.
 * 
 * @param event MouseEvent
 */
DvtPanelDrawer.prototype.HandleRollOut = function(event) {
  //this.ApplyAlphasForMouse();
  if (!this._bFocus) {
    this.ApplyAlphasRollout();
  }
};

/**
 * Apply alpha values for mouse roll over.
 */
DvtPanelDrawer.prototype.ApplyAlphasRollover = function() {
  this.ApplyFillAlpha(DvtPanelDrawer._BACKGROUND_ALPHA_ROLLOVER);
};

/**
 * Apply alpha values for mouse roll out.
 */
DvtPanelDrawer.prototype.ApplyAlphasRollout = function() {
  this.ApplyFillAlpha(this._bgAlpha);
};

/**
 * Updates state for each tab in the panel drawer
 * @protected
 */
DvtPanelDrawer.prototype.ChangeTabsState = function() {

  for (var panelId in this._tabs) {
    var tab = this._tabs[panelId];
    if (tab) {
      var stroke = tab.getStroke().clone();
      if (panelId == this.getDisplayedPanelId() && this.isDisclosed()) {
        tab.setSolidFill(this._bgColor, this._bgAlpha);
        stroke.setColor(this._borderColor);
      }
      else {
        tab.setSolidFill(this._bgInactiveColor, this._bgAlpha);
        stroke.setColor(this._borderInactiveColor);
      }
      tab.setStroke(stroke);
    }
    
    //the displayed panel's icon remains highlighted
    var bActivePanel = this.isDisclosed() && panelId == this.getDisplayedPanelId();
    var icon = this.GetIcon(panelId);
    if (icon) {
      icon.setToggled(bActivePanel);
    }
    if (bActivePanel) {
      this._activeContent.addChild(tab);
    }
    else {
      this._contentPane.addChildAt(tab, 0);
    }
  }
};

DvtPanelDrawer.prototype.setScrollingEnabled = function(enabled) {
  this._scrollEnabled = enabled;
}

/**
 * Apply alphas based on whether the mouse is over the control panel.
 */
/*DvtPanelDrawer.prototype.ApplyAlphasForMouse = function() {
  //apply alphas based on whether the mouse is over the control panel
  var bMouseOver = true;//false;
  //TO DO: figure out how to hit test the mouse point
//  if (stage) {
//    bMouseOver = this.HitTestPoint(stage.mouseX, stage.mouseY, true);
//  }
  if (bMouseOver || this._bFocus) {
    this.ApplyAlphasRollover();
  }
  else {
    this.ApplyAlphasRollout();
  }
};*/

DvtPanelDrawer.prototype.addAccessibilityAttributes = function(obj, desc) {
  // WAI-ARIA
  if (obj && desc) {
      obj.setDesc(desc);
      obj.setAriaRole('img');
      obj.setAriaProperty('label', desc);
  }
}

DvtPanelDrawer.prototype.setMaxContainerHeight = function(height) {
  if (!this._maxContainerHeight || this._maxContainerHeight < height)
    this._maxContainerHeight = height;
}

DvtPanelDrawer.prototype.getMaxContainerHeight = function() {
  return this.GetExpandedContentHeight(this._maxContainerHeight);
}

/**
 * @override
 */
DvtPanelDrawer.prototype.getDimensions = function(targetCoordinateSpace) {
  var dim = DvtPanelDrawer.superclass.getDimensions.call(this, targetCoordinateSpace);
  dim.w /= DvtPanelDrawer._BOUNCE_WIDTH_FACTOR;
  return dim;
}
// Copyright (c) 2012, 2013, Oracle and/or its affiliates. 
// All rights reserved. 
/**
 * @constructor
 */
var DvtPanelDrawerEventManager = function(context, callback, callbackObj) {
  this.Init(context, callback, callbackObj);
};

DvtObj.createSubclass(DvtPanelDrawerEventManager, DvtEventManager, "DvtPanelDrawerEventManager");

/**
 * Click event handler.
 * @protected
 */
DvtPanelDrawerEventManager.prototype.OnClick = function(event) {
  var obj = this.GetLogicalObject(this.GetCurrentTargetForEvent(event));
  DvtPanelDrawerEventManager.superclass.OnClick.call(this, event);
  
  // Done if there is no object
  if (!obj) {
    return;
  }
  
  if (obj.HandleClick) {
    obj.HandleClick(event);
  }
  event.stopPropagation();
};

/**
 * Double click event handler.
 * @protected
 */
DvtPanelDrawerEventManager.prototype.OnDblClick = function(event) {
  DvtPanelDrawerEventManager.superclass.OnDblClick.call(this, event);
  var obj = this.GetLogicalObject(this.GetCurrentTargetForEvent(event));
  
  // Done if there is no object
  if (!obj) {
    return;
  }
  
  if (obj.isDoubleClickable && obj.isDoubleClickable() && obj.HandleDblClick) {
    obj.HandleDblClick(event);
  }
  event.stopPropagation();
};

/**
 * Roll Over event handler
 * @protected
 */
DvtPanelDrawerEventManager.prototype.OnRollOver = function(event) {
  DvtPanelDrawerEventManager.superclass.OnRollOver.call(this, event);
  var obj = this.GetLogicalObject(this.GetCurrentTargetForEvent(event));
  
  // Return if no object is found
  if (!obj) {
    return;
  }
  
  if(obj.HandleRollOver) {
    obj.HandleRollOver(event);
  }
};

/**
 * Roll Out event handler
 * @protected
 */
DvtPanelDrawerEventManager.prototype.OnRollOut = function(event) {
  DvtPanelDrawerEventManager.superclass.OnRollOut.call(this, event);
  var obj = this.GetLogicalObject(this.GetCurrentTargetForEvent(event));
    
  // Return if no object is found
  if (!obj) {
    return;
  }
  
  if(obj.HandleRollOut) {
    obj.HandleRollOut(event);
  }  
};

/**
 * Touch Click event handler.
 * @protected
 */
DvtPanelDrawerEventManager.prototype.OnComponentTouchClick = function(event) {
  var obj = this.GetLogicalObject(this.GetCurrentTargetForEvent(event));
  DvtPanelDrawerEventManager.superclass.OnComponentTouchClick.call(this, event);
  
  // Done if there is no object
  if (!obj) {
    return;
  }
  
  if (obj.HandleClick) {
    obj.HandleClick(event);
  }
  event.stopPropagation();  
};
/**
 *  @constructor
 *  Creates an accordion UI control
 *  @param {DvtContext} context object
 *  @param {number} w width of the viewport
 *  @param {number} h height of the viewport
 *  @param {DvtEventManager} eventManager event manager for the control
 *  @param {images} images for the control 
 *  @param {Object} styleMap for the control
 */
var DvtAccordion = function (context, w, h, eventManager, images, styleMap) {
  this.Init(context, w, h, eventManager, images, styleMap);
};

DvtObj.createSubclass(DvtAccordion, DvtContainer, "DvtAccordion");

DvtAccordion.COLLAPSE_ENA = "sectionColEna";
DvtAccordion.COLLAPSE_OVR = "sectionColOvr";
DvtAccordion.COLLAPSE_DWN = "sectionColDwn";
DvtAccordion.EXPAND_ENA = "sectionExpEna";
DvtAccordion.EXPAND_OVR = "sectionExpOvr";
DvtAccordion.EXPAND_DWN = "sectionExpDwn";


/**
 * @protected
 * Initialization method called by the constructor
 * @param {DvtContext} context object
 * @param {number} w width of the viewport
 * @param {number} h height of the viewport
 * @param {DvtEventManager} eventManager event manager for the control
 * @param {images} images for the control 
 * @param {Object} styleMap for the control
 */
DvtAccordion.prototype.Init = function (context, w, h, eventManager, images, styleMap) {
  DvtAccordion.superclass.Init.call(this, context, null, w, h); // TODO for JRAMANAT: Passing w,h height is wrong.
  this._images = images;
  var defaultStyles = new DvtAccordionDefaults();
  this._styleMap = defaultStyles.calcOptions(styleMap);
  this._sections = new Object();
  this._sectionOrder = [];
  this._ww = w;
  this._hh = h;
  this._bCollapseAll = false;
  this._bExpandMany = false;

  this._eventManager = eventManager;
  this._eventManager.addListeners(this);
  this._eventManager.associate(this, this);  
}

/**
 * Creates and adds an accordion section
 * @param {string} title Section title
 * @param {DvtContainer} sectionContent Section content
 * @param {Boolean} isActive Indicates if the section initially opened
 * @param {Boolean} isCollapsible Indicates if the section is collapsible
 * @param {string} id Section id
 */
DvtAccordion.prototype.addSection = function (title, sectionContent, isActive, isCollapsible, id) {
  if (!id)
    id = "accordion_" + title.replace(/ /g, '_') + Math.floor(Math.random() * 1000000000);    
  var accordionSection = new DvtAccordionSection (this.getCtx(), sectionContent, title, isActive, isCollapsible, this, this._eventManager, id, this._images, this._styleMap);
  this._sections[id] = accordionSection;
  this._sectionOrder.push(id);
  this.addChild(accordionSection);
}

/**
 * Renders the control
 */
DvtAccordion.prototype.render = function () {
  var maxSectionWidth = this.getMaxWidth();
  var bHasActive = false; //ensure that at least one section is initially active
  
  for (var i = 0;i < this._sectionOrder.length;i++) {
    var section = this.getSectionByIndex(i);
    section.render(maxSectionWidth);
    
    // if we already have one active section and only one is allowed, make other sections inactive
    if (bHasActive && !this.canExpandMany()) 
      section.setActive(false);
    if (section.isActive() && section.isCollapsible())
      bHasActive = true;
  }
  if (!bHasActive && this._sectionOrder.length >0)
    this.getSectionByIndex(0).setActive(true);

  this._drawSections();
}

/**
 * Updates accordion panel and resizes external container
 * @param {activeSectionId} title Section title
 * @protected
 */
DvtAccordion.prototype.Update = function (activeSectionId) {
  var activeSection = this.getSectionById(activeSectionId);
  var currActiveState = activeSection.isActive();
  if (!currActiveState) {
    //collapse sections if necessary, then open an active one
    if (!this.canExpandMany()) { 
      for (var i = 0; i < this._sectionOrder.length; i++)
        this.getSectionByIndex(i).setActive(false);
    }
    activeSection.setActive(true);
  }
  else if (currActiveState && this._canCollapseSection(activeSection)) {
    activeSection.setActive(false);
  }
  this._drawSections();
}

/**
 * Returns max section width
 * @return {number}
 */
DvtAccordion.prototype.getMaxWidth = function () {
  if (!this._maxSectionWidth) {
    var maxSectionWidth = 0;
    var paddingX = this._styleMap['paddingX'];
  
    // find widest section
    for (var i = 0; i < this._sectionOrder.length; i++) {
      var section = this.getSectionByIndex(i);
      var dim = section.GetTitleDimensions();
      if (dim.w > maxSectionWidth)
        maxSectionWidth = dim.w;
      //add padding to the calculated section width
      var secWidth =section.getContentDimensions().w+paddingX*2;
      if (secWidth > maxSectionWidth)
        maxSectionWidth = secWidth;     
    }
    
    if (maxSectionWidth > this._ww)
      maxSectionWidth = this._ww;
    this._maxSectionWidth = maxSectionWidth;
  }
  return this._maxSectionWidth;
}

/**
 * Returns max control height
 * @return {number}
 */
DvtAccordion.prototype.getMaxHeight = function () {
  if (!this._maxHeight) {
    var maxCollapsibleSectionHeight = 0; //collapsible sections height
    var maxFixedSectionHeight = 0; //fixed sections height
    for (var i = 0;i < this._sectionOrder.length;i++) {
      var section = this.getSectionByIndex(i);
      var sectionHeight =section.getMaxDimensions().h;
      
      if (section.isCollapsible() && sectionHeight > maxCollapsibleSectionHeight)
          maxCollapsibleSectionHeight = sectionHeight;
      else if (!section.isCollapsible() || this.canExpandMany())
          maxFixedSectionHeight += sectionHeight;
    }
    this._maxHeight = maxCollapsibleSectionHeight + maxFixedSectionHeight;
  }
  return this._maxHeight;
}

/**
 * Gets section by given index
 * @param {number} index Section index
 * @return {DvtAccordionSection} Section by given index
 */
DvtAccordion.prototype.getSectionByIndex = function (index) {
  if (index >= 0 && index < this._sectionOrder.length) {
    var sectionId = this._sectionOrder[index];
    return this.getSectionById(sectionId);
  }
  else
    return null;
}

/**
 * Gets section by given section id
 * @param {string} sectionId Section id
 * @return {DvtAccordionSection} Section by given id
 */
DvtAccordion.prototype.getSectionById = function (sectionId) {
  return this._sections[sectionId];
}

/**
 * Sets "expand many" attribute for the control. Default value is false.
 * @param {boolean} bExpandMany True if more than one section can be expanded
 */
DvtAccordion.prototype.setExpandMany = function (bExpandMany) {
  this._bExpandMany = bExpandMany;
}

/**
 * Checks "expand many" attribute for the control. Default value is false.
 * @return {boolean} True if more than one section can be expanded
 */
DvtAccordion.prototype.canExpandMany = function () {
  return this._bExpandMany;
}

/**
 * Sets "collapse all" attribute for the control. Default value is false.
 * @param {boolean} bCollapseAll True if all section could be collapsed
 */
DvtAccordion.prototype.setCollapseAll = function (bCollapseAll) {
  this._bCollapseAll = bCollapseAll;
}

/**
 * Checks "collapse all" attribute for the control. Default value is false.
 * @return {boolean} True if all sections could be collapsed
 */
DvtAccordion.prototype.canCollapseAll = function () {
  return this._bCollapseAll;
}

/**
 * @private
 * Check if the given section can be collapsed
 * @param {DvtAccordionSection} section The section to check for collapsability
 */
DvtAccordion.prototype._canCollapseSection = function (section) {
  if (!section.isCollapsible())
    return false;
  else if (this.canCollapseAll())
    return true;
  else {
    var expandedSectionCounter = 0;
    for (var i = 0;i < this._sectionOrder.length;i++) {
      section = this.getSectionByIndex(i);
      if (section.isActive())
        expandedSectionCounter++;
    }
    return (expandedSectionCounter > 1);
  }
}

/**
 * @private
 * Collapse and expand sections as needed
 */
DvtAccordion.prototype._drawSections = function () {
  var currY = 0;
  for (var i = 0;i < this._sectionOrder.length;i++) {
    var section = this.getSectionByIndex(i);
    section.setTranslateY(currY);
    
    if (section.isActive()) { 
      section.expand();
      currY += section.getDimensions().h;
      currY += this._styleMap['paddingY'];
    }
    else {
      section.collapse();
      currY += this._styleMap['sectionHeader']['headerHeight'];
    }
  }
  this.FireListener(new DvtResizeEvent(this.getMaxWidth(), currY, 0, 0));
}
/**
 *  @constructor
 *  Creates an accordion section
 *  @param {DvtContext} context object
 *  @param {DvtContainer} section content (doesn't include header)
 *  @param {string} title section title
 *  @param {Boolean} isActive Indicates if the section initially opened
 *  @param {Boolean} isCollapsible Indicates if the section is collapsible  
 *  @param {DvtAccordion} parent
 *  @param {DvtEventManager} eventManager
 *  @param {string} id Section id
 *  @param {images} images for the control 
 *  @param {Object} styleMap for the control
 */
var DvtAccordionSection = function (context, section, title, isActive, isCollapsible, parent, eventManager, id, images, styleMap) {
  this.Init(context, section, title, isActive, isCollapsible, parent, eventManager, id, images, styleMap);
};

DvtObj.createSubclass(DvtAccordionSection, DvtContainer, "DvtAccordionSection");

/**
 * @protected
 * Initialization method called by the constructor
 * @param {DvtContext} context object
 * @param {DvtContainer} section content (doesn't include header)
 * @param {string} title section title
 * @param {Boolean} isActive Indicates if the section initially opened
 * @param {Boolean} isCollapsible Indicates if the section is collapsible  
 * @param {DvtAccordion} parent
 * @param {DvtEventManager} eventManager
 * @param {string} id Section id
 * @param {images} images for the control 
 * @param {Object} styleMap for the control
 */
DvtAccordionSection.prototype.Init = function (context, section, title, isActive, isCollapsible, parent, eventManager, id, images, styleMap) {
  DvtAccordionSection.superclass.Init.call(this, context, null, id);
  this._parent = parent;
  this._images = images;
  this._title = title;
  this._id = id;
  this._sectionContent = section;
  this._expandedBtn = null;
  this._collapsedBtn = null;
  this._isCollapsible = isCollapsible;
  this._isActive = isCollapsible ? isActive : true;
  this._eventManager = eventManager;
  
  //styles
  this._styleMap = styleMap;
  this._headerHeight = this._styleMap['sectionHeader']['headerHeight'];
  this._paddingX = this._styleMap['paddingX'];
  this._paddingY = this._styleMap['paddingY'];
  this._titleStyle = this._styleMap['sectionHeader']['styleEna'];
  this._imageWidth = this._styleMap['sectionHeader']['imageWidth'];
  this._imageHeight = this._styleMap['sectionHeader']['imageHeight'];
  this._textPadding = this._styleMap['sectionHeader']['textPadding'];
}

/**
 * Returns section id
 * 
 * @return {string}
 */
DvtAccordionSection.prototype.getId = function() {
    return this._id;
}

/**
 * Returns section title
 * 
 * @return {string}
 */
DvtAccordionSection.prototype.getTitle = function() {
    return this._title;
}

/**
 * Sets active indicator
 * 
 * @param {Boolean} active 
 */
DvtAccordionSection.prototype.setActive = function(active) {
  this._isActive = active;
}

/**
 * Returns whether section is active
 * 
 * @return {Boolean}
 */
DvtAccordionSection.prototype.isActive = function() {
  return this._isActive;
}

/**
 * Returns whether section is collapsible
 * 
 * @return {Boolean}
 */
DvtAccordionSection.prototype.isCollapsible = function() {
  return this._isCollapsible;
}

/**
 * Returns content dimentsions (does not include title bar)
 * 
 * @return {DvtRect}
 */
DvtAccordionSection.prototype.getContentDimensions = function() {
  var dim = null;
  if (this.getChildIndex(this._sectionContent) < 0) {
    this.addChild(this._sectionContent);
    dim = this._sectionContent.getDimensions();
    this.removeChild(this._sectionContent);
  }
  else
    dim = this._sectionContent.getDimensions();
  return dim;
}

/**
 * Returns expanded section dimentsions (includes title bar and content section)
 * 
 * @return {DvtRect}
 */
DvtAccordionSection.prototype.getMaxDimensions = function() {
  var dim = null;
  if (this.getChildIndex(this._sectionContent) < 0) {
    this.addChild(this._sectionContent);
    this._sectionContent.setTranslateX(this._paddingX);
    this._sectionContent.setTranslateY(this._headerHeight + this._paddingY);
    dim = this.getDimensions();
    this.removeChild(this._sectionContent);
  }
  else
    dim = this.getDimensions();
  return dim;
}

/**
 * Renders the accordion section
 */
DvtAccordionSection.prototype.render = function(width) {
  
  this._createHeader(width, this._headerHeight);
  
  if (!this.isCollapsible()) {
    this.addChildAt(this._header,0);
    this.addChild(this._sectionContent);
    this._sectionContent.setTranslateX(this._paddingX);
    this._sectionContent.setTranslateY(this._headerHeight + this._paddingY);
  }
  else if (this.isActive()) {
    this.addChildAt(this._expandedBtn,0);
    this.addChild(this._sectionContent);
    this._sectionContent.setTranslateX(this._paddingX);
    this._sectionContent.setTranslateY(this._headerHeight + this._paddingY);
  }
  else
    this.addChild(this._collapsedBtn);
}

/**
 * Collapses the accordion section
 */
DvtAccordionSection.prototype.collapse = function() {
  if (this.isCollapsible()) {
    if (this.getChildIndex(this._expandedBtn) >= 0)
      this.removeChild(this._expandedBtn);
    if (this.getChildIndex(this._sectionContent) >= 0)
      this.removeChild(this._sectionContent);
    this.addChild(this._collapsedBtn);
    this.setActive(false);
  }
}

/**
 * Expands the accordion section
 */
DvtAccordionSection.prototype.expand = function() {  
  if (this.getChildIndex(this._collapsedBtn) >= 0)
    this.removeChild(this._collapsedBtn);
      
  this.addChild(this._expandedBtn);
  this.addChild(this._sectionContent);
  this._sectionContent.setTranslateX(this._paddingX);
  this._sectionContent.setTranslateY(this._headerHeight + this._paddingY);
  this.setActive(true);
}

/**
 * @protected
 */
DvtAccordionSection.prototype.HandleHeaderClick = function(event) {
  this._parent.Update(this.getId());
};

/**
 * @protected
 */
DvtAccordionSection.prototype.GetTitleDimensions = function () {
  if (!this._titleDim) {
    var text = new DvtOutputText(this._context, this._title) ;
    text.setCSSStyle(this._titleStyle);
    var dim = text.measureDimensions();
    if (dim)
      dim.w = dim.w + this._imageWidth + this._textPadding;
    this._titleDim = dim;      
  }
  return this._titleDim;
}

/**
 * @protected
 */
DvtAccordionSection.prototype.SetTitleDimensions = function (dim) {
  if (!this._titleDim || this._titleDim.w < dim.w || this._titleDim.h < dim.h)
    this._titleDim = dim;
}
/**
 * @private
 * Creates section header
 * @param {number} width Section width
 * @param {height} height Section height
 */
DvtAccordionSection.prototype._createHeader = function(width, height) {

  // create header  
  if (this.isCollapsible()) {  
    ena = this._createHeaderState(DvtButton.STATE_ENABLED, this._images.getAttr(DvtAccordion.EXPAND_ENA), this._title, width, height);
    ovr = this._createHeaderState(DvtButton.STATE_OVER, this._images.getAttr(DvtAccordion.EXPAND_OVR), this._title, width, height);
    dwn = this._createHeaderState(DvtButton.STATE_DOWN, this._images.getAttr(DvtAccordion.EXPAND_DWN), this._title, width, height);
    this._expandedBtn = new DvtButton(this._context, ena, ovr, dwn);
      
    ena = this._createHeaderState(DvtButton.STATE_ENABLED, this._images.getAttr(DvtAccordion.COLLAPSE_ENA), this._title, width, height);
    ovr = this._createHeaderState(DvtButton.STATE_OVER, this._images.getAttr(DvtAccordion.COLLAPSE_OVR), this._title, width, height);
    dwn = this._createHeaderState(DvtButton.STATE_DOWN, this._images.getAttr(DvtAccordion.COLLAPSE_DWN), this._title, width, height);
    this._collapsedBtn = new DvtButton(this._context, ena, ovr, dwn);
    
    var thisRef = this;
    var proxy = {};
    proxy.HandleClick = function(event) {
      thisRef.HandleHeaderClick(event);
    };
    
    this._eventManager.associate(this._expandedBtn, proxy);
    this._eventManager.associate(this._collapsedBtn, proxy);
  }
  else {
    var base = this._createButtonBase(DvtButton.STATE_DISABLED, width, height);  
    var text = this._createButtonText (DvtButton.STATE_DISABLED, this._title);
    this._header = new DvtContainer(this._context);
    this._header.addChild(base);
    this._header.addChild(text);
  }
}

/**
 * @private
 * Helper function that creates header state
 * @param {string} uri The URL to the collapse/expand image used in the header state
 * @param {string} label Section label
 * @param {number} width Section width
 * @param {height} height Section height
 */
DvtAccordionSection.prototype._createHeaderState = function (state, uri, label, ww, hh) {

  var imageWidth = this._imageWidth;
  var imageHeight = this._imageHeight;
  var imageOffsetX = 0;
  var imageOffsetY = (this._headerHeight - imageHeight)/2;

  var base = this._createButtonBase(state, ww, hh);
  var text = this._createButtonText (state, label);
  var image = null;
  if (uri)
    image = new DvtImage(this._context, uri, imageOffsetX, imageOffsetY, imageWidth, imageHeight);

  var buttonState = new DvtContainer(this._context);
  buttonState.addChild(base);
  if (image)
    buttonState.addChild(image);
  buttonState.addChild(text);
    
  if (!DvtAgent.isRightToLeft(this._context)) {
    text.setTranslateX(imageWidth);
  }
  else {
    var dim = text.measureDimensions();
    text.setTranslateX(ww - dim.w - imageWidth);
    if (image)
      image.setTranslateX(ww - imageWidth);
  }
  return buttonState;
}

/**
 * @private
 */
DvtAccordionSection.prototype._createButtonText = function (state, label) {
  var text = null;
  if (label) {
    text = new DvtOutputText(this._context, label) ;
    text.setCSSStyle(this._titleStyle);

    var dim = text.measureDimensions();
    dim.w = dim.w + this._imageWidth + this._textPadding;
    this.SetTitleDimensions(dim);
    var offsetY = (this._headerHeight - dim.h)/2;
    text.setTranslateY(offsetY);
  }
  return text;
}

/**
 * @private
 */
DvtAccordionSection.prototype._createButtonBase = function (state, ww, hh) {
    var style = null;
    switch (state) {
      case DvtButton.STATE_OVER:
        style = this._styleMap['sectionHeader']['styleOvr'];
        break;
      case DvtButton.STATE_DOWN:
        style = this._styleMap['sectionHeader']['styleDwn'];
        break;
      case DvtButton.STATE_DISABLED:
        style = this._styleMap['sectionHeader']['styleDis'];
        break;      
      case DvtButton.STATE_ENABLED:
      default:
        style = this._styleMap['sectionHeader']['styleEna'];
    }
    var base = new DvtRect(this._context, 0,0,ww,hh);
    base.setStroke(DvtAccordionSection._getStroke(style));
    base.setFill(DvtAccordionSection._getFill(style));
    return base;
};

/**
 * Helper function that gets fill value from the style map and creates a gradient or solid fill
 * @return{DvtLinearGradientFill|DvtSolidFill} section header fill
 */
DvtAccordionSection._getFill = function(style) {
  var color = style.getStyle(DvtCSSStyle.BACKGROUND_COLOR);
  var gradObj = style.getBackgroundImage();
      
  var fill = null;
  if (gradObj && (gradObj instanceof DvtCSSGradient)) {
    var arColors = gradObj.getColors();
    var arAlphas = gradObj.getAlphas();
    var arStops = gradObj.getRatios();
    var angle = gradObj.getAngle();
    fill = new DvtLinearGradientFill(angle, arColors, arAlphas, arStops);        
  }
  else if (color) 
    fill = new DvtSolidFill(color,1);
  return fill;
}
/**
 * Helper function that gets stroke value from the style map and creates a stroke for the section border
 * @return{DvtSolidStroke} section header stroke for the section border
 */
DvtAccordionSection._getStroke = function(style) {
  var color = style.getStyle(DvtCSSStyle.BORDER_COLOR);
  return new DvtSolidStroke(color, 1, 1);
}
//
// $Header: dsstools/modules/dvt-shared-js/src/META-INF/bi/sharedJS/toolkit/adfinternal/subcomponent/DvtAccordionDefaults.js /bibeans_root/1 2013/12/16 11:33:33 nbalatsk Exp $
//
// DvtAccordionDefaults.js
//
// Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.
//
//    NAME
//     DvtAccordionDefaults.js - <one-line expansion of the name>
//
//    DESCRIPTION
//     <short description of component this file declares/defines>
//
//    NOTES
//     <other useful comments, qualifications, etc. >
//
//    MODIFIED  (MM/DD/YY)
//    nbalatsk   12/12/13 - Created
//
/**
 * Default values and utility functions for component versioning.
 * @class
 * @constructor
 * @extends {DvtBaseComponentDefaults}
 */
var DvtAccordionDefaults = function() {
  this.Init({'skyros': DvtAccordionDefaults.VERSION_1, 'alta': DvtAccordionDefaults.SKIN_ALTA});
}

DvtObj.createSubclass(DvtAccordionDefaults, DvtBaseComponentDefaults, "DvtAccordionDefaults");

/**
 * Defaults for version 1.
 */
DvtAccordionDefaults.VERSION_1 = {
  'skin': DvtCSSStyle.SKIN_ALTA,
  'sectionHeader': {
    'styleEna': new DvtCSSStyle("font-family:'Helvetica Neue',Helvetica,Arial,sans-serif;font-size:14px;font-weight:bold;color:#252525;border-color:#D9DFE3;background-color:#F5F5F5;"),
    'styleOvr': new DvtCSSStyle("font-family:'Helvetica Neue',Helvetica,Arial,sans-serif;font-size:14px;font-weight:bold;color:#252525;border-color:#D9DFE3;background-color:#F5F5F5;"),
    'styleDwn': new DvtCSSStyle("font-family:'Helvetica Neue',Helvetica,Arial,sans-serif;font-size:14px;font-weight:bold;color:#252525;border-color:#D9DFE3;background-color:#F5F5F5;"),
    'styleDis': new DvtCSSStyle("font-family:'Helvetica Neue',Helvetica,Arial,sans-serif;font-size:14px;font-weight:bold;color:#252525;border-color:#D9DFE3;background-color:#F5F5F5;"),
    'headerHeight':33,
    'imageWidth':24,
    'imageHeight':24,
    'textPadding':5
  },
  'paddingX':15,
  'paddingY':15
}

DvtAccordionDefaults.SKIN_ALTA = {
}
/**
 * @constructor
 * 
 * @param {Array} buttonStyles An array of DvtCSSStyle: TrainButtonStyle, TrainButtonHoverStyle and TrainButtonActiveStyle
 */
var DvtTrain = function (context, eventManager, labels, buttonStyles, id) {
  this.Init(context, eventManager, labels, buttonStyles, id);
};

/**
 * make DvtTrain a subclass of DvtContainer
 */
DvtObj.createSubclass(DvtTrain, DvtContainer, "DvtTrain");

DvtTrain.TRAIN_EVENT = "dvtTrain";
DvtTrain.FILL_COLOR = "#c0cbd5";
DvtTrain.BORDER_COLOR = "#5d7891";
DvtTrain.SELECTED_FILL_COLOR = "#61bde3";
DvtTrain.SELECTED_BORDER_COLOR = "#0066ff";
DvtTrain.BUTTON_SIZE = 8;
DvtTrain.VPADDING = 1;
DvtTrain.HPADDING = 3;

DvtTrain.STATE_ENABLED = 0;
DvtTrain.STATE_HOVER = 1;
DvtTrain.STATE_SELECTED = 2;


DvtTrain.prototype.Init = function (context, eventManager, labels, buttonStyles, id) {
  DvtTrain.superclass.Init.call(this, context, null, id);

  //tooltipManager to use for displaying tooltips for items in Train
  this._tooltipManager = context.getTooltipManager();

  //Array of labels for items in Train
  this._labels = labels;
  this._buttonStyles = buttonStyles;
  this._count = labels.length;
  this._buttons = new Array(this._count);
  this._selectedIndex = 0;

  this.RenderSelf(eventManager);
};


/**
 * Set the selected index of the train.
 * 
 * @param index new selected index
 */
DvtTrain.prototype.setSelectedIndex = function (index) {
  if (index >= 0 && index < this._count) {
    this.SelectedIndexChanged(this._selectedIndex, index);
  }
};

/**
 * Get the selected index of the train.
 * 
 * @return selected index
 */
DvtTrain.prototype.getSelectedIndex = function () {
  return this._selectedIndex;

};


/**
 * Handle a click event on a train item.
 * 
 * @param event mouse click event
 */
DvtTrain.prototype.HandleClick = function (event) {

  //don't want click to fall through to rest of node
  DvtEventManager.consumeEvent(event);

  for (var i = 0; i < this._buttons.length; i++) {
    var target = event.target.getParent();

    if (target === this._buttons[i]) {
      var selIndex = this.getSelectedIndex();
      this.SelectedIndexChanged(selIndex, i);

      if (selIndex != i) {
        this.fireTrainEvent();
      }
      break;
    }
  }
};

/**
 * Update the train for a change to the selected index.
 * 
 * @param oldIndex old selected index
 * @param newIndex new selected index
 */
DvtTrain.prototype.SelectedIndexChanged = function (oldIndex, newIndex) {
  this._selectedIndex = newIndex;

  var button = this._buttons[oldIndex];
  if (button) {
    if (button.getOverState())
      button.getOverState().setCursor("pointer");
    if (button.getDownState())
      button.getDownState().setCursor("pointer");

    button.setToggled(false);
  }

  button = this._buttons[newIndex];
  if (button) {
    if (button.getOverState())
      button.getOverState().setCursor("default");
    if (button.getDownState())
      button.getDownState().setCursor("default");

    button.setToggled(true);
  }
}


/**
 * Add a TrainEvent listener to this train.
 * @param {function} listener the function to call
 * @param {object} obj instance of the object the listener is defined on
 */
DvtTrain.prototype.addTrainEventListener = function(listener, obj) {
  this.addEvtListener(DvtTrain.TRAIN_EVENT, listener, false, obj);
}

/**
 * Remove a TrainEvent listener from this train.
 * @param {function} listener the function to call
 * @param {object} obj instance of the object the listener is defined on
 */
DvtTrain.prototype.removeTrainEventListener = function(listener, obj) {
  this.removeEvtListener(DvtTrain.TRAIN_EVENT, listener, false, obj);
}

/**
 * Fire a train event.
 */
DvtTrain.prototype.fireTrainEvent = function() {
  var event = new DvtTrainEvent(this._selectedIndex);
  this.FireListener(event, false);
};

/**
 * Render this train.
 */
DvtTrain.prototype.RenderSelf = function(eventManager) {
  var bBiDi = DvtAgent.isRightToLeft(this.getCtx());
  var buttonSize = this._getButtonSize();

  for (var i = 0; i < this._count; i++) {
    var bSelected = (i == this._selectedIndex);
    var button;

    button = this.CreateButton(buttonSize, bSelected, this._labels[i]);
    this.addButtonListeners(button);

    var j = i;

    //BiDi: reverse order of display of train items
    if (bBiDi)
      j = this._count - 1 - i;

    if (eventManager)
      eventManager.associate(button, button);

    button.setTranslate(j * buttonSize + (j + 1) * DvtTrain.HPADDING, DvtTrain.VPADDING);
    this.addChild(button);

    this._buttons[i] = button;
  }
}

DvtTrain.prototype.DrawButtonState = function(buttonSize, bSelected) {
  var buttonStyle;
  var bdColor;
  var bgColor;
  var offset;

  if (bSelected) {
    offset = 0;
    bgColor = DvtTrain.SELECTED_FILL_COLOR;
    bdColor = DvtTrain.SELECTED_BORDER_COLOR;
    if (this._buttonStyles)
      buttonStyle = this._buttonStyles[DvtTrain.STATE_SELECTED];
  }
  else {
    offset = 1;
    bgColor = DvtTrain.FILL_COLOR;
    bdColor = DvtTrain.BORDER_COLOR;
    if (this._buttonStyles)
      buttonStyle = this._buttonStyles[DvtTrain.STATE_ENABLED];
  }

  if (buttonStyle) {
    if (buttonStyle.getStyle(DvtCSSStyle.BORDER_COLOR)) {
      bdColor = buttonStyle.getStyle(DvtCSSStyle.BORDER_COLOR);
    }
    if (buttonStyle.getStyle(DvtCSSStyle.BACKGROUND_COLOR)) {
      bgColor = buttonStyle.getStyle(DvtCSSStyle.BACKGROUND_COLOR);
    }  
  }

  var shape = new DvtRect(this.getCtx(), offset, offset, 
                          buttonSize - 2 * offset, 
                          buttonSize - 2 * offset);
  shape.setSolidFill(bgColor);
  shape.setSolidStroke(bdColor);

  return shape;
}


/**
 * Add listeners to a button.
 * 
 * @param button button to add listeners to
 */
DvtTrain.prototype.addButtonListeners = function(button) { 
  button.addEvtListener(DvtTouchEvent.TOUCHSTART, this.HandleClick, false, this);
  if (!DvtAgent.isTouchDevice()) {
    button.addEvtListener(DvtMouseEvent.CLICK, this.HandleClick, false, this);
  }
}

/**
 * Remove listeners from a button.
 * 
 * @param button button to remove listeners from
 */
DvtTrain.prototype.removeButtonListeners = function(button) {
  button.removeEvtListener(DvtTouchEvent.TOUCHSTART, this.HandleClick, false, this);
  if (!DvtAgent.isTouchDevice()) {
    button.removeEvtListener(DvtMouseEvent.CLICK, this.HandleClick, false, this);
  }
}

DvtTrain.prototype._getButtonSize = function() { 
  if (! this._buttonSize) {
    if (this._buttonStyles) {
      //assume they are all the same size for now
      var buttonStyle = this._buttonStyles[0];
      if (buttonStyle) {
        this._buttonSize = DvtCSSStyle.toNumber(buttonStyle.getWidth());
      }
    }
    if (! this._buttonSize)
      this._buttonSize = DvtTrain.BUTTON_SIZE;
  }
  return this._buttonSize;
}

DvtTrain.prototype.CreateButtonState = function(url, buttonSize) {
  return new DvtImage(this.getCtx(), url, 0, 0, buttonSize, buttonSize);
}

DvtTrain.prototype.MakeButtonState = function(buttonSize, state, bSelected ) {
  var style = this._buttonStyles ? this._buttonStyles[state] : null;
  var url = style ? style.getIconUrl() : null;

  var shape = url ? this.CreateButtonState(url, buttonSize) :
                    this.DrawButtonState(buttonSize, (state == DvtTrain.STATE_SELECTED));

  shape.setCursor((state == DvtTrain.STATE_ENABLED || bSelected) ? 
                  "default" : "pointer");

  return shape;
}

DvtTrain.prototype.CreateButton = function(buttonSize, bSelected, tooltip) { 
  var button = new DvtButton(this.getCtx(), 
                             this.MakeButtonState(buttonSize, DvtTrain.STATE_ENABLED, bSelected),
                             this.MakeButtonState(buttonSize, DvtTrain.STATE_HOVER, bSelected),
                             this.MakeButtonState(buttonSize, DvtTrain.STATE_SELECTED, bSelected),
                             null);

  button.setTooltip(tooltip);
  button.setToggleEnabled(true);
  if (bSelected)
    button.setToggled(bSelected);

  return button;
}

/*
DvtTrain.prototype.destroy = function (listener) {
  if (listener)
    this.removeTrainEventListener(listener);

  for (var i = 0; i < this._count; i++) {
    var button = this._buttons[i];
    this.removeButtonListeners(button);
  }
}
*/

/**
 * A Train event.
 * @param {int} index The currently selected index
 * @class
 * @constructor
 * @export
 */
var DvtTrainEvent = function(index) {
  this.Init(DvtTrainEvent.TYPE);
  this.type = this.getType();
  this._index = index;
}

DvtObj.createSubclass(DvtTrainEvent, DvtBaseComponentEvent, "DvtTrainEvent");

/**
 * @export
 */
DvtTrainEvent.TYPE = "dvtTrain";

/**
 * Returns the index of the selected button
 * @return {index}The selected button
 * @export
 */
DvtTrainEvent.prototype.getIndex = function() {
  return this._index;
}
// Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.
/**
 * Creates an Overview window component
 * @class DvtOverviewWindow
 * @constructor  
 *  
 * @param {DvtContext} context The rendering context
 * @param {string} id the id of the overview window
 * @param {number} x The leftmost position of the Overview window
 * @param {number} y The topmost position of the Overview window
 * @param {number} ww The width of the Overview window
 * @param {number} hh The height of the Overview window
 */
var  DvtOverviewWindow = function(context, id, x, y, ww, hh)
{   
   this.Init(context, id, x, y, ww, hh);
};

DvtObj.createSubclass(DvtOverviewWindow, DvtContainer, "DvtOverviewWindow");

DvtOverviewWindow.VIEWPORT_BG_COLOR = "viewport-bg-color";
DvtOverviewWindow.VIEWPORT_BORDER_COLOR = "viewport-border-color";

DvtOverviewWindow.OVERVIEW_DISCLOSED_KEY = "isOverviewDisclosed";

/**
 * Initialization method called by the constructor
 * 
 * @param {DvtContext} context The rendering context
 * @param {string} id the id of the overview window
 * @param {number} x The leftmost position of the Overview window
 * @param {number} y The topmost position of the Overview window
 * @param {number} ww The width of the Overview window
 * @param {number} hh The height of the Overview window
 */
DvtOverviewWindow.prototype.Init = function(context, id, x, y, ww, hh) {
  DvtOverviewWindow.superclass.Init.call(this, context, null, id);
  this._x = x;
  this._y = y;
  this._ww = ww;
  this._hh = hh;

  this._skinStyle = null;
}

/**
 * Renders the overview window
 */
DvtOverviewWindow.prototype.render = function()
{    
  this._md = false;
  this._panEnable = true;
  
  if (this._overview) {
    if (DvtAgent.isTouchDevice()) {
      this._overview.removeEvtListener(DvtTouchEvent.TOUCHSTART, this._mouseDown, false, this);
      this._overview.removeEvtListener(DvtTouchEvent.TOUCHMOVE, this._mouseMove, false, this);
      this._overview.removeEvtListener(DvtTouchEvent.TOUCHEND, this._mouseUp, false, this);      
    }
    else {
      this._overview.removeEvtListener(DvtMouseEvent.MOUSEDOWN, this._mouseDown, false, this);
      this._overview.removeEvtListener(DvtMouseEvent.MOUSEMOVE, this._mouseMove, false, this);
      this._overview.removeEvtListener(DvtMouseEvent.MOUSEUP, this._mouseUp, false, this);
      this._overview.removeEvtListener(DvtMouseEvent.MOUSEOUT, this._mouseOut, false, this); 
    }    
    this._overview.setClipPath(null);
  }
  this.removeChildren();
  this._viewport = null;
  this._overview = null;
  
  var clipPath = new DvtClipPath(this.getId());
  clipPath.addRect(0.0, 0.0, this._ww, this._hh);
  this._overview = new DvtRect(this._context, 0.0, 0.0, this._ww, this._hh);
  this._overview.setClipPath(clipPath);
  this._overview.setInvisibleFill();
  this.addChild(this._overview);
  
  // Create viewport
  this._viewport = new DvtRect (this._context, 0.0, 0.0, 0.0, 0.0, this.getId()+":"+'viewport');
  var bgColor = this.getSkinStyleAttr(DvtOverviewWindow.VIEWPORT_BG_COLOR);
  var borderColor = this.getSkinStyleAttr(DvtOverviewWindow.VIEWPORT_BORDER_COLOR);
  
  this._viewport.setSolidStroke(borderColor, null, 2);
  this._viewport.setSolidFill(bgColor);
  this._viewport.setMouseEnabled(false);
  this._overview.addChild(this._viewport);

  if (DvtAgent.isTouchDevice()) {
    this._overview.addEvtListener(DvtTouchEvent.TOUCHSTART, this._mouseDown, false, this);
    this._overview.addEvtListener(DvtTouchEvent.TOUCHMOVE, this._mouseMove, false, this);
    this._overview.addEvtListener(DvtTouchEvent.TOUCHEND, this._mouseUp, false, this);      
  }
  else {
    this._overview.addEvtListener(DvtMouseEvent.MOUSEDOWN, this._mouseDown, false, this);
    this._overview.addEvtListener(DvtMouseEvent.MOUSEMOVE, this._mouseMove, false, this);
    this._overview.addEvtListener(DvtMouseEvent.MOUSEUP, this._mouseUp, false, this);
    this._overview.addEvtListener(DvtMouseEvent.MOUSEOUT, this._mouseOut, false, this); 
  }
}

DvtOverviewWindow.prototype.loadXmlNode = function (ovNode) 
{
  //TODO
  this._isDisclosed = ovNode.getAttr('disclosed') == 'true';
};

DvtOverviewWindow.prototype.isDisclosed = function () 
{
  return this._isDisclosed; 
}

DvtOverviewWindow.prototype.setDisclosed = function (bDisclosed) {
  this._isDisclosed = bDisclosed;
}

DvtOverviewWindow.prototype.getContentAreaWidth = function ()
{
  return this.getContentDimensions().w;
}

DvtOverviewWindow.prototype.getContentAreaHeight = function ()
{
  return this.getContentDimensions().h;
}

DvtOverviewWindow.prototype.getContentDimensions = function () 
{
    return new DvtRectangle(this._x, this._y, this._ww, this._hh);
}

/** 
 * Sets the dimensions of the viewport within the overviewWindow.
 *
 * @param {DvtRectangle} dim The dimensions of the viewport (in content coordinates)
 * @param {DvtAnimator} animator An optional animator for animating the change
 *
 */ 
DvtOverviewWindow.prototype.setViewportDimensions = function (dim, animator)
{
  var topLeft = this.TransformFromContentToViewportCoords(dim.x, dim.y, animator);
  var bottomRight = this.TransformFromContentToViewportCoords(dim.x + dim.w, dim.y + dim.h, animator);
  var vx = topLeft.x;
  var vy = topLeft.y;
  var vw = bottomRight.x - topLeft.x;
  var vh = bottomRight.y - topLeft.y;

  if (animator) {
    animator.addProp(DvtAnimator.TYPE_NUMBER, this._viewport, this._viewport.getX, this._viewport.setX, vx);
    animator.addProp(DvtAnimator.TYPE_NUMBER, this._viewport, this._viewport.getY, this._viewport.setY, vy);
    animator.addProp(DvtAnimator.TYPE_NUMBER, this._viewport, this._viewport.getWidth, this._viewport.setWidth, vw);
    animator.addProp(DvtAnimator.TYPE_NUMBER, this._viewport, this._viewport.getHeight, this._viewport.setHeight, vh);
  }
  else {
    this._viewport.setX(vx);
    this._viewport.setY(vy);
    this._viewport.setWidth(vw);
    this._viewport.setHeight(vh);      
  }
}

/** 
 * Gets the dimensions of the viewport within the overviewWindow.
 *
 * @return {DvtRectangle} The dimensions of the viewport (in content coordinates)
 */ 
DvtOverviewWindow.prototype.getViewportDimensions = function () {
  var topLeft = this.TransformFromViewportToContentCoords(
                        this._viewport.getX(), this._viewport.getY());
  var bottomRight = this.TransformFromViewportToContentCoords(
                        this._viewport.getX() + this._viewport.getWidth(), 
                        this._viewport.getY() + this._viewport.getHeight());
  return new DvtRectangle(topLeft.x, topLeft.y, 
                          bottomRight.x - topLeft.x,
                          bottomRight.y - topLeft.y);
}

/**  Determine whether the viewport is pannable or not
  *
  *  @param {Boolean} pan         True if you can pan the viewport
  *
  */ 

DvtOverviewWindow.prototype.setPanEnabled = function (pan)
{
  this._panEnable = pan;
}

/**  
  *  @returns {Boolean}  Return true if the viewport is pannable
  */ 
DvtOverviewWindow.prototype.isPanEnabled = function ()
{
  return this._panEnable;
}

/**
 * Sets the content for this overview window
 * 
 * @param {DvtDisplayable} content the content for this overview window
 */
DvtOverviewWindow.prototype.setContent = function (content) {
  var oldDims = this.getViewportDimensions();
  
  //remove old content
  if (this._content) {
    this._overview.removeChild(this._content);
  }

  this._content = content;

  //move the content from the rootPane to the clipContainer
  this._overview.addChildAt(content, 0);
  
  this.setViewportDimensions(oldDims);
};


/**
 * Handler for the mouse down event
 * 
 * @param {DvtMouseEvent} the mouse down event
 */
DvtOverviewWindow.prototype._mouseDown = function (evt) {
  if (!this._md && this._panEnable) {
    this._md = true;
    var offset = this._getRelativePosition(evt);   
    var viewportEvent = new ViewportChangeEvent (this.getViewportDimensions(), this._getCenteredViewportDimensions(offset), evt);
    this.FireListener(viewportEvent);      
  }
}

/**
 * Handler for the mouse move event
 * 
 * @param {DvtMouseEvent} the mouse move event
 */
DvtOverviewWindow.prototype._mouseMove = function (evt) {
  if (this._md && this._panEnable) {
    var offset = this._getRelativePosition(evt);
    var viewportEvent = new ViewportChangeEvent (this.getViewportDimensions(), this._getCenteredViewportDimensions(offset), evt);
    this.FireListener(viewportEvent);
  }
}

/**
 * Handler for the mouse up event
 * 
 * @param {DvtMouseEvent} the mouse up event
 */
DvtOverviewWindow.prototype._mouseUp = function (evt) {  
  if (this._md && this._panEnable) {
    this._md = false;
  }
}

/**
 * Handler for the mouse out event
 * 
 * @param {DvtMouseEvent} the mouse out event
 */
DvtOverviewWindow.prototype._mouseOut = function (evt) {  
  this._mouseUp(evt);
}

DvtOverviewWindow.prototype._getRelativePosition = function(evt) {
  var pageX;
  var pageY;
  
  if (DvtAgent.isTouchDevice()) {
    // evt is a touch event
    var touches = evt.touches;
    if (touches.length > 0) {
      pageX = touches[0].pageX;
      pageY = touches[0].pageY;
    }
  }
  else {
    // evt is a mouse event
    pageX = evt.pageX;
    pageY = evt.pageY;
  }
  return this._context.pageToStageCoords(pageX, pageY);
}

/**
 * @protected
 */
DvtOverviewWindow.prototype.TransformFromViewportToContentCoords = function(vx, vy)
{
  var tx = 0;
  var ty = 0;
  var sx = 1;
  var sy = 1;
  if (this._content)
  {
    tx = this._content.getTranslateX();
    ty = this._content.getTranslateY();
    sx = this._content.getScaleX();
    sy = this._content.getScaleY();
  }
  
  var cx = (vx - tx) / sx;
  var cy = (vy - ty) / sy;
  return new DvtPoint(cx, cy);
};

/**
 * @protected
 */
DvtOverviewWindow.prototype.TransformFromContentToViewportCoords = function(cx, cy, animator)
{
  var tx = 0;
  var ty = 0;
  var sx = 1;
  var sy = 1;
  if (this._content)
  {
    tx = animator ? animator.getDestVal(this._content, this._content.getTranslateX, true) : this._content.getTranslateX();
    ty = animator ? animator.getDestVal(this._content, this._content.getTranslateY, true) : this._content.getTranslateY();
    sx = animator ? animator.getDestVal(this._content, this._content.getScaleX, true) : this._content.getScaleX();
    sy = animator ? animator.getDestVal(this._content, this._content.getScaleY, true) : this._content.getScaleY();
  }
  
  var vx = (cx * sx) + tx;
  var vy = (cy * sy) + ty;
  return new DvtPoint(vx, vy);
};

DvtOverviewWindow.prototype.getSkinStyle = function () {
  return this._skinStyle;
}

DvtOverviewWindow.prototype.setSkinStyle = function (skinStyle) {
  this._skinStyle = skinStyle;
}

DvtOverviewWindow.prototype.getSkinStyleAttr = function(attr) {
  // Note: this._skinStyle is a map, not a DvtCSSStyle
  if (this._skinStyle && this._skinStyle[attr] != 'undefined') 
    return this._skinStyle[attr];
  else
    return null;
}

/**
 * Gets the dimensions for a viewport centered at the specified position
 * 
 * @param {DvtPoint} pos the position to center the viewport
 * @return {DvtRectangle} the centered viewport dimensions
 */
DvtOverviewWindow.prototype._getCenteredViewportDimensions = function(pos) {
  var overviewStart = this._overview.localToStage(new DvtPoint(0, 0));
  var viewportDims = this._viewport.getDimensions();
  var centeredViewportX = (pos.x - overviewStart.x) - viewportDims.w/2;
  var centeredViewportY = (pos.y - overviewStart.y) - viewportDims.h/2;
  var topLeft = this.TransformFromViewportToContentCoords(centeredViewportX, centeredViewportY);
  var bottomRight = this.TransformFromViewportToContentCoords(centeredViewportX + viewportDims.w, centeredViewportY + viewportDims.h);
  return new DvtRectangle(topLeft.x, topLeft.y, bottomRight.x - topLeft.x, bottomRight.y - topLeft.y);
}

DvtOverviewWindow.prototype.SetViewportRectangle = function(rect) {
  this._viewport.setX(rect.x);
  this._viewport.setY(rect.y);
  this._viewport.setWidth(rect.w);
  this._viewport.setHeight(rect.h); 
};

DvtOverviewWindow.prototype.GetViewportRectangle = function() {
  return new DvtRectangle(this._viewport.getX(), this._viewport.getY(), this._viewport.getWidth(), this._viewport.getHeight()); 
};

/**
 * @override
 */
DvtOverviewWindow.prototype.getDimensions = function (targetCoordinateSpace) {
  var bounds = new DvtRectangle(0, 0, this._ww, this._hh);
  if (!targetCoordinateSpace || targetCoordinateSpace === this)
    return bounds;
  else { // Calculate the bounds relative to the target space
    return this.ConvertCoordSpaceRect(bounds, targetCoordinateSpace);
  }
}
// Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.


//TODO: remove focusEvent
/**
 * @extends DvtContainer
 * @constructor
 * @class DvtComboBox ComboBox UI control
 * @param {DvtContext} context Platform specific context object
 * @param {String} id Optional id for this object
 * @param {Object} styleMap The object containing style specifications for this component
 */
var DvtComboBox = function (context, id, styleMap) {
  this.Init(context, id, styleMap);
};

/*
 * make DvtComboBox a subclass of DvtContainer
 */
DvtObj.createSubclass(DvtComboBox, DvtContainer, "DvtComboBox");

DvtComboBox._HIDE_DROPDOWN_DELAY = 100;//in ms
DvtComboBox._DROPDOWN_OUTOFFOCUS_CHECK = 100;//in ms

/**
 * Initialization method called by the constructor
 * 
 * @param {DvtContext} context Platform specific context object
 * @param {String} id Optional id for this object
 * @param {object} styleMap The object containing style specifications for this component
 */
DvtComboBox.prototype.Init = function (context, id, styleMap)
{
  DvtComboBox.superclass.Init.call(this, context, null, id);
    
  this._styleMap = styleMap;

  //array of button states to use for main button when given item is selected
  this._itemButtonStates = [];
  this._items = [];
  this._tooltips = [];
  this._selectedIndex = 0;

  //flag indicating if the main button states should change when
  //the selected item changes
  this._bStaticButtonStates = false;

  //BUG FIX #10142865: flag indicating that the dropdown has been hidden and
  //should be removed
  this._bRemoveDropdown = false;

  this._maxItemDim = new DvtRectangle(0, 0, 0, 0);
  this._dim = new DvtRectangle(0, 0, 0, 0);

  this._tooltipManager = context.getTooltipManager();
  this._isTouchDevice = DvtAgent.isTouchDevice();

  //create the button representing the collapsed state
  this._button = this.createButton(id + "_cl");
  this.addChild(this._button);

  //create the content area of the button, which appears over the button 
  //itself instead of in the button so that the content doesn't
  //have to be copied for each button state
  this._contentArea = new DvtContainer(context);
  this._contentArea.setMouseEnabled(false);
  this.addChild(this._contentArea);

  //create timer to auto-hide the dropdown after focus moves out of combobox
  this._hideDropdownTimer = new DvtTimer(context, DvtComboBox._HIDE_DROPDOWN_DELAY, 
                                         this.HandleHideDropdownTimer, this, 1);
                                         
  this._outOfFocusCheckTimer = new DvtTimer(context, DvtComboBox._DROPDOWN_OUTOFFOCUS_CHECK, 
                                         this.HandleOutOfFocusCheckTimer, this, 1);
  this._dropdownItemClickEvent = false;
};


DvtComboBox.prototype._stopHideDropdownTimer = function() {
  if (this._hideDropdownTimer) {
    this._hideDropdownTimer.stop();
    this._hideDropdownTimer = null;
  }
};




/**
 * Get the index of the selected item.
 * @return {Number}  index of selected item
 */
DvtComboBox.prototype.getSelectedIndex = function () {
  return this._selectedIndex;
};

/**
 * Set the index of the selected item.
 * @param {Number} selectedIndex index of item to select
 */
DvtComboBox.prototype.setSelectedIndex = function (selectedIndex) {
  this._selectedIndex = selectedIndex;

  //only update the content if the states are not static
  if (! this._bStaticButtonStates) {
    //update the content area for the selected item
    this.UpdateContentArea();
  }

  this.FireChangeEvent(selectedIndex);
};

/**
 * Create the button representing the collapsed combo box.
 * @param {string} id Button id
 * @return {DvtButton} button representing the collapsed combo box
 */
DvtComboBox.prototype.createButton = function (id) {
  var button = new DvtButton(this.getCtx(), 
                             this.createUpState(id), 
                             this.createDownState(id), 
                             this.createOverState(id), 
                             null,
                             id);
  button.setCallback(this.HandleExpandClick, this);
  button.setCursor(DvtSelectionEffectUtils.getSelectingCursor());
  if (!this._isTouchDevice)
    button.addEvtListener(DvtMouseEvent.MOUSEDOWN, this.HandleButtonDown,  false, this);
  button.setToggleEnabled(true);
  return button;
};

/**
 * Create the "up" state of the collapsed combo box button.
 *
 * @return display object representing "up" state
 */
DvtComboBox.prototype.createUpState = function (id) {
  var context = this.getCtx();
  var dim = this.getDimensions();

  var s = new DvtRect(context, 0, 0, dim.w, dim.h, id + "_up");
  s.setCornerRadius(DvtButtonLAFUtils.ROUND_RECT_ELLIPSE);

  //Note: no border
  s.setInvisibleFill();

  s.addChild(DvtComboBox.DrawArrow(context, s.getWidth(), s.getHeight()));
  return s;
};

/**
 * Create the "over" state of the collapsed combo box button.
 *
 * @return display object representing "over" state
 */
DvtComboBox.prototype.createOverState = function (id) {
  var context = this.getCtx();
  var dim = this.getDimensions();

  var s = new DvtRect(context, 0, 0, dim.w, dim.h, id + "_up");
  s.setCornerRadius(DvtButtonLAFUtils.ROUND_RECT_ELLIPSE);

  s.setSolidStroke(DvtButtonLAFUtils.BORDER_COLOR);
//  s.setFill(new DvtGradientFill(DvtButtonLAFUtils.GRADIENT_LIGHT, 1));      // not passing arrays !!
s.setFill(new DvtLinearGradientFill(0, [DvtButtonLAFUtils.GRADIENT_DARK, DvtButtonLAFUtils.GRADIENT_LIGHT]));  //temp

  s.addChild(DvtComboBox.DrawArrow(context, s.getWidth(), s.getHeight()));
  return s;
};

/**
 * Create the "down" state of the collapsed combo box button.
 *
 * @return display object representing "down" state
 */
DvtComboBox.prototype.createDownState = function (id) {
  var context = this.getCtx();
  var dim = this.getDimensions();

  var s = new DvtRect(context, 0, 0, dim.w, dim.h, id + "_up");
  s.setSolidStroke(DvtButtonLAFUtils.BORDER_COLOR);
//  s.setFill(new DvtGradientFill(DvtButtonLAFUtils.GRADIENT_DARK, 1));     // not passing arrays!!
s.setFill(new DvtLinearGradientFill(0, [DvtButtonLAFUtils.GRADIENT_LIGHT, DvtButtonLAFUtils.GRADIENT_DARK]));   // temp
  s.setCornerRadius(DvtButtonLAFUtils.ROUND_RECT_ELLIPSE);

  s.addChild(DvtComboBox.DrawArrow(context, s.getWidth(), s.getHeight()));
  return s;
};

/**
  * Set the static button states to use for the main button.
  *
  * @param {DvtDisplayable} enaState  enabled state
  * @param {DvtDisplayable} ovrState  over state
  * @param {DvtDisplayable} dwnState  down state
  */
//  Note: this method is only called by panelCard
DvtComboBox.prototype.setStaticButtonStates = function (enaState, ovrState, dwnState) {
  this._button.setUpState(enaState);
  this._button.setDownState(dwnState);
  this._button.setOverState(ovrState);

  //set the flag indicating that the button states are static
  this._bStaticButtonStates = true;
};

/**
 * Add an item to the ComboBox.
 *
 * @param {DvtDisplayablej}  s          display object to add to the ComboBox
 * @param {String}           tooltip    tooltip to show for the item
 * @param {DvtDisplayable}   enaState   enabled state to use for item button in dropdown
 * @param {DvtDisplayable}   ovrState   over state to use for item button in dropdown
 * @param {DvtDisplayable}   dwnState   down state to use for item button in dropdown
 */
DvtComboBox.prototype.addItem = function (obj, tooltip, enaState, ovrState, dwnState)
{
   obj.setMouseEnabled(false);                //disable mouse interaction with item

   this._items.push(obj);
   this._tooltips.push(tooltip);

  // get/set max item width & height

  var itdim      = DvtButtonLAFUtils._getDimForced(this.getCtx(), (enaState? enaState : obj));
  var maxItemDim = this._getMaxItemDim();
  var dim        = this.getDimensions();
  var context    = this.getCtx() ;

  if (itdim.w > maxItemDim.w) {
    maxItemDim.w = itdim.w;
    dim.w = itdim.w + 16;
  }
  if (itdim.h > maxItemDim.h) {
    maxItemDim.h = itdim.h;
    dim.h = itdim.h;
  }
  this._maxItemDim = maxItemDim ;


  //store the array of states for the item button in the dropdown
  var buttonStates = null;

  if (enaState && ovrState && dwnState) {
    buttonStates = [];
    buttonStates[DvtButton.STATE_ENABLED] = enaState;
    buttonStates[DvtButton.STATE_OVER]    = ovrState;
    buttonStates[DvtButton.STATE_DOWN]    = dwnState;
  }
  this._itemButtonStates.push(buttonStates);

  //only create a new button and update the content if the states are not static
  if (! this._bStaticButtonStates) {
    //create a new button, taking the new item's dimensions into account
    this.removeChild(this._button);
    this._button = this.createButton(obj.getId());
    this.addChildAt(this._button, 0);

    //update the content area for the selected item
    this.UpdateContentArea();
  }
};

/**
 * Get an item in the ComboBox.
 *
 * @param i index of the item to get
 *
 * @return Sprite item in the ComboBox
 */
DvtComboBox.prototype.getItem = function (i) {
  return this._items[i];
};

/**
 * Get the number of items in the ComboBox.
 *
 * @return number of items in the ComboBox
 */
DvtComboBox.prototype.getItemCount = function () {
  return this._items.length;
};

/**
 * Get the index of the item in the ComboBox.
 *
 * @param s item to get index for
 *
 * @return index of the item in the ComboBox, or -1 if not found
 */
DvtComboBox.prototype.getItemIndex = function (s) {
  for (var i = 0;i < this.getItemCount();i++) {
    if (this.getItem(i) === s)
      return i;
  }
  return  - 1;
};

/**
 * Get the selected item.
 *
 * @return selected item
 */
DvtComboBox.prototype.getSelectedItem = function () {
  var selIndex = this.getSelectedIndex();
  if (selIndex < 0 || selIndex > this._items.length - 1)
    return null;

  return this._items[selIndex];
};

/**
 * Fire a change event.
 *
 * @param index index of the selected item
 *
 * @return true if event was successfully dispatched, false otherwise
 */
DvtComboBox.prototype.FireChangeEvent = function (index) {
  var comboBoxEvent = new DvtComboBoxEvent(DvtComboBoxEvent.SUBTYPE_ITEM_CHANGE, index, this._event);
  this._event = null;
  this.FireListener(comboBoxEvent);

  return true;
};

/**
 * Handle a click on the collapsed combo box to show its dropdown.
 *
 * @param  {MouseEvent}   event
 */
DvtComboBox.prototype.HandleExpandClick = function (event)
{
 
  DvtEventManager.consumeEvent(event);    //don't want click to fall through to other components

  //BUG FIX #10142865: if the previous dropdown was hidden but hasn't been
  //removed yet, then remove it now before the new dropdown is created
  if (this._bRemoveDropdown) {
    this.RemoveDropdown();
  }

  var context = this.getCtx() ;
  
  //create the dropdown containing all the items
  this._dropdown = this.createDropdown();
  var dddim =   DvtButtonLAFUtils._getDimForced(context, this._dropdown);
  this.addChild(this._dropdown);
  
  var dim = this._button.getDimensions();

  //BiDi: in right-to-left locale, shift dropdown towards the left
  var transX;
  if (DvtAgent.isRightToLeft(context)) {
    transX = - dddim.w + dim.w*1/4;
  }
  //position the dropdown relative to the button (based on UI spec)
  else {
    transX = dim.w*3/4;
  }
  this._dropdown.setTranslate(transX, dim.h*3/4);

  //disable the expand button until the dropdown is dismissed
  this._button.setMouseEnabled(false);
  this._button.setToggled(true);

  this.FireListener(new DvtComboBoxEvent(DvtComboBoxEvent.SUBTYPE_SHOW_DROPDOWN));

  //add a mouse focus change listener to the stage to detect
  //when we should auto-hide the dropdown
  var stage = context.getStage();
  if (stage) {  
    if (this._isTouchDevice) {
      stage.addEvtListener(DvtTouchEvent.TOUCHSTART, this.HandleStageMouseFocusChange, true, this);
    } else {
      stage.addEvtListener(DvtMouseEvent.MOUSEUP, this.HandleStageMouseFocusChange, true, this);
    }
  }
};

/**
 * Handle an event from the timer used to auto-hide the dropdown.
 *
 * @param event TimerEvent
 */
DvtComboBox.prototype.HandleHideDropdownTimer = function (event) {
  //hide the dropdown
  this.HideDropdown();

  //only update the content if the button states are not static
  if (! this._bStaticButtonStates) {
    //update the content area to show the currently selected item
    this.UpdateContentArea();
  }
};

/**
 * Handle a mouse focus change event on the stage.
 *
 * @param even FocusEvent
 */
DvtComboBox.prototype.HandleStageMouseFocusChange = function (event) {

  this._dropdownItemClickEvent = false;
  this._outOfFocusCheckTimer.reset();
  this._outOfFocusCheckTimer.start();
};

/**
 * Handle an event from the timer used to check focus change.
 * If the user clicked outside of the dropdown - hide the dropdown
 *
 * @param event TimerEvent
 */
DvtComboBox.prototype.HandleOutOfFocusCheckTimer = function (event) {
  if (!this._dropdownItemClickEvent) {
    //reset and start the timer to auto-hide the dropdown;
    //the timer will be stopped if an item in the dropdown was selected
    this._hideDropdownTimer.reset();
    this._hideDropdownTimer.start(); 
  }
};

/**
 * Create the dropdown showing all the available items to select.
 *
 * @return {DvtPath} display object representing the dropdown
 */
DvtComboBox.prototype.createDropdown = function () {
  //constants for padding around items in dropdown
  var comboBoxStyles =  this._styleMap ?  this._styleMap['comboBox'] : null;
  var topPadding = DvtStyleUtils.getStyle(comboBoxStyles,DvtPanZoomControlPanel.CP_PADDING_TOP,0);
  var leftPadding = DvtStyleUtils.getStyle(comboBoxStyles,DvtPanZoomControlPanel.CP_PADDING_LEFT,0);
  var bottomPadding = DvtStyleUtils.getStyle(comboBoxStyles,DvtPanZoomControlPanel.CP_PADDING_BOTTOM,0);
  var rightPadding = DvtStyleUtils.getStyle(comboBoxStyles,DvtPanZoomControlPanel.CP_PADDING_RIGHT,0);
  var interItemPadding = DvtStyleUtils.getStyle(comboBoxStyles,DvtPanZoomControlPanel.CP_PADDING_INNER,0);

  var currY = topPadding;
  var context = this.getCtx();
  var dim;
  var itemSprite;
  var item;

  var content = new DvtContainer(context, "__dd");
  for (var i = 0; i < this._items.length; i++) {
    item = this._items[i];
    dim = DvtButtonLAFUtils._getDimForced(context, item);

    //move each item below the previous one
    itemSprite = new DvtContainer(context, "__it" + i);
    itemSprite.setTranslate(leftPadding, currY);

    itemSprite.addChild(item);
    item.setMouseEnabled(true);
    item.setCursor(DvtSelectionEffectUtils.getSelectingCursor());

    currY += dim.h + interItemPadding;

    //add event listeners to each item
    if (this._eventManager) {
      var proxy = new DvtPanZoomControlPanelEventHandlerProxy(this, this.HandleDropdownItemClick, this.HandleButtonDown, 
                                                    null, null, null,
                                                    this._tooltips[i]);    
      this._eventManager.associate(item, proxy);      
    }
    content.addChild(itemSprite);
  }

  var dd = DvtButtonLAFUtils.drawDropdownShape(context, 
                                               this._getMaxItemDim().w + leftPadding + rightPadding,
                                               currY + bottomPadding - interItemPadding, comboBoxStyles);
  dd.addChild(content);

  //draw the background behind all the items now that we know the size of the dropdown
  var borderColor = DvtStyleUtils.getStyle(this._styleMap,DvtCSSStyle.BORDER_COLOR,null);
  var borderAlpha = DvtStyleUtils.getStyle(this._styleMap,DvtPanZoomControlPanel.FRAME_ROLLOUT_ALPHA,1);
  var bgColor =  DvtStyleUtils.getStyle(this._styleMap,DvtCSSStyle.BACKGROUND_COLOR,null);
  var bgAlpha =  DvtStyleUtils.getStyle(this._styleMap,DvtPanZoomControlPanel.BG_ALPHA,1);
  
  dd.setSolidStroke(borderColor, borderAlpha);  
  if (bgColor)
    dd.setSolidFill(bgColor, bgAlpha);

  return dd;
};


/**
 * Handle a mouse down
 *
 * @param event MouseEvent
 */
DvtComboBox.prototype.HandleButtonDown = function (event) {
  // logEvent(event, "DvtCombo");
  DvtEventManager.consumeEvent();
}

/**
 * Handle a mouse click on an item in the dropdown.
 *
 * @param event MouseEvent
 */
DvtComboBox.prototype.HandleDropdownItemClick = function (event) {
  // logEvent(event, "DvtCombo");
  this._dropdownItemClickEvent = true;

  //stop the dropdown auto-hide timer
  this._hideDropdownTimer.stop();
//   this._hideDropdownTimer = null;

  //don't want click to fall through to other components
  DvtEventManager.consumeEvent(event);

  //update after the event so that animation is smooth
  // event.updateAfterEvent();

  //hide the dropdown and set the new selected item index
  //get the root sprite of the item
  var eventTarget = DvtComboBox.getRootDropdownItemSprite(event.target);

  var index;
  //get the index of the item
  if (this._dropdown && eventTarget) {
    var content = this._dropdown.getChildAt(0);
    if (content) {
      index = content.getChildIndex(eventTarget);
    }
  }

  this.HideDropdown();

  //Note: this._event is clear after firing
  this._event = event;

  this.setSelectedIndex(index);

};

/**
 * Get the root DropdownItemSprite of the given object in the dropdown.
 *
 * @param displayObject display object in an item in the dropdown
 *
 * @return root DropdownItemSprite parent for the object
 */
DvtComboBox.getRootDropdownItemSprite = function (displayObject) {
  var n;
  var id;
  while (displayObject) {
    id = displayObject.getId();
    if (id && displayObject instanceof DvtContainer && id.substr(0, 4) == "__it" ) {
      n = displayObject;
      break;
    }
    displayObject = displayObject.getParent();
  }

  return n;
};

/**
 * Hide the dropdown and enable the main button again.
 */
DvtComboBox.prototype.HideDropdown = function () {

  if (this._dropdown) {
    this._dropdown.setVisible(false);
    this._button.setToggled(false);
    this.FireListener(new DvtComboBoxEvent(DvtComboBoxEvent.SUBTYPE_HIDE_DROPDOWN));
    //BUG FIX #10142865: don't remove the dropdown yet, because we want 
    //the item the mouse was over to register a mouse rollout event
    //first so that when we next show the dropdown, which will contain
    //the same item, the item won't appear to be highlighted at first;
    //instead, just set the flag to remove the dropdown later
    //this._dropdown.getParent().removeChild(this._dropdown);
    //this._dropdown = null;
    this._bRemoveDropdown = true;
  }

  //remove the mouse focus change listener from the stage now
  //that the dropdown is no longer visible
  //bug 9885226: ACC:keyBoard togggle for show/hide controlPanel is borken
  var stage = this.getCtx().getStage();
  if (stage) {
    if (this._isTouchDevice) {
      stage.removeEvtListener(DvtTouchEvent.TOUCHSTART, this.HandleStageMouseFocusChange, true, this);
    } else {
      stage.removeEvtListener(DvtMouseEvent.MOUSEUP, this.HandleStageMouseFocusChange, true, this);
    }
  }
  //enable expand button again
  this._button.setMouseEnabled(true);
};

/**
 * Remove the dropdown from the display list.
 */
DvtComboBox.prototype.RemoveDropdown = function () {
  //BUG FIX #10142865: remove the dropdown from the display list after
  //the item in it has had time to register a mouse rollout event
  //so that it doesn't appear to be highlighted the next time the
  //dropdown is displayed
  //turn off the flag because we're removing the dropdown now
  this._bRemoveDropdown = false;
  if (this._dropdown) {
    this._dropdown.setVisible(false);
    this._dropdown.getParent().removeChild(this._dropdown);
    this._dropdown = null;
  }
};

/**
 * Get the maximum size of the items.
 *
 * @return maximum size of the items
 */
DvtComboBox.prototype._getMaxItemDim = function () {
  return this._maxItemDim;
};

/**
 * @override
 */
DvtComboBox.prototype.getDimensions = function () {
  return this._dim;
};

/**
 * Update the content area of the collapsed combo box to
 * show the selected item.
 */
DvtComboBox.prototype.UpdateContentArea = function () {
  //flag indicating if the content should re-use the item itself
  var bUseItem = true;

  //if the states for the main button are specified by the item,
  //then use them
  var selIndex = this.getSelectedIndex();
  if (this._itemButtonStates && this._itemButtonStates.length > selIndex) {

    var buttonStates = this._itemButtonStates[selIndex];
    if (buttonStates && buttonStates.length > 2) {
      this._button.setUpState(buttonStates[DvtButton.STATE_ENABLED]);
      this._button.setOverState(buttonStates[DvtButton.STATE_OVER]);
      this._button.setDownState(buttonStates[DvtButton.STATE_DOWN]);

      //toggle the flag because the button states are specified
      bUseItem = false;
    }
  }

  //if using the item itself in the button, update the content with it
  if (bUseItem) {
    //remove old content
    if (this._contentArea.getNumChildren () > 0) {
      this._contentArea.removeChildAt(0);
    }
    //add currently selected item
    this._contentArea.addChild(this.getSelectedItem());
  }
};

/**
 * Draw the arrow in the collapsed combo box button.
 *
 * @param s Sprite in which to draw arrow
 */
DvtComboBox.DrawArrow = function (context, ww, hh) {
  var padding = 4;

  var aPoints = [];
  aPoints.push(ww - 12, hh / 2 - padding / 2);
  aPoints.push(ww - 4,  hh / 2 - padding / 2);
  aPoints.push(ww - 8,  hh / 2 + padding / 2);
  aPoints.push(ww - 12, hh / 2 - padding / 2);

  var shape = new DvtPolygon(context, aPoints, null);
  shape.setSolidStroke(DvtButtonLAFUtils.BORDER_COLOR);
  shape.setSolidFill(DvtButtonLAFUtils.BORDER_COLOR);
  shape.setMouseEnabled(false);

  return shape;
};

/**
 * Hide the dropdown and enable the main button again.
 */
DvtComboBox.prototype.closeDropdown = function () {
  this.HideDropdown();
};

DvtComboBox.prototype.setEventManager = function (eventManager) {
  this._eventManager = eventManager;
};

/**
 * @constructor
 * DropdownItemSprite Class to use as item in dropdown.
 */
var DropdownItemSprite = function (context, x, y, w, h, id) {
  this.Init(context, x, y, w, h, id);
};

/*
 * make DropdownItemSprite a subclass of DvtRect
 */
DvtObj.createSubclass(DropdownItemSprite, DvtRect, "DropdownItemSprite");

DropdownItemSprite.prototype.Init = function (context, x, y, w, h, id) {
  DvtRect.superclass.Init.call(this, context);
};


/**
 * @constructor
 * 
 * @param {string} subtype The type of DvtComboBoxEvent
 * @param {number} index The selected index, if this is a SUBTYPE_ITEM_CHANGE event
 * @param {DvtBaseEvent} evt the base event that caused this DvtComboBoxEvent
 */
var DvtComboBoxEvent = function (subtype, index, evt) {
    this.Init(subtype, index, evt);
}

/**
 * The type of this event
 * 
 * @const
 */
DvtComboBoxEvent.TYPE = 'comboBoxEvent';

/**
 * This event subtype is fired when the combo box selection changes
 * 
 * @const
 */
DvtComboBoxEvent.SUBTYPE_ITEM_CHANGE = 'cbItemChange';

/**
 * This event subtype is fired when the dropdown is shown
 * 
 * @const
 */
DvtComboBoxEvent.SUBTYPE_SHOW_DROPDOWN = 'cbShowDropdown';

/**
 * This event subtype is fired when the dropdown is hidden
 * 
 * @const
 */
DvtComboBoxEvent.SUBTYPE_HIDE_DROPDOWN = 'cbHideDropdown';

DvtObj.createSubclass(DvtComboBoxEvent, DvtBaseEvent, "DvtComboBoxEvent");

/**
 * Initialization method called by the constructor.
 *
 * @param {string} subtype The subtype of DvtComboBoxEvent
 * @param {number} index The selected index, if this is a SUBTYPE_ITEM_CHANGE event
 * @param {DvtBaseEvent} evt the base event that caused this DvtComboBoxEvent
 */
DvtComboBoxEvent.prototype.Init = function (subtype, index, evt) {
  DvtComboBoxEvent.superclass.Init.call(this, DvtComboBoxEvent.TYPE);

  if (index === undefined) {
    index = -1;
  }
  this.subtype = subtype;
  this._index = index;
  this._evt = evt;
};

/**
 * Get the index of the selected item.
 *
 * @return index of the selected item
 */
DvtComboBoxEvent.prototype.getIndex = function () {
  return this._index;
}
/**
 * @constructor
 * Base Class for PanZoomControl
 */
var DvtBasePanZoomControl = function (context, panZoomCanvas, resources) {
  this.Init(context, panZoomCanvas, resources);
};


/*
 * make DvtBasePanZoomControl a subclass of DvtContainer
 */
DvtObj.createSubclass(DvtBasePanZoomControl, DvtContainer, "DvtBasePanZoomControl");

/*--------------------------------------------------------------------*/
/*  Init()                                                            */
/*--------------------------------------------------------------------*/
DvtBasePanZoomControl.prototype.Init = function (context, panZoomCanvas, resources) {
  DvtBasePanZoomControl.superclass.Init.call(this, context);

  this._panZoomCanvas = panZoomCanvas;
  this._context = context;
  this._tooltipManager = context.getTooltipManager();
  this._resources = resources;
}
    
/**
 * Set the tooltip manager to use.
 * 
 * @param tooltipManager manager to use
 */
DvtBasePanZoomControl.prototype.setTooltipManager = function (tooltipManager) {
  this._tooltipManager = tooltipManager;
}
  
/**
 * Get the tooltip manager being used.
 * 
 * @return tooltipManager being used
 */
DvtBasePanZoomControl.prototype.getTooltipManager = function () {
  return this._tooltipManager;
}
    
/**
 * Set the translated resources to use.
 * 
 * @param resources translated resources
 */
DvtBasePanZoomControl.prototype.setResources = function (resources) {
  this._resources = resources;
}
  
/**
 * Get the translated resources to use.
 * 
 * @return translated resources
 */
DvtBasePanZoomControl.prototype.getResources = function () {
  if (this._resources == null) {
    this._resources = new DvtPanZoomControlPanelResources();
  }
  return this._resources;
}



/**
 * Show tooltip
 * 
 * @return tooltip text to display
 */
DvtBasePanZoomControl.prototype.ShowTooltip = function (event, tooltip) {
  this.getTooltipManager().showTooltip(event.pageX, event.pageY, 
                                       tooltip, event.target);
}
    
/**
 * Hide tooltip
 */
DvtBasePanZoomControl.prototype.HideTooltip = function () {
  this.getTooltipManager().hideTooltip();
}
    

DvtBasePanZoomControl.prototype._logEvent = function (event) {
//  var name = this.getTypeName();
//  if (name === "DvtPanControl") {
//    logEvent(event, name);
//  }
}
    
/**
 * @constructor
 * ZoomInButton for use with Diagram.
 */
var DvtZoomInButton = function (context, button, panZoomCanvas, resources, eventManager) {
  this.Init(context, button, panZoomCanvas, resources, eventManager);
};

DvtZoomInButton._ZOOM_INCR_TIMER_INTERVAL = 100;//in ms
DvtZoomInButton._ZOOM_START_TIMER_INTERVAL = 250;//in ms

/*
 * make DvtZoomInButton a subclass of DvtBasePanZoomControl
 */
DvtObj.createSubclass(DvtZoomInButton, DvtBasePanZoomControl, "DvtZoomInButton");

/**
 * Helper method called by the constructor to initialize this object.
 * @param {DvtContext} context An object maintaining application specific context, as well as well as providing
 *                             access to platform specific data and objects, such as the factory
 * @param {DvtButton} button A button used by the control
 * @param {DvtPanZoomCanvas} canvas The PanZoomCanvas this control will be associated with
 * @param {DvtXmlNode} resources The map of translated resource strings
 * @param {DvtEventManager} eventManager An event manager to handle events for the control
 */
DvtZoomInButton.prototype.Init = function (context, button, panZoomCanvas, resources, eventManager) {
  DvtZoomInButton.superclass.Init.call(this, context, panZoomCanvas, resources);

  this._bZoomInMouseDown = false;
  this._zoomInTimer = new DvtTimer(context, DvtZoomInButton._ZOOM_INCR_TIMER_INTERVAL,
                                   this.HandleZoomInTimer, this);

  //BUG FIX #10037201: delay the start of the zoom in timer so that there is
  //less chance that it will interfere with a slow, regular click
  this._zoomStartTimer = new DvtTimer(context, DvtZoomInButton._ZOOM_START_TIMER_INTERVAL, 
                                      this.HandleZoomStartTimer, this, 1);

  this._zoomInButton = button;
  this._zoomInButton.setCallback(this.HandleZoomInClick, this);
  this._eventManager = eventManager;
  var proxy = new DvtPanZoomControlPanelEventHandlerProxy(this, null, this.HandleZoomInMouseDown, 
                                                    this.HandleZoomInMouseUp, this.HandleZoomInMouseUp, null,
                                                    this.getResources().getZoomInTooltip());
  this._eventManager.associate(this._zoomInButton, proxy);
  this.addChild(this._zoomInButton);
}

/**
 *this.Handle a mouse click on the zoom in button.
 *
 * @param event MouseEvent
 */
DvtZoomInButton.prototype.HandleZoomInClick = function (event) {
  this._logEvent(event);

  //don't respond to click event if the timer had been 
  //continuously zooming
  if (this._zoomInTimer.isRunning()) {
    return;
  }
  var currZoom = this._panZoomCanvas.getZoom();
  var newZoom = this._panZoomCanvas.getNextZoomLevel(currZoom);
  //trace("zoomIn: " + currZoom + " to " + newZoom);

  var animator = new DvtAnimator(this.getCtx(), this._panZoomCanvas.getAnimationDuration());
  this._panZoomCanvas.zoomTo(newZoom, undefined, undefined, animator);
  animator.play();
}

/**
 *this.Handle a mouse down on the zoom in button.
 *
 * @param event MouseEvent
 */
DvtZoomInButton.prototype.HandleZoomInMouseDown = function (event) {
  this._logEvent(event);

  this._bZoomInMouseDown = true;

  //reset the timers and start the initial delay timer
  //TODO   this._zoomInTimer.reset();
  this._zoomInTimer.stop();

  //BUG FIX #10037201: delay the start of the zoom in timer so that there is
  //less chance that it will interfere with a slow, regular click
  //TODO   this._zoomStartTimer.reset();
  this._zoomStartTimer.stop();
  this._zoomStartTimer.start();
}

/**
 *this.Handle a mouse up on the zoom in button.
 *
 * @param event MouseEvent
 */
DvtZoomInButton.prototype.HandleZoomInMouseUp = function (event) {
  if (this._bZoomInMouseDown) {
    this._logEvent(event);

    this._bZoomInMouseDown = false;

    //stop the timers
    this._zoomInTimer.stop();
    this._zoomStartTimer.stop();
  }

}

/**
 *this.Handle an event from the start timer.
 *
 * @param event TimerEvent
 */
DvtZoomInButton.prototype.HandleZoomStartTimer = function (event) {
  //start the zoom in timer
  this._zoomInTimer.start();
}

/**
 *this.Handle a zoom in timer event to zoom in on the view.
 *
 * @param event TimerEvent
 */
DvtZoomInButton.prototype.HandleZoomInTimer = function (event) {
  var currZoom = this._panZoomCanvas.getZoom();
  var newZoom = this._panZoomCanvas.getNextZoomLevel(currZoom);

  this._panZoomCanvas.zoomTo(newZoom);
}

DvtZoomInButton.prototype._stopTimer = function() {
  if (this._zoomInTimer) {
    this._zoomInTimer.stop();
    this._zoomInTimer = null;
  }
  if (this._zoomStartTimer) {
    this._zoomStartTimer.stop();
    this._zoomStartTimer = null;
  }
};

/**
 * Sets button state
 * @param {boolean} enabled True to enable the button
 */
DvtZoomInButton.prototype.setEnabled = function(enabled) {
  this._zoomInButton.setCursor(enabled ? DvtSelectionEffectUtils.getSelectingCursor() : null);
  this._zoomInButton.setEnabled(enabled);
  this._zoomInButton.initState();
}
/**
 * @constructor
 * ZoomOutButton for use with Diagram.
 */
var DvtZoomOutButton = function (context, button, panZoomCanvas, resources, eventManager) {
  this.Init(context, button, panZoomCanvas, resources, eventManager);
};

DvtZoomOutButton._ZOOM_INCR_TIMER_INTERVAL = 100;//in ms
DvtZoomOutButton._ZOOM_START_TIMER_INTERVAL = 250;//in ms

/*
 * make DvtZoomOutButton a subclass of DvtBasePanZoomControl
 */
DvtObj.createSubclass(DvtZoomOutButton, DvtBasePanZoomControl, "DvtZoomOutButton");

/**
 * Helper method called by the constructor to initialize this object.
 * @param {DvtContext} context An object maintaining application specific context, as well as well as providing
 *                             access to platform specific data and objects, such as the factory
 * @param {DvtButton} button A button used by the control
 * @param {DvtPanZoomCanvas} canvas The PanZoomCanvas this control will be associated with
 * @param {DvtXmlNode} resources The map of translated resource strings
 * @param {DvtEventManager} eventManager An event manager to handle events for the control
 */
DvtZoomOutButton.prototype.Init = function (context, button, panZoomCanvas, resources, eventManager) {
  DvtZoomOutButton.superclass.Init.call(this, context, panZoomCanvas, resources);
  this._bZoomOutMouseDown = false;
  this._zoomOutTimer = new DvtTimer(context, DvtZoomOutButton._ZOOM_INCR_TIMER_INTERVAL,
                                    this.HandleZoomOutTimer, this);

  //BUG FIX #10037201: delay the start of the zoom out timer so that there is
  //less chance that it will interfere with a slow, regular click
  this._zoomStartTimer = new DvtTimer(context, DvtZoomOutButton._ZOOM_START_TIMER_INTERVAL, 
                                      this.HandleZoomStartTimer, this, 1);
  this._zoomOutButton = button;
  this._zoomOutButton.setCallback(this.HandleZoomOutClick, this);
  //this._zoomOutButton.setCursor(DvtSelectionEffectUtils.getSelectingCursor());  
  this._eventManager = eventManager;
  var proxy = new DvtPanZoomControlPanelEventHandlerProxy(this, null, this.HandleZoomOutMouseDown, 
                                                    this.HandleZoomOutMouseUp, this.HandleZoomOutMouseUp, null, 
                                                    this.getResources().getZoomOutTooltip());
  this._eventManager.associate(this._zoomOutButton, proxy);

  this.addChild(this._zoomOutButton);
}

/**
 *this.Handle a mouse click on the zoom out button.
 *
 * @param event MouseEvent
 */
DvtZoomOutButton.prototype.HandleZoomOutClick = function (event) {
  this._logEvent(event);

  //don't respond to click event if the timer had been 
  //continuously zooming
  if (this._zoomOutTimer.isRunning()) {
    return;
  }  
  var currZoom = this._panZoomCanvas.getZoom();
  var newZoom = this._panZoomCanvas.getPrevZoomLevel(currZoom);
  //trace("zoomOut: " + currZoom + " to " + newZoom);
  var context = this.getCtx();
  var animator = new DvtAnimator(context, this._panZoomCanvas.getAnimationDuration());

  this._panZoomCanvas.zoomTo(newZoom, undefined, undefined, animator);

  animator.play();
}

/**
 *this.Handle a mouse down on the zoom out button.
 *
 * @param event MouseEvent
 */
DvtZoomOutButton.prototype.HandleZoomOutMouseDown = function (event) {
  this._logEvent(event);

  this._bZoomOutMouseDown = true;

  //reset the timers and start the initial delay timer
  //   this._zoomOutTimer.reset();
  this._zoomOutTimer.stop();

  //BUG FIX #10037201: delay the start of the zoom out timer so that there is
  //less chance that it will interfere with a slow, regular click
  //   this._zoomStartTimer.reset();
  this._zoomStartTimer.stop();
  this._zoomStartTimer.start();
}

/**
 *this.Handle a mouse up on the zoom out button.
 *
 * @param event MouseEvent
 */
DvtZoomOutButton.prototype.HandleZoomOutMouseUp = function (event) {
  if (this._bZoomOutMouseDown) {
    this._logEvent(event);

    this._bZoomOutMouseDown = false;

    //stop the timers
    this._zoomOutTimer.stop();
    this._zoomStartTimer.stop();
  }
}


/**
 *this.Handle an event from the start timer.
 *
 * @param event TimerEvent
 */
DvtZoomOutButton.prototype.HandleZoomStartTimer = function (event) {
  //start the zoom out timer
  this._zoomOutTimer.start();
}

/**
 *this.Handle a zoom out timer event to zoom out on the view.
 *
 * @param event TimerEvent
 */
DvtZoomOutButton.prototype.HandleZoomOutTimer = function (event) {
  var currZoom = this._panZoomCanvas.getZoom();
  var newZoom = this._panZoomCanvas.getPrevZoomLevel(currZoom);

  this._panZoomCanvas.zoomTo(newZoom);
}

DvtZoomOutButton.prototype._stopTimer = function() {
  if (this._zoomOutTimer) {
    this._zoomOutTimer.stop();
    this._zoomOutTimer = null;
  }
  if (this._zoomStartTimer) {
    this._zoomStartTimer.stop();
    this._zoomStartTimer = null;
  }
};

/**
 * Sets button state
 * @param {boolean} enabled True to enable the button
 */
DvtZoomOutButton.prototype.setEnabled = function(enabled) {
  this._zoomOutButton.setCursor(enabled ? DvtSelectionEffectUtils.getSelectingCursor() : null);
  this._zoomOutButton.setEnabled(enabled);
  this._zoomOutButton.initState();
}
/**
 * @constructor
 * ZoomToFitButton for use with Diagram.
 */
var DvtZoomToFitButton = function (context, button, panZoomCanvas, resources, eventManager) {
  this.Init(context, button, panZoomCanvas, resources, eventManager);
};

/*
 * make DvtZoomToFitButton a subclass of DvtBasePanZoomControl
 */
DvtObj.createSubclass(DvtZoomToFitButton, DvtBasePanZoomControl, "DvtZoomToFitButton");

/**
 * Helper method called by the constructor to initialize this object.
 * @param {DvtContext} context An object maintaining application specific context, as well as well as providing
 *                             access to platform specific data and objects, such as the factory
 * @param {DvtButton} button A button used by the control
 * @param {DvtPanZoomCanvas} canvas The PanZoomCanvas this control will be associated with
 * @param {DvtXmlNode} resources The map of translated resource strings
 * @param {DvtEventManager} eventManager An event manager to handle events for the control
 */
DvtZoomToFitButton.prototype.Init = function (context, button, panZoomCanvas, resources, eventManager) {
  DvtZoomToFitButton.superclass.Init.call(this, context, panZoomCanvas, resources);

  this._zoomToFitButton = button;
  this._zoomToFitButton.setCallback(this.HandleZoomToFitClick, this);
  this._zoomToFitButton.setCursor(DvtSelectionEffectUtils.getSelectingCursor());
  this._eventManager = eventManager;
  var proxy = new DvtPanZoomControlPanelEventHandlerProxy(this, null, null, 
                                                    null, null, null, 
                                                    this.getResources().getZoomToFitTooltip());  
  this._eventManager.associate(this._zoomToFitButton, proxy);
  
  this.addChild(this._zoomToFitButton);
}

/**
 * Handle a mouse click on the zoom to fit button.
 *
 * @param event MouseEvent
 */
DvtZoomToFitButton.prototype.HandleZoomToFitClick = function (event) {
  this._logEvent(event);

  var animator = new DvtAnimator(this.getCtx(), this._panZoomCanvas.getAnimationDuration());
  this._panZoomCanvas.zoomToFit(animator);
  animator.play();
};



/**
 * @constructor
 * ZoomSlider for use with Diagram.
 */
var DvtZoomSlider = function (context, panZoomCanvas, resources, zoomLevels, zoomLevelsTooltips, minScale, maxScale) {
  this.Init(context, panZoomCanvas, resources, zoomLevels, zoomLevelsTooltips, minScale, maxScale);
};

DvtZoomSlider.DEFAULT_ZOOM_LEVELS = [0, .25, .5, .75, 1];
DvtZoomSlider.ZOOM_SLIDER_HEIGHT = 76;
DvtZoomSlider.ZOOM_SLIDER_WIDTH = 15;

/*
 * make DvtZoomSlider a subclass of DvtBasePanZoomControl
 */
DvtObj.createSubclass(DvtZoomSlider, DvtBasePanZoomControl, "DvtZoomSlider");

/*--------------------------------------------------------------------*/
/*  Init()                                                            */
/*--------------------------------------------------------------------*/
DvtZoomSlider.prototype.Init = function (context, panZoomCanvas, resources, zoomLevels, zoomLevelsTooltips, minScale, maxScale) {
  DvtZoomSlider.superclass.Init.call(this, context, panZoomCanvas, resources);

  this._zoomLevels = DvtZoomSlider.DEFAULT_ZOOM_LEVELS;
  this._bZoomSliderThumbMouseDown = false;
  this._panZoomCanvas.addEvtListener(ZoomEvent.ZOOM, this.HandleZoomEvent, false, this);

  if (!zoomLevels)
    zoomLevels = DvtZoomSlider.DEFAULT_ZOOM_LEVELS;
  this._zoomLevels = zoomLevels;

  this._zoomLevelsTooltips = zoomLevelsTooltips;
  if (!minScale)
    minScale = 0;
  if (!maxScale)
    maxScale = 1;
  this._minScale = minScale;
  this._maxScale = maxScale;

  this.Render();

}

DvtZoomSlider.prototype.getZoomLevels = function () {
  return this._zoomLevels;
}

/**
 * Set the tooltips for the discrete zoom levels in the zoom slider.
 *
 * @param zoomLevelsTooltips tooltips for discrete zoom levels in zoom slider
 */
DvtZoomSlider.prototype.setZoomLevelsTooltips = function (zoomLevelsTooltips) {
  this._zoomLevelsTooltips = zoomLevelsTooltips;

  this.AddZoomSliderCrosslinesTooltipListeners();
}

/**
 * Get the tooltips for the discrete zoom levels in the zoom slider.
 *
 * @return tooltips for discrete zoom levels in zoom slider
 */
DvtZoomSlider.prototype.getZoomLevelsTooltips = function () {
  return this._zoomLevelsTooltips;
}

DvtZoomSlider.prototype.AddZoomSliderCrosslinesTooltipListeners = function () {
  var zoomLevelsTooltips = this.getZoomLevelsTooltips();
  var numZoomLevelsTooltips = 0;
  if (zoomLevelsTooltips)
    numZoomLevelsTooltips = zoomLevelsTooltips.length;

  var crossline;
  var zoomLevelTooltip;
  var numCrosslines = 0;
  if (this._zoomSliderCrosslines)
    numCrosslines = this._zoomSliderCrosslines.length;

  for (var i = 0;i < numCrosslines;i++) {
    if (i < numZoomLevelsTooltips) {
      crossline = this._zoomSliderCrosslines[i];
      zoomLevelTooltip = zoomLevelsTooltips[i];
      if (zoomLevelTooltip != null && zoomLevelTooltip.length > 0) {
        if (!crossline.hasEventListener(DvtMouseEvent.MOUSEOVER)) {
          crossline.addEvtListener(DvtMouseEvent.MOUSEOVER, this.HandleZoomSliderCrosslineRollOver, false, 0, true);
        }
        if (!crossline.hasEventListener(DvtMouseEvent.MOUSEOUT)) {
          crossline.addEvtListener(DvtMouseEvent.MOUSEOUT, this.HandleZoomSliderCrosslineRollOut, false, 0, true);
        }
      }
    }
  }
}

/**
 * Create the zoom slider.
 *
 * @return zoom slider
 */
DvtZoomSlider.prototype.Render = function () {
  this._zoomSliderCrosslines = [];

  var zoomLevels = this.getZoomLevels();
  var numZoomLevels = 0;
  if (zoomLevels != null)
    numZoomLevels = zoomLevels.length;

  var ww = ZOOM_SLIDER_WIDTH;
  var gap = NaN;
  if (numZoomLevels >= 0)
    gap = ZOOM_SLIDER_HEIGHT / 5;
  var padding = 4;

  //set the size of the slider
  var g = graphics;
  g.lineStyle(0, 0, 0);
  g.DvtPathUtils.moveTo(0, 0);
  g.DvtPathUtils.lineTo(ww, ZOOM_SLIDER_HEIGHT);

  var lineThickness = 1;//2;
  var mouseLineThickness = 5;

  this._zoomSliderStartY = 2 * padding;
  this._zoomSliderEndY = height - 2 * padding;

  //draw the incremental cross lines
  var crossline;
  for (var i = 0;i < numZoomLevels;i++) {
    crossline = new Sprite();
    crossline.buttonMode = true;
    var intersectY = this._zoomSliderEndY - ((zoomLevels[i] - this._minScale) / (this._maxScale - this._minScale)) * (this._zoomSliderEndY - this._zoomSliderStartY);
    crossline.y = intersectY;
    addChild(crossline);
    g = crossline.graphics;
    PanZoomDvtButtonLAFUtilsPanelLAFUtils.drawZoomSliderCrossLine(crossline, padding, 0, ww);
    //BUG #6977287: increase mouse detection region
    g.lineStyle(mouseLineThickness, 0, 0);
    g.DvtPathUtils.moveTo(padding, 0);
    g.DvtPathUtils.lineTo(padding + ww, 0);

    this._zoomSliderCrosslines.push(crossline);

    crossline.addEvtListener(DvtMouseEvent.CLICK, this.HandleZoomSliderCrosslineClick, false, 0, true);
  }

  this.addZoomSliderCrosslinesTooltipListeners();

  //create the thumb
  this._zoomSliderThumb = this._createZoomSliderThumb();
  this._positionZoomSliderThumb();

  this.addChild(this._zoomSliderThumb);
}

/**
 * Create the zoom slider thumb.
 *
 * @return zoom slider thumb
 */
DvtZoomSlider.prototype._createZoomSliderThumb = function () {
  var padding = 4;
  var context = this.getCtx();
  var s = new DvtContainer(context);

  // Bug 9506699 - BIDI: Control panel buttons should have local specific icons
  // in case of R2L, zoomslider button should start from right
  var ww = DvtStyleUtils.isLocaleL2R() ? 0 : (ZOOM_SLIDER_WIDTH - 2);

  var button = new DvtButton(context,
                   DvtButtonLAFUtils.createZoomSliderButtonState(context, DvtButton.STATE_ENABLED, ww),
                   DvtButtonLAFUtils.createZoomSliderButtonState(DvtButton.STATE_OVER, ww),
                   DvtButtonLAFUtils.createZoomSliderButtonState(DvtButton.STATE_DOWN, ww));
  s.addChild(button);

  s.addEvtListener(DvtMouseEvent.MOUSEDOWN, this.HandleZoomSliderThumbMouseDown, false, this);
  //BUG FIX #10079178: add mouseMove and mouseUp listeners when we get the mouseDown event
  //s.addEvtListener(DvtMouseEvent.MOUSEMOVE, this.HandleZoomSliderThumbMouseMove, false, this);
  //s.addEvtListener(DvtMouseEvent.MOUSEUP, this.HandleZoomSliderThumbMouseUp, false, this);
  //s.addEvtListener(DvtMouseEvent.MOUSEOUT, this.HandleZoomSliderThumbMouseUp, false, this);
  s.addEvtListener(DvtMouseEvent.CLICK, DvtEventManager.consumeEvent, false, this);

  return s;
}

/**
 * Position the zoom slider thumb based on the current zoom factor.
 */
DvtZoomSlider.prototype._positionZoomSliderThumb = function () {
  if (this._panZoomCanvas && this._zoomSliderThumb) {
    var currZoom = this._panZoomCanvas.getCurrentZoom();

    var yPos = Number(this._zoomSliderEndY) - ((currZoom - this._minScale) / (this._maxScale - this._minScale)) * Number(this._zoomSliderEndY - this._zoomSliderStartY);

    if (yPos > this._zoomSliderEndY)
      yPos = this._zoomSliderEndY;
    else if (yPos < this._zoomSliderStartY)
      yPos = this._zoomSliderStartY;
    this._zoomSliderThumb.y = yPos - (this._zoomSliderThumb.height / 2.0);
  }
}

/**
 *this.Handle a zoom event from the view.
 * The UI should update for the new zoom state.
 *
 * @param event zoom event
 */
DvtZoomSlider.prototype.HandleZoomEvent = function (event) {
  if (event.getSubType() == ZoomEvent.SUBTYPE_ZOOMED) {
    this._positionZoomSliderThumb();
  }
}

/**
 *this.Handle a mouse click on the continuous zoom slider line.
 *
 * @param event MouseEvent
 */
DvtZoomSlider.prototype.HandleZoomSliderBodyClick = function (event) {
  //don't want click to fall through to other components
  DvtEventManager.consumeEvent(event);

  var relY = this._zoomSliderEndY - event.localY;
  if (relY < 0)
    relY = 0;
  var ratio = this._minScale + (relY / (this._zoomSliderEndY - this._zoomSliderStartY)) * (this._maxScale - this._minScale);

  var animator = new DvtAnimator(this.getCtx(), this._panZoomCanvas.getAnimationDuration());
  this._panZoomCanvas.zoomTo(ratio, undefined, undefined, animator);
  animator.play();
}

/**
 *this.Handle a mouse click on one of the incremental
 * cross lines on the zoom slider.
 *
 * @param event MouseEvent
 */
DvtZoomSlider.prototype.HandleZoomSliderCrosslineClick = function (event) {
  //don't want click to fall through to other components
  DvtEventManager.consumeEvent(event);

  var i;
  var numCrosslines = 0;
  if (this._zoomSliderCrosslines != null)
    numCrosslines = this._zoomSliderCrosslines.length;
  for (i = 0;i < numCrosslines;i++) {
    //find the crossline that was clicked, so we know the index,
    //which is the same as the index of its zoom level in the array
    if (event.target == this._zoomSliderCrosslines[i])
      break;
  }
  var newScale = this._zoomLevels[i];

  var animator = new DvtAnimator(this.getCtx(), this._panZoomCanvas.getAnimationDuration());
  this._panZoomCanvas.zoomTo(newScale, undefined, undefined, animator);
  animator.play();
}

DvtZoomSlider.prototype.HandleZoomSliderCrosslineRollOver = function (event) {
  var i;
  var numCrosslines = 0;
  if (this._zoomSliderCrosslines != null)
    numCrosslines = this._zoomSliderCrosslines.length;
  for (i = 0;i < numCrosslines;i++) {
    //find the crossline that was rolled over, so we know the index,
    //which is the same as the index of its tooltip in the array
    if (event.target == this._zoomSliderCrosslines[i])
      break;
  }

  var tooltip = null;
  if (i < this._zoomLevelsTooltips.length)
    tooltip = this._zoomLevelsTooltips[i];

  if (tooltip && this.getTooltipManager()) {
    this.getTooltipManager().showTooltip(tooltip, event.target);
  }
}

DvtZoomSlider.prototype.HandleZoomSliderCrosslineRollOut = function (event) {
  if (this.getTooltipManager() != null)
    this.getTooltipManager().hideTooltip();
}

/**
 *this.Handle a mouse down on the zoom slider thumb.
 *
 * @param event MouseEvent
 */
DvtZoomSlider.prototype.HandleZoomSliderThumbMouseDown = function (event) {
  //don't want click to fall through to other components
  DvtEventManager.consumeEvent(event);

  this._bZoomSliderThumbMouseDown = true;
  //save the offset of the mouse position relative to the thumb position
  //this._zoomSliderThumbMouseDeltaY = event.localY;
  //BUG FIX #7241349: listen to mouse move event on thumb so we can 
  //make the drag animation smooth
  //BUG FIX #10079178: add mouseUp listener on the stage so that
  //we can detect it even if the mouse is outside of the thumb
  stage.addEvtListener(DvtMouseEvent.MOUSEMOVE, this.HandleZoomSliderThumbMouseMove, false, 0, true);
  stage.addEvtListener(DvtMouseEvent.MOUSEUP, this.HandleZoomSliderThumbMouseUp, false, 0, true);

  var dragBounds = new Rectangle(this._zoomSliderThumb.x, this._zoomSliderStartY - this._zoomSliderThumb.height / 2, 0, this._zoomSliderEndY - this._zoomSliderStartY);
  this._zoomSliderThumb.startDrag(false, dragBounds);
}

/**
 *this.Handle a mouse move on the zoom slider thumb.
 *
 * @param event MouseEvent
 */
DvtZoomSlider.prototype.HandleZoomSliderThumbMouseMove = function (event) {
  //only respond if the mouse down occurred on the thumb
  if (this._bZoomSliderThumbMouseDown) {
    //BUG FIX #7241349: update the view while dragging so that the
    //animation is smooth
    event.updateAfterEvent();

    /*
        //don't want click to fall through to other components
        DvtEventManager.consumeEvent(event);
        
        //calculate new thumb position
        var newY = this._zoomSliderThumb.y + event.localY - this._zoomSliderThumbMouseDeltaY;
        //constrain thumb position to length of zoom slider line
        if (newY < this._zoomSliderStartY - this._zoomSliderThumb.height / 2)
          newY = this._zoomSliderStartY - this._zoomSliderThumb.height / 2;
        else if (newY > this._zoomSliderEndY - this._zoomSliderThumb.height / 2)
          newY = this._zoomSliderEndY - this._zoomSliderThumb.height / 2;
        //set the new thumb position
        this._zoomSliderThumb.y = newY;
        */
  }
}

/**
 *this.Handle a mouse up on the zoom slider thumb.
 *
 * @param event MouseEvent
 */
DvtZoomSlider.prototype.HandleZoomSliderThumbMouseUp = function (event) {
  //BUG FIX #7241349: remove mouse move listener on thumb
  //BUG FIX #10079178: remove mouseUp listener that was added when we got the mouseDown event
  stage.removeEvtListener(DvtMouseEvent.MOUSEMOVE, this.HandleZoomSliderThumbMouseMove);
  stage.removeEvtListener(DvtMouseEvent.MOUSEUP, this.HandleZoomSliderThumbMouseUp);

  if (this._bZoomSliderThumbMouseDown) {
    //don't want click to fall through to other components
    DvtEventManager.consumeEvent(event);

    this._bZoomSliderThumbMouseDown = false;

    this._zoomSliderThumb.stopDrag();

    //calculate the new zoom ratio
    var relY = this._zoomSliderEndY - (this._zoomSliderThumb.y + this._zoomSliderThumb.height / 2);
    if (relY < 0)
      relY = 0;
    var ratio = this._minScale + (relY / (this._zoomSliderEndY - this._zoomSliderStartY)) * (this._maxScale - this._minScale);

    var animator = new DvtAnimator(this.getCtx(), this._panZoomCanvas.getAnimationDuration());
    this._panZoomCanvas.zoomTo(ratio, undefined, undefined, animator);
    animator.play();
  }
}


/**
 * @constructor
 * PanControl for use with Diagram.
 */
var DvtPanControl = function (context, panButton, recenterButton, panZoomCanvas, resources, control, styleMap) {
  this.Init(context, panButton, recenterButton, panZoomCanvas, resources, control, styleMap);
};

DvtPanControl.PAN_TIMER_INTERVAL = 50; //in ms
DvtPanControl.PAN_TIMER_ACCELERATE_COUNT = 2 * //seconds
                                          (1000 / DvtPanControl.PAN_TIMER_INTERVAL);//iterations per second
                                           
/*
 * make DvtPanControl a subclass of DvtBasePanZoomControl
 */
DvtObj.createSubclass(DvtPanControl, DvtBasePanZoomControl, "DvtPanControl");

/*--------------------------------------------------------------------*/
/*  Init()                                                            */
/*--------------------------------------------------------------------*/
DvtPanControl.prototype.Init = function (context, panButton, recenterButton, panZoomCanvas, resources, control, styleMap) {
  DvtPanControl.superclass.Init.call(this, context, panZoomCanvas, resources);
  
  this._panTimer = new DvtTimer(context, DvtPanControl.PAN_TIMER_INTERVAL, 
                                this.HandlePanTimer, this);
  this._bPanMouseDown = false;
  this._panCenter = new DvtPoint(20, 20);

  if (control) {
    this._controls = control;
  }
  else {
    this._controls = DvtPanZoomControlPanel.CONTROLS_ALL;
  }
  
  panButton.addChild(recenterButton);
  if (recenterButton) {
    this._panCenterSprite = recenterButton;
    this._panCenterSprite.setVisible(false);
    this._panCenterSprite.addEvtListener(DvtTouchEvent.TOUCHSTART, this.HandlePanCenterClick, false, this);
    if (!DvtAgent.isTouchDevice()) {
      this._panCenterSprite.addEvtListener(DvtMouseEvent.CLICK, this.HandlePanCenterClick, false, this);
      this._panCenterSprite.addEvtListener(DvtMouseEvent.MOUSEDOWN, this.HandlePanCenterDown, false, this);
      this._panCenterSprite.addEvtListener(DvtMouseEvent.MOUSEUP, this.HandlePanCenterUp, false, this);
      this._panCenterSprite.addEvtListener(DvtMouseEvent.MOUSEOVER, this.HandlePanCenterRollOver, false, this);
      this._panCenterSprite.addEvtListener(DvtMouseEvent.MOUSEOUT, this.HandlePanCenterRollOut, false, this);
    }

    //Bug 13436842 - pan control rotates when hovering over the re-center button
    this._panCenterSprite.addEvtListener(DvtMouseEvent.MOUSEMOVE, this.HandlePanCenterMouseMove, false, this);
  }
  
  this._panButton = panButton;
  this._panButton.addEvtListener(DvtTouchEvent.TOUCHSTART, this.HandlePanClick, false, this);
  if (!DvtAgent.isTouchDevice()) {
    this._panButton.addEvtListener(DvtMouseEvent.CLICK, this.HandlePanClick, false, this);
    this._panButton.addEvtListener(DvtMouseEvent.MOUSEDOWN, this.HandlePanMouseDown, false, this);
    this._panButton.addEvtListener(DvtMouseEvent.MOUSEUP, this.HandlePanMouseUp, false, this);
    this._panButton.addEvtListener(DvtMouseEvent.MOUSEOVER, this.HandlePanRollOver, false, this);
    this._panButton.addEvtListener(DvtMouseEvent.MOUSEOUT, this.HandlePanRollOut, false, this);
    this._panButton.addEvtListener(DvtMouseEvent.MOUSEMOVE, this.HandlePanMouseMove, false, this);
  }
  
  this._panControl = DvtButtonLAFUtils.createPanButtonBackground(context, styleMap);
  this._panControl.addChild(this._panButton);
  this.addChild(this._panControl);
}

/**
 * Handle a click on the pan control.
 *
 * @param event MouseEvent
 */
DvtPanControl.prototype.HandlePanClick = function (event) {
  //don't want click to fall through to other components
  DvtEventManager.consumeEvent(event);
  // this._logEvent(event);
}

/**
 * Handle a mouse down on the pan control.
 *
 * @param event MouseEvent
 */
DvtPanControl.prototype.HandlePanMouseDown = function (event) {

  //don't want click to fall through to other components
  DvtEventManager.consumeEvent(event);
  // this._logEvent(event);

  this._bPanMouseDown = true;
//  this._panButton._mouseDownHandler(event);

  //hide the pan center button
  if (this._panCenterSprite)
    this._panCenterSprite.setVisible (false);

  //hide the static compass arrows and show the dynamic directional arrow
  //this._panCompassArrows.visible = false;
  //this._panDirectionalArrow.visible = true;
  //rotate the directional arrow to point towards the mouse
  var stagePoint = this._panZoomCanvas.GetRelativeMousePosition(event);
  var localPoint = this._panButton.stageToLocal(stagePoint);
  this._rotatePanControlDirectionalArrow(localPoint.x, localPoint.y, this._panButton.downState);

  //save the mouse point
  this._panMousePoint = new DvtPoint(localPoint.x, localPoint.y);

  //start the pan timer for continuous panning while the mouse button
  //is held down
  this._panTimer.start();
  this._panTimerCount = 0;
}

/**
 * Handle a mouse up on the pan control.
 *
 * @param event MouseEvent
 */
DvtPanControl.prototype.HandlePanMouseUp = function (event) {

  if (this._bPanMouseDown) {
    //don't want click to fall through to other components
    DvtEventManager.consumeEvent(event);
    this._bPanMouseDown = false;

    //show the pan center button
    if (this._panCenterSprite) {
      this._panCenterSprite.setVisible(true);
    }

    //show the static compass arrows and hide the dynamic directional arrow
    //this._panCompassArrows.visible = true;
    //this._panDirectionalArrow.visible = false;
    //stop the pan timer and reset it for use next time
    this._panTimer.stop();
//     this._panTimer.reset();

  }

  // this._logEvent(event);
  this._panButton._mouseOutHandler(event);

  this.HideTooltip();
}

/**
 * Handle a mouse roll over on the pan control.
 *
 * @param event MouseEvent
 */
DvtPanControl.prototype.HandlePanRollOver = function (event) {
//  DvtEventManager.consumeEvent(event);
  // this._logEvent(event);

  //show the pan center button
  if (this._panCenterSprite) {
    this._panCenterSprite.setVisible(true);
  }

//  this._panButton._mouseOverHandler(event);
    this.ShowTooltip(event, this.getResources().getPanControlTooltip());
}

/**
 * Handle a mouse roll out on the pan control.
 *
 * @param event MouseEvent
 */
DvtPanControl.prototype.HandlePanRollOut = function (event) {
  this.HandlePanMouseUp(event);

  //hide the pan center button
  if (this._panCenterSprite) {
    this._panCenterSprite.setVisible(false);
  }
}

/**
 * Handle a mouse move on the pan control.
 *
 * @param event MouseEvent
 */
DvtPanControl.prototype.HandlePanMouseMove = function (event) {

  //don't want click to fall through to other components
  DvtEventManager.consumeEvent(event);
  // this._logEvent(event);

  var stagePoint = this._panZoomCanvas.GetRelativeMousePosition(event);
  var localPoint = this._panButton.stageToLocal(stagePoint);
  if (this._bPanMouseDown) {
    //rotate the directional arrow to point towards the mouse
    this._rotatePanControlDirectionalArrow(localPoint.x, localPoint.y, this._panButton.downState);

    //save the mouse point
    this._panMousePoint = new DvtPoint(localPoint.x, localPoint.y);

//     event.updateAfterEvent();
  }
  //BUG FIX #7352517: rotate the arrows shown when the mouse is over
  //the pan control
  else {
    //rotate the directional arrow to point towards the mouse
    this._rotatePanControlDirectionalArrow(localPoint.x, localPoint.y, this._panButton.overState);
  }
}

/**
 * Handle a pan timer event to pan the view.
 *
 * @param event TimerEvent
 */
DvtPanControl.prototype.HandlePanTimer = function () {

  if (this._bPanMouseDown) {
    //TODO: ???
//     event.updateAfterEvent();

    //get the difference between the mouse position and the center of the pan control
    var diffY = this._panCenter.y - this._panMousePoint.y;
    var diffX = this._panCenter.x - this._panMousePoint.x;

    //calculate the slope and angle of the mouse from the center of the pan control
    //var slope = diffY / diffX;
    var angleRads = Math.atan2(diffY, diffX);

    //normalize dx and dy increments
    var deltaX = Math.cos(angleRads);
    var deltaY = Math.sin(angleRads);

    //multiply the normalized increment by this factor to determine
    //the pan distance
    var factor = 15;
    this._panTimerCount++
    if (this._panTimerCount > DvtPanControl.PAN_TIMER_ACCELERATE_COUNT)
      factor *= 3;
    this._panZoomCanvas.panBy(factor * deltaX, factor * deltaY);
  }
}

/**
 * Handle a mouse click on the center of the pan control.
 *
 * @param event MouseEvent
 */
DvtPanControl.prototype.HandlePanCenterClick = function (event) {

  //don't want click to fall through to other components
  DvtEventManager.consumeEvent(event);
  this._logEvent(event);
  this._panZoomCanvas.zoomAndCenter();
}

/**
 * Handle a mouse down on the center of the pan control.
 *
 * @param event MouseEvent
 */
DvtPanControl.prototype.HandlePanCenterDown = function (event) {

  //don't want down to fall through to other components
  DvtEventManager.consumeEvent(event);
  this._logEvent(event);

//  this._panCenterSprite._mouseDownHandler(event);
}

/**
 * Handle a mouse up on the center of the pan control.
 *
 * @param event MouseEvent
 */
DvtPanControl.prototype.HandlePanCenterUp = function (event) {

  //don't want up to fall through to other components
  DvtEventManager.consumeEvent(event);
  this._logEvent(event);

//  this._panCenterSprite._mouseOutHandler(event);
  this.HideTooltip();
}

/**
 * Handle a mouse roll over on the center of the pan control.
 *
 * @param event MouseEvent
 */
DvtPanControl.prototype.HandlePanCenterRollOver = function (event) {
  //don't want up to fall through to other components
  // DvtEventManager.consumeEvent(event);
  this._logEvent(event);

//  this._panCenterSprite._mouseOverHandler(event);
  this.ShowTooltip(event, this.getResources().getPanControlCenterTooltip());

  //Bug 13399111 - Wrong tooltip for pan control center button
  //Bug 13436842 - pan control rotates when hovering over the re-center button
  this._panCenterSprite.setVisible(true);
  DvtEventManager.consumeEvent(event);
};

/**
 * Handle a mouse roll out on the center of the pan control.
 *
 * @param event MouseEvent
 */
DvtPanControl.prototype.HandlePanCenterRollOut = function (event) {
  //don't want up to fall through to other components
//  DvtEventManager.consumeEvent(event);
  this._logEvent(event);

//  this._panCenterSprite._mouseOutHandler(event);
  this.HideTooltip();

  //Bug 13399111 - Wrong tooltip for pan control center button
  //Bug 13436842 - pan control rotates when hovering over the re-center button
  DvtEventManager.consumeEvent(event);
}

/**
 * Handle a mouse move on the center of the pan control.
 *
 * @param event MouseEvent
 */
DvtPanControl.prototype.HandlePanCenterMouseMove = function (event) {
  //Bug 13436842 - pan control rotates when hovering over the re-center button
  DvtEventManager.consumeEvent(event);
  this._logEvent(event);
}

/**
 * Rotate the pan control directional arrow to point towards the mouse.
 *
 * @param localX local mouse X coord
 * @param localY local mouse Y coord
 * @param displayObj DisplayObject to rotate
 */
DvtPanControl.prototype._rotatePanControlDirectionalArrow = function (localX, localY, displayObj) {
  var xOffset = localX - this._panCenter.x;
  var yOffset = localY - this._panCenter.y;

  // var angleDeg = Math.atan2(yOffset, xOffset) * RAD_TO_DEG;
  var angleRad = Math.atan2(yOffset, xOffset);

  //adjust the angle by 45 degrees because the image has the arrow pointing 
  //down to the right at an angle of 45 degrees
  // displayObj.rotation = angleDeg - 45;
  displayObj.setRotation(angleRad - Math.PI/4);

}

/**
 * @constructor
 */
var DvtPanZoomControlPanelEvent = function (subtype) {
  this.Init(DvtPanZoomControlPanelEvent.TYPE);
  this._subtype = subtype;
}

DvtObj.createSubclass(DvtPanZoomControlPanelEvent, DvtBaseComponentEvent, "DvtPanZoomControlPanelEvent");

DvtPanZoomControlPanelEvent.TYPE = "dvtPZCPExpand";
DvtPanZoomControlPanelEvent.SUBTYPE_SHOW = "show";
DvtPanZoomControlPanelEvent.SUBTYPE_HIDE = "hide";

DvtPanZoomControlPanelEvent.prototype.getSubType = function() {
  return this._subtype;
}
/**
 * @constructor
 * DvtPanZoomControlPanel for use with PanZoomCanvas.
 * This panel contains tools for zooming and panning.
 * By default, the panel is initially collapsed.
 */
var DvtPanZoomControlPanel = function(context, canvas, buttonImages, resources, controls, view) {
  this.Init(context, canvas, buttonImages, resources, controls, view);
};

DvtObj.createSubclass(DvtPanZoomControlPanel, DvtContainer, "DvtPanZoomControlPanel");

DvtPanZoomControlPanel.STATE_COLLAPSED = 1;
DvtPanZoomControlPanel.STATE_EXPANDED = 2;
DvtPanZoomControlPanel.CONTROLS_ALL = 0xffffff;
DvtPanZoomControlPanel.CONTROLS_ZOOM_SLIDER   = 0x000001;
DvtPanZoomControlPanel.CONTROLS_CENTER_BUTTON = 0x000010;
DvtPanZoomControlPanel.CONTROLS_ZOOM_TO_FIT_BUTTON = 0x000100;
DvtPanZoomControlPanel.CONTROLS_ZOOM = 0x001001; // include CONTROLS_ZOOM_SLIDER


DvtPanZoomControlPanel.CONTROL_PANEL_BEHAVIOR_KEY = "controlPanelBehavior";


//DvtPanZoomControl style names, used in style map
/**
 * Attribute for background opacity
 * @const
 */
DvtPanZoomControlPanel.BG_ALPHA = "backgroundAlpha";
/**
 * Attribute for background opacity on hover
 * @const
 */
DvtPanZoomControlPanel.BG_ROLLOVER_ALPHA = "backgroundHoverAlpha";
/**
 * Attribute for background opacity on drag
 * @const
 */
DvtPanZoomControlPanel.BG_DRAG_ALPHA = "backgroundDragAlpha";
/**
 * Attribute for border opacity
 * @const
 */
DvtPanZoomControlPanel.FRAME_ROLLOUT_ALPHA = "borderAlpha";
/**
 * Attribute for border opacity on hover
 * @const
 */
DvtPanZoomControlPanel.FRAME_ROLLOVER_ALPHA = "borderHoverAlpha";
/**
 * Attribute for border opacity on drag
 * @const
 */
DvtPanZoomControlPanel.FRAME_DRAG_ALPHA = "borderDragAlpha";

/**
 * Attribute for button width style
 * @const
 */
DvtPanZoomControlPanel.CP_BUTTON_WIDTH = "buttonWidth";
/**
 * Attribute for button height style
 * @const
 */
DvtPanZoomControlPanel.CP_BUTTON_HEIGHT = "buttonHeight";
/**
 * Attribute for open/close button width style
 * @const
 */ 
DvtPanZoomControlPanel.CP_OPEN_CLOSE_BUTTON_WIDTH = 'openCloseButtonWidth';
/**
 * Attribute for tab size style
 * @const
 */
DvtPanZoomControlPanel.CP_TAB_SIZE = "tabSize";
/**
 * Attribute for top padding style
 * @const
 */
DvtPanZoomControlPanel.CP_PADDING_TOP = "paddingTop";
/**
 * Attribute for side padding style
 * @const
 */
DvtPanZoomControlPanel.CP_PADDING_SIDE = "paddingSide";
/**
 * Attribute for bottom padding style
 * @const
 */
DvtPanZoomControlPanel.CP_PADDING_BOTTOM = "paddingBottom";
/**
 * Attribute for left padding style
 * @const
 */
DvtPanZoomControlPanel.CP_PADDING_LEFT = "paddingLeft";
/**
 * Attribute for right padding style
 * @const
 */
DvtPanZoomControlPanel.CP_PADDING_RIGHT = "paddingRight";
/**
 * Attribute for inner padding style (padding used between elements)
 * @const
 */
DvtPanZoomControlPanel.CP_PADDING_INNER = "paddingInner";
/**
 * Attribute for querying panel drawer styles
 * @const
 */
DvtPanZoomControlPanel.CP_PANEL_DRAWER_STYLES = "panelDrawerStyles";
/**
 * Attribute for image width style
 * @const
 */
DvtPanZoomControlPanel.CP_IMAGE_WIDTH = "imageWidth";
/**
 * Attribute for image height style
 * @const
 */
DvtPanZoomControlPanel.CP_IMAGE_HEIGHT = "imageHeight";
/**
 * Attribute for querying center button (pan button) existence
 * @const
 */
DvtPanZoomControlPanel.CP_CENTER_BUTTON_DISPLAYED = "centerButtonDisplayed";

/**
 * Helper method called by the constructor to initialize this object.
 * @param {DvtContext} context An object maintaining application specific context, as well as well as providing
 *                             access to platform specific data and objects, such as the factory
 * @param {DvtPanZoomCanvas} canvas The PanZoomCanvas this control panel will be associated with
 * @param {DvtXmlNode} buttonImages The map of button images
 * @param {DvtXmlNode} resources The map of translated resource strings
 * @param {number} controls The bit mask specifying which controls to show; constants are 
 *        defined in this class and begin with CONTROLS_; the default
 *        is CONTROLS_ALL
 * @param {DvtAbstractPanZoomComponent} view The parent component that extends DvtAbstractPanZoomComponent
 */
DvtPanZoomControlPanel.prototype.Init = function(context, canvas, buttonImages, resources, controls, view) {

  DvtPanZoomControlPanel.superclass.Init.call(this, context, null, "_controlPanel");
    
  this._bMouseDragPanning = false;
  this._bMouseOver = false;

  this._panZoomCanvas = canvas;
  this._tooltipManager = context.getTooltipManager();
  
  this._resources = new DvtPanZoomControlPanelResources(resources);

  if (controls == null)
    this._controls = DvtPanZoomControlPanel.CONTROLS_ALL;
  else 
    this._controls = controls;

  this._styleMap = null;
  this._view  = view; 
  if (this._view) {
    // retrieve the control panel style map including skinning defaults from the parent component
    this._styleMap = this._view.getControlPanelStyleMap();
    if (!this._styleMap[DvtPanZoomControlPanel.CP_CENTER_BUTTON_DISPLAYED]) {
      // disable the pan control if necessary and update the parent displayed controls value
      this._controls = this._controls & ~DvtPanZoomControlPanel.CONTROLS_CENTER_BUTTON;
      this._view.setDisplayedControls(this._controls);
    }
  }
  
  this._zoomLevels = DvtZoomSlider.DEFAULT_ZOOM_LEVELS;
  this._zoomSliderMinScale = 0;
  this._zoomSliderMaxScale = 1;
  this._state = DvtPanZoomControlPanel.STATE_COLLAPSED;
  this._bTransition = false;
  
  this._buttonImages = buttonImages;  
  
  this._bgAlpha = this._styleMap[DvtPanZoomControlPanel.BG_ALPHA];

  this._eventManager = new DvtPanZoomControlPanelEventManager(context, null, view);
  this._eventManager.addRolloverType(DvtPanZoomControlPanel);
  this._eventManager.addListeners(this);
  this._eventManager.associate(this, this);

  var s = this.RenderCollapsed();
  this._background.setAlpha(this._bgAlpha);
  this._frame.setAlpha(this._styleMap[DvtPanZoomControlPanel.FRAME_ROLLOUT_ALPHA]);
  this.addChild(s);
      
  //TOOD: disable tabbing for control panel tools
  this.tabChildren = false;
  this.setPixelHinting(true);
};

/**
 * Set the state of this control panel.
 * 
 * @param state STATE_EXPANDED or STATE_COLLAPSED
 */
DvtPanZoomControlPanel.prototype.setState = function(state) {
  if (this._state != state) {
    this.toggleExpandCollapse();
    this._state = state;
    this._applyAlphasRollout();
  }
};

/**
 * Get the state of this control panel.
 * 
 * @return STATE_EXPANDED or STATE_COLLAPSED
 */
DvtPanZoomControlPanel.prototype.getState = function() {
  return this._state;
};

/**
 * Set the discrete zoom levels that appear in the zoom slider.
 * 
 * @param zoomLevels array of discrete zoom levels to show in the zoom slider
 */
DvtPanZoomControlPanel.prototype.setZoomLevels = function(zoomLevels) {
  if (! zoomLevels) {
      zoomLevels = ZoomSlider.DEFAULT_ZOOM_LEVELS;
  }
  this._zoomLevels = zoomLevels;
  this.replaceZoomSlider();
};

/**
 * Get the discrete zoom levels that appear in the zoom slider.
 * 
 * @return array of discrete zoom levels to show in the zoom slider
 */
DvtPanZoomControlPanel.prototype.getZoomLevels = function() {
  return this._zoomLevels;
};
    
/**
 * Set the tooltips for the discrete zoom levels in the zoom slider.
 * 
 * @param zoomLevelsTooltips tooltips for discrete zoom levels in zoom slider
 */
DvtPanZoomControlPanel.prototype.setZoomLevelsTooltips = function(zoomLevelsTooltips) {
  this._zoomLevelsTooltips = zoomLevelsTooltips;
  if (this._zoomSlider) {
     this._zoomSlider.setZoomLevelsTooltips(zoomLevelsTooltips);
  }
};
    
/**
 * Get the tooltips for the discrete zoom levels in the zoom slider.
 * 
 * @return tooltips for discrete zoom levels in zoom slider
 */
DvtPanZoomControlPanel.prototype.getZoomLevelsTooltips = function() {
  return this._zoomLevelsTooltips;
};
    
/**
 * Set the tooltip manager to use.
 * 
 * @param tooltipManager manager to use
 */
DvtPanZoomControlPanel.prototype.setTooltipManager = function(tooltipManager) {
  this._tooltipManager = tooltipManager;
  if (this._zoomSlider) {
    this._zoomSlider.setTooltipManager(tooltipManager);
  }
  if (this._zoomInButton)
    this._zoomInButton.setTooltipManager(tooltipManager);
  if (this._zoomOutButton)
    this._zoomOutButton.setTooltipManager(tooltipManager);
  if (this._zoomToFitButton)
    this._zoomToFitButton.setTooltipManager(tooltipManager);

};

/**
 * Get the tooltip manager being used.
 * 
 * @return tooltipManager being used
 */
DvtPanZoomControlPanel.prototype.getTooltipManager = function() {
  return this._tooltipManager;
};

/**
 * Set the translated resources to use.
 * 
 * @param resources translated resources
 */
DvtPanZoomControlPanel.prototype.setResources = function(resources) {
  this._resources = resources;
      
  if (this._zoomSlider)
    this._zoomSlider.setResources(resources);
  if (this._zoomInButton)
    this._zoomInButton.setResources(resources);
  if (this._zoomOutButton)
    this._zoomOutButton.setResources(resources);
  if (this._zoomToFitButton)
    this._zoomToFitButton.setResources(resources);
};

/**
 * Get the translated resources to use.
 * 
 * @return translated resources
 */
DvtPanZoomControlPanel.prototype.getResources = function() {
  return this._resources;
};

/**
 * Set the min scale for the zoom slider.
 * 
 * @param minScale minimum value of zoom slider
 */
DvtPanZoomControlPanel.prototype.setZoomSliderMinScale = function(minScale) {
  this._zoomSliderMinScale = minScale;
  this.replaceZoomSlider();
}

/**
 * Get the min scale for the zoom slider.  
 * 
 * @return minimum value of zoom slider
 */
DvtPanZoomControlPanel.prototype.getZoomSliderMinScale = function() {
  return this._zoomSliderMinScale;
}
    
/**
 * Set the max scale for the zoom slider.
 * 
 * @param maxScale maximum value of zoom slider
 */
DvtPanZoomControlPanel.prototype.setZoomSliderMaxScale = function(maxScale) {
  this._zoomSliderMaxScale = maxScale;
  this.replaceZoomSlider();
}

/**
 * Get the max scale for the zoom slider.  
 * 
 * @return maximum value of zoom slider
 */
DvtPanZoomControlPanel.prototype.getZoomSliderMaxScale = function() {
  return this._zoomSliderMaxScale;
}

/**
 * Notify the control panel that mouse drag panning has started.
 */
DvtPanZoomControlPanel.prototype.mouseDragPanningStarted = function() {
  this._bMouseDragPanning = true;
  //disable interaction
  this._background.setMouseEnabled(false);
  this._frame.setMouseEnabled(false);
  
  //change alphas of background and frame
  this._background.setAlpha(this._styleMap[DvtPanZoomControlPanel.BG_DRAG_ALPHA]);
  this._frame.setAlpha(this._styleMap[DvtPanZoomControlPanel.FRAME_DRAG_ALPHA]);
};

/**
 * Notify the control panel that mouse drag panning has ended. 
 */
DvtPanZoomControlPanel.prototype.mouseDragPanningEnded = function() {
  this._bMouseDragPanning = false;
  //enable interaction
  this._background.setMouseEnabled(true);
  this._frame.setMouseEnabled(true);
    
  //change alphas based on whether the mouse is currently over
  //the control panel
  var bMouseOver = this._bMouseOver;//TODO???hitTestPoint(stage.mouseX, stage.mouseY, true);
  if (bMouseOver) {
    this.HandleRollOver(null);
  }
  else {
    this.HandleRollOut(null);
  }
};

/**
 * Rotate a given DisplayObject to pseudo-flip it horizontally for BiDi.
 * Vertically the DisplayObject must be the exact image of itself because it will
 * end up upside down.  
 * 
 * @param dispObj DisplayObject to rotate
 */
DvtPanZoomControlPanel.prototype.rotateControlPanelDisplayObject = function(dispObj) {
  dispObj.setRotation(Math.PI);

  var dim = DvtButtonLAFUtils._getDimForced(this._context, dispObj);
  dispObj.setTranslate(dispObj.getTranslateX() + dim.w, dispObj.getTranslateY() + dim.h);
};

//BUG FIX #10154856: show single row of controls in TMap
/**
 * Determine whether the horizontal arm of the control panel shows a single row or
 * two rows.
 * The default is false, meaning that the control panel shows two rows.
 * 
 * @return true if the horizontal arm of the control panel shows a single row
 */
DvtPanZoomControlPanel.prototype.isSingleHorzRow = function() {
  return true;
};
    
//BUG FIX #10154856: show single row of controls in TMap
/**
 * Get the height of the horizontal bar of the control panel.
 * 
 * @return {number} height of the horizontal bar of the control panel
 */
DvtPanZoomControlPanel.prototype.getViewPanelHeight = function() {
  var h = 0;
  if (this.isSingleHorzRow())
    h = DvtPanZoomControlPanelLAFUtils.getViewPanelHalfHeight();
  else
    h = DvtPanZoomControlPanelLAFUtils.getViewPanelHeight();
  var defaultHeight = DvtStyleUtils.getStyle(this._styleMap,DvtPanZoomControlPanel.CP_TAB_SIZE,0);
  return Math.max(defaultHeight, h);
};

/**
 * Get the width of the vertical bar of the control panel.
 * 
 * @return {number} the width of the vertical bar of the control panel
 */
DvtPanZoomControlPanel.prototype.getViewPanelWidth = function() {
  return DvtStyleUtils.getStyle(this._styleMap,DvtPanZoomControlPanel.CP_TAB_SIZE,0);
};

/**
 * Render the collapsed state of the panel.
 * 
 * @return {DvtContainer} container representing collapsed state
 */
DvtPanZoomControlPanel.prototype.RenderCollapsed = function() {
  var context = this.getCtx();

  var contentBar = new DvtContainer(context);
  var hh = this.getViewPanelHeight();

  var bR2L = DvtAgent.isRightToLeft(context);
  this._background = DvtPanZoomControlPanelLAFUtils.createEmptyViewClosedShape(context, hh, this._styleMap, bR2L);
  this._frame = DvtPanZoomControlPanelLAFUtils.createEmptyViewClosedFrame(context, hh, this._styleMap, bR2L);
  
  //Note: get dimensions before adding expand button
  this._collapsedDim = DvtButtonLAFUtils._getDimForced(context, this._frame);

  //create the control panel expand button
  this._expandButton = DvtButtonLAFUtils.createExpandButton(this.getCtx(), this._buttonImages, this.getViewPanelHeight(), this._styleMap, bR2L);
  this._expandButton.setCallback(this.HandleExpandClick, this);
  this._expandButton.setCursor(DvtSelectionEffectUtils.getSelectingCursor());
  var proxy = new DvtPanZoomControlPanelEventHandlerProxy(this, null, null, 
                                                    null, null,  null,
                                                    this.getResources().getControlPanelExpandTooltip());  
  this._eventManager.associate(this._expandButton, proxy);

  this._frame.addChild(this._expandButton);

  contentBar.addChild(this._background);
  contentBar.addChild(this._frame);

  return contentBar;
};

/**
 * Creates and adds zoom to fit button to the vertical bar of the control panel
 * @param {DvtContainer} vertContentBar display object representing the vertical bar
 * @param {number} currY current Y coordinate
 * @return {number} updated current Y coordinate
 */
DvtPanZoomControlPanel.prototype._addZoomToFitButton = function(vertContentBar, currY) {

  //create the zoom to fit button
  if ((this._controls & DvtPanZoomControlPanel.CONTROLS_ZOOM_TO_FIT_BUTTON) != 0) {
    var paddingInner = DvtStyleUtils.getStyle(this._styleMap['vbar'],DvtPanZoomControlPanel.CP_PADDING_INNER,0);
    var paddingSide = DvtStyleUtils.getStyle(this._styleMap['vbar'],DvtPanZoomControlPanel.CP_PADDING_LEFT,0);    
    this._zoomToFitButton = DvtButtonLAFUtils.createZoomToFitButton(this.getCtx(), this._panZoomCanvas, 
                                                            this.getResources(), this._eventManager, this._buttonImages, 
                                                            this._styleMap);
    this._zoomToFitButton.setTranslate(paddingSide, this._zoomToFitButton.getTranslateY() + currY);

    var dim = DvtButtonLAFUtils._getDimForced(this.getCtx(), this._zoomToFitButton);
    vertContentBar.addChild(this._zoomToFitButton);
    currY += dim.h;
    currY += paddingInner;
  }
  return currY;
};

/**
 * Creates and adds zoom controls (zoom in, zoom out, zoom slider) to the vertical bar of the control panel
 * @param {DvtContainer} vertContentBar display object representing the vertical bar
 * @param {number} currY current Y coordinate
 * @return {number} updated current Y coordinate
 */
DvtPanZoomControlPanel.prototype._addZoomControls = function(vertContentBar, currY) {

  var dim = null;
  var paddingInner = DvtStyleUtils.getStyle(this._styleMap['vbar'],DvtPanZoomControlPanel.CP_PADDING_INNER,0);
  var paddingSide = DvtStyleUtils.getStyle(this._styleMap['vbar'],DvtPanZoomControlPanel.CP_PADDING_LEFT,0);
  if ((this._controls & DvtPanZoomControlPanel.CONTROLS_ZOOM) != 0) {
    
    //create the zoom in button
    this._zoomInButton = DvtButtonLAFUtils.createZoomInButton(this.getCtx(), this._panZoomCanvas, 
                                                              this.getResources(), this._eventManager, this._buttonImages, 
                                                              this._styleMap);
    this._zoomInButton.setTranslate(paddingSide, this._zoomInButton.getTranslateY() + currY);

    dim = DvtButtonLAFUtils._getDimForced(this.getCtx(), this._zoomInButton);
    vertContentBar.addChild(this._zoomInButton);
    currY += (dim.h + paddingInner);

    if (this.isZoomSliderShown()) {
      //create the zoom slider
      this._zoomSlider = this.createZoomSlider();
      this._zoomSlider.setTranslate(paddingSide, this._zoomSlider.getTranslateY() + currY);

      dim = DvtButtonLAFUtils._getDimForced(this.getCtx(), this._zoomSlider);
      vertContentBar.addChild(this._zoomSlider);
      currY += (dim.h + paddingInner);
    }

    //create the zoom out button
    this._zoomOutButton = DvtButtonLAFUtils.createZoomOutButton(this.getCtx(), this._panZoomCanvas, 
                                                                this.getResources(), this._eventManager, this._buttonImages, this._styleMap);
    this._zoomOutButton.setTranslate(paddingSide, this._zoomOutButton.getTranslateY() + currY);

    dim = DvtButtonLAFUtils._getDimForced(this.getCtx(), this._zoomOutButton);
    vertContentBar.addChild(this._zoomOutButton);
    currY += dim.h;
    this.enableZoomControls();
  }
  return currY;
};

/**
 * Creates vertical bar background and border
 * @param {DvtContainer} horzContentBar display object representing the horizontal bar
 * @param {DvtContainer} vertContentBar display object representing the vertical bar
 * @param {number} nKidHorzContentBar number of child objects on the horizontal bar
 * @param {number} currY current Y coordinate
 * @return {number} updated current Y coordinate
 */
DvtPanZoomControlPanel.prototype._createVBarBackground = function(horzContentBar, vertContentBar, nKidHorzContentBar, currY) {

  var context = this.getCtx();
  if (vertContentBar) {
    
    // Bug 9686175 - controlPanel looks bad when featuresOff="pan zoom cardSync changeLayout"
    // if zoom-to-fit is the only button left on vertContentBar and there is no buttonss in
    // horzContentBar, make bottom right corner square (not round)

    // Bug 10080038 - inconsistent control panel changes for different values of featuresoff
    // featuresOff = "pan zoom"
    var nKidsVert = vertContentBar.getNumChildren();
    var roundedCorner =
      (nKidsVert > 1 || this._zoomToFitButton == null || nKidHorzContentBar > 1 ||
       (nKidHorzContentBar > 0 && nKidsVert == 1));
       
    var openside = null; // alta style
    if (this._styleMap && this._styleMap[DvtPanZoomControlPanel.CP_PANEL_DRAWER_STYLES]) {
      if (nKidHorzContentBar > 0)
        openside = DvtPanZoomControlPanelLAFUtils.OPEN_TOP;
      else
        openside = DvtPanZoomControlPanelLAFUtils.OPEN_RIGHT;
    }

    var dim = DvtButtonLAFUtils._getDimForced(context, horzContentBar);

    currY += 4;
    var cpHeight = roundedCorner? currY: Math.max(dim.h, currY);
    var paddingBottom = DvtStyleUtils.getStyle(this._styleMap['vbar'],DvtPanZoomControlPanel.CP_PADDING_BOTTOM,0);
    cpHeight += paddingBottom;

    var zoomShape = DvtPanZoomControlPanelLAFUtils.renderEmptyZoomShape(context, cpHeight, this._styleMap, openside, this.getViewPanelHeight());
    var zoomFrame = DvtPanZoomControlPanelLAFUtils.renderEmptyZoomFrame(context, cpHeight, roundedCorner, this._styleMap, openside, this.getViewPanelHeight());

    zoomShape.setTranslate(vertContentBar.getTranslateX(), vertContentBar.getTranslateY());
    
    this._background.addChild(zoomShape);
    vertContentBar.addChildAt(zoomFrame, 0);
  }
    
  return currY;
};

/**
 * Positions elements on the vertical bar
 * @param {DvtContainer} horzContentBar display object representing the horizontal bar
 * @param {DvtContainer} vertContentBar display object representing the vertical bar
 * @param {number} currY current Y coordinate
 * @return {number} updated current Y coordinate
 */
DvtPanZoomControlPanel.prototype._positionVBarElements = function(horzContentBar, vertContentBar, currY) {

  var dim = null;
  var context = this.getCtx();
  var bBiDi = DvtAgent.isRightToLeft(context);
  
  var buttonWidth = DvtStyleUtils.getStyle(this._styleMap,DvtPanZoomControlPanel.CP_OPEN_CLOSE_BUTTON_WIDTH,0);
                                                                  
  if (! this._additionalContent &&
      (this._controls & DvtPanZoomControlPanel.CONTROLS_CENTER_BUTTON) == 0) {

    if (bBiDi) {
      horzContentBar.setTranslateX(0 - horzContentBar.getTranslateX());
      horzContentBar.setTranslateY(0);

      if (vertContentBar) {
        dim = DvtButtonLAFUtils._getDimForced(context, vertContentBar);
        horzContentBar.setTranslateX(horzContentBar.getTranslateX() - buttonWidth);
        vertContentBar.setTranslateY(0);
      }
    }
    else {
      if (vertContentBar) {
        var cpWidth = this.getViewPanelWidth();
        vertContentBar.setTranslate(0, 0);
        horzContentBar.setTranslate(horzContentBar.getTranslateX() + cpWidth, 0);
      }
      else {
        horzContentBar.setTranslate(horzContentBar.getTranslateX(), 0);
      }
    }
  }
  else if (bBiDi && vertContentBar) {
    var dimHorizontal = DvtButtonLAFUtils._getDimForced(context, horzContentBar);
    var barWidth = this.getViewPanelWidth();
    horzContentBar.setTranslateX(0);
    vertContentBar.setTranslateX(dimHorizontal.w + dimHorizontal.x - barWidth);
  }
  
};

/**
 * Creates pan control and adds it to the horizontal bar of the control panel
 * @param {DvtContainer} horzContentBar display object representing the horizontal bar
 * @param {number} nKidHorzContentBar number of child objects on the horizontal bar
 * @return {number} updated number of child objects on the horizontal bar
 */
DvtPanZoomControlPanel.prototype._createHBarPanControl = function(horzContentBar, nKidHorzContentBar) {

  var context = this.getCtx();
  
  //BUG FIX #10154856: determine if the control panel is showing a single or 
  //double row of controls
  var bSingleRow = this.isSingleHorzRow();

  // hide panControl if it is off
  if ((this._controls & DvtPanZoomControlPanel.CONTROLS_CENTER_BUTTON) != 0) {
    this._panControl = DvtButtonLAFUtils.createPanControl(context, this._panZoomCanvas, this.getResources(), this._controls, this._buttonImages, this._styleMap);

    //BUG FIX #10154856: create underlays to erase the view of the intersection
    //between the horz and vert arms of the control panel under the pan control,
    //and to show a solid background behind the pan control so that it blends
    //in with the rest of the control panel
    if (bSingleRow) {
      this._panControlUnderlay = DvtButtonLAFUtils.createPanButtonUnderlay(context, this._styleMap);
      this._panControlUnderlay2 = DvtButtonLAFUtils.createPanButtonUnderlay(context, this._styleMap);

      //need to add this one first, because it will be used to erase everything 
      //underneath
      horzContentBar.addChild(this._panControlUnderlay2);
      //add this one second, because it will be visible behind the pan control
      horzContentBar.addChild(this._panControlUnderlay);

      //TODO: Note don't have BlendMode in html5
      //need to set container blendMode to LAYER so that we can use ERASE on
      //bottom-most underlay
//       this.blendMode = BlendMode.LAYER;
//       panControlUnderlay2.blendMode = BlendMode.ERASE;
    }

    horzContentBar.addChild(this._panControl);
    nKidHorzContentBar++;
  }

  return nKidHorzContentBar;
};

/**
 * Creates a container that holds additional content created by subclasses. Adds the container to the horizontal bar.
 * See PopulateHorzContentBar() method for details about additional content.
 * @param {DvtContainer} horzContentBar display object representing the horizontal bar
 * @param {number} nKidHorzContentBar number of child objects on the horizontal bar
 * @return {number} updated number of child objects on the horizontal bar
 */
DvtPanZoomControlPanel.prototype._createHBarAdditionalContent = function(horzContentBar, nKidHorzContentBar) {

  var context = this.getCtx();
  
  //allow subclasses to put their custom tools in the horzContentBar
  this._additionalContent = new DvtContainer(context);
  this.PopulateHorzContentBar(this._additionalContent);

  // dont render additionalContent if no children
  if (this._additionalContent.getNumChildren() > 0) {
    horzContentBar.addChild(this._additionalContent);
    nKidHorzContentBar++;
  }
  else {
    this._additionalContent = null;
  }
  return nKidHorzContentBar;
  
};

/**
 * Creates a collapse button for the horizontal bar
 * @param {DvtContainer} horzContentBar display object representing the horizontal bar
 */
DvtPanZoomControlPanel.prototype._createHBarCollapseButton = function(horzContentBar) {
  this._collapseButton = DvtButtonLAFUtils.createCollapseButton(this.getCtx(), this._buttonImages, this.getViewPanelHeight(), this._styleMap, DvtAgent.isRightToLeft(this.getCtx()));
  this._collapseButton.setCallback(this.HandleCollapseClick, this);
  this._collapseButton.setCursor(DvtSelectionEffectUtils.getSelectingCursor());
  var proxy = new DvtPanZoomControlPanelEventHandlerProxy(this, null, null, 
                                                    null, null, null, 
                                                    this.getResources().getControlPanelCollapseTooltip());
  this._eventManager.associate(this._collapseButton, proxy);
  horzContentBar.addChild(this._collapseButton);
};

/**
 * Positions elements on the horizontal bar of the control panel
 * @param {boolean} bBiDi true if right-to-left, false otherwise
 * @param {number} currX current X coordinate
 * @return {number} updated current X coordinate
 */
DvtPanZoomControlPanel.prototype._positionHBarElements = function(bBiDi, currX) {
  var context = this._context;
  var dim = null;
  var collapseButtonWidth = DvtStyleUtils.getStyle(this._styleMap,DvtPanZoomControlPanel.CP_OPEN_CLOSE_BUTTON_WIDTH,0);
  var buttonWidth = DvtStyleUtils.getStyle(this._styleMap,DvtPanZoomControlPanel.CP_BUTTON_WIDTH,0);
  var panelWidth = this.getViewPanelWidth();
  var panelHeight = this.getViewPanelHeight();
  var buttonPaddingSide = DvtStyleUtils.getStyle(this._styleMap['hbar'],DvtPanZoomControlPanel.CP_PADDING_LEFT,0);
  var buttonPaddingInner = DvtStyleUtils.getStyle(this._styleMap['hbar'],DvtPanZoomControlPanel.CP_PADDING_INNER,0);
  
  if(bBiDi) {
    this._collapseButton.setTranslateX(0);
    currX += collapseButtonWidth;

    if (this._additionalContent) {
      dim = DvtButtonLAFUtils._getDimForced(context, this._additionalContent);
      currX += buttonPaddingInner;
      this._additionalContent.setTranslate(currX, (panelHeight - dim.h)/2);

      currX += Math.max(dim.w, buttonWidth);
    }

    if (this._panControl) {
      currX += buttonPaddingInner;
      var yy = 3.5;
      
      this._panControl.setTranslate(currX, yy);

      //BUG FIX #10154856: keep underlays in sync with pan control position
      if (this._panControlUnderlay) {
        this._panControlUnderlay.setTranslate(currX, yy);
      }

      if (this._panControlUnderlay2){
        this._panControlUnderlay2.setTranslate(currX, yy);
      }
      dim = DvtButtonLAFUtils._getDimForced(context, this._panControl);//40, 40
      currX += dim.w;
    }
    currX += buttonPaddingSide;
  }
  else {
    //position pan control    
    if (this._panControl)
    {
      //offset the pan control slightly
      currX += buttonPaddingSide;
      var xx = buttonPaddingSide;
      var yy = 3.5;
      this._panControl.setTranslate(xx, yy);

      //BUG FIX #10154856: keep underlays in sync with pan control position
      if (this._panControlUnderlay) {
        this._panControlUnderlay.setTranslate(xx, yy);
      }
      if (this._panControlUnderlay2) {
        this._panControlUnderlay2.setTranslate(xx, yy);
      }
      
      dim = DvtButtonLAFUtils._getDimForced(context, this._panControl);   
      currX += buttonPaddingInner + dim.w;
      currX += 1;//49	
    }
  
    //position additional content
    if (this._additionalContent) {
      dim = DvtButtonLAFUtils._getDimForced(context, this._additionalContent);
      if (currX == 0)
        currX += buttonPaddingSide;
      this._additionalContent.setTranslate(currX, (panelHeight - dim.h)/2);

      currX += dim.w;
      currX += buttonPaddingInner;      
      currX = Math.max(currX, panelWidth);        
    }

    //position collapse button
    this._collapseButton.setTranslateX(currX);    
    currX += collapseButtonWidth;
  }
  return currX;
};

/**
 * Creates horizontal bar background and border
 * @param {DvtContainer} horzContentBar display object representing the horizontal bar
 * @param {number} nKidHorzContentBar number of child objects on the horizontal bar
 * @param {boolean} bBiDi true if right-to-left, false otherwise 
 * @param {number} currX current X coordinate
 */
DvtPanZoomControlPanel.prototype._createHBarBackground = function(horzContentBar, nKidHorzContentBar, bBiDi, currX) {
  var context = this._context;
  var buttonWidth = DvtStyleUtils.getStyle(this._styleMap,DvtPanZoomControlPanel.CP_OPEN_CLOSE_BUTTON_WIDTH,0);
  var panelWidth = DvtStyleUtils.getStyle(this._styleMap, DvtPanZoomControlPanel.CP_TAB_SIZE, 0);
  var panelDrawerStyle = DvtStyleUtils.getStyle(this._styleMap, DvtPanZoomControlPanel.CP_PANEL_DRAWER_STYLES, null);  
  var backgroundWidth = panelDrawerStyle ? currX : currX-buttonWidth;  
  var backgroundHeight = this.getViewPanelHeight();
  var backgroundFrameOffsetX = 0;
  var backgroundShapeOffsetX = 0;
  if (!panelDrawerStyle) {
    backgroundFrameOffsetX = bBiDi ? buttonWidth : 0;
    backgroundShapeOffsetX = bBiDi ? buttonWidth : 0;
  }
  else if (panelDrawerStyle && nKidHorzContentBar == 0)
    backgroundShapeOffsetX = bBiDi ? -panelWidth : panelWidth;
 
  if (nKidHorzContentBar > 0 || panelDrawerStyle) {
    var viewFrame = null;
    
    var r = parseInt(DvtStyleUtils.getStyle(this._styleMap, DvtCSSStyle.BORDER_RADIUS, 0));
    if (panelDrawerStyle) {
      var openSide = nKidHorzContentBar > 0 ? DvtPanZoomControlPanelLAFUtils.OPEN_BOTTOM : DvtPanZoomControlPanelLAFUtils.OPEN_LEFT;
      viewFrame = DvtPanZoomControlPanelLAFUtils.makeViewOpenShapeHelperOpenSide(context, r, backgroundWidth, backgroundHeight, openSide, panelWidth);
    }
    else
      viewFrame = DvtPanZoomControlPanelLAFUtils.makeViewOpenShapeHelper(context, r, backgroundWidth - (2 * r), backgroundHeight - (2 * r), 0, 0, !bBiDi); 
    viewFrame.setSolidStroke(DvtStyleUtils.getStyle(this._styleMap, DvtCSSStyle.BORDER_COLOR, null));
    viewFrame.setFill(null);
    viewFrame.setTranslateX(horzContentBar.getTranslateX() + backgroundFrameOffsetX);  
    horzContentBar.addChildAt(viewFrame, 0);

    var viewShape = DvtPanZoomControlPanelLAFUtils.createEmptyViewOpenShape(context, backgroundWidth, 
                                                              this.getViewPanelHeight(), !bBiDi, this._styleMap);
    viewShape.setTranslate(horzContentBar.getTranslateX() + backgroundShapeOffsetX, horzContentBar.getTranslateY());
    this._background.addChild(viewShape);
  }
};

/**
 * Render the expanded state of the panel.
 * 
 * @return {DvtContainer} display object representing expanded state
 */
DvtPanZoomControlPanel.prototype.RenderExpanded = function() {

  var context = this.getCtx();
  var s = new DvtContainer(context);

  this._background = new DvtContainer(context);
  this._frame = new DvtContainer(context);
  s.addChild(this._background);
  s.addChild(this._frame);  
  
  var bBiDi = DvtAgent.isRightToLeft(context);

  //initialize the starting locations for content bar tools
  var currX = 0;

  //create the horizontal content bar, which contains the pan control,
  //layout combo box and control panel collapse button
  var horzContentBar = new DvtContainer(context);
  var nKidHorzContentBar = 0;
  
  nKidHorzContentBar = this._createHBarPanControl(horzContentBar, nKidHorzContentBar);
  this._createHBarCollapseButton(horzContentBar); //create before additional content, 
                                                 //additional content dropdown will be on top of collapse button
  nKidHorzContentBar = this._createHBarAdditionalContent(horzContentBar, nKidHorzContentBar);

  currX = this._positionHBarElements(bBiDi, currX);
  
  //create the vertical content bar, which contains the zoom-to-fit
  //button, zoom in button, zoom out button, and zoom slider

  var vertContentBar = null;
  var currY = this._getVBarButtonsOffsetY(nKidHorzContentBar);
  //BUG FIX #10154856: if showing a single horizontal row, offset the start of the 
  //vertical controls to leave room for the pan control
  if (this.isSingleHorzRow() && 
      (this._controls & DvtPanZoomControlPanel.CONTROLS_CENTER_BUTTON) != 0)
    currY += (DvtPanZoomControlPanelLAFUtils.getViewPanelHeight() - this.getViewPanelHeight());

  if ((this._controls & DvtPanZoomControlPanel.CONTROLS_ZOOM_TO_FIT_BUTTON) != 0 ||
      (this._controls & DvtPanZoomControlPanel.CONTROLS_ZOOM) != 0) {

    vertContentBar = new DvtContainer(context);
    vertContentBar.setTranslateY(horzContentBar.getTranslateY() + this.getViewPanelHeight());
    
    currY = this._addZoomToFitButton(vertContentBar, currY);
    currY = this._addZoomControls(vertContentBar, currY);
    
    this._frame.addChild(vertContentBar);
  }
  
  //Bug 13376596 - pan control in control panel difficult to use
  //problem is part of the vertical content bar overlap the pan control
  this._createHBarBackground(horzContentBar, nKidHorzContentBar, bBiDi, currX);
  this._frame.addChild(horzContentBar);
  this._positionVBarElements(horzContentBar, vertContentBar, currY);
  
  //render background after all tools have been added so that
  //we know the size of the content bar 
  this._createVBarBackground(horzContentBar, vertContentBar, nKidHorzContentBar, currY);
  this._expandedDim = DvtButtonLAFUtils._getDimForced(context, s);   
  
  return s;
};

/**
 * Populate the horzContentBar with additional tools.  
 * This implementation does nothing.  Subclasses should override to include
 * custom tools in the control panel.  
 * 
 * @param contentSprite sprite to contain additional tools that will be
 *        added to the horzContentBar
 */
DvtPanZoomControlPanel.prototype.PopulateHorzContentBar = function(contentSprite) {
  //do nothing
};

/**
 * Toggle the state of the control panel between expanded and collapsed.
 */
DvtPanZoomControlPanel.prototype.toggleExpandCollapse = function() {
  if (!this._bTransition) {
    if (this._state === DvtPanZoomControlPanel.STATE_EXPANDED) {
      this._doCollapse();
    }
    else if (this._state === DvtPanZoomControlPanel.STATE_COLLAPSED) {
      this._doExpand();
    }
  }
};

/**
 * Get the dimensions of the panel in its collapsed state.
 * 
 * @return dimensions of collapsed panel
 */
DvtPanZoomControlPanel.prototype.getCollapsedDim = function() {
  return this._collapsedDim;
};

DvtPanZoomControlPanel.prototype.getExpandedDim = function() {
  return this._expandedDim;
};

/**
 * Handle a mouse click on the expand button.
 * 
 * @param {DvtMouseEvent} event MouseEvent
 */
DvtPanZoomControlPanel.prototype.HandleExpandClick = function(event) {
  //don't want click to fall through to other components
  DvtEventManager.consumeEvent(event);
  
  if (!this._bTransition) {
    this._doExpand();
    if (this.getTooltipManager()) {
      this.getTooltipManager().hideTooltip();
    }
  }
};

/**
 * Handles transition from collapsed state to expanded state.
 * 
 * @private
 */
DvtPanZoomControlPanel.prototype._doExpand = function() {
  //make sure _doCollapse and _doExpand cannot be called
  this._bTransition = true;
  this.setMouseEnabled(false);

  //render the expanded control panel
  var s = this.RenderExpanded();
  this.addChild(s);

  //apply alphas based on mouse position
  this._applyAlphasForMouse();

  //transition from the collapsed control panel to the expanded one
  this.transitionExpand(this.getChildAt(0), s);
  
  //update state
  this._state = DvtPanZoomControlPanel.STATE_EXPANDED;
      
  //BUG FIX #8719343: fire expand event
  this.fireExpandEvent();
};

/**
 * Apply alphas based on whether the mouse is over the control panel.
 */
DvtPanZoomControlPanel.prototype._applyAlphasForMouse = function() {
  //apply alphas based on whether the mouse is over the control panel
  var bMouseOver = false;
  var stage = this.getCtx().getStage();
  if (stage) {
      bMouseOver = true;//TODO???hitTestPoint(stage.mouseX, stage.mouseY, true);
  }
  if (bMouseOver) {
    this._applyAlphasRollover();
  }
  else {
    this._applyAlphasRollout();
  }
}

/**
 * Handle a mouse click on the collapse button.
 * 
 * @param {DvtMouseEvent} event MouseEvent
 */
DvtPanZoomControlPanel.prototype.HandleCollapseClick = function(event) {
  //don't want click to fall through to other components
  DvtEventManager.consumeEvent(event);
      
  if (!this._bTransition) {
    this._doCollapse();
  }
}

/**
 * Handles transition from expanded state to collapsed state.
 * 
 * @private
 */
DvtPanZoomControlPanel.prototype._doCollapse = function() {
  //make sure _doCollapse and _doExpand cannot be called
  this._bTransition = true;

  //render the collapsed control panel
  var s = this.RenderCollapsed();
  this.addChild(s);

  //apply alphas based on mouse position
  this._applyAlphasForMouse();

  //transition from the expanded control panel to the collapsed one
  this.transitionCollapse(this.getChildAt(0), s);
  
  //update state
  this._state = DvtPanZoomControlPanel.STATE_COLLAPSED;

  //BUG FIX #8719343: fire collapse event
  this.fireCollapseEvent();
}

/**
 * Animate the transition from the collapsed control to the expanded control.
 * 
 * @param {DvtContainer} oldContent collapsed control
 * @param {DvtContainer} newContent expanded control
*/ 
DvtPanZoomControlPanel.prototype.transitionExpand = function(oldContent, newContent) {
  var odim = oldContent.getDimensions();
  var openCloseButtonWidth = DvtStyleUtils.getStyle(this._styleMap,DvtPanZoomControlPanel.CP_OPEN_CLOSE_BUTTON_WIDTH,0);
         
  // No need to animate if control panel was initially added to the DOM indicating this is an initial render
  if (odim && odim.w != 0) {
    var ndim = newContent.getDimensions();
    //fade out old, fade in new
    var animator = new DvtAnimator(this.getCtx(), .25);
    oldContent.setAlpha(1);
    newContent.setAlpha(0);
    animator.addProp(DvtAnimator.TYPE_NUMBER, oldContent, oldContent.getAlpha, oldContent.setAlpha, 0);
    animator.addProp(DvtAnimator.TYPE_NUMBER, newContent, newContent.getAlpha, newContent.setAlpha, 1);
  
    //grow new control from size of old
    // newContent.width = oldContent.width;
    // t.$(newContent).scaleX = 1.0;
    newContent.setScaleX(odim.w/ndim.w);
    animator.addProp(DvtAnimator.TYPE_NUMBER, newContent, newContent.getScaleX, newContent.setScaleX, 1);
  
    //BiDi: need to change x position also, because panel expands out to the left
    if (DvtAgent.isRightToLeft(this.getCtx())) {
      newContent.setTranslateX(oldContent.getTranslateX());
      var dimWidth = ndim.w + ndim.x;
      animator.addProp(DvtAnimator.TYPE_NUMBER, newContent, newContent.getTranslateX, newContent.setTranslateX, 
                       oldContent.getTranslateX() + openCloseButtonWidth - dimWidth);
    }
  
    // newContent.height = oldContent.height;
    // t.$(newContent).scaleY = 1.0;
    newContent.setScaleY(odim.h/ndim.h);
    animator.addProp(DvtAnimator.TYPE_NUMBER, newContent, newContent.getScaleY, newContent.setScaleY, 1);
  
    //remove the old control at the end of the transition
    // t.removeChild(oldContent);
    // t.play();
    animator.setOnEnd(function() {
      oldContent.getParent().removeChild(oldContent);
      this._bTransition = false;
      this.setMouseEnabled(true);
      }, this);
      
    animator.play();
  } else {
    oldContent.getParent().removeChild(oldContent);
    var transX;
    if (DvtAgent.isRightToLeft(this.getCtx())) {
        var ndim = DvtDisplayableUtils._getDimForced(this.getCtx(), newContent);
        var dimWidth = Math.floor(ndim.w + ndim.x);
        transX = openCloseButtonWidth - dimWidth;
    }
    else
        transX = 0;
    newContent.setTranslate(transX, 0);
  }
}

/**
 * Animate the transition from the expanded control to the collapsed control.
 * 
 * @param {DvtContainer} oldContent expanded control
 * @param {DvtContainer} newContent collapsed control
 */
DvtPanZoomControlPanel.prototype.transitionCollapse = function(oldContent, newContent) {
  var animator = new DvtAnimator(this.getCtx(), .25);

  //fade out old, fade in new
  oldContent.setAlpha(1);
  newContent.setAlpha(0);
  animator.addProp(DvtAnimator.TYPE_NUMBER, oldContent, oldContent.getAlpha, oldContent.setAlpha, 0);
  animator.addProp(DvtAnimator.TYPE_NUMBER, newContent, newContent.getAlpha, newContent.setAlpha, 1);

  //shrink old control to size of new
  var ndim = this.getCollapsedDim();
  var odim = this.getExpandedDim();
  animator.addProp(DvtAnimator.TYPE_NUMBER, oldContent, oldContent.getScaleX, oldContent.setScaleX, ndim.w/odim.w);

  //BiDi: need to change x position also, because panel collapses to the right
  if (DvtAgent.isRightToLeft(this.getCtx())) {
    animator.addProp(DvtAnimator.TYPE_NUMBER, oldContent, oldContent.getTranslateX, oldContent.setTranslateX, 
                     newContent.getTranslateX());
  }
  animator.addProp(DvtAnimator.TYPE_NUMBER, oldContent, oldContent.getScaleY, oldContent.setScaleY, ndim.h/odim.h);

  //remove the old control at the end of the transition
  animator.setOnEnd(function() {
    oldContent.getParent().removeChild(oldContent);
    this._bTransition = false;
    }, this);
    
  animator.play();
}

/**
 * Fire expand event.
 * 
 * @return true if event was dispatched successfully, 
 *         false otherwise
 */
DvtPanZoomControlPanel.prototype.fireExpandEvent = function() {
  var event = new DvtPanZoomControlPanelEvent(DvtPanZoomControlPanelEvent.SUBTYPE_SHOW);
  this.FireListener(event);
  return true;
}

/**
 * Fire collapse event.
 * 
 * @return true if event was dispatched successfully,
 *         false otherwise
 */
DvtPanZoomControlPanel.prototype.fireCollapseEvent = function() {
  var event = new DvtPanZoomControlPanelEvent(DvtPanZoomControlPanelEvent.SUBTYPE_HIDE);
  this.FireListener(event);
  return true;
}

/**
 * Adjust the collapse and expand arrow icons for BiDi.
 * 
 * @param dispObjCon display object containing the arrow icon
 * @param offset amount to translate arrow icon
 */
DvtPanZoomControlPanel.prototype.adjustArrowsIconForBiDi = function(dispObjCon, offset) {
  var loader = this.findLoader(dispObjCon);
  if (loader) {
    loader.setTranslateX(loader.getTranslateX() + offset);
  }
};

/**
 * Find a Loader object in the given container.
 * 
 * @param dispObjCon container to look for a Loader object in
 * 
 * @return Loader object found, or null if none found
 */
DvtPanZoomControlPanel.prototype.findLoader = function(dispObjCon) {
  var childCount = dispObjCon.getNumChildren();
  var dispObj;
  for (var i = 0; i < childCount; i++) {
    dispObj = dispObjCon.getChildAt(i);
    if (dispObj instanceof DvtImage) {
      return dispObj;
    }
    else if (dispObj instanceof DvtContainer) {
      return this.findLoader(dispObj);
    }
  }
  return null;
};

// Mouse event handling
DvtPanZoomControlPanel.prototype.HandleRollOver = function(event) {
  this._bMouseOver = true;
  if (!this._bMouseDragPanning)
  {
    this._applyAlphasRollover();
  }
};

DvtPanZoomControlPanel.prototype.HandleRollOut = function(event) {
  this._bMouseOver = false;
  if (!this._bMouseDragPanning)
  {
    this._applyAlphasRollout();
  }
};

/**
 * Apply alphas to the background and frame for when the
 * mouse is over the control panel.
 */
DvtPanZoomControlPanel.prototype._applyAlphasRollover = function() {
  this._background.setAlpha(this._styleMap[DvtPanZoomControlPanel.BG_ROLLOVER_ALPHA]);
  this._frame.setAlpha(this._styleMap[DvtPanZoomControlPanel.FRAME_ROLLOVER_ALPHA]);
    
  //BUG FIX #10154856: fade underlay just like control panel fill
  if (this._panControlUnderlay) {
    this._panControlUnderlay.setAlpha(this._styleMap[DvtPanZoomControlPanel.BG_ROLLOVER_ALPHA]);
  }
};

/**
 * Apply alphas to the background and frame for when the
 * mouse is not over the control panel.
 */
DvtPanZoomControlPanel.prototype._applyAlphasRollout = function() {
  this._background.setAlpha(this._bgAlpha);
  this._frame.setAlpha(this._styleMap[DvtPanZoomControlPanel.FRAME_ROLLOUT_ALPHA]);
    
  //BUG FIX #10154856: fade underlay just like control panel fill
  if (this._panControlUnderlay) {
    this._panControlUnderlay.setAlpha(this._bgAlpha);
  }
};

/**
 * Determine if the zoom slider is supposed to be included in the control panel.
 * 
 * @return true if the zoom slider is supposed to be included, false if not
 */
DvtPanZoomControlPanel.prototype.isZoomSliderShown = function() {
  //  return (this._controls & DvtPanZoomControlPanel.CONTROLS_ZOOM_SLIDER) > 0;
  return false;
}

DvtPanZoomControlPanel.prototype.isPanControlShown = function() {
  return (this._controls & DvtPanZoomControlPanel.CONTROLS_CENTER_BUTTON) > 0;
}

/**
 * @override
 */
DvtPanZoomControlPanel.prototype.getDimensions = function() {
  if (! this._dim) {
    this._dim = DvtPanZoomControlPanel.superclass.getDimensions.call(this);
  }
  return this._dim;
}

DvtPanZoomControlPanel.prototype.renderComponent = function() {
}

DvtPanZoomControlPanel.prototype.getButtonImages = function() {
  return this._buttonImages ;
};

/**
 * Returns top padding for vertical bar
 * @return {number} number of pixels specified as top padding for vertical bar
 */
DvtPanZoomControlPanel.prototype._getVBarButtonsOffsetY = function(nKidHorzContentBar) {
  // we need extra room if we have pan control or if this is Alta style and horizontal bar is empty
  if ( (this._controls & DvtPanZoomControlPanel.CONTROLS_CENTER_BUTTON) || 
    this._styleMap && this._styleMap[DvtPanZoomControlPanel.CP_PANEL_DRAWER_STYLES] && nKidHorzContentBar == 0)
    return DvtStyleUtils.getStyle(this._styleMap['vbar'],DvtPanZoomControlPanel.CP_PADDING_TOP,0);
  else
    return 0;
};


DvtPanZoomControlPanel.prototype.enableZoomControls = function(){
  var currZoom = this._panZoomCanvas.getZoom();
  var nextZoom = this._panZoomCanvas.getNextZoomLevel(currZoom);
  var prevZoom = this._panZoomCanvas.getPrevZoomLevel(currZoom);
  if (this._zoomInButton)
    this._zoomInButton.setEnabled(currZoom != nextZoom);
  if (this._zoomOutButton)
    this._zoomOutButton.setEnabled(currZoom != prevZoom);
}

DvtPanZoomControlPanel.prototype.enableZoomInControl = function(enabled){
  if (this._zoomInButton)
    this._zoomInButton.setEnabled(enabled);
}

DvtPanZoomControlPanel.prototype.enableZoomOutControl = function(enabled){
  if (this._zoomOutButton)
    this._zoomOutButton.setEnabled(enabled);
}
/**
 * Default values and utility functions for PanZoomControlPanel versioning.
 * @class
 */
var DvtPanZoomControlPanelDefaults = new Object();

DvtObj.createSubclass(DvtPanZoomControlPanelDefaults, DvtObj, "DvtPanZoomControlPanelDefaults");

/**
 * Contains overrides for the 'alta' skin.
 */ 
DvtPanZoomControlPanelDefaults.SKIN_ALTA = {
  'fill-type': 'solid',
  'backgroundAlpha': 1,
  'backgroundDragAlpha': 1,
  'borderDragAlpha': 1,  
  'panelDrawerStyles': true,
  'buttonWidth': 42,
  'buttonHeight': 42,
  'buttonRadius': 0,
  'openCloseButtonWidth':42,
  'tabSize': 42,
  'paddingTop': 15,
  'paddingSide': -1,
  'imageWidth': 24,
  'imageHeight': 24,
  'centerButtonDisplayed': false,
  'scrollbarBackground': 'linear-gradient(bottom, #dce2e7 0%, #f8f8f8 8%)',
  'scrollbarBorderColor': '#dce2e7',
  'scrollbarHandleColor': '#abb0b4',
  'scrollbarHandleHoverColor' : '#333333',
  'scrollbarHandleActiveColor' : '#333333',
  'comboBox':{
    'paddingTop':0,
    'paddingBottom':0,
    'paddingLeft':0,
    'paddingRight':0,
    'paddingInner':0,
    'itemHeight':30,
    'imagePadding':0,
    'itemPadding':10
  },
  'vbar':{
    'paddingTop':0,
    'paddingBottom':0,
    'paddingLeft':0,
    'paddingRight':0,
    'paddingInner':0    
  },
  'hbar':{
    'paddingTop':0,
    'paddingBottom':0,
    'paddingLeft':0,
    'paddingRight':0,
    'paddingInner':0    
  }  
}

/**
 * Contains overrides for the 'skyros' skin.
 */ 
DvtPanZoomControlPanelDefaults.SKIN_SKYROS = {
  'fill-type': 'solid'
}

/**
 * Contains control panel defaults.
 */ 
DvtPanZoomControlPanelDefaults.DEFAULT = {
  'fill-type': 'gradient',
  'border-color':'#ffffff',
  'background-color':'#ffffff',
  'border-radius': 6,
  'backgroundAlpha': .5,
  'backgroundHoverAlpha': 1.0,
  'backgroundDragAlpha': .5,
  'borderAlpha': 1,
  'borderHoverAlpha': 1,
  'borderDragAlpha': .5,
  'tabSize': 26,
  'buttonWidth': 22,
  'buttonHeight': 22,
  'buttonRadius': 3,
  'paddingTop': 5,
  'paddingSide': 5,  
  'imageWidth': 22,
  'imageHeight': 20,  
  'openCloseButtonWidth':10,
  'centerButtonDisplayed': true,
  'comboBox':{
    'paddingTop':2,
    'paddingBottom':6,
    'paddingLeft':3,
    'paddingRight':3,
    'paddingInner':2,
    'itemHeight':22,
    'radius':4,
    'imagePadding':2,
    'itemPadding':7
  },
  'vbar':{
    'paddingTop':2.5,
    'paddingBottom':2.5,
    'paddingLeft':2,
    'paddingRight':2,
    'paddingInner':2   
  },
  'hbar':{
    'paddingTop':2,
    'paddingBottom':2,
    'paddingLeft':3,
    'paddingRight':3,
    'paddingInner':2    
  } 
}

/**
 * Combines the user options with the defaults for the specified version.  Returns the
 * combined options object.  This object will contain internal attribute values and
 * should be accessed in internal code only.
 * @param {object} userOptions The object containing options specifications for this component.
 * @return {object} The combined options object.
 */
DvtPanZoomControlPanelDefaults.calcOptions = function(userOptions) {
  var defaults = DvtPanZoomControlPanelDefaults._getDefaults(userOptions);

  // Use defaults if no overrides specified
  if(!userOptions)
    return defaults;
  else // Merge the options object with the defaults
    return DvtJSONUtils.merge(userOptions, defaults);
}

/**
 * Returns the default options object for the specified version of the component.
 * @param {object} userOptions The object containing options specifications for this component.
 * @private
 */
DvtPanZoomControlPanelDefaults._getDefaults = function(userOptions) {
  var defaults = null;
  if (userOptions && userOptions['skin'] === 'skyros') 
    defaults = DvtJSONUtils.merge(DvtPanZoomControlPanelDefaults.SKIN_SKYROS, DvtPanZoomControlPanelDefaults.DEFAULT);
  else if (userOptions && userOptions['skin'] === 'alta')
    defaults =  DvtJSONUtils.merge(DvtPanZoomControlPanelDefaults.SKIN_ALTA, DvtPanZoomControlPanelDefaults.DEFAULT);
  else
    defaults = DvtJSONUtils.clone(DvtPanZoomControlPanelDefaults.DEFAULT);
  return defaults;    
}
/**
 * @constructor
 * Class used to maintain translated resources used by the PanZoomControlPanel.
 */
var DvtPanZoomControlPanelResources = function (parent) {
  this.Init(parent);
};


/*
 * make DvtPanZoomControlPanelResources a subclass of DvtObj
 */
DvtObj.createSubclass(DvtPanZoomControlPanelResources, DvtObj, "DvtPanZoomControlPanelResources");


DvtPanZoomControlPanelResources.prototype.Init = function (parent) {
  //control panel
  if(!parent){
      this._controlPanelExpandTooltip = "Show Control Panel (/)";
      this._controlPanelCollapseTooltip = "Hide (/)";
      this._panControlCenterTooltip = "Zoom and Center (Ctrl+Alt+0)";
      this._panControlTooltip = "Pan";
      this._zoomToFitTooltip = "Zoom to Fit (0)";
      this._zoomInTooltip = "Zoom In (+)";
      this._zoomOutTooltip = "Zoom Out (-)";
      this._panelCardTooltip = "View";
      this._layoutHierVertTopTooltip = "Vertical, Top Down";
      this._layoutHierHorzLeftTooltip = "Horizontal, Left-to-Right";
      this._layoutTreeTooltip = "Tree";
      this._layoutRadialTooltip = "Radial";
      this._layoutCircleTooltip = "Circle";
      this._layoutTooltip = "Layout";
  } else {
      this._controlPanelExpandTooltip = parent.getAttr("cpe");
      this._controlPanelCollapseTooltip = parent.getAttr("cpc");
      this._panControlCenterTooltip = parent.getAttr("pcc");
      this._panControlTooltip = parent.getAttr("pc");
      this._zoomToFitTooltip = parent.getAttr("ztf");
      this._zoomInTooltip = parent.getAttr("zi");
      this._zoomOutTooltip = parent.getAttr("zo"); 
      this._panelCardTooltip = parent.getAttr("pcs"); 
      this._layoutHierVertTopTooltip = parent.getAttr("lhvt");
      this._layoutHierHorzLeftTooltip = parent.getAttr("lhhl");
      this._layoutTreeTooltip = parent.getAttr("lt");
      this._layoutRadialTooltip = parent.getAttr("lr");
      this._layoutCircleTooltip = parent.getAttr("lc");
      this._layoutTooltip = parent.getAttr("lo");
  }
}

/**
 * Set the ControlPanelExpandTooltip to use.
 * 
 * @param controlPanelExpandToolTip to use
 */
DvtPanZoomControlPanelResources.prototype.setControlPanelExpandTooltip = function (s) {
  this._controlPanelExpandTooltip = s;
}
  
/**
 * Get the ControlPanelExpandTooltip to use.
 * 
 * @return controlPanelExpandToolTip being used
 */
DvtPanZoomControlPanelResources.prototype.getControlPanelExpandTooltip = function () {
  return this._controlPanelExpandTooltip;
}
    
/**
 * Set the ControlPanelCollapseTooltip to use.
 * 
 * @param controlPanelCollapseToolTip to use
 */
DvtPanZoomControlPanelResources.prototype.setControlPanelCollapseTooltip = function (s) {
  this._controlPanelCollapseTooltip = s;
}
  
/**
 * Get the ControlPanelCollapseTooltip to use.
 * 
 * @return controlPanelCollapseToolTip being used
 */
DvtPanZoomControlPanelResources.prototype.getControlPanelCollapseTooltip = function () {
  return this._controlPanelCollapseTooltip;
}
    
/**
 * Set the PanControlCenterTooltip to use.
 * 
 * @param panControlCenterToolTip to use
 */
DvtPanZoomControlPanelResources.prototype.setPanControlCenterTooltip = function (s) {
  this._panControlCenterTooltip = s;
}
  
/**
 * Get the PanControlCenterTooltip to use.
 * 
 * @return panControlCenterToolTip being used
 */
DvtPanZoomControlPanelResources.prototype.getPanControlCenterTooltip = function () {
  return this._panControlCenterTooltip;
}
    
/**
 * Set the PanControlTooltip to use.
 * 
 * @param panControlToolTip to use
 */
DvtPanZoomControlPanelResources.prototype.setPanControlTooltip = function (s) {
  this._panControlTooltip = s;
}
  
/**
 * Get the PanControlTooltip to use.
 * 
 * @return panControlToolTip being used
 */
DvtPanZoomControlPanelResources.prototype.getPanControlTooltip = function () {
  return this._panControlTooltip;
}

/**
 * Set the ZoomToFitTooltip to use.
 * 
 * @param zoomToFitToolTip to use
 */
DvtPanZoomControlPanelResources.prototype.setZoomToFitTooltip = function (s) {
  this._zoomToFitTooltip = s;
}
  
/**
 * Get the ZoomToFitTooltip to use.
 * 
 * @return zoomToFitToolTip being used
 */
DvtPanZoomControlPanelResources.prototype.getZoomToFitTooltip = function () {
  return this._zoomToFitTooltip;
}
    
/**
 * Set the ZoomInTooltip to use.
 * 
 * @param zoomInToolTip to use
 */
DvtPanZoomControlPanelResources.prototype.setZoomInTooltip = function (s) {
  this._zoomInTooltip = s;
}
  
/**
 * Get the ZoomInTooltip to use.
 * 
 * @return zoomInToolTip being used
 */

DvtPanZoomControlPanelResources.prototype.getZoomInTooltip = function () {
  return this._zoomInTooltip;
}
    
/**
 * Set the ZoomOutTooltip to use.
 * 
 * @param zoomOutToolTip to use
 */
DvtPanZoomControlPanelResources.prototype.setZoomOutTooltip = function (s) {
  this._zoomOutTooltip = s;
}
  
/**
 * Get the ZoomOutTooltip to use.
 * 
 * @return zoomOutToolTip being used
 */
DvtPanZoomControlPanelResources.prototype.getZoomOutTooltip = function () {
  return this._zoomOutTooltip;
}
    
/**
 * Set the PanelCardTooltip to use.
 * 
 * @param panelCardTooltip to use
 */
DvtPanZoomControlPanelResources.prototype.setPanelCardTooltip = function (s) {
  this._panelCardTooltip = s;
}
  
/**
 * Get the PanelCardTooltip to use.
 * 
 * @return panelCardTooltip being used
 */
DvtPanZoomControlPanelResources.prototype.getPanelCardTooltip = function () {
  return this._panelCardTooltip;
}
 
/**
 * Set the LayoutHierVertTopTooltip to use.
 * 
 * @param LayoutHierVertTopTooltip to use
 */
DvtPanZoomControlPanelResources.prototype.setLayoutHierVertTopTooltip = function (s) {
  this._layoutHierVertTopTooltip = s;
}
  
/**
 * Get the LayoutHierVertTopTooltip to use.
 * 
 * @return LayoutHierVertTopTooltip being used
 */
DvtPanZoomControlPanelResources.prototype.getLayoutHierVertTopTooltip = function () {
  return this._layoutHierVertTopTooltip;
}

/**
 * Set the LayoutHierHorzLeftTooltip to use.
 * 
 * @param LayoutHierHorzLeftTooltip to use
 */
DvtPanZoomControlPanelResources.prototype.setLayoutHierHorzLeftTooltip = function (s) {
  this._layoutHierHorzLeftTooltip = s;
}
  
/**
 * Get the LayoutHierHorzLeftTooltip to use.
 * 
 * @return LayoutHierHorzLeftTooltip being used
 */
DvtPanZoomControlPanelResources.prototype.getLayoutHierHorzLeftTooltip = function () {
  return this._layoutHierHorzLeftTooltip;
}


/**
 * Set the LayoutTreeTooltip to use.
 * 
 * @param LayoutTreeTooltip to use
 */
DvtPanZoomControlPanelResources.prototype.setLayoutTreeTooltip = function (s) {
  this._layoutTreeTooltip = s;
}
  
/**
 * Get the LayoutTreeTooltip to use.
 * 
 * @return LayoutTreeTooltip being used
 */
DvtPanZoomControlPanelResources.prototype.getLayoutTreeTooltip = function () {
  return this._layoutTreeTooltip;
}

/**
 * Set the LayoutRadialTooltip to use.
 * 
 * @param LayoutRadialTooltip to use
 */
DvtPanZoomControlPanelResources.prototype.setLayoutRadialTooltip = function (s) {
  this._layoutRadialTooltip = s;
}
  
/**
 * Get the LayoutRadialTooltip to use.
 * 
 * @return LayoutRadialTooltip being used
 */
DvtPanZoomControlPanelResources.prototype.getLayoutRadialTooltip = function () {
  return this._layoutRadialTooltip;
}

/**
 * Set the LayoutCircleTooltip to use.
 * 
 * @param LayoutCircleTooltip to use
 */
DvtPanZoomControlPanelResources.prototype.setLayoutCircleTooltip = function (s) {
  this._layoutCircleTooltip = s;
}
  
/**
 * Get the LayoutCircleTooltip to use.
 * 
 * @return LayoutCircleTooltip being used
 */
DvtPanZoomControlPanelResources.prototype.getLayoutCircleTooltip = function () {
  return this._layoutCircleTooltip;
}

/**
 * Set the LayoutTooltip to use.
 * 
 * @param LayoutTooltip to use
 */
DvtPanZoomControlPanelResources.prototype.setLayoutTooltip = function (s) {
  this._layoutTooltip = s;
}
  
/**
 * Get the LayoutTooltip to use.
 * 
 * @return LayoutTooltip being used
 */
DvtPanZoomControlPanelResources.prototype.getLayoutTooltip = function () {
  return this._layoutTooltip;
}

// Copyright (c) 2012, 2014, Oracle and/or its affiliates. All rights reserved.
/**
 * @constructor
 */
var DvtPanZoomControlPanelEventManager = function(context, callback, callbackObj) {
  this.Init(context, callback, callbackObj);
};

DvtObj.createSubclass(DvtPanZoomControlPanelEventManager, DvtEventManager, "DvtPanZoomControlPanelEventManager");

/**
 * Click event handler.
 * @protected
 */
DvtPanZoomControlPanelEventManager.prototype.OnMouseDown = function(event) {
  var obj = this.GetLogicalObject(this.GetCurrentTargetForEvent(event));
  DvtPanZoomControlPanelEventManager.superclass.OnMouseDown.call(this, event);
  
  // Done if there is no object
  if (!obj) {
    return;
  }
  
  if (obj.HandleMouseDown) {
    obj.HandleMouseDown(event);
  }
  event.stopPropagation();
};

DvtPanZoomControlPanelEventManager.prototype.OnMouseUp = function(event) {
  var obj = this.GetLogicalObject(this.GetCurrentTargetForEvent(event));
  DvtPanZoomControlPanelEventManager.superclass.OnMouseUp.call(this, event);
  
  // Done if there is no object
  if (!obj) {
    return;
  }
  
  if (obj.HandleMouseUp) {
    obj.HandleMouseUp(event);
  }
  event.stopPropagation();
}

DvtPanZoomControlPanelEventManager.prototype.OnMouseOut = function(event) {
  var obj = this.GetLogicalObject(this.GetCurrentTargetForEvent(event));
  DvtPanZoomControlPanelEventManager.superclass.OnMouseOut.call(this, event);
  
  // Done if there is no object
  if (!obj) {
    return;
  }
  
  if (obj.HandleMouseOut) {
    obj.HandleMouseOut(event);
  }
  event.stopPropagation();
}

/**
 * Click event handler.
 * @protected
 */
DvtPanZoomControlPanelEventManager.prototype.OnClick = function(event) {
  
  var obj = this.GetLogicalObject(this.GetCurrentTargetForEvent(event));
  DvtPanZoomControlPanelEventManager.superclass.OnClick.call(this, event);
  
  // Done if there is no object
  if (!obj) {
    return;
  }
  
  if (obj.HandleClick) {
    obj.HandleClick(event);
  }
  event.stopPropagation();
};

/**
 * Roll Over event handler
 * @protected
 */
DvtPanZoomControlPanelEventManager.prototype.OnRollOver = function(event) {
  DvtPanZoomControlPanelEventManager.superclass.OnRollOver.call(this, event);
  var obj = this.GetLogicalObject(this.GetCurrentTargetForEvent(event));
  
  // Return if no object is found
  if (!obj) {
    return;
  }
  
  if(obj.HandleRollOver) {
    obj.HandleRollOver(event);
  }
};

/**
 * Roll Out event handler
 * @protected
 */
DvtPanZoomControlPanelEventManager.prototype.OnRollOut = function(event) {
  DvtPanZoomControlPanelEventManager.superclass.OnRollOut.call(this, event);
  var obj = this.GetLogicalObject(this.GetCurrentTargetForEvent(event));
    
  // Return if no object is found
  if (!obj) {
    return;
  }
  
  if(obj.HandleRollOut) {
    obj.HandleRollOut(event);
  }  
};

/**
 * @override
 */
DvtPanZoomControlPanelEventManager.prototype.OnComponentTouchClick = function(event) {
  var obj = this.GetLogicalObject(this.GetCurrentTargetForEvent(event));
  
  // Return if no object is found
  if (!obj) {
    return;
  }
  
  if(obj.HandleClick) {
    obj.HandleClick(event);
  }
  event.stopPropagation();
}
/**
 * @override
 */
DvtPanZoomControlPanelEventManager.prototype.HandleImmediateTouchStartInternal = function(event) {
 event.blockTouchHold();
 DvtEventManager.consumeEvent(event);
}

/*
 * DvtPanZoomControlPanelEventHandlerProxy Utility 
 */
var DvtPanZoomControlPanelEventHandlerProxy = function (callback, handleClick, handleMouseDown, handleMouseUp, handleMouseOut, handleMouseOver, tooltip){
  this.Init(callback, handleClick, handleMouseDown, handleMouseUp, handleMouseOut, handleMouseOver, tooltip);
};

DvtObj.createSubclass(DvtPanZoomControlPanelEventHandlerProxy, DvtObj, "DvtPanZoomControlPanelEventHandlerProxy");

DvtPanZoomControlPanelEventHandlerProxy.prototype.Init = function (callbackObj, handleClick, handleMouseDown, handleMouseUp, handleMouseOut, handleMouseOver, tooltip) {
  this._callbackObj = callbackObj;
  this._handleClick = handleClick;
  this._handleMouseUp = handleMouseUp;
  this._handleMouseDown = handleMouseDown;
  this._handleMouseOut = handleMouseOut;
  this._handleMouseOver = handleMouseOver;
  this._tooltip = tooltip;
};

DvtPanZoomControlPanelEventHandlerProxy.prototype.HandleClick = function(event) {
  if (this._handleClick)
    this._handleClick.call(this._callbackObj, event);
};
DvtPanZoomControlPanelEventHandlerProxy.prototype.HandleMouseDown = function(event) {
  if (this._handleMouseDown)
    this._handleMouseDown.call(this._callbackObj, event);
};
DvtPanZoomControlPanelEventHandlerProxy.prototype.HandleMouseUp = function(event) {
  if (this._handleMouseUp)
    this._handleMouseUp.call(this._callbackObj, event);
};  
DvtPanZoomControlPanelEventHandlerProxy.prototype.HandleMouseOut = function(event) {
  if (this._handleMouseOut)
    this._handleMouseOut.call(this._callbackObj, event);
};
DvtPanZoomControlPanelEventHandlerProxy.prototype.HandleMouseOver = function(event) {
  if (this._handleMouseOver)
    this._handleMouseOver.call(this._callbackObj, event);
};
DvtPanZoomControlPanelEventHandlerProxy.prototype.getTooltip = function() {
  return this._tooltip;
};
/*
 * DvtPanZoomControlPanelLAFUtils Utility class for providing LAF for buttons in the control panel.
 */
var DvtPanZoomControlPanelLAFUtils = {};

DvtObj.createSubclass(DvtPanZoomControlPanelLAFUtils, DvtObj, "DvtPanZoomControlPanelLAFUtils");

DvtPanZoomControlPanelLAFUtils.OPEN_TOP = "top";
DvtPanZoomControlPanelLAFUtils.OPEN_RIGHT = "right";
DvtPanZoomControlPanelLAFUtils.OPEN_LEFT = "left";
DvtPanZoomControlPanelLAFUtils.OPEN_BOTTOM = "bottom";

DvtPanZoomControlPanelLAFUtils.VIEW_PANEL_HEIGHT = 47;
DvtPanZoomControlPanelLAFUtils.VIEW_PANEL_HALF_HEIGHT = 26;

DvtPanZoomControlPanelLAFUtils.SIN_PI_4 = Math.sin(Math.PI / 4);
DvtPanZoomControlPanelLAFUtils.TAN_PI_8 = Math.tan(Math.PI / 8);

/**
 * Returns the height of the horizontal bar of the control panel to allow
 * showing double rows of controls
 * @return {number} height of the horizontal bar for double rows
 */
DvtPanZoomControlPanelLAFUtils.getViewPanelHeight = function () {
  return DvtPanZoomControlPanelLAFUtils.VIEW_PANEL_HEIGHT;
}

/**
 * Returns the height of the horizontal bar of the control panel to allow
 * showing only a single row of controls, like in TMap.
 * @return {number} height of the horizontal bar for single row
 */
DvtPanZoomControlPanelLAFUtils.getViewPanelHalfHeight = function () {
  //BUG FIX #10154856: show single row of controls in horizontal arm of control panel in TMap
  return DvtPanZoomControlPanelLAFUtils.VIEW_PANEL_HALF_HEIGHT;
}

/**
 * Create the background for the view part of the expanded control panel.
 *
 * @param {DvtContext} context Platform specific context object
 * @param {number} nw width of the view part of the control panel
 * @param {number} nh height of the view part of the control panel
 * @param {boolean} bL2R true if the reading direction is left-to-right, so that the
 *        control panel is in the top left corner of the view
 * @param {Object} styleMap The object containing style specifications for this component
 * @return {DvtPath} background for the view part of the expanded control panel
 */
DvtPanZoomControlPanelLAFUtils.createEmptyViewOpenShape = function (context, nw, nh, bL2R, styleMap) {
  //BUG FIX #10154856: pass in height to show single row of controls in 
  //horizontal arm of control panel in TMap
  if (! nw)
    nw = 86;
  if (! nh)
    nh = 47;
  if (bL2R === undefined)
    bL2R = true;

  var r = parseInt(DvtStyleUtils.getStyle(styleMap, DvtCSSStyle.BORDER_RADIUS, 0));
  var ww = nw - (2 * r);
  var hh = nh - (2 * r);

  var xx = 0;
  var yy = 0;

  var mc = DvtPanZoomControlPanelLAFUtils.makeViewOpenShapeHelper(context, r, ww, hh, xx, yy, bL2R);
  mc.setSolidFill(DvtStyleUtils.getStyle(styleMap, DvtCSSStyle.BACKGROUND_COLOR, null));

  return mc;
}

DvtPanZoomControlPanelLAFUtils.makeViewOpenShapeHelper = function (context, r, ww, hh, xx, yy, bL2R) {
  var x = ww + r;
  var y = hh + r;  

  //bottom right corner
  var cmds = DvtPathUtils.moveTo(x + r, y + r);
  cmds += DvtPathUtils.lineTo(x - ww, y + r);
  x = x - ww;
  y = y;

  //bottom left corner
  cmds += DvtPathUtils.lineTo(x - r, y + r);
  cmds += DvtPathUtils.lineTo(x - r, y - hh);
  x = x;
  y = y - hh;

  if (bL2R) {
    //top left corner
    cmds += DvtPathUtils.quadTo( - r + x,  - DvtPanZoomControlPanelLAFUtils.TAN_PI_8 * r + y,  
                                 - DvtPanZoomControlPanelLAFUtils.SIN_PI_4 * r + x,  
                                 - DvtPanZoomControlPanelLAFUtils.SIN_PI_4 * r + y) + 
    DvtPathUtils.quadTo( - DvtPanZoomControlPanelLAFUtils.TAN_PI_8 * r + x,  - r + y, x,  - r + y)+
    DvtPathUtils.lineTo(x,  - r + y);
    cmds += DvtPathUtils.lineTo(x + ww + r,  - r + y);
    x = x + ww;
    y = y;
    //bottom right corner
    cmds += DvtPathUtils.lineTo(x+r, y+hh);
  }
  else 
  {
    //top left corner
    cmds += DvtPathUtils.lineTo(x - r, - r + y);
    cmds += DvtPathUtils.lineTo(x + ww,  - r + y);
    x = x + ww;
    y = y;
    //bottom right corner
    cmds += DvtPathUtils.quadTo(DvtPanZoomControlPanelLAFUtils.TAN_PI_8 * r + x,  - r + y, 
                                DvtPanZoomControlPanelLAFUtils.SIN_PI_4 * r + x,  
                                - DvtPanZoomControlPanelLAFUtils.SIN_PI_4 * r + y) + 
    DvtPathUtils.quadTo(r + x,  - DvtPanZoomControlPanelLAFUtils.TAN_PI_8 * r + y, r + x, y) + 
    DvtPathUtils.lineTo(x + r, y + hh);	
  }

  cmds += DvtPathUtils.closePath();
  return new DvtPath(context, cmds);
}

/**
 * Create the background for the collapsed control panel.
 * 
 * @param {DvtContext} context Platform specific context object
 * @param {number} nh height of the empty control panel
 * @param {Object} styleMap The object containing style specifications for this component
 * @param {boolean} bL2R true if the reading direction is left-to-right, so that the
 *        control panel is in the top left corner of the view 
 * @return {DvtPath} background for the collapsed control panel
 */
DvtPanZoomControlPanelLAFUtils.createEmptyViewClosedShape = function (context, nh, styleMap, bR2L) {
  //BUG FIX #10154856: pass in height to show single row of controls in 
  //horizontal arm of control panel in TMap
  if (!nh)
    nh = 47;

  var r = parseInt(DvtStyleUtils.getStyle(styleMap, DvtCSSStyle.BORDER_RADIUS, 0));
  var buttonWidth = DvtStyleUtils.getStyle(styleMap,DvtPanZoomControlPanel.CP_OPEN_CLOSE_BUTTON_WIDTH,0);
  var buttonHeight = Math.max(nh, DvtStyleUtils.getStyle(styleMap,DvtPanZoomControlPanel.CP_BUTTON_HEIGHT,nh));

  var arPoints = DvtButtonLAFUtils.GetButtonPathCommands(buttonWidth, buttonHeight, r, bR2L);
  arPoints = arPoints.concat("Z");
  var mc = new DvtPath(context, arPoints, "cls_shape");

  var color= DvtStyleUtils.getStyle(styleMap, DvtAbstractComponent.TAB_BG_COLOR_INACTIVE, null);
  if (!color)
    color= DvtStyleUtils.getStyle(styleMap, DvtCSSStyle.BACKGROUND_COLOR, null);
  mc.setSolidFill(color);
  
  return mc;
}
 
/**
 * Create the frame for the collapsed control panel.
 *
 * @param {DvtContext} context Platform specific context object
 * @param {number} nh height of the empty control panel
 * @param {Object} styleMap The object containing style specifications for this component
 * @param {boolean} bL2R true if the reading direction is left-to-right, so that the
 *        control panel is in the top left corner of the view
 * @return {DvtPath} frame for the collapsed control panel
 */
DvtPanZoomControlPanelLAFUtils.createEmptyViewClosedFrame = function (context, nh, styleMap, bR2L) {
  //BUG FIX #10154856: pass in height to show single row of controls in 
  //horizontal arm of control panel in TMap
  if (!nh)
    nh = 47;
  var r = parseInt(DvtStyleUtils.getStyle(styleMap, DvtCSSStyle.BORDER_RADIUS, 0));
  var buttonWidth = DvtStyleUtils.getStyle(styleMap,DvtPanZoomControlPanel.CP_OPEN_CLOSE_BUTTON_WIDTH,0);
  var buttonHeight = Math.max(nh, DvtStyleUtils.getStyle(styleMap,DvtPanZoomControlPanel.CP_BUTTON_HEIGHT,nh));

  var arPoints = DvtButtonLAFUtils.GetButtonPathCommands(buttonWidth, buttonHeight, r, bR2L);
  arPoints = arPoints.concat("Z");
  var mc = new DvtPath(context, arPoints, "cls_shape");
  mc.setSolidStroke(DvtStyleUtils.getStyle(styleMap, DvtCSSStyle.BORDER_COLOR, null));
  mc.setFill(null);
  return mc;
}
 
/**
 * Render the background for the vertical bar of the expanded control panel.
 * 
 * @param {DvtContext} context Platform specific context object
 * @param {number} nh height of the vertical bar of the control panel 
 * @param {Object} styleMap The object containing style specifications for this component
 * @param {string} openSide DvtPanZoomControlPanelLAFUtils.OPEN_TOP or DvtPanZoomControlPanelLAFUtils.OPEN_RIGHT
 * @param {number} openSideSize horizontal bar height
 */
DvtPanZoomControlPanelLAFUtils.renderEmptyZoomShape = function (context, nh, styleMap, openSide, openSideSize) {
  if (!nh) {
    nh = 137;
  }
  var r = parseInt(DvtStyleUtils.getStyle(styleMap, DvtCSSStyle.BORDER_RADIUS, 0));
  var cpWidth = DvtStyleUtils.getStyle(styleMap, DvtPanZoomControlPanel.CP_TAB_SIZE, 0);
  var ww = cpWidth - (2 * r);
  var hh = nh + 7 - (2 * r);
  var xx = 0;
  var yy = 0;

  // Fill
  var mc;
  if (openSide && openSideSize)
    mc = DvtPanZoomControlPanelLAFUtils.makeZoomShapeHelperOpenSide(context, r, cpWidth, nh, openSide, openSideSize);
  else  
    mc = DvtPanZoomControlPanelLAFUtils.makeZoomShapeHelper(context, r, ww, hh, xx, yy);
  mc.setSolidFill(DvtStyleUtils.getStyle(styleMap, DvtCSSStyle.BACKGROUND_COLOR, null));

  return mc;
}


/**
 * Render the border for the vertical bar of the expanded control panel.
 * 
 * @param {DvtContext} context Platform specific context object
 * @param {number} nh height of the vertical bar of the control panel 
 * @param {boolean} roundBottomRight indicator for rounding bottom right
 * @param {Object} styleMap The object containing style specifications for this component
 * @param {string} openSide DvtPanZoomControlPanelLAFUtils.OPEN_TOP or DvtPanZoomControlPanelLAFUtils.OPEN_RIGHT
 * @param {number} openSideSize horizontal bar height
 */
DvtPanZoomControlPanelLAFUtils.renderEmptyZoomFrame = function (context, nh, roundBottomRight, styleMap, openSide, openSideSize) {
  if (!nh)
    nh = 137;
  if (!roundBottomRight)
    roundBottomRight = true;

  var r = parseInt(DvtStyleUtils.getStyle(styleMap, DvtCSSStyle.BORDER_RADIUS, 0));
  var cpWidth = DvtStyleUtils.getStyle(styleMap, DvtPanZoomControlPanel.CP_TAB_SIZE, 0);
  var ww = cpWidth - (2 * r);
  var hh = nh + 7 - (2 * r);
  var xx = 0;
  var yy = 0;

  // Line Style
  var mc = null;
  if (openSide && openSideSize)
    mc = DvtPanZoomControlPanelLAFUtils.makeZoomShapeHelperOpenSide(context, r, cpWidth, nh, openSide, openSideSize);
  else
    mc = DvtPanZoomControlPanelLAFUtils.makeZoomShapeHelper(context, r, ww, hh, xx, yy, roundBottomRight);
  mc.setSolidStroke(DvtStyleUtils.getStyle(styleMap, DvtCSSStyle.BORDER_COLOR, null));
  mc.setFill(null);
  return mc;
}

DvtPanZoomControlPanelLAFUtils.makeZoomShapeHelper = function (context, r, ww, hh, xx, yy, roundBottomRight) {
  if (!roundBottomRight) {
    roundBottomRight = true;
  }
  var x = ww + r;
  var y = hh;

  var cmds = DvtPathUtils.moveTo(x + r, y);

  // Bug 9686175 - controlPanel looks bad when featuresOff="pan zoom cardSync changeLayout"
  if (roundBottomRight) {
    cmds += DvtPathUtils.quadTo(r + x, DvtPanZoomControlPanelLAFUtils.TAN_PI_8 * r + y, 
                                DvtPanZoomControlPanelLAFUtils.SIN_PI_4 * r + x, 
                                DvtPanZoomControlPanelLAFUtils.SIN_PI_4 * r + y) + 
    DvtPathUtils.quadTo(DvtPanZoomControlPanelLAFUtils.TAN_PI_8 * r + x, r + y, x, r + y) + 
    DvtPathUtils.lineTo(x, r + y);
  }
  else {
    cmds += DvtPathUtils.lineTo(x + r, y + r);
  }
  cmds += DvtPathUtils.lineTo(x - ww, r + y);
  x = x - ww;
  y = y;

  cmds += DvtPathUtils.quadTo( - DvtPanZoomControlPanelLAFUtils.TAN_PI_8 * r + x, r + y,  
                               - DvtPanZoomControlPanelLAFUtils.SIN_PI_4 * r + x, 
                               DvtPanZoomControlPanelLAFUtils.SIN_PI_4 * r + y) + 
  DvtPathUtils.quadTo( - r + x, DvtPanZoomControlPanelLAFUtils.TAN_PI_8 * r + y,  - r + x, y) + 
  DvtPathUtils.lineTo( - r + x, y) + DvtPathUtils.lineTo( - r + x, y - hh);
  x = x;
  y = y - hh;
  
  cmds += DvtPathUtils.lineTo(x + ww + r, y) + DvtPathUtils.lineTo(x + ww + r, y + hh) + DvtPathUtils.closePath();
  return new DvtPath(context, cmds);
}

/**
 * Creates a path used for the vertical bar according to the specified dimensions
 * 
 * @param {DvtContext} context Platform specific context object
 * @param {number} r radius for the generated shape 
 * @param {number} width width of the generated shape
 * @param {number} height height of the generated shape
 * @param {string} openSide DvtPanZoomControlPanelLAFUtils.OPEN_TOP or DvtPanZoomControlPanelLAFUtils.OPEN_RIGHT
 * @param {number} openSideSize horizontal bar height
 * @return {DvtPath}  a path for the vertical bar
 */
DvtPanZoomControlPanelLAFUtils.makeZoomShapeHelperOpenSide = function (context, r, width, height, openSide, openSideSize) {
  var arPoints = DvtPanZoomControlPanelLAFUtils.GetShapePathCommands(width, height, r, openSide, openSideSize);
  return new DvtPath(context, arPoints);
}

/**
 * Creates a path used for the horizontal bar according to the specified dimensions
 * 
 * @param {DvtContext} context Platform specific context object
 * @param {number} r radius for the generated shape 
 * @param {number} width width of the generated shape
 * @param {number} height height of the generated shape
 * @param {string} openSide DvtPanZoomControlPanelLAFUtils.OPEN_TOP or DvtPanZoomControlPanelLAFUtils.OPEN_RIGHT or DvtPanZoomControlPanelLAFUtils.OPEN_BOTTOM
 * @param {number} openSideSize horizontal bar height
 * @return {DvtPath}  a path for the horizontal bar
 */
DvtPanZoomControlPanelLAFUtils.makeViewOpenShapeHelperOpenSide = function (context, r, width, height, openSide, openSideSize) {
  var arPoints = DvtPanZoomControlPanelLAFUtils.GetShapePathCommands(width, height, r, openSide, openSideSize);
  return new DvtPath(context, arPoints);
}

/**
 * Returns an array of commands for the DvtPath. The array is used to generate vertical or horizontal bar shape
 * 
 * @param {number} width width of the generated shape
 * @param {number} height height of the generated shape
 * @param {number} r radius for the generated shape 
 * @param {string} openSide DvtPanZoomControlPanelLAFUtils.OPEN_TOP or DvtPanZoomControlPanelLAFUtils.OPEN_RIGHT or DvtPanZoomControlPanelLAFUtils.OPEN_BOTTOM
 * @param {number} openSideSize horizontal bar height
 * @return {Array} array is used to generate vertical or horizontal bar shape
 */
DvtPanZoomControlPanelLAFUtils.GetShapePathCommands = function(width, height, r, openSide, openSideSize) {
  var arPoints;
  var bidi = DvtAgent.isRightToLeft();
  if (openSide == DvtPanZoomControlPanelLAFUtils.OPEN_TOP && !bidi){ //vertical bar
    arPoints = ["M", width, 0,
                "L", width, height-r,
                "A", r, r, 0, 0, 1, width-r, height,
                "L", 0, height,
                "L", 0, 0];
  }
  if (openSide == DvtPanZoomControlPanelLAFUtils.OPEN_TOP && bidi){ //vertical bar
    arPoints = ["M", width, 0,
                "L", width, height,
                "L", r, height,
                "A", r, r, 0, 0, 1, 0, height-r,
                "L", 0, 0];
  }  
  else if (openSide == DvtPanZoomControlPanelLAFUtils.OPEN_RIGHT && !bidi){ //vertical bar
    arPoints = ["M", width, openSideSize,
                "L", width, height-r,
                "A", r, r, 0, 0, 1, width-r, height,
                "L", 0, height,
                "L", 0, 0,
                "L", width, 0];    
  }
  else if (openSide == DvtPanZoomControlPanelLAFUtils.OPEN_RIGHT && bidi ){ //vertical bar
    arPoints = ["M", 0, 0,
                "L", width, 0,
                "L", width, height,
                "L", r, height,
                "A", r, r, 0, 0, 1, 0, height-r,
                "L", 0, openSideSize];
  }
  else if (openSide == DvtPanZoomControlPanelLAFUtils.OPEN_LEFT && !bidi) { //horizontal bar
    arPoints = ["M", 0, 0,
                "L", width-r, 0,
                "A", r, r, 0, 0, 1, width, r,
                "L", width, height-r,
                "A", r, r, 0, 0, 1, width-r, height,
                "L", 0, height];    
  }  
  else if (openSide == DvtPanZoomControlPanelLAFUtils.OPEN_LEFT && bidi) { //horizontal bar
    arPoints = ["M", width, height,
                "L", r, height,
                "A", r, r, 0, 0, 1, 0, height-r,
                "L", 0, r,
                "A", r, r, 0, 0, 1, r, 0,
                "L", width, 0];
  }
  else if (openSide == DvtPanZoomControlPanelLAFUtils.OPEN_BOTTOM && !bidi){ //horizontal bar
    arPoints = ["M", 0, height,
                "L", 0, 0,
                "L", width-r, 0,
                "A", r, r, 0, 0, 1, width, r,
                "L", width, height-r,
                "A", r, r, 0, 0, 1, width-r, height,
                "L", openSideSize, height];
  }
  else if (openSide == DvtPanZoomControlPanelLAFUtils.OPEN_BOTTOM && bidi){ //horizontal bar
    arPoints = ["M", width, height,
                "L", width, 0,
                "L", r, 0,
                "A", r, r, 0, 0, 0, 0, r,
                "L", 0, height-r,
                "A", r, r, 0, 0, 0, r, height,
                "L", width - openSideSize, height];
  }  
  return arPoints;
};
/**
 * @constructor
 * @export
 */
var DvtAbstractComponent = function(context)
{
  this.Init(context);
};

DvtObj.createSubclass(DvtAbstractComponent, DvtContainer, "DvtAbstractComponent");

DvtAbstractComponent.LOAD_XML_INITIAL = "initial";

DvtAbstractComponent._DEFAULT_BACKGROUND_COLOR = '#7396C8';

DvtAbstractComponent._ELEM_ROOT = "r";
DvtAbstractComponent._ATTR_INLINE_STYLE = "inlineStyle";
DvtAbstractComponent._ATTR_SKIN_STYLE = "skinStyle";
DvtAbstractComponent.SKIN_NAME = "skin";

// control panel skinning
DvtAbstractComponent._ATTR_CTRLPANEL_BACKGROUND_COLOR = "cpBackgroundColor";
DvtAbstractComponent._ATTR_CTRLPANEL_BORDER_COLOR = "cpBorderColor";
DvtAbstractComponent._ATTR_CTRLPANEL_BOX_SHADOW = "cpBoxShadow";
DvtAbstractComponent._ATTR_CTRLPANEL_BORDER_RADIUS = "cpBorderRadius";
  
DvtAbstractComponent.BOX_SHADOW = "box-shadow";

DvtAbstractComponent._ATTR_TAB_BG_COLOR_INACTIVE = "tabBgColorInactive";
DvtAbstractComponent._ATTR_TAB_BORDER_COLOR_INACTIVE = "tabBorderColorInactive";
DvtAbstractComponent.TAB_BG_COLOR_INACTIVE = "tab-color-inactive";
DvtAbstractComponent.TAB_BORDER_COLOR_INACTIVE = "tab-border-color-inactive";

DvtAbstractComponent._ATTR_SCROLLBAR_BACKGROUND = "scrollbarBg";
DvtAbstractComponent._ATTR_SCROLLBAR_BORDER_COLOR = "scrollbarBorderColor";
DvtAbstractComponent._ATTR_SCROLLBAR_HANDLE_COLOR = "scrollbarHandleColor";
DvtAbstractComponent._ATTR_SCROLLBAR_HANDLE_ACTIVE_COLOR = "scrollbarHandleActiveColor";
DvtAbstractComponent._ATTR_SCROLLBAR_HANDLE_HOVER_COLOR = "scrollbarHandleHoverColor";

/**
 * Helper method called by the constructor for initializing this object
 * @param {DvtContext} context The platform specific context object
 * @protected
 */
DvtAbstractComponent.prototype.Init = function(context)
{
  DvtAbstractComponent.superclass.Init.call(this, context);  

  this._backgroundPane = new DvtRect(context, 0, 0, 0, 0);
  this.addChild(this._backgroundPane);
  
  this._resourcesMap = null;
  this._compCSSStyle = null;
  this._controlPanelStyleMap = null;
  this._legendStyleMap = null;
  this._skinName = "";
  //flag indicating if we're currently rendering null xml, for example based on 
  //a resize event from the peer
  this._bRenderNullXml = false;
  
  //IE10, Flash toolkit and FF version 17 do not support vector-effects=non-scaling-stroke so we still need to set stroke width based on zoom
  this._bSupportsVectorEffects = (!DvtAgent.isPlatformIE() && !(DvtAgent.isPlatformGecko() && DvtAgent.getVersion() <= 17));  
};

DvtAbstractComponent.prototype.getBackgroundPane = function()
{
  return this._backgroundPane;
};

DvtAbstractComponent.prototype.renderComponent = function()
{
  this.InitComponentInternal();
  this.RenderComponentInternal();
};

DvtAbstractComponent.prototype.InitComponentInternal = function() {
  this._bAbsCompRendered = false;
};

DvtAbstractComponent.prototype.RenderComponentInternal = function()
{
  //subclasses must extend
  
  if (!this._bAbsCompRendered)
  {
    this.RenderBackground();
  }
  
  this._bAbsCompRendered = true;
};

DvtAbstractComponent.prototype.loadXml = function(xmlString, eventType, paramKeys, paramValues)
{
  var parser = this.GetXmlStringParser();
  if (parser)
  {
    var rootXmlNode = parser.parse(xmlString);
    if (rootXmlNode)
    {
      if (rootXmlNode.getName() === DvtAbstractComponent._ELEM_ROOT)
        rootXmlNode = rootXmlNode.getFirstChild();
      
      if (rootXmlNode)
        this.LoadXmlDom(eventType, rootXmlNode, paramKeys, paramValues);
    }
  }
};

DvtAbstractComponent.prototype.GetXmlStringParser = function()
{
  return new DvtXmlParser(this.getCtx());
};

DvtAbstractComponent.prototype.LoadXmlDom = function(eventType, rootXmlNode, paramKeys, paramValues)
{
  switch (eventType)
  {
    case DvtAbstractComponent.LOAD_XML_INITIAL:
    default:
      this.LoadXmlInitial(eventType, rootXmlNode, paramKeys, paramValues);
      break;
  }
};

DvtAbstractComponent.prototype.LoadXmlInitial = function(eventType, rootXmlNode, paramKeys, paramValues)
{
  //subclasses must override
};

/**
 * @export
 */
DvtAbstractComponent.prototype.render = function(xmlString, width, height)
{
  this._width = width;
  this._height = height;
  
  this._backgroundPane.setWidth(this._width);
  this._backgroundPane.setHeight(this._height);

  //set the flag that we're rendering null xml
  if (!xmlString) {
    this._bRenderNullXml = true;
  }
  else {
    // Convert the data into XML if it's a json string
    xmlString = this.ProcessJSON(xmlString);
  }

  this.loadXml(xmlString);
  this.renderComponent();

  //reset the flag for rendering null xml
  this._bRenderNullXml = false;
};

DvtAbstractComponent.prototype.setBackgroundColor = function(color)
{
  this._backgroundColor = color;
};

DvtAbstractComponent.prototype.RenderBackground = function()
{
  //BUG FIX 13704008: if there's an inlineStyle, use its attributes
  //when rendering the background
  if (this.getComponentStyle()) {
    var fill = this._getBackgroundFill();
    if (fill) {
      this._backgroundPane.setFill(fill);
    }
  }
  else if (this._backgroundColor != 'none') {
    var fill = this._getBackgroundGradient(this._backgroundColor);
    this._backgroundPane.setFill(fill);
  }  
  else {
    this._backgroundPane.setInvisibleFill();
  }
};

DvtAbstractComponent.prototype._getBackgroundFill = function() {
  var compCSSStyle = this.getComponentStyle();
  if (compCSSStyle) {
    var fillType = compCSSStyle.getStyle(DvtCSSStyle.FILL_TYPE);
    var bgColor = compCSSStyle.getStyle(DvtCSSStyle.BACKGROUND_COLOR);
    if (!bgColor) {
      bgColor = DvtAbstractComponent._DEFAULT_BACKGROUND_COLOR;
    }
    if (fillType == "solid") {
      return new DvtSolidFill(bgColor);
    }
    else {
      return this._getBackgroundGradient(bgColor);
    }
  }
};

DvtAbstractComponent.prototype._getBackgroundGradient = function(color)
{
  var startColor = '#FFFFFF';
	var midOneColor = '#FFFFFF';
	var midTwoColor = '#AECDEA';
	var endColor = DvtAbstractComponent._DEFAULT_BACKGROUND_COLOR;
  var arColors;
  var bgAlpha = 1;
  
	if (color && color != endColor) {
    //BUG FIX 13704008: get alpha from the given color
    bgAlpha = DvtColorUtils.getAlpha(color);
    
		var rrRatio = (DvtColorUtils.getRed(midTwoColor) - DvtColorUtils.getRed(endColor)) / 
                  (0xff - DvtColorUtils.getRed(endColor));
		var ggRatio = (DvtColorUtils.getGreen(midTwoColor) - DvtColorUtils.getGreen(endColor)) / 
		              (0xff - DvtColorUtils.getGreen(endColor));
		var bbRatio = (DvtColorUtils.getBlue(midTwoColor) - DvtColorUtils.getBlue(endColor)) / 
		              (0xff - DvtColorUtils.getBlue(endColor));
		var rr = DvtColorUtils.getRed(color);
		var gg = DvtColorUtils.getGreen(color);
		var bb = DvtColorUtils.getBlue(color);
		var newRR = Math.round(rr + rrRatio * (0xff - rr));
		var newGG = Math.round(gg + ggRatio * (0xff - gg));
		var newBB = Math.round(bb + bbRatio * (0xff - bb));
		var newColor = DvtColorUtils.makeRGB(newRR, newGG, newBB);
    //BUG FIX 13704008: make sure to get the RGB (without alpha) from 
    //the given color so that the browser doesn't misinterpret the 
    //#aarrggbb format (it may assume the color is really #aarrgg)
    var bgRgb = DvtColorUtils.getRGB(color);
		arColors = new Array(startColor, midOneColor, newColor, bgRgb);
	} else {
		arColors = [startColor,midOneColor,midTwoColor,endColor];
	}
  
  var arAlphas = [bgAlpha, bgAlpha, bgAlpha, bgAlpha];
  var arStops = [0, 45/255, 190/255, 1];
  
  var xx = 0;
  var yy = 0;
  var ww = this._width;
  var hh = this._height;
  var n = 1.7;
  var gw = ww*n*n;
  var gh = hh*n;
  var gx = xx+((ww-gw)/2);
  var gy = yy-35;
  
  var cx = gx + gw / 2;
  var cy = gy + gh / 2;
  //TODO: not sure how to corectly calculate single r for a non-square 
  //bounding rect...
  var r = 1.5 * Math.min(gw / 2, gh / 2);
  var arBounds = [gx, gy, gw, gh];
  
  var fill = new DvtRadialGradientFill(arColors, arAlphas, arStops, cx, cy, r, arBounds);
  return fill;
}
                                       

DvtAbstractComponent.prototype.GetWidth = function() {
  return this._width;
}

DvtAbstractComponent.prototype.GetHeight = function() {
  return this._height;
}

DvtAbstractComponent.prototype.getResourcesMap = function() {
  if (!this._resourcesMap) {
    this._resourcesMap = {};
  }
  return this._resourcesMap;
};


DvtAbstractComponent.prototype.setSkinName = function(skinName) {
  this._skinName = skinName;
};

DvtAbstractComponent.prototype.getSkinName = function() {
  return this._skinName;
};

DvtAbstractComponent.prototype.setComponentStyle = function(cssStyle) {
  this._compCSSStyle = cssStyle;
};

DvtAbstractComponent.prototype.getComponentStyle = function() {
  return this._compCSSStyle;
};

DvtAbstractComponent.prototype.setControlPanelStyleMap = function(styleMap) {
  this._controlPanelStyleMap = styleMap;
};

DvtAbstractComponent.prototype.getControlPanelStyleMap = function() {
  return this._controlPanelStyleMap;
};

/**
 * Returns the map containing the legend styling attributes for the skin
 * @return {object} The map of legend styling attributes
 */
DvtAbstractComponent.prototype.getLegendStyleMap = function() {
  return this._legendStyleMap;
}

/**
 * Sets the legend styling map containing skin specific styling attributes
 * @param {object} styleMap The map of legend styling attributes
 */
DvtAbstractComponent.prototype.setLegendStyleMap = function(styleMap) {
  this._legendStyleMap = styleMap;
}

DvtAbstractComponent.prototype.parseComponentAttrs = function(xmlNode) {

  var compCSSStyle = null;
  compCSSStyle = this.parseComponentStyle(xmlNode.getAttr(DvtAbstractComponent._ATTR_SKIN_STYLE), compCSSStyle);
  compCSSStyle = this.parseComponentStyle(xmlNode.getAttr(DvtAbstractComponent._ATTR_INLINE_STYLE), compCSSStyle);
  if (compCSSStyle)
    this.setComponentStyle(compCSSStyle);

  // parse attributes for the widgets - control panel, search panel and panel drawer    
  this.parseWidgetAttrs(xmlNode); 
};

DvtAbstractComponent.prototype.parseComponentStyle = function (attr, compCSSStyle) {
  if (attr) {
    if (compCSSStyle)
      compCSSStyle.merge(new DvtCSSStyle(attr));
    else
      compCSSStyle = new DvtCSSStyle(attr);
  }
  return compCSSStyle;
};


DvtAbstractComponent.prototype.ProcessJSON = function(xmlString) {
  return xmlString;
};

/**
 * Parses and creates skin specific subcomponent style maps
 * @param {DvtXmlNode} xmlNode The xml node containing subcomponent attributes
 */
DvtAbstractComponent.prototype.parseWidgetAttrs = function(xmlNode) {
  var cpStyleMap = new Object();
  var skinName = xmlNode.getAttr(DvtAbstractComponent.SKIN_NAME);
  if (skinName) {
    this.setSkinName(skinName);
    cpStyleMap[DvtAbstractComponent.SKIN_NAME] = skinName;
  }

  // control panel, search panel, panel drawer styles
  DvtStyleUtils.setStyle(cpStyleMap, DvtCSSStyle.BACKGROUND_COLOR, xmlNode.getAttr(DvtAbstractComponent._ATTR_CTRLPANEL_BACKGROUND_COLOR));
  DvtStyleUtils.setStyle(cpStyleMap, DvtCSSStyle.BORDER_COLOR, xmlNode.getAttr(DvtAbstractComponent._ATTR_CTRLPANEL_BORDER_COLOR));
  DvtStyleUtils.setStyle(cpStyleMap, DvtCSSStyle.BORDER_RADIUS, xmlNode.getAttr(DvtAbstractComponent._ATTR_CTRLPANEL_BORDER_RADIUS));
  DvtStyleUtils.setStyle(cpStyleMap, DvtAbstractComponent.BOX_SHADOW, xmlNode.getAttr(DvtAbstractComponent._ATTR_CTRLPANEL_BOX_SHADOW));
  DvtStyleUtils.setStyle(cpStyleMap, DvtAbstractComponent.TAB_BG_COLOR_INACTIVE, xmlNode.getAttr(DvtAbstractComponent._ATTR_TAB_BG_COLOR_INACTIVE));
  DvtStyleUtils.setStyle(cpStyleMap, DvtAbstractComponent.TAB_BORDER_COLOR_INACTIVE, xmlNode.getAttr(DvtAbstractComponent._ATTR_TAB_BORDER_COLOR_INACTIVE));

  // scrollbar styles for scrollable container  
  DvtStyleUtils.setStyle(cpStyleMap, DvtScrollbar.BACKGROUND, xmlNode.getAttr(DvtAbstractComponent._ATTR_SCROLLBAR_BACKGROUND));
  DvtStyleUtils.setStyle(cpStyleMap, DvtScrollbar.BORDER_COLOR, xmlNode.getAttr(DvtAbstractComponent._ATTR_SCROLLBAR_BORDER_COLOR));    
  DvtStyleUtils.setStyle(cpStyleMap, DvtScrollbar.HANDLE_COLOR, xmlNode.getAttr(DvtAbstractComponent._ATTR_SCROLLBAR_HANDLE_COLOR));
  DvtStyleUtils.setStyle(cpStyleMap, DvtScrollbar.HANDLE_ACTIVE_COLOR, xmlNode.getAttr(DvtAbstractComponent._ATTR_SCROLLBAR_HANDLE_ACTIVE_COLOR));
  DvtStyleUtils.setStyle(cpStyleMap, DvtScrollbar.HANDLE_HOVER_COLOR, xmlNode.getAttr(DvtAbstractComponent._ATTR_SCROLLBAR_HANDLE_HOVER_COLOR));
  //merge skinned styles with defaults
  //TODO: we should reevalute this code when we'll have the defaults coming from a server as a JSON string
  // and merge the defaults in the subcomponent with the corresponding subcomponent's defaults
  cpStyleMap = DvtPanZoomControlPanelDefaults.calcOptions(cpStyleMap);    
  this.setControlPanelStyleMap(cpStyleMap);  
  
  // legend
  var legendStyleMap = new Object();
  if (skinName)
    legendStyleMap[DvtAbstractComponent.SKIN_NAME] = skinName;
  this.setLegendStyleMap(DvtCommonLegendDefaults.calcOptions(legendStyleMap));
};

/**
 * Gets whether or not the current rendering technology supports vector effects
 * 
 * @return {boolean} whether or not the current rendering technology supports vector effects
 */
DvtAbstractComponent.prototype.supportsVectorEffects = function() {
 return this._bSupportsVectorEffects;
}
/**
 * @constructor
 * @export
 */
var DvtAbstractPanZoomComponent = function (context) {
  this.Init(context);
};

DvtObj.createSubclass(DvtAbstractPanZoomComponent, DvtAbstractComponent, "DvtAbstractPanZoomComponent");

//control panel is initially collapsed
DvtAbstractPanZoomComponent.CONTROL_PANEL_BEHAVIOR_INIT_COLLAPSED = "initCollapsed";
//control panel is initially expanded
DvtAbstractPanZoomComponent.CONTROL_PANEL_BEHAVIOR_INIT_EXPANDED = "initExpanded";
//control panel is not shown
DvtAbstractPanZoomComponent.CONTROL_PANEL_BEHAVIOR_HIDDEN = "hidden";

DvtAbstractPanZoomComponent._PANNING_OFF = 1;
DvtAbstractPanZoomComponent._ZOOMING_OFF = 2;
DvtAbstractPanZoomComponent._ZOOM_TO_FIT_OFF = 4;

DvtAbstractPanZoomComponent.PAN_ZOOM_KEY = "panZoomInfo";

//TODO: move some where else
DvtAbstractPanZoomComponent._CHANGE_LAYOUT_OFF = (1 << 29);//536870912
DvtAbstractPanZoomComponent.prototype.Init = function (context) {
  DvtAbstractPanZoomComponent.superclass.Init.call(this, context);
  this._featuresOff = 0;
  this._controlPanelBehavior = DvtAbstractPanZoomComponent.CONTROL_PANEL_BEHAVIOR_INIT_COLLAPSED;
  this._displayedControls = DvtPanZoomCanvas.DEFAULT_DISPLAYED_CONTROLS;
};

/**
 * @override
 */
DvtAbstractPanZoomComponent.prototype.InitComponentInternal = function () {
  DvtAbstractPanZoomComponent.superclass.InitComponentInternal.call(this);

  //if not rendering null xml, recreate the panZoomCanvas
  if (!this._bRenderNullXml) {
    if (this._panZoomCanvas) {
      this.removeChild(this._panZoomCanvas);
      this._panZoomCanvas = null;
    }
    this._panZoomCanvas = this.CreatePanZoomCanvas(this.GetWidth(), this.GetHeight());
    this._panZoomCanvas.renderComponent();
    var controlPanel = this._panZoomCanvas.getControlPanel();
    if (controlPanel)
      controlPanel.addEvtListener(DvtPanZoomControlPanelEvent.TYPE, this.HandleControlPanelEvent, false, this);
  }
  //if rendering null xml, update the size of the panZoomCanvas
  else {
    this._panZoomCanvas.setSize(this.GetWidth(), this.GetHeight());
  }
  this.SetClipRect(this.GetWidth(), this.GetHeight());      
};

DvtAbstractPanZoomComponent.prototype.ConvertControlPanelBehaviorStringToInt = function(s) {
  switch (s) {
    case DvtAbstractPanZoomComponent.CONTROL_PANEL_BEHAVIOR_INIT_COLLAPSED:
      return DvtPanZoomCanvas.CONTROL_PANEL_BEHAVIOR_INIT_COLLAPSED;
    case DvtAbstractPanZoomComponent.CONTROL_PANEL_BEHAVIOR_INIT_EXPANDED:
      return DvtPanZoomCanvas.CONTROL_PANEL_BEHAVIOR_INIT_EXPANDED;
    case DvtAbstractPanZoomComponent.CONTROL_PANEL_BEHAVIOR_HIDDEN:
    default:
      return DvtPanZoomCanvas.CONTROL_PANEL_BEHAVIOR_HIDDEN;
  }
}
    
/**
 * Creates and adds the pan zoom canvas to this component
 * 
 * @param {number} ww the width of the pan zoom canvas
 * @param {number} hh the height of the pan zoom canvas
 * 
 * @return {DvtPanZoomCanvas} the pan zoom canvas
 */
DvtAbstractPanZoomComponent.prototype.CreatePanZoomCanvas = function (ww, hh) {
  var pzc = new DvtPanZoomCanvas(this.getCtx(), 
                                 this._buttonImages, 
                                 ww, 
                                 hh, 
                                 null, 
                                 this.ConvertControlPanelBehaviorStringToInt(this._controlPanelBehavior),
                                 this._panZoomResources,
                                 this._displayedControls, this);
  pzc.addEvtListener(DvtPanEvent.TYPE, this.HandlePanEvent, false, this);
  pzc.addEvtListener(DvtZoomEvent.TYPE, this.HandleZoomEvent, false, this);
  this.addChildAt(pzc, 1); // Add directly on top of backgroundPane
  return pzc;
};

DvtAbstractPanZoomComponent.prototype.HandleControlPanelEvent = function (event) {
  //do nothing; for subclasses to implement
};

DvtAbstractPanZoomComponent.prototype.HandlePanEvent = function (event) {
  //do nothing; for subclasses to implement
};

DvtAbstractPanZoomComponent.prototype.HandleZoomEvent = function (event) {
  //do nothing; for subclasses to implement
};

DvtAbstractPanZoomComponent.prototype.getPanZoomCanvas = function () {
  return this._panZoomCanvas;
};

/**
 * Pan by the given amount.
 * @param {number} dx horizontal amount to pan by
 * @param {number} dy vertical amount to pan by
 * @param {DvtAnimator} animator optional animator to use to animate the pan
 */
DvtAbstractPanZoomComponent.prototype.panBy = function (dx, dy, animator) {
  this.getPanZoomCanvas().panBy(dx, dy, animator);
};

/**
 * Pan to the given position.
 * @param {number} xx horizontal position to pan to
 * @param {number} yy vertical position to pan to
 * @param {DvtAnimator} animator optional animator to use to animate the pan
 */
DvtAbstractPanZoomComponent.prototype.panTo = function (xx, yy, animator) {
  this.getPanZoomCanvas().panTo(xx, yy, animator);
};

/**
 * Zoom by the given amount.
 * @param {number} dz amount to zoom by
 * @param {number} xx horizontal center of zoom (if not specified, treated as the horizontal center of the canvas)
 * @param {number} yy vertical center of zoom (if not specified, treated as the vertical center of the canvas)
 * @param {DvtAnimator} animator optional animator to use to animate the zoom
 */
DvtAbstractPanZoomComponent.prototype.zoomBy = function (dz, xx, yy, animator) {
  this.getPanZoomCanvas().zoomBy(dz, xx, yy, animator);
};

/**
 * Zoom to the given scale.
 * @param {number} zz new scale
 * @param {number} xx horizontal center of zoom (if not specified, treated as the horizontal center of the canvas)
 * @param {number} yy vertical center of zoom (if not specified, treated as the vertical center of the canvas)
 * @param {DvtAnimator} animator optional animator to use to animate the zoom
 */
DvtAbstractPanZoomComponent.prototype.zoomTo = function (zz, xx, yy, animator) {
  this.getPanZoomCanvas().zoomTo(zz, xx, yy, animator);
};

/**
 * Zoom and pan the content pane to fit the canvas size.
 * @param {DvtAnimator} animator optional animator to use to animate the zoom-to-fit
 */
DvtAbstractPanZoomComponent.prototype.zoomToFit = function (animator) {
  this.getPanZoomCanvas().zoomToFit(animator);
};

/**
 * Get the Resources to use with this view.
 *
 * @return translated resources to use with this view
 */
DvtAbstractPanZoomComponent.prototype.getPanZoomResources = function () {
  return this._panZoomResources;
};

/**
 * Set the Resources to use with this view.
 *
 * @param resources translated resources to use with this view
 */
DvtAbstractPanZoomComponent.prototype.setPanZoomResources = function (resources) {
  this._panZoomResources = resources;
};

/**
 * Get the featuresOff
 *
 * @return featuresOff used with this view
 */
DvtAbstractPanZoomComponent.prototype.getFeaturesOff = function () {
  return this._featuresOff;
};

/**
 * Set the featuresOff
 *
 * @param flags featuresOff used with this view
 */
DvtAbstractPanZoomComponent.prototype.setFeaturesOff = function (flags) {
  this._featuresOff = flags;
};

DvtAbstractPanZoomComponent.prototype.isPanningOff = function () {
  return (this._featuresOff & DvtAbstractPanZoomComponent._PANNING_OFF) != 0;
};

DvtAbstractPanZoomComponent.prototype.isZoomingOff = function () {
  return (this._featuresOff & DvtAbstractPanZoomComponent._ZOOMING_OFF) != 0;
};

DvtAbstractPanZoomComponent.prototype.isZoomToFitOff = function () {
  return (this._featuresOff & DvtAbstractPanZoomComponent._ZOOM_TO_FIT_OFF) != 0;
};

//TODO: don't render layout combo for now
//Move this method to Diagram,er???
DvtAbstractPanZoomComponent.prototype.isChangeLayoutOff = function () {
  return true;//return (this._featuresOff & DvtAbstractPanZoomComponent._CHANGE_LAYOUT_OFF) != 0;
};

/**
 * Get the Resources to use with this view.
 *
 * @return translated resources to use with this view
 */
DvtAbstractPanZoomComponent.prototype.getResources = function () {
  return this._resources;
};

/**
 * Set the Resources to use with this view.
 *
 * @param resources translated resources to use with this view
 */
DvtAbstractPanZoomComponent.prototype.setResources = function (resources) {
  this._resources = resources;
};

DvtAbstractPanZoomComponent.prototype.setButtonImages = function (uris) {
  this._buttonImages = uris;
};

/**
 * Set the control panel behavior: initExpanded, initCollapsed, or hidden.
 * The default is initCollapsed.  
 * 
 * @param behavior control panel behavior  
 */
DvtAbstractPanZoomComponent.prototype.setControlPanelBehavior = function(behavior) {
  this._controlPanelBehavior = behavior;
};

/**
 * Get the control panel behavior.
 * 
 * @return control panel behavior: initExpanded, initCollapsed, or hidden
 */
DvtAbstractPanZoomComponent.prototype.getControlPanelBehavior = function() {
  return this._controlPanelBehavior;
};

/**
 * Sets the controls that should be displayed in the control panel
 * 
 * @param displayedControls flags indicating the controls that should be displayed
 */
DvtAbstractPanZoomComponent.prototype.setDisplayedControls = function(displayedControls) {
  this._displayedControls = displayedControls;
};

/**
 * Gets the controls that should be displayed in the control panel
 * 
 * @return flags indicating the controls that should be displayed
 */
DvtAbstractPanZoomComponent.prototype.getDisplayedControls = function() {
  return this._displayedControls;
};

/**
 * Gets whether this component will handle JS MouseWheel events
 * 
 * @return {boolean} true if this component will handle JS MouseWheel events, false otherwise
 * @export
 */
DvtAbstractPanZoomComponent.prototype.isMouseWheelHandled = function() {
  return this.getPanZoomCanvas().isZoomingEnabled() && !this.isZoomingOff();
}

/**
 *  Sets a clipping region for the component.
 *  @param {number} ww Component width
 *  @param {number} hh Component height
 */
DvtAbstractPanZoomComponent.prototype.SetClipRect = function(ww, hh) {
  var clipPath = new DvtClipPath('comp');
  clipPath.addRect(this.getTranslateX(), this.getTranslateY(), ww, hh);
  this.setClipPath(clipPath);
};
// Copyright (c) 2011, 2014, Oracle and/or its affiliates. All rights reserved.

/**
  *  Creates a canvas that supports panning and zooming.
  *  @extends DvtContainer
  *  @class DvtPanZoomCanvas is a platform independent class representing a 
  *  pannable, zoomable canvas.  
  *  <p>
  *  <b>Example:</b><br><br> <code>
  *  var canvas = new DvtPanZoomCanvas(context, 400, 200, 'myCanvas') ;<br>
  *  <br>
  *</code>
  *  @constructor  
  *  @param {DvtContext} context The context object
  *  @param {number} ww The width of the canvas
  *  @param {number} hh The height of the canvas
  *  @param {string} id optional identifier
  *  @param {number} controlPanelState the control panel state
  *  @param {Object} controlPanelResources the map of control panel button tooltip translations
  *  @param {number} displayedControls flags indicating what controls should be displayed in the control panel
  */
var DvtPanZoomCanvas = function(context, buttonImages, ww, hh, id, controlPanelState, controlPanelResources, displayedControls, view)
{
  this.Init(context, buttonImages, ww, hh, id, controlPanelState, controlPanelResources, displayedControls, view);
};

DvtObj.createSubclass(DvtPanZoomCanvas, DvtContainer, "DvtPanZoomCanvas");

DvtPanZoomCanvas.DEFAULT_PAN_INCREMENT = 15;
DvtPanZoomCanvas.DEFAULT_ZOOM_INCREMENT = .05;
DvtPanZoomCanvas.DEFAULT_ANIMATION_DURATION = .5;

//control panel is collapsed
DvtPanZoomCanvas.CONTROL_PANEL_BEHAVIOR_INIT_COLLAPSED = 0;
//control panel is expanded
DvtPanZoomCanvas.CONTROL_PANEL_BEHAVIOR_INIT_EXPANDED = 1;
//control panel is not shown
DvtPanZoomCanvas.CONTROL_PANEL_BEHAVIOR_HIDDEN = 2;
    
DvtPanZoomCanvas.DEFAULT_DISPLAYED_CONTROLS = DvtPanZoomControlPanel.CONTROLS_ALL;

DvtPanZoomCanvas.prototype.Init = function(context, buttonImages, ww, hh, id, controlPanelState, controlPanelResources, displayedControls, view)
{
  DvtPanZoomCanvas.superclass.Init.call(this, context, null, id);
  
  this._view = view;
  
  this._ww = ww;
  this._hh = hh;
  this._buttonImages = buttonImages;
  
  this._px = 0;
  this._py = 0;
  this._mx = 0;
  this._my = 0;
  
  this._minPanX = null;
  this._maxPanX = null;
  this._minPanY = null;
  this._maxPanY = null;
  this._minZoom = .1;
  this._maxZoom = 1;
  
  this._panIncrement = DvtPanZoomCanvas.DEFAULT_PAN_INCREMENT;
  this._zoomIncrement = DvtPanZoomCanvas.DEFAULT_ZOOM_INCREMENT;
  this._bTiltPanningEnabled = false;
  this._zoomToFitPadding = 20;  

  this._controlPanel = null;
  this._controlPanelState = controlPanelState ? controlPanelState : DvtPanZoomCanvas.CONTROL_PANEL_BEHAVIOR_INIT_COLLAPSED;
  this._displayedControls = (displayedControls || displayedControls == 0) ? displayedControls : DvtPanZoomCanvas.DEFAULT_DISPLAYED_CONTROLS;
  this._controlPanelResources = controlPanelResources;

  this._bPanningEnabled = true;
  this._bZoomingEnabled = true;
  this._bZoomToFitEnabled = true;

  this._backgroundPane = new DvtRect(this.getCtx(), 
                                     0, 0, this._ww, this._hh);
  this.addChild(this._backgroundPane);
  this._backgroundPane.setInvisibleFill();
  
  this._contentPane = new DvtContainer(this.getCtx());
  this.addChild(this._contentPane);
  this._contentPane.setMatrix(new DvtMatrix());
  
  this._animationDuration = DvtPanZoomCanvas.DEFAULT_ANIMATION_DURATION;
  
  this._eventManager = new DvtPanZoomCanvasEventManager(context, this.FireListener, this);
  this._eventManager.addListeners(this);
  
  this._clipIdSuffix = 1;
  this.SetClipRect(ww, hh);
  
  //flag indicating if constraints should be treated as elastic, so that overflow is possible, with bounce back
  this._bElasticConstraints = false;
  //anim for bouncing back elastic constraints
  this._elasticConstraintsAnim = null;
};

/**
 * Sets the pan zoom canvas size with an optional parameter to set a clipPath
 * @param {number} ww The new width of the pan zoom canvas.
 * @param {number} hh The new height of the pan zoom canvas.
 * @param {boolean} bAdjustSizeOnly If true, only the pan zoom canvas size is adjusted and no clip path is set.
 */
DvtPanZoomCanvas.prototype.setSize = function(ww, hh, bAdjustSizeOnly) {
  this._ww = ww;
  this._hh = hh;
  // Thematic Map uses this method to update canvas width temporarily before a zoom to fit to position the map within 
  // a smaller bounds when legend is fixed without actually decreasing the canvas size
  if (!bAdjustSizeOnly) {
    this._backgroundPane.setWidth(ww);
    this._backgroundPane.setHeight(hh);
    //position control panel again, in case it's on the right side for BiDi
    if (this._controlPanel)
      this.PositionControlPanel();
    this.SetClipRect(ww, hh);
  }
};

DvtPanZoomCanvas.prototype.getSize = function() {
  return new DvtDimension(this._ww, this._hh);
};

/**
 *  Sets a clipping region for the panZoomCanvas.
 *  @param {number} ww width
 *  @param {number} hh height
 */
DvtPanZoomCanvas.prototype.SetClipRect = function(ww, hh) {
  var clipPath = new DvtClipPath('pzc');
  clipPath.addRect(this.getTranslateX(), this.getTranslateY(), ww, hh);
  this.setClipPath(clipPath);
};
/**
  * Get the content pane of the canvas.  The content pane is the
  * object that will be panned and zoomed.  Content should be
  * added as a child of the content pane, not the canvas itself.
  * @returns {DvtContainer} the content pane of the canvas
  */
DvtPanZoomCanvas.prototype.getContentPane = function()
{
  return this._contentPane;
};

DvtPanZoomCanvas.prototype.setContentPane = function(contentPane) {
  this._contentPane = contentPane;
};

/**
  * Get the background pane of the canvas.  The background
  * pane appears behind the content pane, and should be used
  * for styling.
  * @returns {DvtRect} the background pane of the canvas
  */
DvtPanZoomCanvas.prototype.getBackgroundPane = function()
{
  return this._backgroundPane;
};

/**
 * Gets the matrix for this pan zoom canvas
 * @param {DvtAnimator} an optional animator which may continue a destination value for this matrix
 * @return {DvtMatrix} the matrix
 */
DvtPanZoomCanvas.prototype.getContentPaneMatrix = function(animator) {
  if (animator) {
    var mat = animator.getDestVal(this._contentPane, this._contentPane.getMatrix);
    if (mat) {
      return mat;
    }
  }
  return this._contentPane.getMatrix();
}

/**
  * Get the current zoom level. 
  * @param {DvtAnimator} animator (optional) The animator to check for a more current value
  * @returns {number} the current zoom level
  */
DvtPanZoomCanvas.prototype.getZoom = function(animator)
{
  return this.getContentPaneMatrix(animator).getA();
};

/**
  * Get the current horizontal pan position. 
  * @param {DvtAnimator} animator (optional) The animator to check for a more current value
  * @returns {number} the current horizontal pan position
  */
DvtPanZoomCanvas.prototype.getPanX = function(animator)
{
  return this.getContentPaneMatrix(animator).getTx();
};

/**
  * Get the current vertical pan position. 
  * @param {DvtAnimator} animator (optional) The animator to check for a more current value
  * @returns {number} the current vertical pan position
  */
DvtPanZoomCanvas.prototype.getPanY = function(animator)
{
  return this.getContentPaneMatrix(animator).getTy();
};

/**
  * Set the padding to leave around the content when it is zoomed-to-fit.
  * The default value is 20.
  * @param {number} n new zoom-to-fit padding
  */
DvtPanZoomCanvas.prototype.setZoomToFitPadding = function(n)
{
  this._zoomToFitPadding = n;
};

/**
  * Get the padding to leave around the content when it is zoomed-to-fit. 
  * @returns {number} zoom-to-fit padding
  */
DvtPanZoomCanvas.prototype.getZoomToFitPadding = function()
{
  return this._zoomToFitPadding;
};

/**
  * Pan by the given amount. 
  * @param {number} dx horizontal amount to pan by
  * @param {number} dy vertical amount to pan by
  * @param {DvtAnimator} animator optional animator to use to animate the pan
  */
DvtPanZoomCanvas.prototype.panBy = function(dx, dy, animator)
{
  if (!this.isPanningEnabled()) {
    return;
  }

  var oldX = this.getPanX(animator);
  var oldY = this.getPanY(animator);
  var newX = this.ConstrainPanX(oldX + dx);
  var newY = this.ConstrainPanY(oldY + dy);

  var deltaX = newX - oldX;
  var deltaY = newY - oldY;
  
  var mat = null;
  if (animator)
  {
    mat = animator.getDestVal(this._contentPane, this._contentPane.getMatrix);
    if (mat)
    {
      mat = mat.clone();
    }
  }
  if (!mat)
  {
    mat = this._contentPane.getMatrix().clone();
  }
  
  mat.translate(deltaX, deltaY);
  
  var thisRef = this;
  var fireStartEventFunc = function() {
    thisRef.FirePanEvent(DvtPanEvent.SUBTYPE_PANNING, newX, newY, oldX, oldY, animator);
  }
  var fireEndEventFunc = function() {
    thisRef.FirePanEvent(DvtPanEvent.SUBTYPE_PANNED, newX, newY, oldX, oldY, animator);
  };
  
  if (animator)
  {
    animator.addProp(DvtAnimator.TYPE_MATRIX, 
                     this._contentPane, 
                     this._contentPane.getMatrix,
                     this._contentPane.setMatrix,
                     mat);
    DvtPlayable.prependOnInit(animator, fireStartEventFunc);
    DvtPlayable.appendOnEnd(animator, fireEndEventFunc);
  }
  else
  {
    fireStartEventFunc();
    this._contentPane.setMatrix(mat);
    fireEndEventFunc();
  }
};

/**
  * Pan to the given position. 
  * @param {number} xx horizontal position to pan to
  * @param {number} yy vertical position to pan to
  * @param {DvtAnimator} animator optional animator to use to animate the pan
  */
DvtPanZoomCanvas.prototype.panTo = function(xx, yy, animator)
{
  if (!this.isPanningEnabled()) {
    return;
  }

  var dx = xx - this.getPanX(animator);
  var dy = yy - this.getPanY(animator);
  this.panBy(dx, dy, animator);
};

/**
  * Zoom by the given amount. 
  * @param {number} dz amount to zoom by
  * @param {number} xx horizontal center of zoom (if not specified, treated as the horizontal center of the canvas)
  * @param {number} yy vertical center of zoom (if not specified, treated as the vertical center of the canvas)
  * @param {DvtAnimator} animator optional animator to use to animate the zoom
  */
DvtPanZoomCanvas.prototype.zoomBy = function(dz, xx, yy, animator)
{
  if (!this.isZoomingEnabled()) {
    return;
  }

  if (!xx && xx !== 0)
  {
    xx = this._ww / 2;
  }
  if (!yy && yy !== 0)
  {
    yy = this._hh / 2;
  }
  
  var oldZoom = this.getZoom(animator);
  var newZoom = this.ConstrainZoom(oldZoom * dz);
  this.adjustZoomControls(newZoom);

  if (DvtPanZoomCanvas.RoundFloatForCompare(oldZoom) == DvtPanZoomCanvas.RoundFloatForCompare(newZoom))
  {
    return;
  }
  
  var deltaZoom = newZoom / oldZoom;
  
  var mat = null;
  if (animator)
  {
    mat = animator.getDestVal(this._contentPane, this._contentPane.getMatrix);
    if (mat)
    {
      mat = mat.clone();
    }
  }
  if (!mat)
  {
    mat = this._contentPane.getMatrix().clone();
  }
  
  // determine the new matrix after zooming
  mat.scale(deltaZoom, deltaZoom, xx, yy);

  // shift the update matrix back into bounds
  var xDiff = this.ConstrainPanX(mat.getTx()) - mat.getTx();
  var yDiff = this.ConstrainPanY(mat.getTy()) - mat.getTy();  
  this.FireZoomEvent(DvtZoomEvent.SUBTYPE_ADJUST_PAN_CONSTRAINTS, newZoom, oldZoom, animator, null, xx, yy, xDiff, yDiff);
  
  // shift the update matrix back into bounds again in case the zooming listener changes the pan constraints
  xDiff = this.ConstrainPanX(mat.getTx()) - mat.getTx();
  yDiff = this.ConstrainPanY(mat.getTy()) - mat.getTy();
  mat.translate(xDiff, yDiff);

  var thisRef = this;
  var fireStartEventFunc = function() {
    thisRef.FireZoomEvent(DvtZoomEvent.SUBTYPE_ZOOMING, newZoom, oldZoom, animator, null, xx, yy, xDiff, yDiff);
  };
  var fireEndEventFunc = function() {
    //use current zoom level at time of firing event as new zoom level
    //in event, because if continously scrolling the mouse wheel, each
    //zoom animation gets interrupted by the next one, so each event
    //doesn't actually zoom all the way to the desired scale until the
    //last event
    thisRef.FireZoomEvent(DvtZoomEvent.SUBTYPE_ZOOMED, thisRef.getZoom(), oldZoom, animator, null, xx, yy, xDiff, yDiff);
  };
    
  if (animator)
  {
    animator.addProp(DvtAnimator.TYPE_MATRIX, 
                     this._contentPane, 
                     this._contentPane.getMatrix,
                     this._contentPane.setMatrix,
                     mat);
    DvtPlayable.prependOnInit(animator, fireStartEventFunc);
    DvtPlayable.appendOnEnd(animator, fireEndEventFunc);
  }
  else
  {
    fireStartEventFunc();
    this._contentPane.setMatrix(mat);
    fireEndEventFunc();
  }
};

/**
  * Zoom to the given scale. 
  * @param {number} zz new scale
  * @param {number} xx horizontal center of zoom (if not specified, treated as the horizontal center of the canvas)
  * @param {number} yy vertical center of zoom (if not specified, treated as the vertical center of the canvas)
  * @param {DvtAnimator} animator optional animator to use to animate the zoom
  */
DvtPanZoomCanvas.prototype.zoomTo = function(zz, xx, yy, animator)
{
  if (!this.isZoomingEnabled()) {
    return;
  }

  var dz = zz / this.getZoom(animator);
  this.zoomBy(dz, xx, yy, animator);
};

/**
  * Pan the content pane to be centered in the canvas. 
  * @param {DvtAnimator} animator optional animator to use to animate the zoom-to-fit
  * @param {DvtRectangle} fitBounds optional bounds in content pane coordinate system to zoom-to-fit to
  */
DvtPanZoomCanvas.prototype.center = function(animator, fitBounds) {
  var panningEnabled = this.isPanningEnabled();
  this.setPanningEnabled(true);
  var bounds = fitBounds;
  if (!bounds)
    bounds = this._contentPane.getDimensions();
  
  var cxBounds = (bounds.x + bounds.w / 2) * this.getZoom();
  var cyBounds = (bounds.y + bounds.h / 2) * this.getZoom();
  var dx = (this._ww / 2) - cxBounds;
  var dy = (this._hh / 2) - cyBounds;
  this.panTo(dx, dy, animator);
  this.setPanningEnabled(panningEnabled);
}

/**
  * Zoom and pan the content pane to fit the canvas size. 
  * @param {DvtAnimator} animator optional animator to use to animate the zoom-to-fit
  * @param {DvtRectangle} fitBounds optional bounds in content pane coordinate system to zoom-to-fit to
  */
DvtPanZoomCanvas.prototype.zoomToFit = function(animator, fitBounds)
{
  if (!this.isZoomToFitEnabled()) {
    return;
  }
  
  var panningEnabled = this.isPanningEnabled();
  var zoomingEnabled = this.isZoomingEnabled();
  this.setPanningEnabled(true);
  this.setZoomingEnabled(true);
  try {
    var bounds = fitBounds;
    if (!bounds) {
      bounds = this._contentPane.getDimensions();
    }
    
    var event = this.FireZoomEvent(DvtZoomEvent.SUBTYPE_ZOOM_TO_FIT_CALC_BOUNDS, null, null, animator, bounds);    
    bounds = event.getZoomToFitBounds();
    
    var dzx = (this._ww - 2 * this._zoomToFitPadding) / (bounds.w);
    var dzy = (this._hh - 2 * this._zoomToFitPadding) / (bounds.h);
    var dz = Math.min(dzx, dzy);
    dz = this.ConstrainZoom(dz);
    
    var cxBounds = (bounds.x + bounds.w / 2) * dz;
    var cyBounds = (bounds.y + bounds.h / 2) * dz;
    var dx = (this._ww / 2) - cxBounds;
    var dy = (this._hh / 2) - cyBounds;    

    var thisRef = this;
    var fireStartEventFunc = function() {
      thisRef.FireZoomEvent(DvtZoomEvent.SUBTYPE_ZOOM_TO_FIT_BEGIN, null, null, animator, bounds);
    };
    var fireEndEventFunc = function() {
      thisRef.FireZoomEvent(DvtZoomEvent.SUBTYPE_ZOOM_TO_FIT_END, null, null, animator, bounds);
    };
    
    if (!animator)
      fireStartEventFunc();
    else
      DvtPlayable.prependOnInit(animator, fireStartEventFunc);
      
    this.zoomTo(dz, 0, 0, animator);
    this.panTo(dx, dy, animator);
    
    if (animator) {   
      DvtPlayable.appendOnEnd(animator, fireEndEventFunc);
    }
    else {
      fireEndEventFunc();
    }
  }
  finally {
    this.setPanningEnabled(panningEnabled);
    this.setZoomingEnabled(zoomingEnabled);
  }
};

/**
  * Calculate the zoom-to-fit scale. 
  * @param {DvtRectangle} bounds optional bounds in content pane coordinate system to calculate zoom-to-fit scale to
  */
DvtPanZoomCanvas.prototype.calcZoomToFitScale = function(bounds)
{
  if (!bounds) {
    bounds = this._contentPane.getDimensions();
  }
  
  var event = this.FireZoomEvent(DvtZoomEvent.SUBTYPE_ZOOM_TO_FIT_CALC_BOUNDS, null, null, null, bounds);
  
  bounds = event.getZoomToFitBounds();
  
  var dzx = (this._ww - 2 * this._zoomToFitPadding) / (bounds.w);
  var dzy = (this._hh - 2 * this._zoomToFitPadding) / (bounds.h);
  var dz = Math.min(dzx, dzy);
  dz = this.ConstrainZoom(dz);
  
  return dz;
};

/**
  * Calculate the zoom-to-fit dimensions. 
  */
DvtPanZoomCanvas.prototype.calcZoomToFitBounds = function()
{
var bounds = this._contentPane.getDimensions();
  
  var event = this.FireZoomEvent(DvtZoomEvent.SUBTYPE_ZOOM_TO_FIT_CALC_BOUNDS, null, null, null, bounds);
  
  bounds = event.getZoomToFitBounds();
  
  bounds.x -= this._zoomToFitPadding;
  bounds.y -= this._zoomToFitPadding;
  bounds.w += 2 * this._zoomToFitPadding;
  bounds.h += 2 * this._zoomToFitPadding;
  
  return bounds;
};

/**
 * Get the current viewport in the coordinate system of the content pane.
 * @returns  {DvtRectangle}  current viewport
 */
DvtPanZoomCanvas.prototype.getViewport = function()
{
  var topLeftGlobal = this.localToStage(new DvtPoint(0, 0));
  var bottomRightGlobal = this.localToStage(new DvtPoint(this._ww, this._hh));
  var topLeftLocal = this.getContentPane().stageToLocal(topLeftGlobal);
  var bottomRightLocal = this.getContentPane().stageToLocal(bottomRightGlobal);
  return new DvtRectangle(topLeftLocal.x, topLeftLocal.y, 
                          bottomRightLocal.x - topLeftLocal.x, 
                          bottomRightLocal.y - topLeftLocal.y);
};

/**
 * @protected
 * Set whether constraints should be elastic, with overflow and bounce back.
 */
DvtPanZoomCanvas.prototype.SetElasticConstraints = function(bElastic) {
  this._bElasticConstraints = bElastic;
  
  //if turning on, stop any previously running bounce back anim
  if (bElastic) {
    if (this._elasticConstraintsAnim) {
      if (this._elasticConstraintsAnim.isRunning()) {
        this._elasticConstraintsAnim.stop();
      }
      this._elasticConstraintsAnim = null;
    }
  }
  //if turning off, animate the bounce back to constraint values
  else {
    var currX = this.getPanX();
    var currY = this.getPanY();
    var currZoom = this.getZoom();
    this._bElasticPan = (currX != this.ConstrainPanX(currX) || currY != this.ConstrainPanY(currY));
    this._bElasticZoom = (currZoom != this.ConstrainZoom(currZoom));
    if (this._bElasticPan || this._bElasticZoom) {
      this._elasticConstraintsAnim = new DvtAnimator(this.getCtx(), .4);
      //do cubicOut easing so that the anim happens fast at the beginning and slows down at the end,
      //to make it seem like an elastic
      this._elasticConstraintsAnim.setEasing(DvtEasing.cubicOut);
      //if zoom beyond constraint, constrain it
      if (this._bElasticZoom) {
        this.zoomBy(1, .5 * this._ww, .5 * this._hh, this._elasticConstraintsAnim);
      }
      //if pan is beyond constraints, constrain it
      if (this._bElasticPan) {
        this.panBy(0, 0, this._elasticConstraintsAnim);
      }
      
      DvtPlayable.appendOnEnd(this._elasticConstraintsAnim, this._elasticConstraintsAnimOnEnd, this);
      if (this._bElasticPan)
        this.FirePanEvent(DvtPanEvent.SUBTYPE_ELASTIC_ANIM_BEGIN, null, null, null, null, this._elasticConstraintsAnim);
      if (this._bElasticZoom)
        this.FireZoomEvent(DvtZoomEvent.SUBTYPE_ELASTIC_ANIM_BEGIN, null, null, null, null, this._elasticConstraintsAnim);
      this._elasticConstraintsAnim.play();
    }
  }
};

/**
 * @protected
 * Determine whether constraints are elastic, with overflow and bounce back.
 */
DvtPanZoomCanvas.prototype.IsElasticConstraints = function() {
  return this._bElasticConstraints;
};

/**
 * @private
 */
DvtPanZoomCanvas.prototype._elasticConstraintsAnimOnEnd = function() {
  this._elasticConstraintsAnim = null;
  if (this._bElasticPan)
    this.FirePanEvent(DvtPanEvent.SUBTYPE_ELASTIC_ANIM_END);
  if (this._bElasticZoom)
    this.FireZoomEvent(DvtZoomEvent.SUBTYPE_ELASTIC_ANIM_END);
};

/**
 * @private
 * Damping function for elastic pan constraints.
 */
DvtPanZoomCanvas.prototype._panDampingFunc = function(delta, whole) {
  //parabola centered at (0,0) expanding to the right: y ^ 2 = 4 * a * x
  var a = .01 * whole;
  return Math.sqrt(4 * a * delta);
};

/**
 * @private
 * Damping function for elastic zoom constraints.
 */
DvtPanZoomCanvas.prototype._zoomDampingFunc = function(delta, whole) {
  //parabola centered at (0,0) expanding to the right: y ^ 2 = 4 * a * x
  var a = .002 * whole;
  return Math.sqrt(4 * a * delta);
};

DvtPanZoomCanvas.prototype.ConstrainPanX = function(xx)
{
  var offsetX = xx;
  if (this._minPanX && offsetX < this._minPanX)
  {
    //if elastic constraints, damp the constraint overflow delta
    if (this.IsElasticConstraints()) {
      var dx = this._minPanX - offsetX;
      offsetX = this._minPanX - this._panDampingFunc(dx, this._ww);
    }
    else {
      offsetX = this._minPanX;
    }
  }
  if (this._maxPanX && offsetX > this._maxPanX)
  {
    //if elastic constraints, damp the constraint overflow delta
    if (this.IsElasticConstraints()) {
      var dx = offsetX - this._maxPanX;
      offsetX = this._maxPanX + this._panDampingFunc(dx, this._ww);
    }
    else {
      offsetX = this._maxPanX;
    }
  }
  return offsetX;
};

DvtPanZoomCanvas.prototype.ConstrainPanY = function(yy)
{
  var offsetY = yy;
  if (this._minPanY && offsetY < this._minPanY)
  {
    //if elastic constraints, damp the constraint overflow delta
    if (this.IsElasticConstraints()) {
      var dy = this._minPanY - offsetY;
      offsetY = this._minPanY - this._panDampingFunc(dy, this._hh);
    }
    else {
      offsetY = this._minPanY;
    }
  }
  if (this._maxPanY && offsetY > this._maxPanY)
  {
    //if elastic constraints, damp the constraint overflow delta
    if (this.IsElasticConstraints()) {
      var dy = offsetY - this._maxPanY;
      offsetY = this._maxPanY + this._panDampingFunc(dy, this._hh);
    }
    else {
      offsetY = this._maxPanY;
    }
  }
  return offsetY;
};

/**
 * Applies zoom constraints to the specified zoom level
 *
 * @param {number} zz the specified zoom level
 *
 * @return {number} the constrained zoom level
 * @protected
 */
DvtPanZoomCanvas.prototype.ConstrainZoom = function(zz)
{
  var newZ = Math.max(0, zz); // zoom can't be negative
  if (this._minZoom && newZ < this._minZoom)
  {
    //if elastic constraints, damp the constraint overflow delta
    if (this.IsElasticConstraints()) {
      var dz = this._minZoom - newZ;
      newZ = this._minZoom - this._zoomDampingFunc(dz, this._maxZoom - this._minZoom); //TO DO: what if no min/max?
    }
    else {
      newZ = this._minZoom;
    }
  }
  if (this._maxZoom && newZ > this._maxZoom)
  {
    //if elastic constraints, damp the constraint overflow delta
    if (this.IsElasticConstraints()) {
      var dz = newZ - this._maxZoom;
      newZ = this._maxZoom + this._zoomDampingFunc(dz, this._maxZoom - this._minZoom); //TO DO: what if no min/max?
    }
    else {
      newZ = this._maxZoom;
    }
  }
  return newZ;
};

DvtPanZoomCanvas.RoundFloatForCompare = function(n)
{
  return Math.round(n * 100000);
};

DvtPanZoomCanvas.prototype.renderComponent = function() {
  if (this._controlPanelState != DvtPanZoomCanvas.CONTROL_PANEL_BEHAVIOR_HIDDEN && !this._controlPanel) {
  
    this._controlPanel = new DvtPanZoomControlPanel(this.getCtx(), this, this._buttonImages, this._controlPanelResources, this._displayedControls, this._view);
    this.addChild(this._controlPanel);
    
    // set control panel state
    if (this._controlPanelState == DvtPanZoomCanvas.CONTROL_PANEL_BEHAVIOR_INIT_COLLAPSED)
      this._controlPanel.setState(DvtPanZoomControlPanel.STATE_COLLAPSED);
    else if (this._controlPanelState == DvtPanZoomCanvas.CONTROL_PANEL_BEHAVIOR_INIT_EXPANDED)
      this._controlPanel.setState(DvtPanZoomControlPanel.STATE_EXPANDED);

    this.PositionControlPanel();       
    this._controlPanel.renderComponent(); 
  }
}

DvtPanZoomCanvas.prototype.setControlPanelState = function (state) {
  this._controlPanelState = state;
  if (this._controlPanelState == DvtPanZoomCanvas.CONTROL_PANEL_BEHAVIOR_HIDDEN)
    this.removeChild(this._controlPanel);
}

DvtPanZoomCanvas.prototype.setControlPanel = function (controlPanel) {
  if (this._controlPanel)
    this.removeChild(this._controlPanel);
  
  this._controlPanel = controlPanel;
  if (this._controlPanelState != DvtPanZoomCanvas.CONTROL_PANEL_BEHAVIOR_HIDDEN) {
    this.addChild(this._controlPanel);
    
    if (this._controlPanelState == DvtPanZoomCanvas.CONTROL_PANEL_BEHAVIOR_INIT_COLLAPSED)
      this._controlPanel.setState(DvtPanZoomControlPanel.STATE_COLLAPSED);
    else if (this._controlPanelState == DvtPanZoomCanvas.CONTROL_PANEL_BEHAVIOR_INIT_EXPANDED)
      this._controlPanel.setState(DvtPanZoomControlPanel.STATE_EXPANDED);

    this.PositionControlPanel();  
  }
}

DvtPanZoomCanvas.prototype.getControlPanel = function() {
  return this._controlPanel;
}

/**
 * @protected
 * Positions Control panel in a component viewport
 */
DvtPanZoomCanvas.prototype.PositionControlPanel = function() {
  var styleMap = this._view.getControlPanelStyleMap();
  var posX = DvtStyleUtils.getStyle(styleMap, DvtPanZoomControlPanel.CP_PADDING_SIDE, 0);
  var posY = DvtStyleUtils.getStyle(styleMap, DvtPanZoomControlPanel.CP_PADDING_TOP, 0);

  var openCloseButtonWidth = DvtStyleUtils.getStyle(styleMap,DvtPanZoomControlPanel.CP_OPEN_CLOSE_BUTTON_WIDTH,0);
  var transX;
  if (DvtAgent.isRightToLeft(this.getCtx())) {
    transX = this._ww - openCloseButtonWidth - posX;
  }
  else {
    transX = posX;
  }
  this._controlPanel.setTranslate(transX, posY);
}

/**
 * @protected
 * Get the position relative to the stage of the given mouse event.
 * @param {object} event mouse event
 * @return {DvtPoint}
 */
DvtPanZoomCanvas.prototype.GetRelativeMousePosition = function(event) {
  return this.getCtx().pageToStageCoords(event.pageX, event.pageY);
}

/**
 * @protected
 */
DvtPanZoomCanvas.prototype.FirePanEvent = function(subType, newX, newY, oldX, oldY, animator)
{
  var panEvent = new DvtPanEvent(subType, newX, newY, oldX, oldY, animator);
  this.FireListener(panEvent);
};

/**
 * Fires a DvtZoomEvent to listeners
 * 
 * @param {string}  subType  subtype of the event
 * @param {number}  newZoom  new zoom factor
 * @param {number}  oldZoom  old zoom factor
 * @param {DvtAnimator}  animator  optional animator used to animate the zoom
 * @param {DvtRectangle}  zoomToFitBounds  bounds to use for zoom-to-fit
 * @param {number}  xx  horizontal center of zoom
 * @param {number}  yy  vertical center of zoom
 * @param {number}  tx  the horizontal translation applied after the zoom
 * @param {number}  ty  the vertical translation applied after the zoom
 * @protected
 */
DvtPanZoomCanvas.prototype.FireZoomEvent = function(subType, newZoom, oldZoom, animator, zoomToFitBounds, xx, yy, tx, ty)
{
  var zoomEvent = new DvtZoomEvent(subType, newZoom, oldZoom, animator, zoomToFitBounds, new DvtPoint(xx, yy), tx, ty);
  this.FireListener(zoomEvent);
  return zoomEvent;
};


DvtPanZoomCanvas.prototype.zoomAndCenter = function() {
  this.FireZoomEvent(DvtZoomEvent.SUBTYPE_ZOOM_AND_CENTER);
}
    
/**
 * Get the next incremental, increasing, zoom level.
 * 
 * @param currZoom current zoom level
 * 
 * @return next zoom level
 */
DvtPanZoomCanvas.prototype.getNextZoomLevel = function(currZoom) {
  var zoomLevel = currZoom;

  zoomLevel += this.getZoomIncrement();
  if (zoomLevel > this.getMaxZoom())
    zoomLevel = this.getMaxZoom();

  return zoomLevel;
}
    
/**
 * Get the previous incremental, decreasing, zoom level.
 * 
 * @param currZoom current zoom level
 * 
 * @return previous zoom level
 */
DvtPanZoomCanvas.prototype.getPrevZoomLevel = function(currZoom) {
  var zoomLevel = currZoom;

  zoomLevel -= this.getZoomIncrement();
  if (zoomLevel < this.getMinZoom())
    zoomLevel = this.getMinZoom();

  return zoomLevel;
}
    
/**
 * Set the increment to use for zooming.
 * The increment should be a percentage between 0 and 1. 
 * The default is .05.  
 * 
 * @param n zoom increment
 */
DvtPanZoomCanvas.prototype.setZoomIncrement = function(n) {
  this._zoomIncrement = n;
}
    
/**
 * Get the increment to use for zooming.
 * 
 * @return zoom increment
 */
DvtPanZoomCanvas.prototype.getZoomIncrement = function() {
  return this._zoomIncrement;
}
    
/**
 * Set the increment to use for panning.
 * The increment should be in pixels. 
 * The default is 15.  
 * 
 * @param n pan increment
 */
DvtPanZoomCanvas.prototype.setPanIncrement = function(n) {
  this._panIncrement = n;
}
    
/**
 * Get the increment to use for panning.
 * 
 * @return pan increment
 */
DvtPanZoomCanvas.prototype.getPanIncrement = function() {
  return this._panIncrement;
}
    
/**
 * Set the minimum zoom factor allowed.  
 * The default is .1.
 * 
 * @param n minimum zoom factor
 */
DvtPanZoomCanvas.prototype.setMinZoom = function(n) {
  this._minZoom = n;
}
    
/**
 * Get the minimum zoom factor allowed.
 * 
 * @return minimum zoom factor
 */
DvtPanZoomCanvas.prototype.getMinZoom = function() {
  return this._minZoom;
}
    
/**
 * Set the maximum zoom factor allowed.
 * 
 * @param n maximum zoom factor
 */
DvtPanZoomCanvas.prototype.setMaxZoom = function(n) {
  if (n < 0)
    n = 1;
  this._maxZoom = n;
}

/**
 * Get the maximum zoom factor allowed.
 * 
 * @return maximum zoom factor
 */
DvtPanZoomCanvas.prototype.getMaxZoom = function() {
  return this._maxZoom;
}

/**
 * Set the minimum x coord allowed.  
 * The default is NaN, meaning there is no minimum.
 * 
 * @param n minimum x coord
 */
DvtPanZoomCanvas.prototype.setMinPanX = function(n) {
  this._minPanX = n;
}

/**
 * Get the minimum x coord allowed.  
 * 
 * @return minimum x coord
 */
DvtPanZoomCanvas.prototype.getMinPanX = function() {
  return this._minPanX;
}

/**
 * Set the maximum x coord allowed.  
 * The default is NaN, meaning there is no maximum.
 * 
 * @param n maximum x coord
 */
DvtPanZoomCanvas.prototype.setMaxPanX = function(n) {
  this._maxPanX = n;
}

/**
 * Get the maximum x coord allowed.  
 * 
 * @return maximum x coord
 */
DvtPanZoomCanvas.prototype.getMaxPanX = function() {
  return this._maxPanX;
}

/**
 * Set the minimum y coord allowed.  
 * The default is NaN, meaning there is no minimum.
 * 
 * @param n minimum y coord
 */
DvtPanZoomCanvas.prototype.setMinPanY = function(n) {
  this._minPanY = n;
}

/**
 * Get the minimum y coord allowed.  
 * 
 * @return minimum y coord
 */
DvtPanZoomCanvas.prototype.getMinPanY = function() {
  return this._minPanY;
}

/**
 * Set the maximum y coord allowed.  
 * The default is NaN, meaning there is no maximum.
 * 
 * @param n maximum y coord
 */
DvtPanZoomCanvas.prototype.setMaxPanY = function(n) {
  this._maxPanY = n;
}

/**
 * Get the maximum y coord allowed.  
 * 
 * @return maximum y coord
 */
DvtPanZoomCanvas.prototype.getMaxPanY = function() {
  return this._maxPanY;
}

/**
 * Set whether tilt panning is enabled.
 * 
 * @param b true to enable tilt panning, false to disable it
 */
DvtPanZoomCanvas.prototype.setTiltPanningEnabled = function(b) {
  this._bTiltPanningEnabled = b;
}

/**
 * Determine whether tilt panning is enabled.
 * 
 * @return true if tilt panning is enabled, false if disabled
 */
DvtPanZoomCanvas.prototype.isTiltPanningEnabled = function(b) {
  return this._bTiltPanningEnabled;
}

/**
 * Sets the animation duration (in seconds) for zoom interactions
 * 
 * @param animationDuration the animation duration (in seconds)
 */
DvtPanZoomCanvas.prototype.setAnimationDuration = function(animationDuration) {
  this._animationDuration = animationDuration;
}

/**
 * Gets the animation duration (in seconds) for zoom interactions
 * 
 * @return the animation duration (in seconds)
 */
DvtPanZoomCanvas.prototype.getAnimationDuration = function() {
  return this._animationDuration;
}

DvtPanZoomCanvas.prototype.setPanningEnabled = function(panningEnabled) {
  this._bPanningEnabled = panningEnabled;
};

DvtPanZoomCanvas.prototype.isPanningEnabled = function() {
  return this._bPanningEnabled;
};

DvtPanZoomCanvas.prototype.setZoomingEnabled = function(zoomingEnabled) {
  this._bZoomingEnabled = zoomingEnabled;
};

DvtPanZoomCanvas.prototype.isZoomingEnabled = function() {
  return this._bZoomingEnabled;
};

DvtPanZoomCanvas.prototype.setZoomToFitEnabled = function(zoomToFitEnabled) {
  this._bZoomToFitEnabled = zoomToFitEnabled;
};

DvtPanZoomCanvas.prototype.isZoomToFitEnabled = function() {
  return this._bZoomToFitEnabled;
};

DvtPanZoomCanvas.prototype.adjustZoomControls = function(next) {
  if (this._controlPanel) {
    var currZoom = this.getZoom();
    
    if (next == this.getMinZoom() && next == this.getMaxZoom()) {
      this._controlPanel.enableZoomInControl(false);  
      this._controlPanel.enableZoomOutControl(false);
    }
    else if (currZoom <= next && next == this.getMaxZoom()) {
      this._controlPanel.enableZoomInControl(false);
      this._controlPanel.enableZoomOutControl(true);
    }
    else if (currZoom >= next && next == this.getMinZoom()) {
      this._controlPanel.enableZoomInControl(true);  
      this._controlPanel.enableZoomOutControl(false);
    }
    else {
      this._controlPanel.enableZoomInControl(true);  
      this._controlPanel.enableZoomOutControl(true);
    }
  }
}

/**
 * Stores current touch targets (for zoom events)
 * @param {array} targets an array of the current touch targets
 */
DvtPanZoomCanvas.prototype.setCurrentTouchTargets = function(targets) {
  this._currTargets = targets;
};

/**
 * Returns current touch targets (for zoom events)
 * @return {array} an array of the current touch targets
 */
DvtPanZoomCanvas.prototype.getCurrentTouchTargets = function() {
  return this._currTargets;
};
// Copyright (c) 2011, 2014, Oracle and/or its affiliates. All rights reserved.
/**
 * @constructor
 */
var DvtPanZoomCanvasEventManager = function (context, callback, callbackObj) {
  this.Init(context, callback, callbackObj);
};

DvtObj.createSubclass(DvtPanZoomCanvasEventManager, DvtEventManager, "DvtPanZoomCanvasEventManager");

DvtPanZoomCanvasEventManager.prototype.Init = function (context, callback, callbackObj) {
  DvtPanZoomCanvasEventManager.superclass.Init.call(this, context, callback, callbackObj);
  this._pzc = callbackObj;
  this._zoomAnimator = null;
  this._bPanning = false;
  this._bZooming = false;
  //momentum-based panning (turned on for both touch and desktop)
  this._bMomentumPanning = true;//DvtAgent.isTouchDevice();
}

DvtPanZoomCanvasEventManager.PAN_TOUCH_KEY = "panTouch";
DvtPanZoomCanvasEventManager.ZOOM_TOUCH_KEY = "zoomTouch";

DvtPanZoomCanvasEventManager._MOMENTUM_START_TIMER_INTERVAL = 50;

/**
 * @override
 */
DvtPanZoomCanvasEventManager.prototype.addListeners = function (displayable) {
  DvtPanZoomCanvasEventManager.superclass.addListeners.call(this, displayable);
  if (DvtAgent.isPlatformGecko())//Firefox
    displayable.addEvtListener("DOMMouseScroll", this.OnMouseWheel, false, this);
  else 
    displayable.addEvtListener(DvtMouseEvent.MOUSEWHEEL, this.OnMouseWheel, false, this);
}

/**
 * @override
 */
DvtPanZoomCanvasEventManager.prototype.OnMouseDown = function (event) {
  if (event.button != DvtMouseEvent.RIGHT_CLICK_BUTTON) {
    var pos = this._callbackObj.GetRelativeMousePosition(event);
    this._mx = pos.x;
    this._my = pos.y;
    this._px = this._mx;
    this._py = this._my;
    this._bDown = true;
    
    //for elastic constraints, save the original values
    this._origPanX = this._callbackObj.getPanX();
    this._origPanY = this._callbackObj.getPanY();
    this._origZoom = this._callbackObj.getZoom();
    
    if (this._bMomentumPanning) {
      //save current time for momentum-based panning
      this._currTime = new Date().getTime();
    }
  }
  //if momentum panning was running, stop it
  if (this._momentumTimer && this._momentumTimer.isRunning()) {
    this._momentumTimer.stop();
    this._momentumTimer.reset();
  }
}

/**
 * @override
 */
DvtPanZoomCanvasEventManager.prototype.OnMouseMove = function (event) {
  if (this._bDown) {
    var pos = this._callbackObj.GetRelativeMousePosition(event);
    var xx = pos.x;
    var yy = pos.y;

    if (event.ctrlKey) {
      if (!this._bZooming) {
        this._callback.call(this._callbackObj, new DvtZoomEvent(DvtZoomEvent.SUBTYPE_DRAG_ZOOM_BEGIN));
        this._bZooming = true;
        if (this._pzc.getControlPanel()) {
          this._pzc.getControlPanel().mouseDragPanningStarted();
        }
        //turn on elastic constraints for the duration of this drag
        this._callbackObj.SetElasticConstraints(true);
      }
      //for elastic constraints, use a zoomTo so that the delta is relative to the mouseDown point,
      //resulting in more consistent values and smoother elastic animation
      //var dz = 1 + (this._my - yy) / 100;
      //to emulate the behavior from the line above, which scaled by 1% for each pixel, need to 
      //take that 1% with the correct sign and raise it to the power of the total number of pixels moved
      var sign = (this._py >= yy) ? 1 : -1;
      var zz = this._origZoom * Math.pow(1 + sign * .01, Math.abs(this._py - yy));
      if (!this._callbackObj.isPanningEnabled()) {
        //this._callbackObj.zoomBy(dz, null, null);
        this._callbackObj.zoomTo(zz, null, null);
      }
      else {
        //this._callbackObj.zoomBy(dz, this._px, this._py);
        this._callbackObj.zoomTo(zz, this._px, this._py);
      }
    }
    else {
      this._handlePanMove(xx, yy);
    }

    this._mx = xx;
    this._my = yy;
  }
}

/**
 * @override
 */
DvtPanZoomCanvasEventManager.prototype.OnMouseUp = function (event) {
  this._bDown = false;

  if (this._bPanning) {
    this._handlePanEnd();
  }
  if (this._bZooming) {
    this._handleZoomEnd();
  }
}

/**
 * @override
 */
DvtPanZoomCanvasEventManager.prototype.OnMouseOut = function (event) {
  // simulate mouse up event if needed
  if (this._bDown && (this._bPanning || this._bZooming)) {
    if (!event.relatedTarget || event.relatedTarget == null) {
      this.OnMouseUp(event);
    }
  }
  
  DvtPanZoomCanvasEventManager.superclass.OnMouseOut.call(this, event);
}

DvtPanZoomCanvasEventManager.prototype.OnMouseWheel = function (event) {
  var currZoom = this._callbackObj.getZoom();
  //TODO: re-enable animation after fixing how it works in conjunction with overview window
  var animator = null;//new DvtAnimator(this.getCtx(), this.getAnimationDuration());
  //if there is already a zoom animator running, clean it up
  if (this._zoomAnimator) {
    var oldZoomAnim = this._zoomAnimator;
    //stop the old animator
    this._zoomAnimator.stop();
    //get the destination zoom level of the old animator so that we can add to it
    currZoom = this._callbackObj.getZoom(oldZoomAnim);
    this._zoomAnimator = null;
    oldZoomAnim = null;

    //change the easing function so that it's fast at the start to
    //blend in more seamlessly with the animation we just stopped
    //partway through
    if (animator) {
      animator.setEasing(DvtEasing.cubicOut);
    }
  }
  this._zoomAnimator = animator;

  var delta = 0;
  if (event.wheelDelta != null) {
    delta = event.wheelDelta;

    //reverse the sign of the delta in Firefox so that mouse wheel up zooms in and mouse wheel down zooms out
    if (DvtAgent.isPlatformGecko()) {
      delta = -delta;
    }
  }

  //FIX BUG 17184701: divide by the absolute value of the delta so that the zoom only changes by the increment,
  //just like in native Flash
  var zz = currZoom * (1 + this._callbackObj.getZoomIncrement() * delta / Math.abs(delta));
  var pos = this._callbackObj.GetRelativeMousePosition(event);

  //cancel the mouse wheel event so that the browser doesn't scroll the page
  var docUtils = this.getCtx().getDocumentUtils();
  docUtils.cancelDomEvent(event);
  
  //elastic constraints don't work right for mouse wheel zooming
  //(cause errors when zooming out in zooming.jspx Diagram demo page)
  //this._callbackObj.SetElasticConstraints(true);
  if (!this._callbackObj.isPanningEnabled()) {
    this._callbackObj.zoomTo(zz, null, null, this._zoomAnimator);
  }
  else {
    this._callbackObj.zoomTo(zz, pos.x, pos.y, this._zoomAnimator);
  }
  //this._callbackObj.SetElasticConstraints(false);

  if (this._zoomAnimator) {
    DvtPlayable.appendOnEnd(this._zoomAnimator, this._clearZoomAnimator, this);
    this._zoomAnimator.play();
  }
}

DvtPanZoomCanvasEventManager.prototype._clearZoomAnimator = function() {
  this._zoomAnimator = null;
}

DvtPanZoomCanvasEventManager.prototype._handleMomentumStartTimer = function() {
  //do nothing
};

DvtPanZoomCanvasEventManager.prototype._handleMomentumTimer = function() {
  //percent to slow down momentum each iteration
  var fraction = .04;//.02;
  //quadratic damping function
  var ratio = 1 - fraction * this._momentumIterCount;
  ratio *= ratio;
  var interval = this._momentumTimer.getInterval();//DvtPanZoomCanvasEventManager._MOMENTUM_START_TIMER_INTERVAL;
  //deltas to pan by for this iteration
  var dx = ratio * this._momentumXperMS * interval;
  var dy = ratio * this._momentumYperMS * interval;
  //add deltas to accumulated values
  this._momentumDx += dx;
  this._momentumDy += dy;
  //add accumulated deltas to the last drag pan position
  var newX = this._origPanX + this._mx - this._px + this._momentumDx;
  var newY = this._origPanY + this._my - this._py + this._momentumDy;
  this._callbackObj.panTo(newX, newY);
  var bStop = false;
  //stop just before ratio goes to 0
  if (this._momentumIterCount >= (1 / fraction) - 1) {
    bStop = true;
  }
  else {
    //stop if we've hit elastic constraints
    var currX = this._callbackObj.getPanX();
    var currY = this._callbackObj.getPanY();
    //if the difference between the desired and actual pan positions is greater than the delta for this timer
    //iteration, we must be hitting the elastic constraints, so stop iterating
    if (Math.abs(currX - newX) > Math.abs(dx) || Math.abs(currY - newY) > Math.abs(dy)) {
      bStop = true;
    }
  }
  
  if (bStop) {
    this._momentumTimer.stop();
    this._momentumTimer.reset();
    //turn off elastic constraints when momentum stops
    this._callbackObj.SetElasticConstraints(false);
  }
  else {
    this._momentumIterCount++;
  }
};

/**
 * @override
 */
DvtPanZoomCanvasEventManager.prototype.HandleImmediateTouchStartInternal = function (event) {
  if (this._callbackObj.isZoomingEnabled())
    this.TouchManager.processAssociatedTouchAttempt(event, DvtPanZoomCanvasEventManager.ZOOM_TOUCH_KEY, this.ZoomStartTouch, this);

  if (this._callbackObj.isPanningEnabled())
    this.TouchManager.processAssociatedTouchAttempt(event, DvtPanZoomCanvasEventManager.PAN_TOUCH_KEY, this.PanStartTouch, this);
}

/**
 * @override
 */
DvtPanZoomCanvasEventManager.prototype.HandleImmediateTouchMoveInternal = function (event) {
  if (this._callbackObj.isZoomingEnabled())
    this.TouchManager.processAssociatedTouchMove(event, DvtPanZoomCanvasEventManager.ZOOM_TOUCH_KEY);

  if (this._callbackObj.isPanningEnabled())
    this.TouchManager.processAssociatedTouchMove(event, DvtPanZoomCanvasEventManager.PAN_TOUCH_KEY);
  
  if (event)
    event.preventDefault();
}

/**
 * @override
 */
DvtPanZoomCanvasEventManager.prototype.HandleImmediateTouchEndInternal = function (event) {
  if (this._callbackObj.isZoomingEnabled())
    this.TouchManager.processAssociatedTouchEnd(event, DvtPanZoomCanvasEventManager.ZOOM_TOUCH_KEY);

  if (this._callbackObj.isPanningEnabled())
    this.TouchManager.processAssociatedTouchEnd(event, DvtPanZoomCanvasEventManager.PAN_TOUCH_KEY);
}

/**
 * Handles zoom start for touch device
 * @protected
 * @param {DvtTouchEvent} event Touch event to handle
 * @touch {DvtTouch} touch Touch object for the event
 */
DvtPanZoomCanvasEventManager.prototype.ZoomStartTouch = function (event, touch) {
  var touchIds = this.TouchManager.getTouchIdsForObj(DvtPanZoomCanvasEventManager.ZOOM_TOUCH_KEY);
  if (touchIds.length <= 1) {
    this.TouchManager.saveProcessedTouch(touch.identifier, DvtPanZoomCanvasEventManager.ZOOM_TOUCH_KEY, null, DvtPanZoomCanvasEventManager.ZOOM_TOUCH_KEY, DvtPanZoomCanvasEventManager.ZOOM_TOUCH_KEY, this.ZoomMoveTouch, this.ZoomEndTouch, this);
    this._mx = touch.pageX;
    this._my = touch.pageY;
    this._px = this._mx;
    this._py = this._my;
    
    //for elastic constraints, save the original values
    this._origPanX = this._callbackObj.getPanX();
    this._origPanY = this._callbackObj.getPanY();
    this._origZoom = this._callbackObj.getZoom();
    
    //FIX BUG 17185041: save the original finger distance
    this._origDist = null;
    touchIds = this.TouchManager.getTouchIdsForObj(DvtPanZoomCanvasEventManager.ZOOM_TOUCH_KEY);
    this._callbackObj.setCurrentTouchTargets(this.TouchManager.getStartTargetsByIds(touchIds));
  }
  
  //if momentum panning was running, stop it
  if (this._momentumTimer && this._momentumTimer.isRunning()) {
    this._momentumTimer.stop();
    this._momentumTimer.reset();
  }
}

/**
 * Handles zoom move for touch device
 * @protected
 * @param {DvtTouchEvent} event Touch event to handle
 * @touch {DvtTouch} touch Touch object for the event
 */
DvtPanZoomCanvasEventManager.prototype.ZoomMoveTouch = function (event, touch) {
  var touchIds = this.TouchManager.getTouchIdsForObj(DvtPanZoomCanvasEventManager.ZOOM_TOUCH_KEY);
  if (touchIds.length == 2) {
    var data = this.TouchManager.getMultiTouchData(touchIds);
    if (data) {
      // set a flag so we won't try to pan while zooming
      if (!this._bZooming) {
        this._bZooming = true;
        this.TouchManager.blockTouchHold();      
        this._callback.call(this._callbackObj, new DvtZoomEvent(DvtZoomEvent.SUBTYPE_DRAG_ZOOM_BEGIN));
        
        if (this._pzc.getControlPanel())
          this._pzc.getControlPanel().mouseDragPanningStarted();
      }
      //turn on elastic constraints for the duration of this drag
      this._callbackObj.SetElasticConstraints(true);

      //FIX BUG 17185041: 
      //the original distance should be the current distance minus the current delta distance
      if (this._origDist == null) {
        this._origDist = data.dist - data.dz;
      }
      //the new zoom should be the original zoom multiplied by the ratio of current finger distance to original 
      //finger distance (e.g. if you move your fingers twice as far apart as they originally were, the view should 
      //zoom by a factor of 2)
      var zz = this._origZoom * (data.dist / this._origDist);
      //the center point of the zoom needs to be converted to stage-relative coords
      var cp = this._pzc.getCtx().pageToStageCoords(data.cx, data.cy);
      
      this.hideTooltip();
      this._callbackObj.setCurrentTouchTargets(this.TouchManager.getStartTargetsByIds(touchIds));      
      this._callbackObj.zoomTo(zz, cp.x, cp.y);
      //the center point delta is in page coords, which should be okay for panning
      this._callbackObj.panBy(data.dcx, data.dcy);
    }
  }
  
}

/**
 * Handles zoom end for touch device
 * @protected
 * @param {DvtTouchEvent} event Touch event to handle
 * @touch {DvtTouch} touch Touch object for the event
 */
DvtPanZoomCanvasEventManager.prototype.ZoomEndTouch = function (event, touch) {
  if (this._bZooming) {
    //FIX BUG 17185041: clear the original finger distance
    this._origDist = null;
    this.TouchManager.unblockTouchHold();
    this._handleZoomEnd();
  }
  var touchIds = this.TouchManager.getTouchIdsForObj(DvtPanZoomCanvasEventManager.ZOOM_TOUCH_KEY);
  this._callbackObj.setCurrentTouchTargets(this.TouchManager.getStartTargetsByIds(touchIds));
  if (touchIds.length == 0)
    this._callback.call(this._callbackObj, new DvtZoomEvent(DvtZoomEvent.SUBTYPE_ZOOM_END));
}

DvtPanZoomCanvasEventManager.prototype.PanStartTouch = function (event, touch) {
  if (!this._bZooming) {
    var touchIds = this.TouchManager.getTouchIdsForObj(DvtPanZoomCanvasEventManager.PAN_TOUCH_KEY);
    if (touchIds.length <= 1) {
      this.TouchManager.saveProcessedTouch(touch.identifier, DvtPanZoomCanvasEventManager.PAN_TOUCH_KEY, null, DvtPanZoomCanvasEventManager.PAN_TOUCH_KEY, DvtPanZoomCanvasEventManager.PAN_TOUCH_KEY, this.PanMoveTouch, this.PanEndTouch, this);
      this._mx = touch.pageX;
      this._my = touch.pageY;
      this._px = this._mx;
      this._py = this._my;
      
      //for elastic constraints, save the original values
      this._origPanX = this._callbackObj.getPanX();
      this._origPanY = this._callbackObj.getPanY();
      this._origZoom = this._callbackObj.getZoom();
      
      if (this._bMomentumPanning) {
        //save current time for momentum-based panning
        this._currTime = new Date().getTime();
      }
    }
  }
    //if momentum panning was running, stop it
  if (this._momentumTimer && this._momentumTimer.isRunning()) {
    this._momentumTimer.stop();
    this._momentumTimer.reset();
  }  
}

DvtPanZoomCanvasEventManager.prototype.PanMoveTouch = function (event, touch) {
  if (!this._bZooming) {
    var touchIds = this.TouchManager.getTouchIdsForObj(DvtPanZoomCanvasEventManager.PAN_TOUCH_KEY);
    if (touchIds.length == 1) {
      var xx = touch.pageX;
      var yy = touch.pageY;
      this._handlePanMove(xx, yy);
      this._mx = xx;
      this._my = yy;
    }
  }
}

DvtPanZoomCanvasEventManager.prototype.PanEndTouch = function (event, touch) {
  if (!this._bZooming && this._bPanning) {
    this._handlePanEnd();
  }
}

DvtPanZoomCanvasEventManager.prototype._handleZoomEnd = function () {
    this._callback.call(this._callbackObj, new DvtZoomEvent(DvtZoomEvent.SUBTYPE_DRAG_ZOOM_END));
    this._bZooming = false;
    if (this._pzc.getControlPanel())
      this._pzc.getControlPanel().mouseDragPanningEnded();
    
    //turn off elastic constraints, which will animate a bounce back to constrained values, if necessary
    this._callbackObj.SetElasticConstraints(false);
}

DvtPanZoomCanvasEventManager.prototype._handlePanMove = function (xx, yy) {
  if (!this._bPanning) {
    this._callback.call(this._callbackObj, new DvtPanEvent(DvtPanEvent.SUBTYPE_DRAG_PAN_BEGIN));
    this._bPanning = true;
    if (this._pzc.getControlPanel()) {
      this._pzc.getControlPanel().mouseDragPanningStarted();
    }
    //turn on elastic constraints for the duration of this drag
    this._callbackObj.SetElasticConstraints(true);
    
    if (this._bMomentumPanning) {
      //keep track of last N mouse moves for momentum-based panning
      this._arLastNMouseMoves = [];
    }
  }
  
  //for elastic constraints, use a panTo so that the delta is relative to the mouseDown point,
  //resulting in more consistent values and smoother elastic animation
  //this._callbackObj.panBy(xx - this._mx, yy - this._my);
  this._callbackObj.panTo(this._origPanX + xx - this._px, this._origPanY + yy - this._py);
  
  if (this._bMomentumPanning) {
    //get new timestamp for momentum-based panning
    this._lastTime = this._currTime;
    this._currTime = new Date().getTime();
    
    //create or reset the timer to determine if we should start momentum-based panning
    if (this._momentumStartTimer) {
      if (this._momentumStartTimer.isRunning()) {
        this._momentumStartTimer.stop();
      }
      this._momentumStartTimer.reset();
    }
    else {
      this._momentumStartTimer = new DvtTimer(this._context, DvtPanZoomCanvasEventManager._MOMENTUM_START_TIMER_INTERVAL, this._handleMomentumStartTimer, this, 1);
    }
    //save the info for this mouse move
    this._arLastNMouseMoves.push({dt: (this._currTime - this._lastTime), dx: (xx - this._mx), dy: (yy - this._my)});
    //only save last N moves, so drop the oldest
    if (this._arLastNMouseMoves.length > 5) {
      this._arLastNMouseMoves.splice(0, 1);
    }
    //start the timer to indicate if we should start momentum-based panning;
    //if the timer expires, we won't do momentum-based panning, if the timer hasn't expired when the
    //mouseup occurs, then we'll start momentum-based panning
    this._momentumStartTimer.start();
  }
}

DvtPanZoomCanvasEventManager.prototype._handlePanEnd = function () {
  this._callback.call(this._callbackObj, new DvtPanEvent(DvtPanEvent.SUBTYPE_DRAG_PAN_END));
  this._bPanning = false;
  if (this._pzc.getControlPanel()) {
    this._pzc.getControlPanel().mouseDragPanningEnded();
  }
  //if the momentum-based panning start timer is still running, that means that the mouseup happened
  //very quickly after the last mouse move, so we want to start momentum-based panning
  if (this._momentumStartTimer && this._momentumStartTimer.isRunning()) {
    this._momentumStartTimer.stop();
    this._momentumStartTimer.reset();
    //create or reset the momentum panning timer
    if (!this._momentumTimer) {
      //initialize with start timer interval, but it will later be changed based on mousemove event intervals
      this._momentumTimer = new DvtTimer(this._context, DvtPanZoomCanvasEventManager._MOMENTUM_START_TIMER_INTERVAL, this._handleMomentumTimer, this);
    }
    else {
      this._momentumTimer.reset();
    }
    
    //use the last N mousemoves to average the x,y deltas per ms
    var dt = 0;
    var dx = 0;
    var dy = 0;
    var numMoves = this._arLastNMouseMoves.length;
    while (this._arLastNMouseMoves.length > 0) {
      var objMove = this._arLastNMouseMoves.pop();
      dt += objMove.dt;
      dx += objMove.dx;
      dy += objMove.dy;
    }
    this._arLastNMouseMoves = null;
    this._momentumXperMS = dx / dt;
    this._momentumYperMS = dy / dt;
    //use timer interval similar to mousemove interval
    this._momentumTimer.setInterval(Math.ceil(dt / numMoves));
    this._momentumIterCount = 1;
    this._momentumDx = 0;
    this._momentumDy = 0;
    this._momentumTimer.start();
  }
  else {
    //turn off elastic constraints, which will animate a bounce back to constrained values, if necessary
    this._callbackObj.SetElasticConstraints(false);
  }
}
/**
 *  @param {DvtEventManager} manager The owning DvtEventManager
 *  @class DvtPanZoomCanvasKeyboardHandler
 *  @extends DvtKeyboardHandler
 *  @constructor
 */
var DvtPanZoomCanvasKeyboardHandler = function (component, manager) {
  this.Init(component, manager);
};

DvtObj.createSubclass(DvtPanZoomCanvasKeyboardHandler, DvtKeyboardHandler, "DvtPanZoomCanvasKeyboardHandler");

/**
 * @override
 */
DvtPanZoomCanvasKeyboardHandler.prototype.Init = function(component, manager) {
  DvtPanZoomCanvasKeyboardHandler.superclass.Init(manager);
  this._component = component;
}

/**
 * @override
 */
DvtPanZoomCanvasKeyboardHandler.prototype.processKeyDown = function(event) {
  var keyCode = event.keyCode;
  var canvas = this._component.getPanZoomCanvas();
  if (keyCode == DvtKeyboardEvent.PAGE_UP) {
    //TODO handle BiDi panning left/right
    if (event.ctrlKey||event.shiftKey)
      canvas.panBy(canvas.getPanIncrement(),0);
    else
      canvas.panBy(0,canvas.getPanIncrement());
  }
  else if (keyCode == DvtKeyboardEvent.PAGE_DOWN) {
    if (event.ctrlKey||event.shiftKey)
      canvas.panBy(-canvas.getPanIncrement(),0);
    else
      canvas.panBy(0,-canvas.getPanIncrement());
  }
  else if (keyCode == DvtKeyboardEvent.FORWARD_SLASH) {
    var controlPanel = canvas.getControlPanel();
    if (controlPanel)
      controlPanel.toggleExpandCollapse();
  }
  else if (DvtKeyboardEvent.isEquals(event) || DvtKeyboardEvent.isPlus(event)) {
    canvas.zoomTo(canvas.getZoom() + canvas.getZoomIncrement());
  }
  else if (DvtKeyboardEvent.isMinus(event) || DvtKeyboardEvent.isUnderscore(event)) {
    canvas.zoomTo(canvas.getZoom() - canvas.getZoomIncrement());
  }
  else if ((keyCode == DvtKeyboardEvent.ZERO || keyCode == DvtKeyboardEvent.NUMPAD_ZERO) && !event.ctrlKey && !event.shiftKey) {
    canvas.zoomToFit();
  }
  else {
    return DvtPanZoomCanvasKeyboardHandler.superclass.processKeyDown.call(this, event);
  }
}
// Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
/**
 *  Creates a DvtCollapsiblePanel
 *  @class DvtCollapsiblePanel
 *  @extends DvtContainer
 *  @constructor
 *  @param {DvtContext} context The context object
 *  @param {id} The id of the CollapsiblePanel
 *  @param {x} The leftmost position of the CollapsiblePanel
 *  @param {y} The topmost position of the CollapsiblePanel
 */
var DvtCollapsiblePanel = function (context, maxWidth, maxHeight, collapseDir, buttonImages, styleMap, disclosed, isFixed) {
  this.Init(context, maxWidth, maxHeight, collapseDir, buttonImages, styleMap, disclosed, isFixed);
};

DvtCollapsiblePanel.COLLAPSE_NORTHEAST = "col_northeast";
DvtCollapsiblePanel.COLLAPSE_SOUTHEAST = "col_southeast";
DvtCollapsiblePanel.COLLAPSE_NORTHWEST = "col_northwest";
DvtCollapsiblePanel.COLLAPSE_SOUTHWEST = "col_southwest";

DvtCollapsiblePanel.ANIMATIONDURATION = 0.25;

DvtCollapsiblePanel.BODYCOLOR = '#EBEFF5';
DvtCollapsiblePanel.TITLEBARCLOSEICON_WIDTH = 10;
DvtCollapsiblePanel.TITLEBARCLOSEICON_HEIGHT = 10;
DvtCollapsiblePanel.BUTTONHEIGHT = 25;

DvtCollapsiblePanel._CONTENT_PADDING = 5;
DvtCollapsiblePanel._SCROLLBAR_CONTENT_PADDING = 3;

DvtObj.createSubclass(DvtCollapsiblePanel, DvtContainer, "DvtCollapsiblePanel");

/**
 * Initialization method called by the constructor
 * 
 * @param {DvtContext} context Platform specific context object
 * @param {number} maxWidth The maximum width of the collapsible panel
 * @param {number} maxHeight The maximum height of the collapsible panel
 * @param {string} collapseDir Collapse direction
 * @param {DvtXmlNode} buttonImages The map of button images
 * @param {object} styleMap The object containing style specifications for this component
 * @param {boolean} disclosed Flag that indicates whether the panel is disclosed
 * @param {boolean} isFixed Flag that indicates whether the panel is collapsible
 * @protected
 */
DvtCollapsiblePanel.prototype.Init = function (context, maxWidth, maxHeight, collapseDir, buttonImages, styleMap, disclosed, isFixed) {
  DvtCollapsiblePanel.superclass.Init.call(this, context);
  
  this._maxWidth = maxWidth;
  this._maxHeight = maxHeight;
  
  this.setCollapseDirection(collapseDir);
  this._buttonImages = buttonImages;
  this._isFixed = isFixed ? isFixed : DvtAgent.isEnvironmentBatik();
  this._expandTooltip = null;
  this._collapseTooltip = null;
  this._animation = null;
  
  this._styleMap = styleMap;
  this._borderColor = DvtStyleUtils.getStyle(this._styleMap, DvtCSSStyle.BORDER_COLOR, null);
  this._borderRadius = parseInt(DvtStyleUtils.getStyle(this._styleMap, DvtCSSStyle.BORDER_RADIUS, null));
  this._bgColor = DvtStyleUtils.getStyle(this._styleMap, DvtCSSStyle.BACKGROUND_COLOR, null);
  this._bgAlpha = DvtStyleUtils.getStyle(this._styleMap, DvtPanZoomControlPanel.BG_ALPHA, 1);
  
  if (disclosed !== undefined)
    this._collapse = !disclosed;
  else
    this._collapse = false;
  
  var scrollMaxWidth = maxWidth - 2*DvtCollapsiblePanel._CONTENT_PADDING;
  var scrollMaxHeight = maxHeight - 2*DvtCollapsiblePanel._CONTENT_PADDING;
  this._scrollableContainer = new DvtScrollableContainer(context, 0, 0, scrollMaxWidth, scrollMaxHeight, 
                                                          DvtCollapsiblePanel._SCROLLBAR_CONTENT_PADDING, "collapsiblePanel");
  this.addChild(this._scrollableContainer);
  this._scrollableContainer.setHorizontalScrollingEnabled(false);
  this._scrollableContainer.setTranslate(DvtCollapsiblePanel._CONTENT_PADDING, DvtCollapsiblePanel._CONTENT_PADDING);

  this.addEvtListener(DvtMouseEvent.MOUSEOVER, this.HandleMouseOver, false, this);
  this.addEvtListener(DvtMouseEvent.MOUSEOUT, this.HandleMouseOut, false, this);
}

/**
 * @private
 * Creates collapse/expand button
 */
DvtCollapsiblePanel.prototype._drawButton = function () {
  // only draw collapse/expand button if not in print or fixed mode
  if (!this._isFixed) {
    this._buttonFrame = DvtPanZoomControlPanelLAFUtils.createEmptyViewClosedFrame(this.getCtx(), DvtCollapsiblePanel.BUTTONHEIGHT, this._styleMap, false);
    this._buttonFrame.setAlpha(this._styleMap[DvtPanZoomControlPanel.FRAME_ROLLOUT_ALPHA]);
    this.addChild(this._buttonFrame);
    if (this.isCollapsed())
      this._collapseExpandButton = DvtButtonLAFUtils.createExpandButton(this.getCtx(), this._buttonImages, DvtCollapsiblePanel.BUTTONHEIGHT, this._styleMap, false);
    else
      this._collapseExpandButton = DvtButtonLAFUtils.createCollapseButton(this.getCtx(), this._buttonImages, DvtCollapsiblePanel.BUTTONHEIGHT, this._styleMap, false);
    this._buttonFrame.addChild(this._collapseExpandButton);
    
    var west = this._collapseDir == DvtCollapsiblePanel.COLLAPSE_NORTHWEST || this._collapseDir == DvtCollapsiblePanel.COLLAPSE_SOUTHWEST;  
    if (!west) {
      this._buttonFrame.setTranslateY(DvtCollapsiblePanel.BUTTONHEIGHT);
      this._buttonFrame.setRotation(-Math.PI);
    }
    
    if (DvtAgent.isRightToLeft(this.getCtx()))
      this._buttonFrame.setTranslateX(this._width);
      
    if (DvtAgent.isTouchDevice()) {
      this._collapseExpandButton.addEvtListener(DvtTouchEvent.TOUCHSTART, this.OnButtonClick, false, this);
    } else {
      this._collapseExpandButton.addEvtListener(DvtMouseEvent.CLICK, this.OnButtonClick, false, this);
      this._collapseExpandButton.addEvtListener(DvtMouseEvent.MOUSEOVER, this.OnButtonHoverOver, false, this);
      this._collapseExpandButton.addEvtListener(DvtMouseEvent.MOUSEOUT, this.OnButtonHoverOut, false, this);
    }
  }
}
  
DvtCollapsiblePanel.prototype.setBackgroundFill = function (fill) {
  this._background.setFill(fill);
}

DvtCollapsiblePanel.prototype.setBackgroundStroke = function (stroke) {
  this._background.setStroke(stroke);
}

DvtCollapsiblePanel.prototype.setButtonTooltips = function (expand, collapse) {
  this._expandTooltip = expand;
  this._collapseTooltip = collapse;
}

DvtCollapsiblePanel.prototype.addContent = function (object) {
  this._scrollableContainer.addChild(object);
  object.addEvtListener(DvtResizeEvent.RESIZE_EVENT, this.HandleResize, false, this);
  
  var dims = this._scrollableContainer.getDimensions();
  var width = dims.w + 2*DvtCollapsiblePanel._CONTENT_PADDING;
  var height = dims.h + 2*DvtCollapsiblePanel._CONTENT_PADDING;
  this._height = height;
  this._width = width;
  
  if (!this._background) {
    this._background = this._createRoundRectangle(width, height);
    this.addChildAt(this._background, 0);
    this._drawButton();
//    if(this._shadow)
//      this.addDrawEffect(this._shadow);
  } else {
    this._background.setCmds(this._getOutlinePath(width, height));
    var west = this._collapseDir == DvtCollapsiblePanel.COLLAPSE_NORTHWEST || this._collapseDir == DvtCollapsiblePanel.COLLAPSE_SOUTHWEST;  
    if (this._buttonFrame && west)
      this._buttonFrame.setTranslateX(this._width); 
  }

  if (this._collapse) {
    this._collapseExpand(false);
  }
}

DvtCollapsiblePanel.prototype.HandleResize = function(event) {
  this._scrollableContainer.refresh();
  
  var dims = this._scrollableContainer.getDimensions();
  var resizeWidth = dims.w + 2*DvtCollapsiblePanel._CONTENT_PADDING;
  var resizeHeight = dims.h + 2*DvtCollapsiblePanel._CONTENT_PADDING;
    
  this._background.setCmds(this._getOutlinePath(resizeWidth, resizeHeight));
  var west = this._collapseDir == DvtCollapsiblePanel.COLLAPSE_NORTHWEST || this._collapseDir == DvtCollapsiblePanel.COLLAPSE_SOUTHWEST;  
  if (this._buttonFrame && west)
    this._buttonFrame.setTranslateX(resizeWidth); 
    
  //fire resize event so parent component can reposition
  this.FireListener(new DvtResizeEvent(resizeWidth, resizeHeight, 0, 0));
};


/**
 * Returns whether the collapsible panel is in collapsed state.
 * @returns {boolean}  True if the collapsible panel is in collapsed state.  Default to false.
 */
DvtCollapsiblePanel.prototype.isCollapsed = function () {
  return this._collapse;
}

/**  
 * Toggles expand/collapse state of the CollapsiblePanel
 * @param {boolean} collapse True to collapse the collapsiblePanel, false to expand
 */
DvtCollapsiblePanel.prototype.setCollapsed = function (collapse) {
  if (this._collapse != collapse) {
    this._collapse = collapse;
    this._collapseExpand(true);
    this.FireListener(new DvtCollapsiblePanelEvent(collapse ? DvtCollapsiblePanelEvent.SUBTYPE_HIDE : 
                                                              DvtCollapsiblePanelEvent.SUBTYPE_SHOW));
  }
}

/**
 * Sets the direction this collapsible panel collapses in
 * @param {String} collapseDir The collapse direction
 */
DvtCollapsiblePanel.prototype.setCollapseDirection = function (collapseDir) {  
  this._collapseDir = collapseDir ? collapseDir : DvtCollapsiblePanel.COLLAPSE_NORTHEAST;
  if (DvtAgent.isRightToLeft(this.getCtx())) {
    if (this._collapseDir == DvtCollapsiblePanel.COLLAPSE_NORTHEAST)
      this._collapseDir = DvtCollapsiblePanel.COLLAPSE_NORTHWEST
    else if (this._collapseDir == DvtCollapsiblePanel.COLLAPSE_NORTHWEST)
      this._collapseDir = DvtCollapsiblePanel.COLLAPSE_NORTHEAST
    else if (this._collapseDir == DvtCollapsiblePanel.COLLAPSE_SOUTHEAST)
      this._collapseDir = DvtCollapsiblePanel.COLLAPSE_SOUTHWEST
    else if (this._collapseDir == DvtCollapsiblePanel.COLLAPSE_SOUTHWEST)
      this._collapseDir = DvtCollapsiblePanel.COLLAPSE_SOUTHEAST
  }
}

DvtCollapsiblePanel.prototype.getMaxWidth = function () {
  return this._maxWidth;
}

/**
 * Returns the maximum width the content for this collapsible panel can be 
 * taking into account the scrollbar width and padding.
 * @return {number} The maximum width the content for this collapsible panel
 */
DvtCollapsiblePanel.prototype.getMaxContentWidth = function () {
  return this._maxWidth - (2*DvtCollapsiblePanel._CONTENT_PADDING + DvtScrollableContainer.DEFAULT_SCROLLBAR_WIDTH + DvtCollapsiblePanel._SCROLLBAR_CONTENT_PADDING);
}

DvtCollapsiblePanel.prototype.getMaxHeight = function () {
  return this._maxHeight;
}

DvtCollapsiblePanel.prototype.getMaxContentHeight = function () {
  return this._maxHeight - (2*DvtCollapsiblePanel._CONTENT_PADDING + DvtScrollableContainer.DEFAULT_SCROLLBAR_WIDTH + DvtCollapsiblePanel._SCROLLBAR_CONTENT_PADDING);
}

/**
 * @private
 * Returns a point to move by used in animation
 * @param {DvtPoint} point The original point that represent one of the corners on collapsibel panel
 * @param {boolean} isScale True to scale the point
 */
DvtCollapsiblePanel.prototype._getRefPoint = function (point, isScale) {
  if (!this.isCollapsed()) {
    if (isScale)
      return new DvtPoint(1 / point.x, 1 / point.y);
    else 
      return new DvtPoint( - point.x,  - point.y);
  }

  return point;
}

/**
 * Internal method to update the expand/collapse state of the CollapsiblePanel
 * @param {boolean} animate True for animation
 * @private
 */
DvtCollapsiblePanel.prototype._collapseExpand = function (animate) {
  if (this._animation) {
    this._animationStopped = true;
    this._animation.stop(true);
  }

  var north = this._collapseDir == DvtCollapsiblePanel.COLLAPSE_NORTHWEST || this._collapseDir == DvtCollapsiblePanel.COLLAPSE_NORTHEAST;
  var west = this._collapseDir == DvtCollapsiblePanel.COLLAPSE_NORTHWEST || this._collapseDir == DvtCollapsiblePanel.COLLAPSE_SOUTHWEST;

  var translateX = west ? 0 : this._width;
  var translateY = north ? 0 : this._height;

  var scalePoint = new DvtPoint(1 / this._width, 1 / this._height);
  var translatePoint = new DvtPoint(translateX, translateY);
  var adjustment = north ? 0 : DvtCollapsiblePanel.BUTTONHEIGHT;
  var translatePoint2 = new DvtPoint(west ? -this._width : this._width, translateY - adjustment);
  
  if (!animate) {
    this._background.setAlpha(0);
    if (this._buttonFrame)
      this._buttonFrame.setAlpha(0);
  }
  
  //TODO figure out actual movement for non animation 
  var scaleAnim = new DvtAnimScaleBy(this.getCtx(), this._background, this._getRefPoint(scalePoint, true), animate ? DvtCollapsiblePanel.ANIMATIONDURATION : 0.00001);
  var moveAnim = new DvtAnimMoveBy(this.getCtx(), this._buttonFrame, this._getRefPoint(translatePoint2), animate ? DvtCollapsiblePanel.ANIMATIONDURATION : 0.00001);
  var moveAnim2 = new DvtAnimMoveBy(this.getCtx(), this._background, this._getRefPoint(translatePoint), animate ? DvtCollapsiblePanel.ANIMATIONDURATION : 0.00001);
  
  this._animation = new DvtParallelPlayable(this.getCtx(), scaleAnim, moveAnim, moveAnim2);
  
  // If an animation was created, play it
  if (this._animation) {
    this.getCtx().getTooltipManager().hideTooltip();
    
    // Disable event listeners temporarily
    this.removeEvtListener(DvtMouseEvent.MOUSEOVER, this.HandleMouseOver, false, this);
    this.removeEvtListener(DvtMouseEvent.MOUSEOUT, this.HandleMouseOut, false, this);
    if (this._collapseExpandButton) {
      this._collapseExpandButton.removeEvtListener(DvtTouchEvent.TOUCHSTART, this.OnButtonClick, false, this);
      this._collapseExpandButton.removeEvtListener(DvtMouseEvent.CLICK, this.OnButtonClick, false, this);
      this._collapseExpandButton.removeEvtListener(DvtMouseEvent.MOUSEOVER, this.OnButtonHoverOver, false, this);
      this._collapseExpandButton.removeEvtListener(DvtMouseEvent.MOUSEOUT, this.OnButtonHoverOut, false, this);
    }
    
    if (this.isCollapsed())
      this._scrollableContainer.setAlpha(0);

    // Start the animation
    this._animation.setOnEnd(this.OnAnimationEnd, this);
    this._animation.play();
  }

}

DvtCollapsiblePanel.prototype._createRoundRectangle = function (width, height) {
  var rect = new DvtPath(this.getCtx(), this._getOutlinePath(width, height));
  var alpha = this._styleMap[DvtPanZoomControlPanel.FRAME_ROLLOUT_ALPHA];
  rect.setSolidFill(this._bgColor, this._bgAlpha);
  rect.setSolidStroke(this._borderColor, alpha);
  return rect;
}

DvtCollapsiblePanel.prototype._getOutlinePath = function (width, height) {
  var r = this._borderRadius;
  var cmds;
  var west = this._collapseDir == DvtCollapsiblePanel.COLLAPSE_NORTHWEST || this._collapseDir == DvtCollapsiblePanel.COLLAPSE_SOUTHWEST;
  if (height <= DvtCollapsiblePanel.BUTTONHEIGHT)
    height = DvtCollapsiblePanel.BUTTONHEIGHT;
  // when collapsing to the west, northwest corner rounded, northeast corner square
  // when collapsing to the east, northwest corner square, northeast corner rounded
  if (this._isFixed || west)
    cmds = DvtPathUtils.moveTo(r, 0);
  else
    cmds = DvtPathUtils.moveTo(0, 0);
    
  cmds += DvtPathUtils.lineTo(width - r, 0);
  
  if (!this._isFixed && west) {
    cmds += DvtPathUtils.lineTo(width, 0);
    cmds += DvtPathUtils.lineTo(width, r);
  } else {
    cmds += DvtPathUtils.quadTo(width, 0, width, r);    
  }
  
  // square if one row and west
  if (!this._isFixed && height == DvtCollapsiblePanel.BUTTONHEIGHT && west) {
    cmds += DvtPathUtils.lineTo(width, height);
  } else {
    cmds += DvtPathUtils.lineTo(width, height - r);
    cmds += DvtPathUtils.quadTo(width, height, width - r, height);
  }
  
  cmds += DvtPathUtils.lineTo(r, height);
  // square if one row and east
  if (!this._isFixed && height == DvtCollapsiblePanel.BUTTONHEIGHT && !west) {
    cmds += DvtPathUtils.lineTo(0, height);
  } else {
    
    cmds += DvtPathUtils.quadTo(0, height, 0, height - r);
  }
  
  if (this._isFixed || west) {
    cmds += DvtPathUtils.lineTo(0, r);
    cmds += DvtPathUtils.quadTo(0, 0, r, 0);
  }
  
  cmds += DvtPathUtils.closePath();
  return cmds;  
}

/**
 * @protected
 * Handles animation behavior at the end of the animation.
 */
DvtCollapsiblePanel.prototype.OnAnimationEnd = function () {
  // Reset the animation stopped flag
  this._animationStopped = false;

  // Remove the animation reference
  this._animation = null;
  
  var stroke = this._background.getStroke().clone();
  stroke.setAlpha(this._styleMap[DvtPanZoomControlPanel.FRAME_ROLLOUT_ALPHA]);
  this._background.setStroke(stroke);
  
  var alpha = this._styleMap[DvtPanZoomControlPanel.BG_ROLLOUT_ALPHA];
  var fill = this._background.getFill().clone();
  fill.setAlpha(alpha);
  this._background.setFill(fill);
  
  if (this._buttonFrame)
    this._buttonFrame.setAlpha(this._styleMap[DvtPanZoomControlPanel.FRAME_ROLLOUT_ALPHA]);
    
  if (!this.isCollapsed())
    this._scrollableContainer.setAlpha(1);

  // Restore event listeners
  this.addEvtListener(DvtMouseEvent.MOUSEOVER, this.HandleMouseOver, false, this);
  this.addEvtListener(DvtMouseEvent.MOUSEOUT, this.HandleMouseOut, false, this);
  if (this._collapseExpandButton) {
    if (this.isCollapsed())
      this._collapseExpandButton = DvtButtonLAFUtils.createExpandButton(this.getCtx(), this._buttonImages, DvtCollapsiblePanel.BUTTONHEIGHT, this._styleMap, false);
    else
      this._collapseExpandButton = DvtButtonLAFUtils.createCollapseButton(this.getCtx(), this._buttonImages, DvtCollapsiblePanel.BUTTONHEIGHT, this._styleMap, false);
    this._buttonFrame.addChild(this._collapseExpandButton);
    this._buttonFrame.removeChildAt(0);
    
    if (DvtAgent.isTouchDevice()) {
      this._collapseExpandButton.addEvtListener(DvtTouchEvent.TOUCHSTART, this.OnButtonClick, false, this);
    } else {
      this._collapseExpandButton.addEvtListener(DvtMouseEvent.CLICK, this.OnButtonClick, false, this);
      this._collapseExpandButton.addEvtListener(DvtMouseEvent.MOUSEOVER, this.OnButtonHoverOver, false, this);
      this._collapseExpandButton.addEvtListener(DvtMouseEvent.MOUSEOUT, this.OnButtonHoverOut, false, this);
    }
  }
}

/**
 * @protected
 * Hides the tooltip and toggles collapsible panel state
 * @param {DvtMouseEvent} evt The trigger event
 */
DvtCollapsiblePanel.prototype.OnButtonClick = function (evt) {
  this.getCtx().getTooltipManager().hideTooltip();
  this.setCollapsed(!this.isCollapsed());
}

/**
 * @protected
 * Displays tooltip on hover event
 * @param {DvtMouseEvent} evt The trigger event
 */
DvtCollapsiblePanel.prototype.OnButtonHoverOver = function (evt) {
  var tooltip = this.isCollapsed() ? this._expandTooltip : this._collapseTooltip;
  if (tooltip != null)
    this.getCtx().getTooltipManager().showTooltip(evt.pageX, evt.pageY, tooltip, this._collapseExpandButton, true);
}

/**
 * @protected
 */
DvtCollapsiblePanel.prototype.OnButtonHoverOut = function (evt) {
  this.getCtx().getTooltipManager().hideTooltip();
}

/**
 * @protected
 */
DvtCollapsiblePanel.prototype.HandleMouseOver = function (event) {
  var stroke = this._background.getStroke().clone();
  stroke.setAlpha(this._styleMap[DvtPanZoomControlPanel.FRAME_ROLLOVER_ALPHA]);
  this._background.setStroke(stroke);
  
  var alpha = this._styleMap[DvtPanZoomControlPanel.BG_ROLLOVER_ALPHA];
  var fill = this._background.getFill().clone();
  fill.setAlpha(alpha);
  this._background.setFill(fill);
  
  if (this._buttonFrame)
    this._buttonFrame.setAlpha(this._styleMap[DvtPanZoomControlPanel.FRAME_ROLLOVER_ALPHA]);
}

/**
 * @protected
 */
DvtCollapsiblePanel.prototype.HandleMouseOut = function (event) {
  var stroke = this._background.getStroke().clone();
  stroke.setAlpha(this._styleMap[DvtPanZoomControlPanel.FRAME_ROLLOUT_ALPHA]);
  this._background.setStroke(stroke);

  var fill = this._background.getFill().clone();
  fill.setAlpha(this._bgAlpha);
  this._background.setFill(fill);
  
  if (this._buttonFrame)
    this._buttonFrame.setAlpha(this._styleMap[DvtPanZoomControlPanel.FRAME_ROLLOUT_ALPHA]);
}
/**
 * @constructor
 */
var DvtCollapsiblePanelEvent = function (subtype) {
    this.Init(DvtCollapsiblePanelEvent.TYPE);
    this._subtype = subtype;
}

DvtObj.createSubclass(DvtCollapsiblePanelEvent, DvtBaseComponentEvent, "DvtCollapsiblePanelEvent");

DvtCollapsiblePanelEvent.TYPE = "dvtCollapsiblePanelEvent";
DvtCollapsiblePanelEvent.SUBTYPE_HIDE = "hide";
DvtCollapsiblePanelEvent.SUBTYPE_SHOW = "show";

DvtCollapsiblePanelEvent.prototype.getSubType = function() {
  return this._subtype;
}
/*
 * DvtImageLAFUtils Utility class for image
 */
var DvtImageLAFUtils = {
};

DvtObj.createSubclass(DvtImageLAFUtils, DvtObj, "DvtImageLAFUtils");

DvtImageLAFUtils.loadIcon = function (context, uri) {
  var image = new DvtImage(context, uri);
  image.setMouseEnabled(false);

  DvtImageLoader.loadImage(context, uri, function (imgDim) {
    // set image size
    if (imgDim != null && imgDim.width && imgDim.height) {
      image.setWidth(imgDim.width);
      image.setHeight(imgDim.height);
    }
  });

  return image;
}
// Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.

/**
 * DvtButtonLAFUtils Utility class for providing LAF for buttons in the control panel.
 */
var DvtButtonLAFUtils = {};

DvtObj.createSubclass(DvtButtonLAFUtils, DvtObj, "DvtButtonLAFUtils");

DvtButtonLAFUtils.EXPAND_COLLAPSE_BUTTON_IMG_OFFSET = -6;

DvtButtonLAFUtils.CONTROL_BUTTON_WIDTH = 23;
DvtButtonLAFUtils.CONTROL_BUTTON_HEIGHT = 21;
DvtButtonLAFUtils.ZOOM_BUTTON_HEIGHT = 20;
DvtButtonLAFUtils.OPEN_CLOSE_IMAGE_WIDTH = 22;
DvtButtonLAFUtils.OPEN_CLOSE_IMAGE_HEIGHT = 20;

DvtButtonLAFUtils.VIEW_PANEL_HEIGHT = 47;
DvtButtonLAFUtils.VIEW_PANEL_HALF_HEIGHT = 26;

DvtButtonLAFUtils.SIN_PI_4 = Math.sin(Math.PI / 4);
DvtButtonLAFUtils.TAN_PI_8 = Math.tan(Math.PI / 8);

DvtButtonLAFUtils.BORDER_COLOR = '#7C8191';
DvtButtonLAFUtils.GRADIENT_DARK = '#E0E1E1';
DvtButtonLAFUtils.GRADIENT_LIGHT = '#F0F1F2';
DvtButtonLAFUtils.ROUND_RECT_ELLIPSE = 8;

//Button image xml attribute names
DvtButtonLAFUtils._ZOOMIN_ENA = "zoominUp";
DvtButtonLAFUtils._ZOOMIN_OVR = "zoominOver";
DvtButtonLAFUtils._ZOOMIN_DWN = "zoominDown";
DvtButtonLAFUtils._ZOOMIN_DISABLED = "zoominDisabled";
DvtButtonLAFUtils._ZOOMTOFIT_ENA = "zoomtofitUp";
DvtButtonLAFUtils._ZOOMTOFIT_OVR = "zoomtofitOver";
DvtButtonLAFUtils._ZOOMTOFIT_DWN = "zoomtofitDown";
DvtButtonLAFUtils._ZOOMOUT_ENA = "zoomoutUp";
DvtButtonLAFUtils._ZOOMOUT_OVR = "zoomoutOver";
DvtButtonLAFUtils._ZOOMOUT_DWN = "zoomoutDown";
DvtButtonLAFUtils._ZOOMOUT_DISABLED = "zoomoutDisabled";
DvtButtonLAFUtils._PAN_ENA = "pandialUp";
DvtButtonLAFUtils._PAN_OVR = "pandialOver"; 
DvtButtonLAFUtils._PAN_DWN = "pandialDown";
DvtButtonLAFUtils._RECENTER_ENA = "recenterUp"; 
DvtButtonLAFUtils._RECENTER_OVR = "recenterOver";
DvtButtonLAFUtils._RECENTER_DWN = "recenterDown";
DvtButtonLAFUtils._RESET_ENA = "resetUp"; 
DvtButtonLAFUtils._RESET_OVR = "resetOver";
DvtButtonLAFUtils._RESET_DWN = "resetDown";
DvtButtonLAFUtils._DRILLUP_ENA = "drillupUp"; 
DvtButtonLAFUtils._DRILLUP_OVR = "drillupOver";
DvtButtonLAFUtils._DRILLUP_DWN = "drillupDown";
DvtButtonLAFUtils._DRILLDOWN_ENA = "drilldownUp"; 
DvtButtonLAFUtils._DRILLDOWN_OVR = "drilldownOver";
DvtButtonLAFUtils._DRILLDOWN_DWN = "drilldownDown";

DvtButtonLAFUtils._MAX_ENA = "maxUp";
DvtButtonLAFUtils._MAX_OVR = "maxOver";
DvtButtonLAFUtils._MAX_DWN = "maxDown";
DvtButtonLAFUtils._RESTORE_ENA = "restoreUp";
DvtButtonLAFUtils._RESTORE_OVR = "restoreOver";
DvtButtonLAFUtils._RESTORE_DWN = "restoreDown";

DvtButtonLAFUtils._COLLAPSE_ENA = "collapseEna"; 
DvtButtonLAFUtils._COLLAPSE_OVR = "collapseOvr";
DvtButtonLAFUtils._COLLAPSE_DWN = "collapseDwn";
DvtButtonLAFUtils._EXPAND_ENA = "expandEna"; 
DvtButtonLAFUtils._EXPAND_OVR = "expandOvr";
DvtButtonLAFUtils._EXPAND_DWN = "expandDwn"; 

DvtButtonLAFUtils._QUICKQUERY_ENA = "quickQueryEna"; 
DvtButtonLAFUtils._QUICKQUERY_OVR = "quickQueryOvr";
DvtButtonLAFUtils._QUICKQUERY_DWN = "quickQueryDwn";

DvtButtonLAFUtils._CLEARRESULTS_ENA = "clearResultsEna"; 
DvtButtonLAFUtils._CLEARRESULTS_OVR = "clearResultsOvr";
DvtButtonLAFUtils._CLEARRESULTS_DWN = "clearResultsDwn"; 

//TODO
DvtButtonLAFUtils._ZOOMSLIDER_ENA = "";
DvtButtonLAFUtils._ZOOMSLIDER_OVR = "";
DvtButtonLAFUtils._ZOOMSLIDER_DWN = "";

DvtButtonLAFUtils._UP   = "Up" ;
DvtButtonLAFUtils._OVER = "Over" ;
DvtButtonLAFUtils._DOWN = "Down" ;
DvtButtonLAFUtils._SEL  = "Sel" ;
DvtButtonLAFUtils._R2L  = "_r" ;
DvtButtonLAFUtils._SYNC = "synchronize" ;


/**
 * Creates pan control
 * @param {DvtContext} context Platform specific context object
 * @param {DvtPanZoomCanvas} panZoomCanvas The PanZoomCanvas this button will be associated with 
 * @param {DvtPanZoomControlPanelResources}  resources An object that contains translated resources for the component
 * @param {DvtXmlNode} imageURIs The xml containing image URIs for the component
 * @param {number} controls The bit mask specifying which controls to show
 * @param {object} styleMap The object containing style specifications for this component
 * @return {DvtBasePanZoomControl} a container used for the pan control
 */
DvtButtonLAFUtils.createPanControl = function (context, panZoomCanvas, resources, controls, imageURIs, styleMap)
{
  var panUpState = DvtButtonLAFUtils._createPanButtonState(context, imageURIs.getAttr(DvtButtonLAFUtils._PAN_ENA), styleMap);

  //need to offset the down state so that we can rotate the arrow around the center of the pan control
  var panDownState = new DvtContainer(context);
  panDownState.setTranslate(20, 20);
  var downImage = DvtButtonLAFUtils._createPanButtonState(context, imageURIs.getAttr(DvtButtonLAFUtils._PAN_DWN), styleMap);
  downImage.setTranslate(- 20, - 20);
  panDownState.addChild(downImage);

  //need to offset the over state so that we can rotate the arrow around the center of the pan control
  var panOverState = new DvtContainer(context);
  panOverState.setTranslate(20, 20);
  var overImage = DvtButtonLAFUtils._createPanButtonState(context, imageURIs.getAttr(DvtButtonLAFUtils._PAN_OVR), styleMap);
  overImage.setTranslate(- 20, - 20);
  panOverState.addChild(overImage);

  var panButton = new DvtButton(context, panUpState, panOverState, panDownState);
  
  if ((controls & DvtPanZoomControlPanel.CONTROLS_CENTER_BUTTON) > 0) {
    //center of pan control is smaller circle that can be used to center the view on the selected node
    var recenterButton = new DvtButton(context,
                                      DvtButtonLAFUtils._createRecenterButtonState(context, imageURIs.getAttr(DvtButtonLAFUtils._RECENTER_ENA), styleMap),
                                      DvtButtonLAFUtils._createRecenterButtonState(context, imageURIs.getAttr(DvtButtonLAFUtils._RECENTER_OVR), styleMap),
                                      DvtButtonLAFUtils._createRecenterButtonState(context, imageURIs.getAttr(DvtButtonLAFUtils._RECENTER_DWN), styleMap));
    recenterButton.setTranslate(9, 9);
  }

  return new DvtPanControl(context, panButton, recenterButton, panZoomCanvas, resources, controls, styleMap);
}


/**
 * Creates a container used for the drill up button.
 * @param {DvtContext} context Platform specific context object
 * @param {function} mapCallback The function that should be called to dispatch component events
 * @param {DvtPanZoomCanvas} panZoomCanvas The PanZoomCanvas this button will be associated with 
 * @param {number} btype A button type - DvtMapControlButton.BUTTON_TYPE_DRILLUP,DvtMapControlButton.BUTTON_TYPE_DRILLDOWN or DvtMapControlButton.BUTTON_TYPE_RESET
 * @param {DvtPanZoomControlPanelResources}  resources An object that contains translated resources for ThematicMap
 * @param {DvtDomXmlNode} imageURIs The xml containing image URIs for the component
 * @param {DvtEventManager} eventManager An event manager for the component
 * @param {object} styleMap The object containing style specifications for this component
 * @return {DvtBasePanZoomControl} a container used for the drill up button
 */
DvtButtonLAFUtils.createDrillUpButton = function (context, mapCallback, panZoomCanvas, btype, resources, imageURIs, eventManager, styleMap)
{
  var ena = DvtButtonLAFUtils._createButtonBaseImage(context, DvtButton.STATE_ENABLED, 
                                                    imageURIs.getAttr(DvtButtonLAFUtils._DRILLUP_ENA), styleMap);
  var ovr = DvtButtonLAFUtils._createButtonBaseImage(context, DvtButton.STATE_OVER, 
                                                    imageURIs.getAttr(DvtButtonLAFUtils._DRILLUP_OVR), styleMap);
  var dwn = DvtButtonLAFUtils._createButtonBaseImage(context, DvtButton.STATE_DOWN, 
                                                    imageURIs.getAttr(DvtButtonLAFUtils._DRILLUP_DWN), styleMap);
  var dis = DvtButtonLAFUtils._createButtonBaseImage(context, DvtButton.STATE_ENABLED, 
                                                    imageURIs.getAttr(DvtButtonLAFUtils._DRILLUP_ENA), styleMap);                              
  return new DvtMapControlButton(context, new DvtButton(context, ena, ovr, dwn, dis), mapCallback, panZoomCanvas, btype, resources, eventManager);
}

/**
 * Creates a container used for the drill down button.
 * @param {DvtContext} context Platform specific context object
 * @param {function} mapCallback The function that should be called to dispatch component events
 * @param {DvtPanZoomCanvas} panZoomCanvas The PanZoomCanvas this button will be associated with 
 * @param {number} btype A button type - DvtMapControlButton.BUTTON_TYPE_DRILLUP,DvtMapControlButton.BUTTON_TYPE_DRILLDOWN or DvtMapControlButton.BUTTON_TYPE_RESET
 * @param {DvtPanZoomControlPanelResources}  resources An object that contains translated resources for ThematicMap
 * @param {DvtDomXmlNode} imageURIs The xml containing image URIs for the component
 * @param {DvtEventManager} eventManager An event manager for the component
 * @param {object} styleMap The object containing style specifications for this component
 * @return {DvtBasePanZoomControl} a container used for the drill down button
 */
DvtButtonLAFUtils.createDrillDownButton = function (context, mapCallback, panZoomCanvas, btype, resources, imageURIs, eventManager, styleMap) {
  var ena = DvtButtonLAFUtils._createButtonBaseImage(context, DvtButton.STATE_ENABLED, 
                                                    imageURIs.getAttr(DvtButtonLAFUtils._DRILLDOWN_ENA), styleMap);
  var ovr = DvtButtonLAFUtils._createButtonBaseImage(context, DvtButton.STATE_OVER, 
                                                    imageURIs.getAttr(DvtButtonLAFUtils._DRILLDOWN_OVR), styleMap);
  var dwn = DvtButtonLAFUtils._createButtonBaseImage(context, DvtButton.STATE_DOWN, 
                                                    imageURIs.getAttr(DvtButtonLAFUtils._DRILLDOWN_DWN), styleMap);
  var dis = DvtButtonLAFUtils._createButtonBaseImage(context, DvtButton.STATE_ENABLED, 
                                                    imageURIs.getAttr(DvtButtonLAFUtils._DRILLDOWN_ENA), styleMap);                              
  return new DvtMapControlButton(context, new DvtButton(context, ena, ovr, dwn, dis), mapCallback, panZoomCanvas, btype, resources, eventManager);
}

/**
 * Creates a container used for the reset button.
 * @param {DvtContext} context Platform specific context object
 * @param {function} mapCallback The function that should be called to dispatch component events
 * @param {DvtPanZoomCanvas} panZoomCanvas The PanZoomCanvas this button will be associated with 
 * @param {number} btype A button type - DvtMapControlButton.BUTTON_TYPE_DRILLUP,DvtMapControlButton.BUTTON_TYPE_DRILLDOWN or DvtMapControlButton.BUTTON_TYPE_RESET
 * @param {DvtPanZoomControlPanelResources}  resources An object that contains translated resources for ThematicMap
 * @param {DvtDomXmlNode} imageURIs The xml containing image URIs for the component
 * @param {DvtEventManager} eventManager An event manager for the component
 * @param {object} styleMap The object containing style specifications for this component
 * @return {DvtBasePanZoomControl} a container used for the reset button
 */
DvtButtonLAFUtils.createResetButton = function (context, mapCallback, panZoomCanvas, btype, resources, imageURIs, eventManager, styleMap) {
  var ena = DvtButtonLAFUtils._createButtonBaseImage(context, DvtButton.STATE_ENABLED, 
                                                    imageURIs.getAttr(DvtButtonLAFUtils._RESET_ENA), styleMap);
  var ovr = DvtButtonLAFUtils._createButtonBaseImage(context, DvtButton.STATE_OVER, 
                                                    imageURIs.getAttr(DvtButtonLAFUtils._RESET_OVR), styleMap);
  var dwn = DvtButtonLAFUtils._createButtonBaseImage(context, DvtButton.STATE_DOWN, 
                                                    imageURIs.getAttr(DvtButtonLAFUtils._RESET_DWN), styleMap);
  var dis = DvtButtonLAFUtils._createButtonBaseImage(context, DvtButton.STATE_ENABLED, 
                                                    imageURIs.getAttr(DvtButtonLAFUtils._RESET_ENA), styleMap);
  return new DvtMapControlButton(context, new DvtButton(context, ena, ovr, dwn, dis), mapCallback, panZoomCanvas, btype, resources, eventManager);
}

/**
 * Creates a container used for the zoom-to-fit button.
 * @param {DvtContext} context Platform specific context object
 * @param {DvtPanZoomCanvas} panZoomCanvas The PanZoomCanvas this button will be associated with 
 * @param {DvtPanZoomControlPanelResources} resources An object that contains translated resources for the component
 * @param {DvtDomXmlNode} imageURIs The xml containing image URIs for the component
 * @param {object} styleMap The object containing style specifications for this component
 * @return {DvtBasePanZoomControl} a container used for the zoom-to-fit button
 */
DvtButtonLAFUtils.createZoomToFitButton = function (context, panZoomCanvas, resources, eventManager, imageURIs, styleMap) {
  var ena = DvtButtonLAFUtils._createButtonBaseImage(context, DvtButton.STATE_ENABLED, 
                              imageURIs.getAttr(DvtButtonLAFUtils._ZOOMTOFIT_ENA), styleMap);
  var ovr = DvtButtonLAFUtils._createButtonBaseImage(context, DvtButton.STATE_OVER, 
                              imageURIs.getAttr(DvtButtonLAFUtils._ZOOMTOFIT_OVR), styleMap);
  var dwn = DvtButtonLAFUtils._createButtonBaseImage(context, DvtButton.STATE_DOWN, 
                              imageURIs.getAttr(DvtButtonLAFUtils._ZOOMTOFIT_DWN), styleMap);
  return new DvtZoomToFitButton(context, new DvtButton(context, ena, ovr, dwn), panZoomCanvas, resources, eventManager);
}



/**
 * Creates a container used for the zoom-in button.
 * @param {DvtContext} context Platform specific context object
 * @param {DvtPanZoomCanvas} panZoomCanvas The PanZoomCanvas this button will be associated with 
 * @param {DvtPanZoomControlPanelResources} resources An object that contains translated resources for the component
 * @param {DvtDomXmlNode} imageURIs The xml containing image URIs for the component
 * @param {object} styleMap The object containing style specifications for this component
 * @return {DvtBasePanZoomControl} a container used for the zoom-in button
 */
DvtButtonLAFUtils.createZoomInButton = function (context, panZoomCanvas, resources, eventManager, imageURIs, styleMap)
{
  var ena = DvtButtonLAFUtils._createButtonBaseImage(context, DvtButton.STATE_ENABLED,
                              imageURIs.getAttr(DvtButtonLAFUtils._ZOOMIN_ENA), styleMap);
  var ovr = DvtButtonLAFUtils._createButtonBaseImage(context, DvtButton.STATE_OVER, 
                              imageURIs.getAttr(DvtButtonLAFUtils._ZOOMIN_OVR), styleMap);
  var dwn = DvtButtonLAFUtils._createButtonBaseImage(context, DvtButton.STATE_DOWN, 
                              imageURIs.getAttr(DvtButtonLAFUtils._ZOOMIN_DWN), styleMap);
  var dis = DvtButtonLAFUtils._createButtonBaseImage(context, DvtButton.STATE_DISABLED, 
                              imageURIs.getAttr(DvtButtonLAFUtils._ZOOMIN_DISABLED), styleMap);  
  return new DvtZoomInButton(context, new DvtButton(context, ena, ovr, dwn, dis), panZoomCanvas, resources, eventManager);
}

/**
 * Creates a container used for the zoom-out button.
 * @param {DvtContext} context Platform specific context object
 * @param {DvtPanZoomCanvas} panZoomCanvas The PanZoomCanvas this button will be associated with 
 * @param {DvtPanZoomControlPanelResources} resources An object that contains translated resources for the component
 * @param {DvtDomXmlNode} imageURIs The xml containing image URIs for the component
 * @param {object} styleMap The object containing style specifications for this component
 * @return {DvtBasePanZoomControl} a container used for the zoom-out button
 */
DvtButtonLAFUtils.createZoomOutButton = function (context, panZoomCanvas, resources, eventManager, imageURIs, styleMap)
{
  var ena = DvtButtonLAFUtils._createButtonBaseImage(context, DvtButton.STATE_ENABLED, 
                              imageURIs.getAttr(DvtButtonLAFUtils._ZOOMOUT_ENA), styleMap);
  var ovr = DvtButtonLAFUtils._createButtonBaseImage(context, DvtButton.STATE_OVER, 
                              imageURIs.getAttr(DvtButtonLAFUtils._ZOOMOUT_OVR), styleMap);
  var dwn = DvtButtonLAFUtils._createButtonBaseImage(context, DvtButton.STATE_DOWN,
                              imageURIs.getAttr(DvtButtonLAFUtils._ZOOMOUT_DWN), styleMap);
  var dis = DvtButtonLAFUtils._createButtonBaseImage(context, DvtButton.STATE_DISABLED, 
                              imageURIs.getAttr(DvtButtonLAFUtils._ZOOMOUT_DISABLED), styleMap);                              
  return new DvtZoomOutButton(context, new DvtButton(context, ena, ovr, dwn, dis), panZoomCanvas, resources, eventManager);
}


/**
 * Creates a container used for the layout switcher button.
 * @param {DvtContext} context Platform specific context object
 * @param {number} controls Button identifier 
 * @param {string} bname Name used to resolve image name
 * @param {number} state Button state - ena, ovr, dwn
 * @param {DvtDomXmlNode} images The xml string that contains image urls for the control
 * @param {object} styleMap The object containing style specifications for this component
 * @return {DvtDisplayable} a container used for the layout switcher button
 */
DvtButtonLAFUtils.createLayoutItemButtonState = function(context, controls, bname, state, images, styleMap)
{
  var r = DvtStyleUtils.getStyle(styleMap,'buttonRadius', 0);
  var w = DvtStyleUtils.getStyle(styleMap,DvtPanZoomControlPanel.CP_BUTTON_WIDTH, 0);
  var h = DvtStyleUtils.getStyle(styleMap,DvtPanZoomControlPanel.CP_BUTTON_WIDTH, 0);
  
  var shape = DvtButtonLAFUtils._createBaseButtonShape(context, state, r, w, h, styleMap);
  DvtButtonLAFUtils._setButtonColors(state, shape, w, h + (r * 2), 0, 0, styleMap, true);
  
  var attrb  = DvtButtonLAFUtils._getLayoutURI(context, state, bname) ;
  var uri = images.getAttr(attrb);
  var image = DvtButtonLAFUtils._loadIcon(context, uri, w , h);
  if (image)
    shape.addChild(image);
  return shape ;
};


// TODO JSDOC
DvtButtonLAFUtils._getLayoutURI = function(context, state, bname, bSel)
{
  var attrb = bname ;
  var r2l   = '' ;
  
  if (state ==  DvtButton.STATE_ENABLED)
    state = DvtButtonLAFUtils._UP ;
  else if (state == DvtButton.STATE_OVER)
    state = DvtButtonLAFUtils._OVER ;
  else if (state == DvtButton.STATE_DOWN)
    state = DvtButtonLAFUtils._DOWN ;

  if (bSel) {
    attrb += DvtButtonLAFUtils._SEL ;
    if (DvtAgent.isRightToLeft(context))
      r2l = DvtButtonLAFUtils._R2L ;
  }
  attrb += state + r2l;

  return attrb ;
};

/**
 * Creates a shape used for the panel card switcher button.
 * @param {DvtContext} context Platform specific context object
 * @param {number} state Button state - ena, ovr, dwn
 * @param {object} styleMap The object containing style specifications for this component
 * @param {DvtDomXmlNode} images The xml string that contains image urls for the control
 * @return {DvtDisplayable} a shape for the panel card switcher button
 */  
DvtButtonLAFUtils.createPanelCardButtonState = function(context, state, styleMap, images)
{
  var  attrb = DvtButtonLAFUtils._getLayoutURI(context, state, DvtButtonLAFUtils._SYNC,true) ;
  var  shape = DvtButtonLAFUtils._createButtonBaseImage(context, state,
                                                        images.getAttr(attrb), styleMap) ;
  return shape ;
};


/**
 * Creates a shape used for the panel card combo box button.
 * @param {DvtContext} context Platform specific context object
 * @param {number} state Button state - ena, ovr, dwn
 * @param {number} ww Button width
 * @param {number} hh Button height
 * @param {object} styleMap The object containing style specifications for this component
 * @param {DvtDomXmlNode} images The xml string that contains image urls for the control
 * @return {DvtDisplayable} a shape for the panel card combo box button
 */
DvtButtonLAFUtils.createPanelCardSyncItemState = function (context, state, ww, hh, styleMap, images)
{
  var r = DvtStyleUtils.getStyle(styleMap,'buttonRadius', 0);
  var base = DvtButtonLAFUtils._createBaseButtonShape(context, state, r, ww, hh, styleMap);
  DvtButtonLAFUtils._setButtonColors(state, base, ww, hh + (r * 2), 0, 0, styleMap, true);
  return base;
};



DvtButtonLAFUtils.createZoomSliderButton = function (context, state)
{
    return null;
};

/**
 * Creates a shape used for the control panel button.
 * @param {DvtContext} context Platform specific context object
 * @param {string} bname Name used to resolve image name
 * @param {number} state Button state - ena, ovr, dwn
 * @param {object} styleMap The object containing style specifications for this component
 * @param {DvtDomXmlNode} images The xml string that contains image urls for the control
 * @return {DvtDisplayable} a shape for the control panel button
 */
DvtButtonLAFUtils.createControlButtonState = function (context, bname, state, images, styleMap)
{
  var attrb = DvtButtonLAFUtils._getLayoutURI(context, state, bname);
  var shape = DvtButtonLAFUtils._createButtonBaseImage(context, state, images.getAttr(attrb), styleMap) ;
  return shape;
}



DvtButtonLAFUtils.createExpandButton = function (context, imageURIs, h, styleMap, bR2L) {
  var ena = DvtButtonLAFUtils._createCollapseExpandButtonState(context, DvtButton.STATE_ENABLED, h, imageURIs.getAttr(DvtButtonLAFUtils._EXPAND_ENA), styleMap, bR2L);
  var ovr = DvtButtonLAFUtils._createCollapseExpandButtonState(context, DvtButton.STATE_OVER, h, imageURIs.getAttr(DvtButtonLAFUtils._EXPAND_OVR), styleMap, bR2L);
  var dwn = DvtButtonLAFUtils._createCollapseExpandButtonState(context, DvtButton.STATE_DOWN, h, imageURIs.getAttr(DvtButtonLAFUtils._EXPAND_DWN), styleMap, bR2L);
  return new DvtButton(context, ena, ovr, dwn);
}

DvtButtonLAFUtils.createCollapseButton = function (context, imageURIs, h, styleMap, bR2L) {
  var ena = DvtButtonLAFUtils._createCollapseExpandButtonState(context, DvtButton.STATE_ENABLED, h, imageURIs.getAttr(DvtButtonLAFUtils._COLLAPSE_ENA), styleMap, bR2L);
  var ovr = DvtButtonLAFUtils._createCollapseExpandButtonState(context, DvtButton.STATE_OVER, h, imageURIs.getAttr(DvtButtonLAFUtils._COLLAPSE_OVR), styleMap, bR2L);
  var dwn = DvtButtonLAFUtils._createCollapseExpandButtonState(context, DvtButton.STATE_DOWN, h, imageURIs.getAttr(DvtButtonLAFUtils._COLLAPSE_DWN), styleMap, bR2L);
  return new DvtButton(context, ena, ovr, dwn);
}

DvtButtonLAFUtils.createQuickQueryButton = function (context, imageURIs) {
  var ena = DvtButtonLAFUtils._createQuickQueryButtonState(context, DvtButton.STATE_ENABLED, imageURIs.getAttr(DvtButtonLAFUtils._QUICKQUERY_ENA));
  var ovr = DvtButtonLAFUtils._createQuickQueryButtonState(context, DvtButton.STATE_OVER, imageURIs.getAttr(DvtButtonLAFUtils._QUICKQUERY_OVR));
  var dwn = DvtButtonLAFUtils._createQuickQueryButtonState(context, DvtButton.STATE_DOWN, imageURIs.getAttr(DvtButtonLAFUtils._QUICKQUERY_DWN));
  return new DvtButton(context, ena, ovr, dwn);
}

DvtButtonLAFUtils.createClearResultsButton = function (context, imageURIs) {
  var ena = DvtButtonLAFUtils._createQuickQueryButtonState(context, DvtButton.STATE_ENABLED, imageURIs.getAttr(DvtButtonLAFUtils._CLEARRESULTS_ENA));
  var ovr = DvtButtonLAFUtils._createQuickQueryButtonState(context, DvtButton.STATE_OVER, imageURIs.getAttr(DvtButtonLAFUtils._CLEARRESULTS_OVR));
  var dwn = DvtButtonLAFUtils._createQuickQueryButtonState(context, DvtButton.STATE_DOWN, imageURIs.getAttr(DvtButtonLAFUtils._CLEARRESULTS_DWN));
  return new DvtButton(context, ena, ovr, dwn);
}


/**
 * Creates a shape used for the panel card combo box button.
 * @param {DvtContext} context Platform specific context object
 * @param {number} state Button state - ena, ovr, dwn
 * @param {string} uri Image URL for the button state
 * @param {object} styleMap The object containing style specifications for this component
 * @param {number} w Optional button width
 * @param {number} h Optional button height
 * @return {DvtDisplayable} a shape for the panel card combo box button
 */
DvtButtonLAFUtils._createButtonBaseImage = function (context, state, uri, styleMap, w, h) {

  var r = DvtStyleUtils.getStyle(styleMap,'buttonRadius', 0);
  if (w === "undefined" || w == null)
    w = DvtStyleUtils.getStyle(styleMap,DvtPanZoomControlPanel.CP_BUTTON_WIDTH, 0);
  if (h === "undefined" || h == null)
    h = DvtStyleUtils.getStyle(styleMap,DvtPanZoomControlPanel.CP_BUTTON_WIDTH, 0);

  var base = DvtButtonLAFUtils._drawBaseButton(context, state, r, w, h, styleMap);
  var image = DvtButtonLAFUtils._loadIcon(context, uri, w , h);
  if (image)
    base.addChild(image);
    
  return base;
}

DvtButtonLAFUtils._loadIcon = function (context, uri, buttonWidth, buttonHeight) {
  var image = new DvtImage(context, uri);
  image.setMouseEnabled(false);

  DvtImageLoader.loadImage(context, uri, function (imgDim) {
    // set image size
    if (imgDim != null && imgDim.width && imgDim.height) {
      image.setWidth(imgDim.width);
      image.setHeight(imgDim.height);
      var translateY = buttonHeight/2 - imgDim.height/2;
      var translateX = buttonWidth/2 -imgDim.width/2;
      image.setTranslate(translateX, translateY);
    }
  });

  return image;
}

/**
 * Create a sprite used in the zoom slider thumb.
 *
 * @param state button state
 *
 * @return Sprite used in zoom slider thumb
 */
DvtButtonLAFUtils._createZoomSliderButtonState = function (context, state, ww, uri) {
//  var ww = 23;
  var hh = 16;
  var x = ww;
  var y = hh;

  var xx = 0;
  var yy = 0;

  var cmds = DvtPathUtils.moveTo(x, y) + DvtPathUtils.lineTo(x - ww, y);
  x = x - ww;
  y = y;

  cmds += DvtPathUtils.lineTo(x, y - hh);
  x = x;
  y = y - hh;

  cmds += DvtPathUtils.lineTo(x + ww, y);
  x = x + ww;
  y = y;

  cmds += DvtPathUtils.lineTo(x, y + hh) + DvtPathUtils.closePath();

  var mc = new DvtPath(context, cmds);

  var currLoader = DvtImageLAFUtils.loadIcon(context, uri);
  if (currLoader) {
    //left-align icon
    // Bug 9506699 - BIDI: Control panel buttons should have local specific icons
    //center icon vertically
    currLoader.setTranslate( - 6 + sw, - 2);
    //TODO?
    mc.addChild(currLoader);
  }

  // Line Style & fill
  DvtButtonLAFUtils._setSliderButtonColors(state, mc, ww, hh, xx, yy);

  return mc;
}

/**
 * Creates a shape used in the pan button.
 * @private
 * @param {DvtContext} context Platform specific context object
 * @param {DvtXmlNode} uri The map of button images
 * @param {object} styleMap The object containing style specifications for this component
 * @return {DvtShape} shape used in pan button
 */
DvtButtonLAFUtils._createPanButtonState = function (context, uri, styleMap) {
  var mc = new DvtContainer(context);
  var hitZone = new DvtCircle(context, 20, 20, 20);
  hitZone.setAlpha(0);
  var color = DvtStyleUtils.getStyle(styleMap, DvtCSSStyle.BACKGROUND_COLOR, null);
  hitZone.setSolidFill(color);
  mc.addChild(hitZone);

  var image = DvtImageLAFUtils.loadIcon(context, uri);
  if (image) {
    mc.addChild(image);
  }
  return mc;
}

/**
 * Creates a shape used in the re-center button.
 * @private
 * @param {DvtContext} context Platform specific context object
 * @param {DvtXmlNode} uri The map of button images
 * @param {object} styleMap The object containing style specifications for this component
 * @return {DvtShape} shape used in re-center button
 */ 
DvtButtonLAFUtils._createRecenterButtonState = function (context, uri, styleMap)
{
   var shape    = new DvtContainer(context);
   var hitZone  = new DvtCircle(context, 11, 11, 8);
   hitZone.setAlpha(0);

   var color = DvtStyleUtils.getStyle(styleMap, DvtCSSStyle.BACKGROUND_COLOR, null);
   hitZone.setSolidFill(color);

   shape.addChild(hitZone);

   var image = DvtImageLAFUtils.loadIcon(context, uri);
   if (image) {
     shape.addChild(image);
   }

  return shape;
}

/**
 * Create a displayable object used in the button to collapse the control panel.
 *
 * @param {DvtContext} context Platform specific context object
 * @param {number} state button state
 * @param {number} nh height of the close button
 * @param {DvtXmlNode} uri The map of button images 
 * @param {Object} styleMap
 * @param {boolean} bL2R true if the reading direction is left-to-right, so that the
 *        control panel is in the top left corner of the view
 * @return {DvtPath} displayable object used in collapse button
 */
DvtButtonLAFUtils._createCollapseExpandButtonState = function (context, state, nh, uri, styleMap, bR2L) {

  //BUG FIX #10154856: pass in height so we can show single row in
  //horizontal arm of control panel in TMap
  if (!nh)
    nh = 47;
  var sprite = DvtButtonLAFUtils._drawOpenCloseButtonHelper(context, state, nh, styleMap, bR2L);
  var iconLoader = DvtImageLAFUtils.loadIcon(context, uri);

  //center the icon in the button
  if (iconLoader) {
    var imageW = DvtStyleUtils.getStyle(styleMap,DvtPanZoomControlPanel.CP_IMAGE_WIDTH,0);
    var imageH = DvtStyleUtils.getStyle(styleMap,DvtPanZoomControlPanel.CP_IMAGE_HEIGHT,0);
    
    sprite.addChild(iconLoader);
    
    var buttonWidth = DvtStyleUtils.getStyle(styleMap,DvtPanZoomControlPanel.CP_OPEN_CLOSE_BUTTON_WIDTH,0);
    var offsetX = (buttonWidth-imageW) / 2;

    //BUG FIX #10154856: calculate y coord instead of hardcoding because we may 
    //show 1 or 2 rows of controls in horizontal arm of control panel
    //(calculation should yield same as old code for 2 rows)
    //icon height is 20   
    var offsetY = (nh-imageH) / 2;
    iconLoader.setTranslate(offsetX, offsetY);
  }
  return sprite;
}

/**
 * Create a sprite used in the button to perform a search.
 *
 * @param state button state
 *
 * @return Sprite used in search button
 */
DvtButtonLAFUtils._createQuickQueryButtonState = function (context, state, uri) {
  var iconLoader = DvtImageLAFUtils.loadIcon(context, uri);
  iconLoader.setMouseEnabled(true);
  return iconLoader;
}

/**
 * Creates the background for the pan button.
 * @param {DvtContext} context Platform specific context object
 * @param {object} styleMap The object containing style specifications for this component
 * @return {DvtShape} pan button background
 */  
DvtButtonLAFUtils.createPanButtonBackground = function (context, styleMap)
{
  var shape = DvtButtonLAFUtils._drawPanButtonBase(context)
  var r     = 20;
  var ww    = 2 * r;
  var hh    = ww;
  var xx    = 0;
  var yy    = 0;
  
  var bgColor     = DvtStyleUtils.getStyle(styleMap, DvtCSSStyle.BACKGROUND_COLOR, null);
  var borderColor = DvtStyleUtils.getStyle(styleMap, DvtCSSStyle.BORDER_COLOR, null);
  var fillType    = DvtStyleUtils.getStyle(styleMap, DvtCSSStyle.FILL_TYPE, null); 
  
  if(fillType == "solid") {
    shape.setSolidStroke(borderColor);
    shape.setSolidFill(bgColor);
  }
  else {

    var line_rot    = 36;// (1.2) * Math.PI;
    var line_colors = ["#8D93A5", "#E0EAEB", borderColor];
    var line_alphas = [1, 1, 1];
    var line_ratios = [0, 125 / 255, 1];
    shape.setStroke(new DvtLinearGradientStroke(line_rot, line_colors, line_alphas, line_ratios, [xx, yy, ww, hh], 1));
  
    var rot = 90;// (1.5) * Math.PI;
    var fill_colors = [bgColor, bgColor, "#5A83BE", bgColor];
    var fill_alphas = [.90, .10, 0, .70];
    var fill_ratios = [0, 105 / 255, 150 / 255, 1];
    shape.setFill(new DvtLinearGradientFill(rot, fill_colors, fill_alphas, fill_ratios, [xx, yy, ww, hh]));
  }
  
  return shape;
};

/**
 * Creates pan button underlay
 * @param {DvtContext} context Platform specific context object
 * @param {object} styleMap The object containing style specifications for this component
 * @return {DvtShape} pan button underlay
 */
DvtButtonLAFUtils.createPanButtonUnderlay = function (context, styleMap)
{
  var shape = DvtButtonLAFUtils._drawPanButtonBase(context);
  var color = DvtStyleUtils.getStyle(styleMap, DvtCSSStyle.BACKGROUND_COLOR, null);

  shape.setSolidStroke(color);
  shape.setSolidFill(color);
  return shape;
};


DvtButtonLAFUtils._drawPanButtonBase = function (context) {
  var r  = 20;
  var ww = 2 * r;
  var hh = ww;
  var x  = r;
  var y  = r;
  var xx = 0;
  var yy = 0;

  var cmds = DvtPathUtils.moveTo(x + r, y) + 
             DvtPathUtils.quadTo(r + x, DvtButtonLAFUtils.TAN_PI_8 * r + y, DvtButtonLAFUtils.SIN_PI_4 * r + x, 
                                 DvtButtonLAFUtils.SIN_PI_4 * r + y) + 
             DvtPathUtils.quadTo(DvtButtonLAFUtils.TAN_PI_8 * r + x, r + y, x, r + y) + 
             DvtPathUtils.quadTo(-DvtButtonLAFUtils.TAN_PI_8 * r + x, r + y,  -DvtButtonLAFUtils.SIN_PI_4 * r + x, 
                                 DvtButtonLAFUtils.SIN_PI_4 * r + y) + 
             DvtPathUtils.quadTo(-r + x, DvtButtonLAFUtils.TAN_PI_8 * r + y,  -r + x, y) + 
             DvtPathUtils.quadTo(-r + x,  -DvtButtonLAFUtils.TAN_PI_8 * r + y,  -DvtButtonLAFUtils.SIN_PI_4 * r + x,  
                                 -DvtButtonLAFUtils.SIN_PI_4 * r + y) + 
             DvtPathUtils.quadTo(-DvtButtonLAFUtils.TAN_PI_8 * r + x,  -r + y, x,  -r + y) + 
             DvtPathUtils.quadTo(DvtButtonLAFUtils.TAN_PI_8 * r + x,  -r + y, DvtButtonLAFUtils.SIN_PI_4 * r + x,  
                                 -DvtButtonLAFUtils.SIN_PI_4 * r + y) + 
             DvtPathUtils.quadTo(r + x,  -DvtButtonLAFUtils.TAN_PI_8 * r + y, r + x, y) + DvtPathUtils.closePath();

  return new DvtPath(context, cmds, "draw_pan_button");
};


DvtButtonLAFUtils._setGradientBorder = function (shape, ww, hh, xx, yy)
{
  shape.setSolidStroke("#FFFFFF");

  var line_rot    = 63;//TODO? (1.35) * Math.PI;
  var line_colors = ["#8D93A5", "#E0EAEB", "#FFFFFF"];
  var line_alphas = [1, 1, 1];
  var line_ratios = [0, 155/255, 1];

  shape.setStroke(new DvtLinearGradientStroke(line_rot, line_colors, line_alphas, line_ratios, [xx, yy, ww, hh], 1));
};


/**
 * @private
 * Helper methods that fills button shape and sets a stroke if necessary
 * @param {number} state One of the button states : STATE_ENABLED, DvtButton.STATE_OVER, DvtButton.STATE_DOWN or DvtButton.STATE_DISABLED
 * @param {DvtPath} shape A button shape
 * @param {number} ww Button width
 * @param {number} hh Button height
 * @param {number} xx Button horizontal offset
 * @param {number} yy Button vertical offset
 * @param {boolean} isDropdownItem True if this is a dropdown item (we might give a different treatment to a dropdown item vs a button on control panel)
 * @param {object} styleMap The object containing style specifications for this component
 */
DvtButtonLAFUtils._setButtonColors = function (state, shape, ww, hh, xx, yy, styleMap, isDropdownItem)
{
  var panelDrawerStyle = DvtStyleUtils.getStyle(styleMap, DvtPanZoomControlPanel.CP_PANEL_DRAWER_STYLES, null);
  if (panelDrawerStyle) {
    if (!isDropdownItem || (isDropdownItem && state == DvtButton.STATE_ENABLED))
      shape.setInvisibleFill();
    else if (state == DvtButton.STATE_OVER || state == DvtButton.STATE_DOWN) //dropdown items
      shape.setFill(new DvtSolidFill('#EBECED'));
  }
  else if (styleMap[DvtAbstractComponent.SKIN_NAME] == DvtCSSStyle.SKIN_SKYROS) {
    switch (state) {
      case DvtButton.STATE_OVER:
          shape.setFill(new DvtSolidFill("#FFFFFF", 0.7));
          shape.setStroke(new DvtSolidStroke(DvtStyleUtils.getStyle(styleMap, DvtCSSStyle.BORDER_COLOR, null)));
          break;
      case DvtButton.STATE_DOWN:
          shape.setFill(new DvtSolidFill("#B3C6DB"));
          shape.setStroke(new DvtSolidStroke(DvtStyleUtils.getStyle(styleMap, DvtCSSStyle.BORDER_COLOR, null)));
          break;
      case DvtButton.STATE_DISABLED:    
      case DvtButton.STATE_ENABLED:
      default:
        shape.setInvisibleFill();;
    }
  }
  else {
    var fill_colors, fill_alphas, fill_ratios;
    var rot = 90;
    switch (state)
    {
      case DvtButton.STATE_DISABLED:    
      case DvtButton.STATE_ENABLED:
                             var lineThickness = 0.25;
                             fill_colors = ["#5B868A", "#FFFFFF", "#FFFFFF", "#5B868A"];
                             fill_alphas = [.01, 0, .05, .01];
                             fill_ratios = [0, 120 / 255, 130 / 255, 1];
                             break;
      case DvtButton.STATE_OVER:
                             DvtButtonLAFUtils._setGradientBorder(shape, ww, hh, xx, yy);
                             fill_colors = ["#FFFFFF", "#4671B0", "#4671B0", "#FFFFFF"];
                             fill_alphas = [.50, .20, .10, .70];
                             fill_ratios = [0, 120 / 255, 130 / 255, 1];
                             break;
      case DvtButton.STATE_DOWN:
                             DvtButtonLAFUtils._setGradientBorder(shape, ww, hh, xx, yy);
                             fill_colors = ["#E0EAEB", "#5B868A", "#4671B0"];
                             fill_alphas = [.10, .30, .60];
                             fill_ratios = [0, 130 / 255, 1];
                             break;
      default:               break;
    }
    
    shape.setFill(new DvtLinearGradientFill(rot, fill_colors, fill_alphas, fill_ratios, [xx, yy, ww, hh]));
  }
};


/**
 * @private
 * Helper methods that fills shape and sets a stroke for close button
 * @param {DvtContext} context Platform specific context object
 * @param {number} state One of the button states : STATE_ENABLED, DvtButton.STATE_OVER, DvtButton.STATE_DOWN or DvtButton.STATE_DISABLED
 * @param {DvtPath} shape A button shape
 * @param {number} ww Button width
 * @param {number} hh Button height
 * @param {number} xx Button horizontal offset
 * @param {number} yy Button vertical offset
 * @param {object} styleMap The object containing style specifications for this component
 */
DvtButtonLAFUtils._setCloseButtonColors = function (context, state, shape, ww, hh, xx, yy, styleMap)
{
  var panelDrawerStyle = DvtStyleUtils.getStyle(styleMap, DvtPanZoomControlPanel.CP_PANEL_DRAWER_STYLES, null);
  if (panelDrawerStyle)
      shape.setInvisibleFill();
  else {
    var stroke, fill;
    var fillType    = DvtStyleUtils.getStyle(styleMap, DvtCSSStyle.FILL_TYPE, null); 
    var borderColor = DvtStyleUtils.getStyle(styleMap, DvtCSSStyle.BORDER_COLOR, null);  
    if(fillType == "solid") {
      var bgColor     = DvtStyleUtils.getStyle(styleMap, DvtCSSStyle.BACKGROUND_COLOR, null);
      switch (state) {
        case DvtButton.STATE_ENABLED:
                             bgAlpha = DvtStyleUtils.getStyle(styleMap, DvtPanZoomControlPanel.BG_ALPHA, 1);
                             strokeAlpha = DvtStyleUtils.getStyle(styleMap, DvtPanZoomControlPanel.FRAME_ROLLOUT_ALPHA, 1);
                             break;
        case DvtButton.STATE_DOWN:
        case DvtButton.STATE_OVER:
                             bgAlpha = DvtStyleUtils.getStyle(styleMap, DvtPanZoomControlPanel.BG_ROLLOVER_ALPHA, 1);
                             strokeAlpha = DvtStyleUtils.getStyle(styleMap, DvtPanZoomControlPanel.FRAME_ROLLOVER_ALPHA, 1);
                             break;
        default:             break;
      }
      fill = new DvtSolidFill(bgColor, bgAlpha);
      stroke = new DvtSolidStroke(borderColor, strokeAlpha);
    } else {  
      var fill_colors, fill_alphas, fill_ratios;
      var rot = 0;
      switch (state) {
        case DvtButton.STATE_ENABLED:
                             fill_colors = ["#FFFFFF", "#5B868A", "#5B868A"];
                             fill_alphas = [0, .20, .30];
                             fill_ratios = [0, 130/255, 1];
                             break;
        case DvtButton.STATE_OVER:
                             fill_colors = ["#FFFFFF", "#FFFFFF", "#4671B0", "#4671B0"];
                             fill_alphas = [.10, .20, .10, .60];
                             fill_ratios = [0, 120/255, 130/255, 1];
                             break;
        case DvtButton.STATE_DOWN:
                             fill_colors = ["#4671B0", "#5B868A", "#5B868A"];
                             fill_alphas = [.50, .20, .40];
                             fill_ratios = [0, 130/255, 1];
                             break;
        default:             break;
      }
      fill = new DvtLinearGradientFill(rot, fill_colors, fill_alphas, fill_ratios, [xx, yy, ww, hh]);
      stroke = new DvtSolidStroke(borderColor, 1, 0.8);
    }
    
    shape.setStroke(stroke);
    shape.setFill(fill);
  }
};



DvtButtonLAFUtils._setSliderButtonColors = function (state, shape, ww, hh, xx, yy)
{
  var rot = 90;
  var fill_colors, fill_alphas, fill_ratios;
  
  switch (state)
  {
    case DvtButton.STATE_ENABLED:
                      var lineThickness = 0.25;
                      shape.setSolidStroke("#FFFFFF", 1, lineThickness);
                      fill_colors = ["#FFFFFF", "#4671B0", "#E0EAEB", "#FFFFFF"];
                      fill_alphas = [.60, .30, .30, .80];
                      fill_ratios = [0, 125 / 255, 130 / 255, 1];
                      break;
    case DvtButton.STATE_OVER:
                      DvtButtonLAFUtils._setGradientBorder(shape, ww, hh, xx, yy);
                      fill_colors = ["#4671B0", "#FFFFFF", "#FFFFFF", "#FFFFFF"];
                      fill_alphas = [.40, .30, .70, 1];
                      fill_ratios = [0, 70/255, 200/255, 1];
                      break;
    case DvtButton.STATE_DOWN:
                      DvtButtonLAFUtils._setGradientBorder(shape, ww, hh, xx, yy);
                      fill_colors = ["#FFFFFF", "#4671B0", "#E0EAEB"];
                      fill_alphas = [.60, .50, .80];
                      fill_ratios = [0, 130/255, 1];
                      break;
    default:          break;
  }

  shape.setFill(new DvtLinearGradientFill(rot, fill_colors, fill_alphas, fill_ratios, [xx, yy, ww, hh]));
}


DvtButtonLAFUtils.GetButtonPathCommands = function(buttonWidth, buttonHeight, r, bidi) {
  var arPoints;
  if (!bidi) {
    arPoints = ["M", 0, 0, 
                "L", buttonWidth - r , 0, 
                "A", r, r, 0, 0, 1, buttonWidth, r,
                "L", buttonWidth, buttonHeight - r,
                "A", r, r, 0, 0, 1, buttonWidth - r, buttonHeight,
                "L", 0, buttonHeight];
  }
  else {
    arPoints = ["M", buttonWidth, 0, 
                "L", r , 0, 
                "A", r, r, 0, 0, 0, 0, r,
                "L", 0, buttonHeight - r,
                "A", r, r, 0, 0, 0, r, buttonHeight,
                "L", buttonWidth, buttonHeight];    
  }
  return arPoints;
};

//BUG FIX #10154856: pass in height to show single row of controls in 
//horizontal arm of control panel in TMap
/**
 * Creates a shape for the open close button
 * @param {DvtContext} context Platform specific context object
 * @param {number} state button state
 * @param {number} nh height of the open-close button
 * @param {Object} styleMap The object containing style specifications for this component
 * @param {boolean} bL2R true if the reading direction is left-to-right, so that the
 *        control panel is in the top left corner of the view
 * @return {DvtPath} frame for the collapsed control panel
 */
DvtButtonLAFUtils._drawOpenCloseButtonHelper = function (context, state, nh, styleMap, bR2L)
{
  if (!nh)
    nh = 47;

  var xx = 0;
  var yy = 0;
  var  r = parseInt(DvtStyleUtils.getStyle(styleMap, DvtCSSStyle.BORDER_RADIUS, 0));
  var buttonWidth = DvtStyleUtils.getStyle(styleMap,DvtPanZoomControlPanel.CP_OPEN_CLOSE_BUTTON_WIDTH,0);
  var buttonHeight = Math.max(nh, DvtStyleUtils.getStyle(styleMap,DvtPanZoomControlPanel.CP_BUTTON_HEIGHT,nh));
  
  var arPoints = DvtButtonLAFUtils.GetButtonPathCommands(buttonWidth, buttonHeight, r, bR2L);
  var shape = new DvtPath(context, arPoints);
  DvtButtonLAFUtils._setCloseButtonColors(context, state, shape, buttonWidth, buttonHeight, xx, yy, styleMap);

  return shape;
}


DvtButtonLAFUtils._drawBaseButton = function (context, state, r, ww, hh, styleMap)
{
  var shape = DvtButtonLAFUtils._createBaseButtonShape(context, state, r, ww, hh, styleMap);
  DvtButtonLAFUtils._setButtonColors(state, shape, ww, hh + (r * 2), 0, 0, styleMap);

  return shape;
};

DvtButtonLAFUtils._createBaseButtonShape = function (context, state, r, ww, hh, styleMap) {
  if (styleMap[DvtAbstractComponent.SKIN_NAME] == DvtCSSStyle.SKIN_SKYROS) {
    return new DvtRect(context, 0,0,ww,hh);
  } else {
    ww = ww - (2 * r);
    hh = hh - (2 * r);
    var x = ww + r;
    var y = hh + r;
  
    var cmds = DvtPathUtils.moveTo(x + r, y) + DvtPathUtils.quadTo(r + x, DvtButtonLAFUtils.TAN_PI_8 * r + y, DvtButtonLAFUtils.SIN_PI_4 * r + x, DvtButtonLAFUtils.SIN_PI_4 * r + y) + DvtPathUtils.quadTo(DvtButtonLAFUtils.TAN_PI_8 * r + x, r + y, x, r + y) + DvtPathUtils.lineTo(x, y + r) + DvtPathUtils.lineTo(x - ww, r + y);
    x = x - ww;
    y = y;
  
    cmds += DvtPathUtils.quadTo( - DvtButtonLAFUtils.TAN_PI_8 * r + x, r + y,  - DvtButtonLAFUtils.SIN_PI_4 * r + x, DvtButtonLAFUtils.SIN_PI_4 * r + y) + DvtPathUtils.quadTo( - r + x, DvtButtonLAFUtils.TAN_PI_8 * r + y,  - r + x, y) + DvtPathUtils.lineTo(x - r, y) + DvtPathUtils.lineTo(x - r, y - hh);
    x = x;
    y = y - hh;
  
    cmds += DvtPathUtils.quadTo( - r + x,  - DvtButtonLAFUtils.TAN_PI_8 * r + y,  - DvtButtonLAFUtils.SIN_PI_4 * r + x,  - DvtButtonLAFUtils.SIN_PI_4 * r + y) + DvtPathUtils.quadTo( - DvtButtonLAFUtils.TAN_PI_8 * r + x,  - r + y, x,  - r + y) + DvtPathUtils.lineTo(x,  - r + y) + DvtPathUtils.lineTo(x + ww,  - r + y);
    x = x + ww;
    y = y;
  
    cmds += DvtPathUtils.quadTo(DvtButtonLAFUtils.TAN_PI_8 * r + x,  - r + y, DvtButtonLAFUtils.SIN_PI_4 * r + x,  - DvtButtonLAFUtils.SIN_PI_4 * r + y) + DvtPathUtils.quadTo(r + x,  - DvtButtonLAFUtils.TAN_PI_8 * r + y, r + x, y) + DvtPathUtils.lineTo(x + r, y + hh) + DvtPathUtils.closePath();
    return new DvtPath(context, cmds);
  }
};

/**
 * Draw a cross line on the zoom slider.
 *
 * @param s sprite to draw into
 * @param xx x coord for start of line
 * @param yy y coord for line
 * @param ww width of line
 */
DvtButtonLAFUtils.drawZoomSliderCrossLine = function (context, s, xx, yy, ww) {
  // Line Style & FILL
  lineStyle(1, "#656D81", 1, true);

  var cmds = DvtPathUtils.moveTo(xx, yy) + DvtPathUtils.lineTo(xx + ww, yy);

  /// white
  lineStyle(1, "#FFFFFF", 1, true);

  cmds += DvtPathUtils.moveTo(xx, yy + 1) + DvtPathUtils.lineTo(xx + ww, yy + 1);
}

/**
 * Draw the background for the dropdown from the layout or panel card sync buttons.
 *
 * @param s sprite to draw into
 * @param ww width of dropdown
 * @param hh height of dropdown
 * @param {object} styleMap The object containing style specifications for this component
 */
DvtButtonLAFUtils.drawDropdownShape = function (context, ww, hh, styleMap) {
  var r = DvtStyleUtils.getStyle(styleMap,'radius',0);
  ww -= 2 * r;
  hh -= r;
  var x = ww + r;
  var y = (hh);

  var cmds = DvtPathUtils.moveTo(x + r, y) + DvtPathUtils.quadTo(r + x, DvtButtonLAFUtils.TAN_PI_8 * r + y, DvtButtonLAFUtils.SIN_PI_4 * r + x, DvtButtonLAFUtils.SIN_PI_4 * r + y) + DvtPathUtils.quadTo(DvtButtonLAFUtils.TAN_PI_8 * r + x, r + y, x, r + y) + DvtPathUtils.lineTo(x, r + y) + DvtPathUtils.lineTo(x - ww, r + y);

  x = x - ww;
  y = y;
  cmds += DvtPathUtils.quadTo( - DvtButtonLAFUtils.TAN_PI_8 * r + x, r + y,  - DvtButtonLAFUtils.SIN_PI_4 * r + x, DvtButtonLAFUtils.SIN_PI_4 * r + y) + DvtPathUtils.quadTo( - r + x, DvtButtonLAFUtils.TAN_PI_8 * r + y,  - r + x, y) + DvtPathUtils.lineTo( - r + x, y) + DvtPathUtils.lineTo( - r + x, y - hh);

  x = x;
  y = y - hh;

  cmds += DvtPathUtils.lineTo(x + ww + r, y) + DvtPathUtils.lineTo(x + ww + r, y + hh) + DvtPathUtils.closePath();

  var shape = new DvtPath(context, cmds);
  return shape;
}



/**
  * Apply a drop shadow filter to the given shape.
  *
  * @param {DvtDisplayable}  t shape to which drop shadow filter is to be applied.
  */
DvtButtonLAFUtils.dropShadowFilter = function (context, t)
{
  var distance = 7;
  var angleInDegrees = 45;
  var color = "#5A83BE";
  var alpha = 0.9;
  var blurX = 14;
  var blurY = 14;
  var strength = 1;
  var quality = 3;
  var inner = false;
  var knockout = false;
  var hideObject = false;

  var filter = new DvtDropShadowFilter(distance, angleInDegrees, color, alpha, blurX, blurY, strength, quality, inner, knockout, hideObject);
  var filterArray = [];
  filterArray.push(filter);
  t.filters = filterArray;
};

/*
 * Temporarily add the display object to the stage to get dimensions.
 * Remove it from stage after done
 */
DvtButtonLAFUtils._getDimForced = function (context, obj) {
  //NOTE: if obj is button, getDimensions on its 1st child
  if (obj instanceof DvtButton) {
    obj = obj.getChildAt(0);
  }
  return DvtDisplayableUtils._getDimForced(context, obj);
}
/**
 * Default values and utility functions for DvtCommonLegend versioning.
 * @class
 */
var DvtCommonLegendDefaults = new Object();

DvtObj.createSubclass(DvtCommonLegendDefaults, DvtObj, "DvtCommonLegendDefaults");

/**
 * Contains overrides for the 'alta' skin.
 */ 
DvtCommonLegendDefaults.SKIN_ALTA = {
  'rowColGap': 6,
  'separatorGap': 7,
  'indicatorSize': 16,
  'buttonSize': 12,
  'dwn': '#0572CE',
  'ovr': '#5D5D5D',
  'ena': '#7E7F80',
  'separatorColor': '#D9DFE3'
}

/**
 * Contains legend defaults.
 */ 
DvtCommonLegendDefaults.SKIN_SKYROS = {
  'dwn': '#202F48',
  'ovr': '#184DD8',
  'ena': '#003D5B'
}

/**
 * Contains legend defaults.
 */ 
DvtCommonLegendDefaults.DEFAULT = {
  'rowColGap': 4,
  'separatorGap': 4,
  'indicatorSize': 11,
  'buttonSize': 11,
  'dwn': '#000000',
  'ovr': '#245EDD',
  'ena': '#495D7C',
  'separatorColor': '#ADB6C7'
}

/**
 * Combines the user options with the defaults for the specified version.  Returns the
 * combined options object.  This object will contain internal attribute values and
 * should be accessed in internal code only.
 * @param {object} userOptions The object containing options specifications for this component.
 * @return {object} The combined options object.
 */
DvtCommonLegendDefaults.calcOptions = function(userOptions) {
  var defaults = DvtCommonLegendDefaults._getDefaults(userOptions);

  // Use defaults if no overrides specified
  if(!userOptions)
    return defaults;
  else // Merge the options object with the defaults
    return DvtJSONUtils.merge(userOptions, defaults);
}

/**
 * Returns the default options object for the specified version of the component.
 * @param {object} userOptions The object containing options specifications for this component.
 * @private
 */
DvtCommonLegendDefaults._getDefaults = function(userOptions) {  
  var defaults = null;
  if (userOptions && userOptions['skin'] === 'skyros') 
    defaults = DvtJSONUtils.merge(DvtCommonLegendDefaults.SKIN_SKYROS, DvtCommonLegendDefaults.DEFAULT);
  else if (userOptions && userOptions['skin'] === 'alta')
    defaults =  DvtJSONUtils.merge(DvtCommonLegendDefaults.SKIN_ALTA, DvtCommonLegendDefaults.DEFAULT);
  else
    defaults = DvtJSONUtils.clone(DvtCommonLegendDefaults.DEFAULT);
  return defaults;    
}
/**
 *  @constructor
 *  Creates a legend component
 *  @class DvtCommonLegend
 *  @param {DvtContext} context The context object
 *  @param {ww} The width of the viewport
 *  @param {hh} The height of the viewport
 */
var DvtCommonLegend = function (context, w, h, images, styleMap) {
  this.Init(context, w, h, images, styleMap);
};

DvtObj.createSubclass(DvtCommonLegend, DvtContainer, "DvtCommonLegend");

DvtCommonLegend.LEGEND_DISCLOSED_KEY = "isLegendDisclosed";
DvtCommonLegend.SKIN_NAME = "skin";

/**
 * Helper method called by the constructor to initialize this object
 * @param {DvtContext} context The platform specific context object
 * @param {number} w The width of the legend
 * @param {number} h The height of the legend
 * @param {object} styleMap A map containing the skin specific styling attributes for this legend
 */
DvtCommonLegend.prototype.Init = function (context, w, h, images, styleMap) {
  DvtCommonLegend.superclass.Init.call(this, context, null, w, h); // TODO for JRAMANAT: Passing w,h height is wrong.
  
  this._isBiDi = DvtAgent.isRightToLeft();
  
  this._viewportWidth = w;
  this._width = w;
  this._height = h;

  this._attrLookUp = new Object();
  this._hideAttrsLookUp = new Object();

  this._associations = new Array();
  this._addSeparators = false;
  this._separators = [];
  
  this._showHideEnabled = false;
  this._rollOverEnabled = false;
  
  this._hidden = [];

  this._images = images;
  this._styleMap = styleMap;
  this._isWordWrap = false;
}

DvtCommonLegend.prototype.GetImages = function () {
  return this._images;
}

DvtCommonLegend.prototype.showHideEnabled = function () {
  return this._showHideEnabled;
}

DvtCommonLegend.prototype.setShowHideEnabled = function (showHideEnabled) {
  this._showHideEnabled = showHideEnabled;
}

/**
 * @param hiddenAttrGroups array of hidden attribute items
 */
DvtCommonLegend.prototype.setHidden = function (hidden) {
  if (hidden) {
    this._hidden = hidden;
  }
}

DvtCommonLegend.prototype.rollOverEnabled = function () {
  return this._rollOverEnabled;
}

DvtCommonLegend.prototype.setRollOverEnabled = function (rollOverEnabled) {
  this._rollOverEnabled = rollOverEnabled;
}

/**  
 * Sets whether the text inside the legend can be wrapped
 * @param {Boolean} bWordWrap True if the text in the legend needs to wrap
 * @private
 */
DvtCommonLegend.prototype._setWordWrap = function (bWordWrap) {
  this._isWordWrap = bWordWrap;
}

/**
 * Returns whether the legend text is wrappable
 * @returns {Boolean}  Return true if the text in the legend can be wrapped
 */
DvtCommonLegend.prototype.isWordWrap = function () {
  return this._isWordWrap;
}

/**
 *  @param {String} attrGroupId     The attributeGroupId of the group of legend items to retrieve
 *  @returns {Array}                Return an array of the displayable of the legend items in the
 *                                  atrributeGroup
 *
 */
DvtCommonLegend.prototype.getAttributeGroupItems = function (attrGroupId) {
  return this._attrLookUp[attrGroupId];
}

DvtCommonLegend.prototype.addAttrLookup = function (attributeGroupId, itemId, itemContainer) {
  if (this._attrLookUp[attributeGroupId] == null)
    this._attrLookUp[attributeGroupId] = new Object();
  this._attrLookUp[attributeGroupId][itemId] = itemContainer;
}

DvtCommonLegend.prototype.addHideAttrsLookup = function (hideAttrs, itemContainer) {
  if (!this._hideAttrsLookUp[hideAttrs])
    this._hideAttrsLookUp[hideAttrs] = itemContainer;
}

DvtCommonLegend.prototype.addAssociation = function (legendRow) {
  this._associations.push(legendRow);
}

/**
 * Set the xml definition of the content of the legend.  The legend will create
 *  new content based on the definition.
 *
 *  @param {DvtDomXmlNode} xml   The xml node that contain definition of the legend's content
 *
 */
DvtCommonLegend.prototype.setXML = function (xml) {
  this._legendNode = xml;
}

DvtCommonLegend.prototype.isDisclosed = function () {
  return this._isDisclosed;
}

DvtCommonLegend.prototype.setDisclosed = function (bDisclosed) {
  this._isDisclosed = bDisclosed;
}

DvtCommonLegend.prototype._parseMarker = function (legendRow, markerNode) {
  var url = markerNode.getAttr('url');
  var shape = markerNode.getAttr('shapeType');
  var color = markerNode.getAttr('color');
  var pattern = markerNode.getAttr('pattern');
  var opacity = markerNode.getAttr('opacity');
  if (opacity)
    opacity = parseFloat(opacity);

  legendRow.setMarker(url, shape, color, pattern, opacity);
}

DvtCommonLegend.prototype._parseItem = function (itemNode) {
  var prop = new Object();
  prop ['itemId'] = itemNode.getAttr('itemId');
  prop['attributeGroupId'] = itemNode.getAttr('attributeGroupId');
  prop['hideAttrs'] = itemNode.getAttr('hideAttrs');

  var legendListItem = new DvtCommonLegendRow(this.getCtx(), this, prop, this._legendItemStyle, this._styleMap);

  var itemChildren = itemNode.getChildNodes();
  for (var i = 0;i < itemChildren.length;i++) {
    if (itemChildren[i].getName() == 'marker') {
      this._parseMarker(legendListItem, itemChildren[i]);
    }
    else if (itemChildren[i].getName() == 'text') {
      legendListItem.setText(itemChildren[i].getAttr('value'));
    }
  }
  return legendListItem;
}

/**
 * Renders a legend section
 * @param {DvtXmlNode} legendSectionNode The xml node containing legend section data
 * @param {DvtContainer} parent The parent to add this legend section to
 * @param {DvtRectangle} availSpace The available space left to render this legend section
 * @param {boolean} isBiDi Whether this legend section should be rendered right to left
 * @private
 */
DvtCommonLegend.prototype._renderLegendSection = function (legendSectionNode, parent, availSpace, isBiDi) {
  var sectionTitle = legendSectionNode.getAttr('label');
  var section = new DvtCommonLegendSection(this.getCtx(), this, sectionTitle, this._sectionTitleStyle, this._styleMap);
  section.render(parent, availSpace, isBiDi);
  
  var childNodes = legendSectionNode.getChildNodes();
  if (childNodes) {
    for (var i = 0;i < childNodes.length;i++) {
      var childNode = childNodes[i];
      var legendListItem;
      if (childNode.getName() == 'item') {
        legendListItem = this._parseItem(childNode);
      }
      else if (childNode.getName() == 'text') {
        legendListItem = new DvtCommonLegendRow(this.getCtx(), this, null, this._legendItemStyle, this._styleMap);
        legendListItem.setText(childNode.getAttr('value'));
      }
      if (legendListItem) {
        legendListItem.render(section, availSpace, isBiDi);
        section.addItem(legendListItem);
      }
    }
  }
  parent.addChild(section);
  // remove the space added by the last legend row and add a gap for the next legend section
  availSpace.y = availSpace.y - this._styleMap['rowColGap'] + this._styleMap['rowColGap'];
  return section;
}

/**
 * Renders a legend section group
 * @param {DvtXmlNode} legendSectionNode The xml node containing legend section group data
 * @param {DvtContainer} parent The parent to add this legend section group to
 * @param {DvtRectangle} availSpace The available space left to render this legend section group
 * @param {boolean} isBiDi Whether this legend section group should be rendered right to left
 * @private
 */
DvtCommonLegend.prototype._renderLegendSectionGroup = function (legendSectionNode, parent, availSpace, isBiDi) {
  var sectionTitle = legendSectionNode.getAttr('label');
  var disclosed = legendSectionNode.getAttr('disclosed') == 'true';
  var expandTooltip = legendSectionNode.getAttr('expandTooltip');
  var collapseTooltip = legendSectionNode.getAttr('collapseTooltip');
  var sectionGroup = new DvtCommonLegendSectionGroup(this.getCtx(), this, sectionTitle, this._sectionGroupTitleStyle, 
                                                    collapseTooltip, expandTooltip, disclosed, this._styleMap);
  sectionGroup.render(parent, availSpace, isBiDi);
  var bidiMultiplier = isBiDi ? -1 : 1;
  var childNodes = legendSectionNode.getChildNodes();
  if (childNodes) {
    for (var i = 0;i < childNodes.length;i++) {
      var childNode = childNodes[i];
      if (childNode.getName() == 'section') {
        // indent legend sub section
        availSpace.x = availSpace.x + (this._styleMap['buttonSize'] + this._styleMap['rowColGap'])*bidiMultiplier;
        var section = this._renderLegendSection(childNode, sectionGroup, availSpace, isBiDi);
        availSpace.x = availSpace.x - (this._styleMap['buttonSize'] + this._styleMap['rowColGap'])*bidiMultiplier;
        sectionGroup.addItem(section);
      }
    }
  }
  // remove the space added by the last legend row and add a gap for the next legend section
  availSpace.y = availSpace.y - this._styleMap['rowColGap'] + this._styleMap['rowColGap'];
  return sectionGroup;
}

/**
 * Renders a separator between legend sections
 * @param {DvtContainer} container The parent to add this separator to
 * @param {DvtRectangle} availSpace The available space left to render this separator
 * @return {DvtDisplayable} The separator
 * @private
 */
DvtCommonLegend.prototype._renderSeparator = function (container, availSpace) {
  // add separator gap
  availSpace.y = availSpace.y - this._styleMap['rowColGap'] + this._styleMap['separatorGap'];
  var line1 = new DvtLine(this.getCtx(), availSpace.x, availSpace.y, availSpace.x, availSpace.y);
  line1.setPixelHinting(true);
  line1.setSolidStroke(this._styleMap['separatorColor']);
  this._separators.push(line1);
  var separator;
  // style separator by skin
  if (this._styleMap['skin'] == DvtCSSStyle.SKIN_ALTA) {
    separator = line1;
  } else {
    availSpace.y++;
    var line2 = new DvtLine (this.getCtx(), availSpace.x, availSpace.y, availSpace.x, availSpace.y);
    line2.setSolidStroke('#FFFFFF');
    line2.setPixelHinting(true);
    separator = new DvtContainer(this.getCtx());
    separator.addChild(line1);
    separator.addChild(line2);
    this._separators.push(line2);
  }
  container.addChild(separator);
  availSpace.y = availSpace.y + this._styleMap['separatorGap'];
  return separator;
}

/**
 * Update after collapsing/expanding a section group
 */
DvtCommonLegend.prototype.update = function (updatedSection, diff) {
  var idx = this._children.indexOf(updatedSection);
  idx += 1;
  // reposition children
  while (idx < this._children.length) {
    var oldTransY = this._children[idx].getTranslateY();
    this._children[idx].setTranslateY(oldTransY+diff);
    idx++;
  }
  
  this._dim.h += diff;
  this.FireListener(new DvtResizeEvent(this._dim.w, this._dim.h, 0, 0));
}

DvtCommonLegend.prototype._processLegendStyleNode = function () {
  var legendStyleNode = this._legendNode.getElementsByTagName('style');
  if (legendStyleNode) {
    var childNodes = legendStyleNode[0].getChildNodes();
    if (childNodes) {
      for (var i = 0;i < childNodes.length;i++) {
        var childNode = childNodes[i];
        if (childNode.getName() == 'legend-title')
          this._legendTitleStyle = childNode.getTextContent();
        else if (childNode.getName() == 'sectionGroup-title')
          this._sectionGroupTitleStyle = childNode.getTextContent();
        else if (childNode.getName() == 'section-title')
          this._sectionTitleStyle = childNode.getTextContent();
        else if (childNode.getName() == 'legend-item')
          this._legendItemStyle = childNode.getTextContent();
      }
    }
  }
}

DvtCommonLegend.prototype.getEventManager = function () {
  return this._eventHandler;
}

/**
 * Creates and adds the legend title and sections to the legend.
 */
DvtCommonLegend.prototype.render = function () {  
  this._eventHandler = new DvtCommonLegendEventManager(this.getCtx(), this._legendEventHandler, this);
  this._title = this._legendNode.getAttr('label');
  this._isDisclosed = this._legendNode.getAttr('disclosed') == 'true';
  this._processLegendStyleNode();
  var noWrap = this._legendNode.getAttr('noWrap');
  if (noWrap)
    this._setWordWrap(noWrap == 'false');
  
  var availSpace;
  if (this._isBiDi) {
    availSpace = new DvtRectangle(this._width, 0, this._width, this._height);
  } else {
    availSpace = new DvtRectangle(0, 0, this._width, this._height);
  }
  
  this._legendContent = new DvtContainer(this.getCtx());
  this.addChild(this._legendContent);
    
  if (this._title) {
    var legendTitle = new DvtTextArea(this.getCtx());
    var fitWidth = availSpace.w-availSpace.x;
    if (this._isBiDi)
      fitWidth = availSpace.w - fitWidth;
    if (fitWidth > 0) {
      if (this._isBiDi)
        legendTitle.alignRight();
      if (this._legendTitleStyle)
          legendTitle.setCSSStyle(new DvtCSSStyle(this._legendTitleStyle));
      legendTitle.setText(this._title);
      legendTitle.setX(availSpace.x);
      legendTitle.setY(availSpace.y);
      
      // truncate or word wrap
      if (this.isWordWrap()) {
        this._legendContent.addChild(legendTitle);
        legendTitle.setMaxWidth(fitWidth);
      } else {
        legendTitle.setWordWrap(false);
        DvtTextUtils.fitText(legendTitle, fitWidth, availSpace.h, this._legendContent)
      }
      
      // add text tooltip as needed 
      if (legendTitle.isTruncated())
        this._eventHandler.associate(legendTitle, new DvtSimpleObjPeer(this._title));
      
      // adjust availSpace as needed
      var titleDim = legendTitle.getDimensions();
      if (titleDim && titleDim.h > 0)
        availSpace.y = availSpace.y +  titleDim.h + this._styleMap['rowColGap'];
    }
  }

  this._children = [];
  
  var childNodes = this._legendNode.getChildNodes();
  if (childNodes) {
    for (var i = 0;i < childNodes.length;i++) {
      var childNode = childNodes[i];
      // see if separators should be rendered
      if (childNode.getName() == 'separatorDef') {
        var separators = childNode.getChildNodes();
        if (separators.length > 0 && separators[0].getName() == 'separator') {
          this._addSeparators = true;
          break;
        }
      }
    }
    for (var i = 0;i < childNodes.length;i++) {
      var childNode = childNodes[i];
      availSpace.x = this._isBiDi ? this._width : 0;
      if (childNode.getName() == 'sectionGroup') {
        if (this._addSeparators && (this._title || i > 1))
          this._children.push(this._renderSeparator(this._legendContent, availSpace));
        this._children.push(this._renderLegendSectionGroup(childNode, this._legendContent, availSpace, this._isBiDi));
      }
      else if (childNode.getName() == 'section') {
        if (this._addSeparators && (this._title || i > 1))
          this._children.push(this._renderSeparator(this._legendContent, availSpace));
        this._children.push(this._renderLegendSection(childNode, this._legendContent, availSpace, this._isBiDi));
      }
    }
  }

  // cache legend dimensions so we can keep track of collapsed/expanded sections
  this._dim = this.getDimensions();
  for (var j=0; j<this._separators.length; j++) {
    if (this._isBiDi) {
      this._dim.x = this._separators[j].getX1() - this._dim.w;
      this._separators[j].setX2(this._dim.x);
    } else {
      this._separators[j].setX2(this._dim.w + this._separators[j].getX1());
    }
  }
  
  this._eventHandler.addListeners(this);

  for (var i = 0;i < this._associations.length;i++) {
    var legendRow = this._associations[i];
    this._eventHandler.associate(legendRow, legendRow);
    // process hidden items
    if (this._hidden) {
        if (DvtArrayUtils.getIndex(this._hidden, legendRow.getAttributeGroup()+':'+legendRow.getItemId()) > -1)
        legendRow.filterRow();
    }
  }
  
  if (this._isBiDi)
    this._legendContent.setTranslateX(-this._dim.x);
}

/**
 * @constructor
 */
var DvtCommonLegendSectionGroup = function (context, legend, sectionTitle, sectionTitleStyle, collapseTooltip, expandTooltip, disclosed, styleMap) {
  this.Init(context, legend, sectionTitle, sectionTitleStyle, collapseTooltip, expandTooltip, disclosed, styleMap);
};

DvtObj.createSubclass(DvtCommonLegendSectionGroup, DvtContainer, "DvtCommonLegendSection");

DvtCommonLegendSectionGroup._EXPANDED = 0;
DvtCommonLegendSectionGroup._COLLAPSED = 1;
 
DvtCommonLegendSectionGroup._DWN_COLOR = 'dwn';
DvtCommonLegendSectionGroup._OVR_COLOR = 'ovr';
DvtCommonLegendSectionGroup._ENA_COLOR = 'ena';

DvtCommonLegendSectionGroup.prototype.Init = function (context, legend, sectionTitle, sectionTitleStyle, collapseTooltip, expandTooltip, disclosed, styleMap) {
  DvtCommonLegendSection.superclass.Init.call(this, context);
  this._title = sectionTitle;
  this._titleStyle = sectionTitleStyle;
  this._items = new Array();
  this._legend = legend;
  this._collapseTooltip = collapseTooltip;
  this._expandTooltip = expandTooltip;
  this._buttonState = disclosed ? DvtCommonLegendSectionGroup._EXPANDED :  DvtCommonLegendSectionGroup._COLLAPSED;
  this._styleMap = styleMap
}

/**
 * Draws a collapse/expand arrow button for a legend section group
 * @param {DvtContainer} parent The parent container to add the button to
 * @param {DvtRectangle} availSpace The remaining available dimensions to render this button
 * @param {boolean} isBiDi Whether this should be rendered right to left
 * @private
 */
DvtCommonLegendSectionGroup.prototype._drawArrowButton = function (parent, availSpace, isBiDi) {
  this._buttonX = availSpace.x;
  this._buttonY = availSpace.y;
  var bidiMultiplier = isBiDi ? -1 : 1;
  if (this._styleMap['skin'] == DvtCSSStyle.SKIN_ALTA) {
    var images = this._legend.GetImages();
    this._expandedBtn = this._createButton(images, this._buttonX, this._buttonY, this._styleMap['buttonSize'], this._styleMap['buttonSize'], DvtCommonLegendSectionGroup._EXPANDED);
    this._collapsedBtn = this._createButton(images, this._buttonX, this._buttonY, this._styleMap['buttonSize'], this._styleMap['buttonSize'], DvtCommonLegendSectionGroup._COLLAPSED);
    this._button = this._expandedBtn;
  } else {
    this._button = new DvtPolygon(this.getCtx(), [this._buttonX + 1.5*bidiMultiplier, 
                                                      this._buttonY + 1.5, this._buttonX + 9.5*bidiMultiplier, this._buttonY + 1.5, 
                                                      this._buttonX + 5.5*bidiMultiplier, this._buttonY + 9.5]);
    this._button.setSolidFill(this._styleMap[DvtCommonLegendSectionGroup._ENA_COLOR]); 
  }
  parent.addChild(this._button);
  // Do not show tooltips for touch devices and collapse immediately on touchstart following the same behavior as panel splitter
  if (DvtAgent.isTouchDevice()) {
    parent.addEvtListener(DvtTouchEvent.TOUCHSTART, this._handleMouseClick, false, this);
  } else {
    parent.addEvtListener(DvtMouseEvent.CLICK, this._handleMouseClick, false, this);
    parent.addEvtListener(DvtMouseEvent.MOUSEOVER, this._handleMouseOver, false, this);
    parent.addEvtListener(DvtMouseEvent.MOUSEOUT, this._handleMouseOut, false, this);
    parent.addEvtListener(DvtMouseEvent.MOUSEDOWN, this._handleMouseDown, false, this);
  }
  
  this._buttonState = DvtCommonLegendSectionGroup._EXPANDED;
  var buttonSpace = (this._styleMap['skin'] == DvtCSSStyle.SKIN_ALTA && isBiDi) ? 0 : this._styleMap['buttonSize'];
  availSpace.x = availSpace.x + (buttonSpace + this._styleMap['rowColGap'])*bidiMultiplier;
}

/**
 * @param {DvtXmlNode} images The xml node containing the collapse/expand section group button image uris
 * @param {number} x The button x coordinate
 * @param {number} y The button y coordinate
 * @param {number} width The button width
 * @param {number} height The button height
 * @param {number} buttonState Whether the button should be rendered in a collapsed or expanded state
 * @return {DvtButton} The resulting button in the given state
 * @private
 */
DvtCommonLegendSectionGroup.prototype._createButton = function (images, x, y, width, height, buttonState) {
  var button;
  switch(buttonState) {
    case DvtCommonLegendSectionGroup._COLLAPSED:
      var ena = new DvtImage(this.getCtx(), images.getAttr(DvtAccordion.COLLAPSE_ENA), x, y, width, height);
      var ovr = new DvtImage(this.getCtx(), images.getAttr(DvtAccordion.COLLAPSE_OVR), x, y, width, height);
      var dwn = new DvtImage(this.getCtx(), images.getAttr(DvtAccordion.COLLAPSE_DWN), x, y, width, height);
      return button = new DvtButton(this.getCtx(), ena, ovr, dwn);
    default:
      var ena = new DvtImage(this.getCtx(), images.getAttr(DvtAccordion.EXPAND_ENA), x, y, width, height);
      var ovr = new DvtImage(this.getCtx(), images.getAttr(DvtAccordion.EXPAND_OVR), x, y, width, height);
      var dwn = new DvtImage(this.getCtx(), images.getAttr(DvtAccordion.EXPAND_DWN), x, y, width, height);
      return button = new DvtButton(this.getCtx(), ena, ovr, dwn);    
  }
}
/**
 * Toggles the arrow button to the opposite state and hides or unhides the legend section.
 * @private
 */
DvtCommonLegendSectionGroup.prototype._toggleArrowButton = function () {
  var bidiMultiplier = DvtAgent.isRightToLeft() ? -1 : 1;
  if (!this._sectionHeight)
    this._sectionHeight = this.getDimensions().h - this._headerHeight;
      
  var diff;
  
  if (this._buttonState == DvtCommonLegendSectionGroup._EXPANDED) {
    if (this._styleMap['skin'] == DvtCSSStyle.SKIN_ALTA) {
      var parent = this._button.getParent();
      parent.removeChild(this._button);
      this._button = this._collapsedBtn;
      parent.addChild(this._button);
    } else {
      this._button.setPoints([this._buttonX + 1.5*bidiMultiplier, this._buttonY + 1.5, 
                              this._buttonX + 9.5*bidiMultiplier, this._buttonY + 5.5, 
                              this._buttonX + 1.5*bidiMultiplier, this._buttonY + 9.5]);
    }
    this._itemsVisible = false;
    this._buttonState = DvtCommonLegendSectionGroup._COLLAPSED;
    diff = -this._sectionHeight;
  } else {
    if (this._styleMap['skin'] == DvtCSSStyle.SKIN_ALTA) {
      var parent = this._button.getParent();
      parent.removeChild(this._button);
      this._button = this._expandedBtn;
      parent.addChild(this._button);
    } else {
      this._button.setPoints([this._buttonX + 1.5*bidiMultiplier, this._buttonY + 1.5, 
                              this._buttonX + 9.5*bidiMultiplier, this._buttonY + 1.5, 
                              this._buttonX + 5.5*bidiMultiplier, this._buttonY + 9.5]);
    }
    this._itemsVisible = true;
    this._buttonState = DvtCommonLegendSectionGroup._EXPANDED;
    diff = this._sectionHeight;
  }
  
  if (this._itemsVisible) {
    for (var i=0; i<this._items.length; i++)
      this.addChild(this._items[i]);
  } else {
    for (var i=0; i<this._items.length; i++)
      this.removeChild(this._items[i]);
  }
  
  // update legend's other sections
  this._legend.update(this, diff);
}

DvtCommonLegendSectionGroup.prototype._handleMouseClick = function (event) {
  this.getCtx().getTooltipManager().hideTooltip();
  this._toggleArrowButton();
}

DvtCommonLegendSectionGroup.prototype._handleMouseOver = function (event) {
  var tooltip;
  if (this._buttonState == DvtCommonLegendSectionGroup._EXPANDED)
    tooltip = this._collapseTooltip;
  else
    tooltip = this._expandTooltip;
    
  if (tooltip != null)
    this.getCtx().getTooltipManager().showTooltip(event.pageX, event.pageY, tooltip, this._button, true);
  if (!this._styleMap['skin'] == DvtCSSStyle.SKIN_ALTA) 
    this._button.setSolidFill(this._styleMap[DvtCommonLegendSectionGroup._OVR_COLOR]);
}

DvtCommonLegendSectionGroup.prototype._handleMouseOut = function (event) {
  this.getCtx().getTooltipManager().hideTooltip();
  if (!this._styleMap['skin'] == DvtCSSStyle.SKIN_ALTA) 
    this._button.setSolidFill(this._styleMap[DvtCommonLegendSectionGroup._ENA_COLOR]);
}

DvtCommonLegendSectionGroup.prototype._handleMouseDown = function (event) {
  if (!this._styleMap['skin'] == DvtCSSStyle.SKIN_ALTA) 
    this._button.setSolidFill(this._styleMap[DvtCommonLegendSectionGroup._DWN_COLOR]);
}

DvtCommonLegendSectionGroup.prototype.addItem = function (item) {
  return this._items.push(item);
}

/**
 * Creates the collapsible legend section and title
 * @param {DvtContainer} parent The parent container to add this DvtCommonLegendSectionGroup to
 * @param {DvtRectangle} availSpace The remaining available dimensions to render this DvtCommonLegendSectionGroup
 * @param {boolean} isBiDi Whether this should be rendered right to left
 */
DvtCommonLegendSectionGroup.prototype.render = function (parent, availSpace, isBiDi) {
  parent.addChild(this);
  var collapsibleHitArea = new DvtContainer(this.getCtx());
  this.addChild(collapsibleHitArea);
  this._drawArrowButton(collapsibleHitArea, availSpace, isBiDi);
  if (this._title) {
    var sectionTitle = new DvtTextArea(this.getCtx());
    var fitWidth = availSpace.w-availSpace.x;
    if (isBiDi)
      fitWidth = availSpace.w - fitWidth;
    if (fitWidth > 0) {
      if (isBiDi)
        sectionTitle.alignRight();
      if (this._titleStyle)
          sectionTitle.setCSSStyle(new DvtCSSStyle(this._titleStyle));
      sectionTitle.setText(this._title);
      sectionTitle.setX(availSpace.x);
      sectionTitle.setY(availSpace.y);
      
      // truncate or word wrap
      if (this._legend.isWordWrap()) {
        collapsibleHitArea.addChild(sectionTitle);
        sectionTitle.setMaxWidth(fitWidth);
      } else {
        sectionTitle.setWordWrap(false);
        DvtTextUtils.fitText(sectionTitle, fitWidth, availSpace.h, collapsibleHitArea)
      }
      
      // add text tooltip as needed
      if (sectionTitle.isTruncated())
        this._legend.getEventManager().associate(sectionTitle, new DvtSimpleObjPeer(this._title));
      
      // adjust availSpace as needed
      var dim = sectionTitle.getDimensions();
      availSpace.y = availSpace.y + Math.max(dim ? dim.h : 0, this._styleMap['buttonSize']) + this._styleMap['rowColGap'];
    }
  }
  
  availSpace.x = availSpace.x + (this._styleMap['buttonSize'] + this._styleMap['rowColGap'])*(isBiDi ? 1 : -1);
  
  this._headerHeight = this.getDimensions().h;
}


/**
 * @constructor
 * @param {DvtContext} context The context object
 * @param {DvtCommonLegend} legend The legend this section belongs to
 * @param {String} sectionTitle The optional title for this legend section
 * @param {String} sectionTitleStyle The CSS style to apply to the section title
 * @param {Object} styleMap The map containing skin specific style attributes
 */
var DvtCommonLegendSection = function (context, legend, sectionTitle, sectionTitleStyle, styleMap) {
  this.Init(context, legend, sectionTitle, sectionTitleStyle, styleMap);
};

DvtObj.createSubclass(DvtCommonLegendSection, DvtContainer, "DvtCommonLegendSection");

/**
 * Helper method called by the constructor to initialize this object.
 * @param {DvtContext} context The context object
 * @param {DvtCommonLegend} legend The legend this section belongs to
 * @param {String} sectionTitle The optional title for this legend section
 * @param {String} sectionTitleStyle The CSS style to apply to the section title
 * @param {Object} styleMap The map containing skin specific style attributes
 */
DvtCommonLegendSection.prototype.Init = function (context, legend, sectionTitle, sectionTitleStyle, styleMap) {
  DvtCommonLegendSection.superclass.Init.call(this, context);
  this._title = sectionTitle;
  this._titleStyle = sectionTitleStyle;
  this._items = new Array();
  this._legend = legend;
  this._styleMap = styleMap;
}

DvtCommonLegendSection.prototype.addItem = function (item) {
  return this._items.push(item);
}
DvtCommonLegendSection.prototype.getItems = function () {
  return this._items;
}

/**
 * Creates the legend section and title
 * @param {DvtContainer} parent The parent container to add this DvtCommonLegendSection to
 * @param {DvtRectangle} availSpace The remaining available dimensions to render this DvtCommonLegendSection
 * @param {boolean} isBiDi Whether this should be rendered right to left
 */
DvtCommonLegendSection.prototype.render = function (parent, availSpace, isBiDi) {
  parent.addChild(this);
  if (this._title) {
    var sectionTitle = new DvtTextArea(this.getCtx());
    var fitWidth = availSpace.w-availSpace.x;
    if (isBiDi)
      fitWidth = availSpace.w - fitWidth;
    if (fitWidth > 0) {
      if (isBiDi)
        sectionTitle.alignRight();
      if (this._titleStyle)
        sectionTitle.setCSSStyle(new DvtCSSStyle(this._titleStyle));
      sectionTitle.setText(this._title);
      sectionTitle.setX(availSpace.x);
      sectionTitle.setY(availSpace.y);
      
      // truncate or wrap text
      if (this._legend.isWordWrap()) {
        this.addChild(sectionTitle);
        sectionTitle.setMaxWidth(fitWidth);
      } else {
        sectionTitle.setWordWrap(false);
        DvtTextUtils.fitText(sectionTitle, fitWidth, availSpace.h, this)
      }
      
      // add text tooltip as needed
      if (sectionTitle.isTruncated())
        this._legend.getEventManager().associate(sectionTitle, new DvtSimpleObjPeer(this._title));
      
      // adjust availSpace as needed
      var dim = sectionTitle.getDimensions();
      availSpace.y = availSpace.y + (dim ? dim.h : 0) + this._styleMap['rowColGap'];
    }
  }
}

/**
 * @constructor
 */
var DvtCommonLegendRow = function (context, legend, prop, itemStyle, styleMap) {
  this.Init(context, legend, prop, itemStyle, styleMap);
};

DvtObj.createSubclass(DvtCommonLegendRow, DvtContainer, "DvtCommonLegendRow");

DvtCommonLegendRow.prototype.Init = function (context, legend, prop, itemStyle, styleMap) {
  DvtCommonLegendRow.superclass.Init.call(this, context);
  this._legend = legend;
  this._prop = prop;
  this._itemStyle = itemStyle;
  this._bHidden = false;
  this._styleMap = styleMap
}

DvtCommonLegendRow.prototype.getAttributeGroup = function () {
  return this._prop['attributeGroupId'];
}

DvtCommonLegendRow.prototype.getItemId = function () {
  return this._prop['itemId'];
}

DvtCommonLegendRow.prototype.getHideAttributes = function () {
  return this._prop['hideAttrs'];
}

DvtCommonLegendRow.prototype.setText = function (text) {
  this._text = text;
}

DvtCommonLegendRow.prototype.setMarker = function (url, shape, color, pattern, opacity) {
  this._url = url;
  this._shape = shape;
  this._color = color ? color : '#000000';
  this._pattern = pattern;
  this._opacity = opacity;
}

DvtCommonLegendRow.prototype.filterRow = function () {
  this._bHidden = !this._bHidden;
  this._marker.setHollow(this._color);
}

DvtCommonLegendRow.prototype.isRowFiltered = function () {
  return this._bHidden;
}

/**
 * Creates the a row in a legend containing a legend marker and text, handliing truncation and tooltips as needed.
 * @param {DvtContainer} parent The parent container to add this DvtCommonLegendRow to
 * @param {DvtRectangle} availSpace The remaining available dimensions to render this DvtCommonLegendRow
 * @param {boolean} isBiDi Whether this should be rendered right to left
 */
DvtCommonLegendRow.prototype.render = function (parent, availSpace, isBiDi) {
  if (this._prop) {
    this._legend.addAttrLookup(this._prop['attributeGroupId'], this._prop['itemId'], this);
    this._legend.addAssociation(this);
    this._legend.addHideAttrsLookup(this._prop['hideAttrs'], this);
  }
  
  parent.addChild(this);
  
  var rowX = availSpace.x;
  if (isBiDi)
    availSpace.x -= this._styleMap['indicatorSize'];
  
  // render marker
  var marker;
  if (this._url || this._shape != null) {
    marker = new DvtMarker(this.getCtx(), this._url ? [this._url] : this._shape, this._styleMap[DvtCommonLegend.SKIN_NAME], 
                            availSpace.x, availSpace.y, this._styleMap['indicatorSize'], this._styleMap['indicatorSize']);
    var isCustomShape = DvtMarkerUtils.getCustomMarkerInfo(this.getCtx(), this._shape);
    if (!this._url && !isCustomShape) {
      if (!this._pattern)
        marker.setSolidFill(this._color, this._opacity);
      else 
        marker.setFill(new DvtPatternFill(this._pattern, this._color));
    }
    this.addChild(marker);
    if (isBiDi)
      availSpace.x = availSpace.x - this._styleMap['rowColGap'];
    else
      availSpace.x = availSpace.x + this._styleMap['indicatorSize'] + this._styleMap['rowColGap'];
  }
  this._marker = marker;
  
  // render text
  var textDim = new DvtRectangle();
  if (this._text) {
    var fitWidth = availSpace.w-availSpace.x;
    if (isBiDi)
      fitWidth = availSpace.w - fitWidth;
    if (fitWidth < 0) {
      this._legend.getEventManager().associate(this._marker, new DvtSimpleObjPeer(this._text));
    } else {
      var text = new DvtTextArea(this.getCtx());
      if (isBiDi)
        text.alignRight();
      if (this._itemStyle)
        text.setCSSStyle(new DvtCSSStyle(this._itemStyle)); 
      text.setText(this._text);
      text.setX(availSpace.x);
      text.setY(availSpace.y);
      
      // truncate or wrap text
      if (this._legend.isWordWrap()) {
        this.addChild(text);
        text.setMaxWidth(fitWidth);
        textDim = text.getDimensions();
      } else {
        text.setWordWrap(false);
        if (DvtTextUtils.fitText(text, fitWidth, availSpace.h, this))
          textDim = text.getDimensions();
      }
      
      // add tooltip as needed
      if (textDim.w > 0) {
        if (text.isTruncated())
          this._legend.getEventManager().associate(text, new DvtSimpleObjPeer(this._text));
      } else {
        this._legend.getEventManager().associate(this._marker, new DvtSimpleObjPeer(this._text));
      }
    }
  }
  
  availSpace.y = availSpace.y + Math.max(this._styleMap['indicatorSize'], textDim.h)  + this._styleMap['rowColGap'];
  availSpace.x = rowX;
}

/**
 * @constructor
 */
var DvtCommonLegendEventManager = function (context, callback, legend) {
  this.Init(context, callback, legend);
  this._legend = legend;
};

DvtObj.createSubclass(DvtCommonLegendEventManager, DvtEventManager, "DvtCommonLegendEventManager");

/**
 * @override
 */
DvtCommonLegendEventManager.prototype.OnClick = function (event) {
  DvtCommonLegendEventManager.superclass.OnClick.call(this, event);
  this._handleClick(event);
}

/**
 * @override
 */
DvtCommonLegendEventManager.prototype.OnMouseOver = function (event) {
  DvtCommonLegendEventManager.superclass.OnMouseOver.call(this, event);
  this._handleRollOver(event);
}

/**
 * @override
 */
DvtCommonLegendEventManager.prototype.OnMouseOut = function (event) {
  DvtCommonLegendEventManager.superclass.OnMouseOut.call(this, event);
  this._handleRollOver(event);
}

/**
 * @override
 */
DvtCommonLegendEventManager.prototype.OnComponentTouchClick = function (event) {
  DvtCommonLegendEventManager.superclass.OnComponentTouchClick.call(this, event);
  this._handleClick(event);
}

DvtCommonLegendEventManager.prototype._handleClick = function (event) {
  if (this._legend.showHideEnabled()) {
    var obj = this.GetLogicalObject(event.target);
    if (obj instanceof DvtCommonLegendRow) {
      this._clickListener(event, obj);
    }
  }
}

DvtCommonLegendEventManager.prototype._handleRollOver = function (event) {
  if (this._legend.rollOverEnabled()) {
    var obj = this.GetLogicalObject(event.target);
    if (obj instanceof DvtCommonLegendRow) {
      this._rollOverListener(event, obj);
    }
  }
}

DvtCommonLegendEventManager.prototype._clickListener = function (evt, listItem) {
  var listItemId = listItem.getItemId();
  var attributeGroupId = listItem.getAttributeGroup();

  var eventType;
  listItem.filterRow();
  var isFiltered = listItem.isRowFiltered();
  if (isFiltered)
    eventType = DvtListItemEvent.HIDE;
  else
    eventType = DvtListItemEvent.SHOW;

  var listItemEvent = new DvtListItemEvent(listItemId, attributeGroupId, eventType, evt);
  this._legend.FireListener(listItemEvent);
}

DvtCommonLegendEventManager.prototype._rollOverListener = function (evt, listItem) {
  var listItemId = listItem.getItemId();
  var attributeGroupId = listItem.getAttributeGroup();
  var hideAttr = listItem.getHideAttributes();
  var rollOverEvent = new DvtLegendItemRollOverEvent(listItemId, attributeGroupId, hideAttr, evt.type, evt);
  this._legend.FireListener(rollOverEvent);
}
/** Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved. */
var DvtTimeUtils = new Object();

DvtTimeUtils.supportsTouch = function()
{
    return DvtAgent.isTouchDevice();
}

DvtObj.createSubclass(DvtTimeUtils, DvtObj, "DvtTimeUtils");

/**
 * startTime - the start time of timeline in millis
 * endTime - the end of the timeline in millis
 * time - the time in question
 * width - the width of the element 
 * 
 * @returns the position relative to the width of the element
 */
DvtTimeUtils.getDatePosition = function(startTime, endTime, time, width)
{
    var number = (time - startTime) * width;
    var denominator = (endTime - startTime);
    if (number == 0 || denominator == 0)
        return 0;
    
    return number / denominator;
}

/**
 * @returns time in millis
 */
DvtTimeUtils.getPositionDate = function(startTime, endTime, pos, width)
{
    var number = pos * (endTime - startTime);
    if (number == 0 || width == 0)
        return startTime;

    return (number / width) + startTime;
}
/**
 * Overview component.
 * @param {DvtContext} context The rendering context.
 * @param {object} callback The function that should be called to dispatch component events.
 * @param {object} callbackObj The object context for the callback function
 * @class Overview component.
 * @constructor
 * @extends {DvtContainer}
 * @export
 */
var DvtOverview = function(context, callback, callbackObj) {
  this.Init(context, callback, callbackObj);
}

DvtObj.createSubclass(DvtOverview, DvtContainer, "DvtOverview");

DvtOverview.MIN_WINDOW_SIZE = 10;
DvtOverview.DEFAULT_VERTICAL_TIMEAXIS_SIZE = 40;
DvtOverview.DEFAULT_HORIZONTAL_TIMEAXIS_SIZE = 20; 
DvtOverview.HANDLE_PADDING_SIZE = 20;

/**
 * Initializes the view.
 * @param {DvtContext} context The rendering context.
 * @param {object} callback The function that should be called to dispatch component events.
 * @param {object} callbackObj The object context for the callback function
 * @protected
 */
DvtOverview.prototype.Init = function(context, callback, callbackObj) 
{
    DvtOverview.superclass.Init.call(this, context);
    this._callback = callback;
    this._callbackObj = callbackObj;
    
    if (this.isFlashEnvironment())
        this._lastChildIndex = 7;
    else
        this._lastChildIndex = 6;
    
    var interactive = (this._callback != null || this._callbackObj != null);
    if (interactive)
    {
        // register listeners
        if (DvtTimeUtils.supportsTouch())
        {
            this.addEvtListener(DvtTouchEvent.TOUCHSTART, this.HandleTouchStart, false, this);
            this.addEvtListener(DvtTouchEvent.TOUCHMOVE, this.HandleTouchMove, false, this);
            this.addEvtListener(DvtTouchEvent.TOUCHEND, this.HandleTouchEnd, false, this);
            this.addEvtListener(DvtMouseEvent.CLICK, this.HandleShapeClick, false, this);
        }
        else
        {
            this.addEvtListener(DvtMouseEvent.MOUSEOVER, this.HandleShapeMouseOver, false, this);
            this.addEvtListener(DvtMouseEvent.MOUSEOUT, this.HandleShapeMouseOut, false, this);
            this.addEvtListener(DvtMouseEvent.CLICK, this.HandleShapeClick, false, this);
            this.addEvtListener(DvtMouseEvent.MOUSEDOWN, this.HandleMouseDown, false, this);
            this.addEvtListener(DvtMouseEvent.MOUSEUP, this.HandleMouseUp, false, this);
            this.addEvtListener(DvtMouseEvent.MOUSEMOVE, this.HandleMouseMove, false, this);
        }
    }

    this._initPos = 0;
}

/**
 * To support Chart zoom and scroll feature
 * Ability to set the overview window start and end pos
 * @param start - the viewport start time
 * @param end - the viewport end time
 */
DvtOverview.prototype.setViewportRange = function(start, end)
{
    var viewportStart = this.getDatePosition(start);
    var viewportEnd = this.getDatePosition(end);

    // make sure it's in bound
    if (viewportStart < this.getMinimumPosition() || viewportEnd > this.getMaximumPosition())
        return;

    // make sure the viewport range is not smaller than the minimum window size
    var size = Math.max(viewportEnd - viewportStart, this.getMinimumWindowSize());

    // make sure values are valid
    if (size > 0 && viewportStart >=0 && viewportEnd <= this.Width)
    {
        var slidingWindow = this.getSlidingWindow();
        this.setSlidingWindowPos(slidingWindow, viewportStart);
        this.setSlidingWindowSize(slidingWindow, size);

        this.ScrollTimeAxis();
    }
}

/**
 * Sets the initial position of the overview window
 */
DvtOverview.prototype.setInitialPosition = function(pos)
{
    // make sure initial position is within bound
    if (pos >= this.getMinimumPosition() && pos <= this.getMaximumPosition())
        this._initPos = pos;
}

/**
 * Checks whether a particular feature is turned off
 */
DvtOverview.prototype.isFeatureOff = function(feature)
{
    if (this._featuresOff == null)
        return false;

    return (this._featuresOff.indexOf(feature) != -1);
}

/**
 * Checks whether sliding window should animate when move
 */
DvtOverview.prototype.isAnimationOnClick = function()
{
    return !(this._animationOnClick === 'off');
}


/**
 * Renders the component using the specified xml.  If no xml is supplied to a component
 * that has already been rendered, this function will rerender the component with the
 * specified size.
 * @param {obj} obj Either the component xml or json object
 * @param {number} width The width of the component.
 * @param {number} height The height of the component.
 * @export
 */
DvtOverview.prototype.render = function(obj, width, height) 
{  
    if (obj == null)
    {
        // sets the correct time where the sliding window starts
        var start = this._start;
        var end = this._end;

        var slidingWindow = this.getSlidingWindow();
        var slidingWindowPos = this.getSlidingWindowPos(slidingWindow);
        if (slidingWindow != null && slidingWindowPos != 0)
        {
            // note this.Width references the old width
            this._renderStart = DvtTimeUtils.getPositionDate(start, end, slidingWindowPos, this.Width);
        }

        // clean out existing elements since they will be regenerate
        this.removeChildren();        
    }

    // Store the size
    if (width != null && height != null)
    {
        this.Width = width;
        this.Height = height;
    }

    // If new xml is provided, parse it and apply the properties
    if(obj) 
    {
        var props = this.Parse(obj);
        this._applyParsedProperties(props);
    }

    var interactive = (this._callback != null || this._callbackObj != null);

    this.createBackground(width, height);

    if (interactive)
        this.createSlidingWindow(width, height);

    this.updateTimeAxis(width, height);

    this.parseFilledTimeRangesXML(width, height);

    // update current time
    this.updateCurrentTime(width, height);

    // render data
    this.parseDataXML(width, height);

    if (interactive)
    {
        this.createBorderAroundSlidingWindow(width, height);

        if (this.isFlashEnvironment())
        {
            // flash does not supply the resize cursor, and since none of the available cursors
            // works for resize, we'll render our own hint
            this._resizeArrow = this.createResizeArrow();
        }

        // updates the position and width of sliding window and borders around window
        this.updateSlidingWindow(width, height);
    }

    if (this._initialFocusTime != null)
        this._initPos = Math.max(0, DvtTimeUtils.getDatePosition(this._start, this._end, this._initialFocusTime, this._width));

    if (this._initPos > 0)
        this.longScrollToPos(this._initPos);
}

DvtOverview.prototype.getParser = function(obj)
{
    return new DvtOverviewParser(this);
}

DvtOverview.prototype.Parse = function(obj) 
{
    var parser = this.getParser(obj);
    return parser.parse(obj);
}

/**
 * Applies the parsed properties to this component.
 * @param {object} props An object containing the parsed properties for this component.
 * @private
 */
DvtOverview.prototype._applyParsedProperties = function(props) 
{
    this._start = props.start;
    this._end = props.end;
    this._width = props.width;
    this._renderStart = props.renderStart;
    this._currentTime = props.currentTime;
    this._initialFocusTime = props.initialFocusTime;
    this._animationOnClick = props.animationOnClick;

    // chart specific options: left and right margin
    this._leftMargin = Math.max(0, props.leftMargin);
    this._rightMargin = Math.max(0, props.rightMargin);
    if (isNaN(this._leftMargin))
        this._leftMargin = 0;
    if (isNaN(this._rightMargin))
        this._rightMargin = 0;

    this._orientation = props.orientation;
    this._overviewPosition = props.overviewPosition;
    this._isRtl = props.isRtl;
    if (props.featuresOff != null)
        this._featuresOff = props.featuresOff.split(" ");
    if (props.minimumWindowSize != null && props.minimumWindowSize > 0)
        this._minimumWindowSize = props.minimumWindowSize;

    this._borderStyles = props.borderStyles;
    this._timeAxisInfo = props.timeAxisInfo;
    if (props.timeAxisInfo != null)
        this._ticks = this._timeAxisInfo.ticks;
    this._formattedTimeRanges = props.formattedTimeRanges;
    
    this._borderTopStyle = props.borderTopStyle;
    this._borderTopColor = props.borderTopColor;
    
    this._windowBackgroundColor = props.windowBackgroundColor;
    this._windowBackgroundAlpha = props.windowBackgroundAlpha;
    this._windowBorderTopStyle = props.windowBorderTopStyle;
    this._windowBorderRightStyle = props.windowBorderRightStyle;
    this._windowBorderBottomStyle = props.windowBorderBottomStyle;
    this._windowBorderLeftStyle = props.windowBorderLeftStyle;
    this._windowBorderTopColor = props.windowBorderTopColor;
    this._windowBorderRightColor = props.windowBorderRightColor;
    this._windowBorderBottomColor = props.windowBorderBottomColor;
    this._windowBorderLeftColor = props.windowBorderLeftColor;
        
    this._handleTextureColor = props.handleTextureColor;
    this._handleFillColor = props.handleFillColor;
    this._handleBackgroundImage = props.handleBackgroundImage;
    this._handleWidth = props.handleWidth;
    this._handleHeight = props.handleHeight;
    
    this._overviewBackgroundColor = props.overviewBackgroundColor;
    this._currentTimeIndicatorColor = props.currentTimeIndicatorColor;
    this._timeIndicatorColor = props.timeIndicatorColor;    

    // chart specific options: left and right filter panels
    this._leftFilterPanelColor = props.leftFilterPanelColor;
    this._leftFilterPanelAlpha = props.leftFilterPanelAlpha;
    this._rightFilterPanelColor = props.rightFilterPanelColor;
    this._rightFilterPanelAlpha = props.rightFilterPanelAlpha;
}

/***************************** common helper methods *********************************************/
DvtOverview.prototype.getDatePosition = function(date)
{
    return Math.max(0, DvtTimeUtils.getDatePosition(this._start, this._end, date, this.getOverviewSize())) + this._leftMargin;
}

DvtOverview.prototype.getPositionDate = function(pos)
{
    return DvtTimeUtils.getPositionDate(this._start, this._end, Math.max(0, pos - this._leftMargin), this.getOverviewSize());
}

DvtOverview.prototype.isRTL = function()
{
    return !this.isVertical() && (this._isRtl == 'true');    
}

DvtOverview.prototype.isVertical = function()
{
    return (this._orientation == 'vertical');
}

DvtOverview.prototype.isOverviewAbove = function()
{
    return (this._overviewPosition == 'above');
}

// Sets the left and right margins, used by chart
DvtOverview.prototype.setMargins = function(leftMargin, rightMargin)
{
    if (!isNaN(leftMargin) && leftMargin != null && leftMargin > 0)
        this._leftMargin = leftMargin;

    if (!isNaN(rightMargin) && rightMargin != null && rightMargin > 0)
        this._rightMargin = rightMargin;
}

// returns the width of the overview, taking margins into account
DvtOverview.prototype.getOverviewSize = function()
{
    if (this.isVertical())
        return this.Height - this._leftMargin - this._rightMargin;            
    else
        return this.Width - this._leftMargin - this._rightMargin;            
}

// return the minmum position where the sliding window can reach
DvtOverview.prototype.getMinimumPosition = function()
{
    return this._leftMargin;
}

// return the maximum position where the sliding window can reach
DvtOverview.prototype.getMaximumPosition = function()
{
    if (this.isVertical())
        return this.Height - this._rightMargin;            
    else
        return this.Width - this._rightMargin;            
}

// returns the minimum size of the sliding window
DvtOverview.prototype.getMinimumWindowSize = function()
{
    if (this._minWinSize != null)
        return this._minWinSize;
    else if (this._minimumWindowSize != null)
    {
        this._minWinSize = DvtTimeUtils.getDatePosition(this._start, this._end, this._start+this._minimumWindowSize, this.getOverviewSize());
        return this._minWinSize;
    }
    else
        return DvtOverview.MIN_WINDOW_SIZE;
}

DvtOverview.prototype.getGrippySize = function()
{
    return 10;
}

// return the start of the resize handle
DvtOverview.prototype.getHandleStart = function()
{
    if (DvtTimeUtils.supportsTouch())
        return this.getHandleSize()/2;
    else
        return 0;
}

// return the size of the resize handle, which is wider on touch devices
DvtOverview.prototype.getHandleSize = function() 
{
    if (DvtTimeUtils.supportsTouch())
        return 30;
    else
        return 10;
}

DvtOverview.prototype.isHandle = function(drawable) 
{
    var id = drawable.getId();
    return (id == 'lh' || id == 'rh' || id == 'lhb' || id == 'rhb' || id == 'grpy' || id == 'lbgrh' || id == 'rbgrh' || (drawable.getParent() != null && drawable.getParent().getId() == 'grpy'));    
}

// for vertical
DvtOverview.prototype.getTimeAxisWidth = function()
{
    // checks if there is a time axis
    if (this._timeAxisInfo == null)
        return 0;

    // read from skin?
    if (this._timeAxisWidth == null)
    {
        var width = parseInt(this._timeAxisInfo.width, 10);
        if (!isNaN(width) && width < this.Width)
            this._timeAxisWidth = width;
        else
            this._timeAxisWidth = DvtOverview.DEFAULT_VERTICAL_TIMEAXIS_SIZE;
    }
    
    return this._timeAxisWidth;    
}

DvtOverview.prototype.getTimeAxisHeight = function()
{
    // checks if there is a time axis
    if (this._timeAxisInfo == null)
        return 0;

    // read from skin?
    if (this._timeAxisHeight == null)
    {
        var height = parseInt(this._timeAxisInfo.height, 10);
        if (!isNaN(height) && height < this.Height)
            this._timeAxisHeight = height;
        else
            this._timeAxisHeight = DvtOverview.DEFAULT_HORIZONTAL_TIMEAXIS_SIZE;
    }
    
    return this._timeAxisHeight;    
}

DvtOverview.prototype.getPageX = function(event)
{
    if (DvtTimeUtils.supportsTouch() && event.targetTouches != null)
    {        
        if (event.targetTouches.length > 0)
            return event.targetTouches[0].pageX;
        else
            return null;
    }
    else
        return event.pageX;
}

DvtOverview.prototype.getPageY = function(event)
{
    if (DvtTimeUtils.supportsTouch() && event.targetTouches != null)
    {        
        if (event.targetTouches.length > 0)
            return event.targetTouches[0].pageY;
        else
            return null;
    }
    else
        return event.pageY;
}

/**
 * Returns true if a panel should be rendered on the left and right side of the overview window.
 * By default they are not rendered.
 * @protected
 */
DvtOverview.prototype.isLeftAndRightFilterRendered = function()
{
    return false;
}

DvtOverview.prototype.getSlidingWindow = function()
{
    return this.getChildAt(1);    
}

DvtOverview.prototype.getLeftBackground = function()
{
    if (this.isLeftAndRightFilterRendered())
        return this.getChildAt(3);
    else
        return null;
}

DvtOverview.prototype.getRightBackground = function()
{
    if (this.isLeftAndRightFilterRendered())
        return this.getChildAt(4);
    else
        return null;
}

DvtOverview.prototype.getLeftBackgroundHandle = function()
{
    if (this.isLeftAndRightFilterRendered() && !this.isFeatureOff('zoom'))
        return this.getChildAt(5);
    else
        return null;
}

DvtOverview.prototype.getRightBackgroundHandle = function()
{
    if (this.isLeftAndRightFilterRendered() && !this.isFeatureOff('zoom'))
        return this.getChildAt(6);
    else
        return null;
}

DvtOverview.prototype.getLeftHandle = function()
{
    var offset = this._lastChildIndex;
    return this.getChildAt(this.getNumChildren()-offset);
}

DvtOverview.prototype.getRightHandle = function()
{
    var offset = this._lastChildIndex - 1;
    return this.getChildAt(this.getNumChildren()-offset);
}

DvtOverview.prototype.getLeftTopBar = function()
{
    var offset = this._lastChildIndex - 2;
    return this.getChildAt(this.getNumChildren()-offset);
}

DvtOverview.prototype.getRightTopBar = function()
{
    var offset = this._lastChildIndex - 3;
    return this.getChildAt(this.getNumChildren()-offset);
}

DvtOverview.prototype.getBottomBar = function()
{
    var offset = this._lastChildIndex - 4;
    return this.getChildAt(this.getNumChildren()-offset);
}

DvtOverview.prototype.getTopBar = function()
{
    var offset = this._lastChildIndex - 5;
    return this.getChildAt(this.getNumChildren()-offset);
}

DvtOverview.prototype.setLinePos = function(line, pos1, pos2)
{
    if (this.isVertical())
    {
        if (pos1 != -1)
            line.setY1(pos1);
        if (pos2 != -1)
            line.setY2(pos2);
    }        
    else
    {
        if (pos1 != -1)
            line.setX1(pos1);
        if (pos2 != -1)
            line.setX2(pos2);        
    }
}

DvtOverview.prototype.getLinePos1 = function(line)
{
    if (this.isVertical())
        return line.getY1();
    else
        return line.getX1();
}

/**
 * Returns the drawable that is the target of the event.
 * @return {DvtBaseTreeNode} the target of the event
 */
DvtOverview.prototype._findDrawable = function(event) 
{
    var target = event.target;
    if (target != null)
    {
        var id = target.getId();
        if (id == null)
            return null;
        
        if (id.substr(id.length-7) == '_border')
        {
            // if it's the border shape, returns the actual drawable
            return this.getChildAfter(target);
        }
        else if (id.substr(0, 4) != 'tick' && id != 'ltb' && id != 'rtb' && id != 'bb' && id != 'tab')
            return target;        
    }
    
    return null;
}

DvtOverview.prototype.isMovable = function(drawable)
{
    if (drawable.getId() == 'window' || 
        drawable.getId() == 'ftr' || 
        drawable.getId() == 'sta' ||
        this.isHandle(drawable))
       return true;
    
    return false;
}

DvtOverview.prototype.isFlashEnvironment = function()
{
    return (window && window.isFlashEnvironment);
}

/***************************** end common helper methods *********************************************/

/***************************** marker creation and event handling *********************************************/
DvtOverview.prototype.createBackground = function (width, height)
{
    // draw a background shape covering all area to capture all mouse events
    var background = new DvtRect(this.getCtx(), 0, 0, width, height, "bg");
    background.setSolidFill(this._overviewBackgroundColor);
    
    // Do not antialias the background
    background.setPixelHinting(true);
    
    this.addChild(background);
    return background;
}

DvtOverview.prototype.createSlidingWindow = function (width, height)
{
    var vertical = this.isVertical();
    
    // draw sliding window first so that it is under the markers
    if (vertical)
        var slidingWindow = new DvtRect(this.getCtx(), 0, 0, width, 0, "window");
    else
        slidingWindow = new DvtRect(this.getCtx(), 0, 0, 0, height, "window");
    slidingWindow.setSolidFill(this._windowBackgroundColor, this._windowBackgroundAlpha);
    
    // Do not antialias the Timeline Overview
    slidingWindow.setPixelHinting(true);
    
    if (!this.isFeatureOff('zoom'))
    {
        var handleSize = this.getHandleSize();
        var handleStart = this.getHandleStart();
        if (vertical)
        {
            var handleX = (width - 36) / 2;        
            var leftHandleCmds = DvtPathUtils.moveTo(handleX, 0) + 
                  DvtPathUtils.quadTo(handleX+3, 6, handleX+8, 8) + 
                  DvtPathUtils.lineTo(handleX+28, 8) + 
                  DvtPathUtils.quadTo(handleX+33, 6, handleX+36, 0)
                  DvtPathUtils.closePath();
            var rightHandleCmds = DvtPathUtils.moveTo(handleX, 0) + 
                  DvtPathUtils.quadTo(handleX+3, -6, handleX+8, -8) + 
                  DvtPathUtils.lineTo(handleX+28, -8) + 
                  DvtPathUtils.quadTo(handleX+33, -6, handleX+36, 0)
                  DvtPathUtils.closePath();
            var leftHandleBackground = new DvtRect(this.getCtx(), 0, 0, width, handleSize, "lhb");
            var rightHandleBackground = new DvtRect(this.getCtx(), 0, 0, width, handleSize, "rhb");
            var cursor = 'row-resize';        
            
            if (this._handleBackgroundImage)
            {
                var leftGrippy = this.createGrippyImage(width, handleSize);
                var rightGrippy = this.createGrippyImage(width, handleSize);
            }
            else
            {
                leftGrippy = this.createGrippy(handleX);
                rightGrippy = this.createGrippy(handleX);
            }
        }
        else
        {
            var handleY = (height - 36) / 2;
            leftHandleCmds = DvtPathUtils.moveTo(0, handleY) + 
                  DvtPathUtils.quadTo(6, handleY+3, 8, handleY+8) + 
                  DvtPathUtils.lineTo(8, handleY+28) + 
                  DvtPathUtils.quadTo(6, handleY+33, 0, handleY+36)
                  DvtPathUtils.closePath();    
            rightHandleCmds = DvtPathUtils.moveTo(0, handleY) + 
                  DvtPathUtils.quadTo(-6, handleY+3, -8, handleY+8) + 
                  DvtPathUtils.lineTo(-8, handleY+28) + 
                  DvtPathUtils.quadTo(-6, handleY+33, 0, handleY+36)
                  DvtPathUtils.closePath();
            leftHandleBackground = new DvtRect(this.getCtx(), 0-handleStart, 0, handleSize, height, "lhb");
            rightHandleBackground = new DvtRect(this.getCtx(), handleStart, 0, handleSize, height, "rhb");
            cursor = 'col-resize';        
            
            if (this._handleBackgroundImage)
            {
                leftGrippy = this.createGrippyImage(handleSize, height);
                rightGrippy = this.createGrippyImage(handleSize, height);
            }
            else
            {
                leftGrippy = this.createGrippy(handleY);
                rightGrippy = this.createGrippy(handleY);
            }
        }

        leftHandleBackground.setSolidFill(this._windowBackgroundColor, 0);
        rightHandleBackground.setSolidFill(this._windowBackgroundColor, 0);
    
        // Do not antialias the handle backgrounds
        leftHandleBackground.setPixelHinting(true);
        rightHandleBackground.setPixelHinting(true);
    
        var leftHandle = new DvtPath(this.getCtx(), leftHandleCmds, "lh");
        var rightHandle = new DvtPath(this.getCtx(), rightHandleCmds, "rh");
        leftHandle.setSolidFill(this._handleFillColor);
        leftHandle.setSolidStroke(this._handleFillColor);
        rightHandle.setSolidFill(this._handleFillColor);
        rightHandle.setSolidStroke(this._handleFillColor);
        
        // if the handle color is the same as the background color, it should not have antialiasing so it does not appear visible
        if (this._windowBackgroundColor == this._handleFillColor)
        {
            leftHandle.setPixelHinting(true);
            rightHandle.setPixelHinting(true);
        }

        // sets the resize cursor, for Flash this will hide the cursor and we will render our own cursor instead
        leftHandleBackground.setCursor(cursor);
        rightHandleBackground.setCursor(cursor);
        leftHandle.setCursor(cursor);
        rightHandle.setCursor(cursor);
        leftGrippy.setCursor(cursor);
        rightGrippy.setCursor(cursor);
    
        slidingWindow.addChild(leftHandleBackground);
        slidingWindow.addChild(leftHandle);
        slidingWindow.addChild(leftGrippy);
        slidingWindow.addChild(rightHandleBackground);
        slidingWindow.addChild(rightHandle);
        slidingWindow.addChild(rightGrippy);
    }
    
    // sets cursor AFTER adding child since toolkit adds a group and the cursor would be set on group instead
    slidingWindow.setCursor('move');
    this.addChild(slidingWindow);

    // border above time axis
    if (vertical)
        var timeAxisTopBar = new DvtLine(this.getCtx(), width-this.getTimeAxisWidth(), 0, width-this.getTimeAxisWidth(), height, "tab");
    else
    {
        if (this.isOverviewAbove())
            timeAxisTopBar = new DvtLine(this.getCtx(), 0, this.getTimeAxisHeight(), width, this.getTimeAxisHeight(), "tab");    
        else
            timeAxisTopBar = new DvtLine(this.getCtx(), 0, height-this.getTimeAxisHeight(), width, height-this.getTimeAxisHeight(), "tab");    
    }
    timeAxisTopBar.setSolidStroke("#e5e5e5");
    
    // Do not antialias the time axis top bar
    timeAxisTopBar.setPixelHinting(true);
    
    this.addChild(timeAxisTopBar);

    if (this.isLeftAndRightFilterRendered())
    {
        if (vertical)
        {
            var leftBackground = new DvtRect(this.getCtx(), 0, 0, width, 0, "lbg");
            var rightBackground = new DvtRect(this.getCtx(), 0, 0, width, 0, "rbg");
        }
        else
        {
            leftBackground = new DvtRect(this.getCtx(), 0, 0, 0, height, "lbg");
            rightBackground = new DvtRect(this.getCtx(), 0, 0, 0, height, "rbg");
        }

        leftBackground.setSolidFill(this._leftFilterPanelColor, this._leftFilterPanelAlpha);
        this.addChild(leftBackground);
        rightBackground.setSolidFill(this._rightFilterPanelColor, this._rightFilterPanelAlpha);
        this.addChild(rightBackground);

        // the left and right background resize handle are needed for touch because the touch area for resize handle goes
        // beyond the handle and into the left and right background area, so we'll need something on top of the background
        if (DvtTimeUtils.supportsTouch() && handleStart != undefined)
        {
            var handleSize = this.getHandleStart();
            if (vertical)
            {
                var leftBackgroundResizeHandle = new DvtRect(this.getCtx(), 0, 0, width, handleStart, "lbgrh");
                var rightBackgroundResizeHandle = new DvtRect(this.getCtx(), 0, 0, width, handleStart, "rbgrh");
            }
            else
            {
                leftBackgroundResizeHandle = new DvtRect(this.getCtx(), 0, 0, handleStart, height, "lbgrh");
                rightBackgroundResizeHandle = new DvtRect(this.getCtx(), 0, 0, handleStart, height, "rbgrh");
            }

            leftBackgroundResizeHandle.setSolidFill(this._leftFilterPanelColor, 0);
            this.addChild(leftBackgroundResizeHandle);
            rightBackgroundResizeHandle.setSolidFill(this._rightFilterPanelColor, 0);
            this.addChild(rightBackgroundResizeHandle);
        }
    }
}

// renders the grippy from an image
DvtOverview.prototype.createGrippyImage = function (width, height)
{
    var posX = (width - this._handleWidth) / 2;
    var posY = (height - this._handleHeight) / 2;
    return new DvtImage(this.getCtx(), this._handleBackgroundImage, posX, posY, this._handleWidth, this._handleHeight, "grpy");
}

// renders the dots in the grippy
DvtOverview.prototype.createGrippy = function (handlePos)
{
    var grippy = new DvtContainer(this.getCtx(), "grpy");
    var gap = 2 // gap between dots
    var count = 9;  // how many dots to draw
    var color = this._handleTextureColor; // color of the dots
    
    if (this.isVertical()) 
    {
        var startx = 8 + handlePos;  // start x location of dots relative to container
        var starty = 3;  // start y location of dots relative to container
        for (var i=0; i<count; i++) 
        {
            var dot = new DvtLine(this.getCtx(), startx+i*gap, starty, startx+i*gap+1, starty, 'dot1'+i);
            dot.setSolidStroke(color);
            grippy.addChild(dot);
    
            starty = starty+gap;
            dot = new DvtLine(this.getCtx(), (startx+1)+i*gap, starty, (startx+1)+i*gap+1, starty, 'dot2'+i);
            dot.setSolidStroke(color);
            grippy.addChild(dot);
    
            starty = starty+gap;
            dot = new DvtLine(this.getCtx(), startx+i*gap, starty, startx+i*gap+1, starty, 'dot3'+i);
            dot.setSolidStroke(color);
            grippy.addChild(dot);
    
            starty = 3;
        }        

        dot = new DvtLine(this.getCtx(), startx+count*gap, starty, startx+count*gap+1, starty, 'dot4');
        dot.setSolidStroke(color);
        grippy.addChild(dot);
        starty = starty+gap*2;
        dot = new DvtLine(this.getCtx(), startx+count*gap, starty, startx+count*gap+1, starty, 'dot5');
        dot.setSolidStroke(color);
        grippy.addChild(dot);
    }
    else
    {
        startx = 3;  // start x location of dots relative to container
        starty = 8 + handlePos;  // start y location of dots relative to container
        for (i=0; i<count; i++) 
        {
            dot = new DvtLine(this.getCtx(), startx, starty+i*gap, startx, starty+i*gap+1, 'dot1'+i);
            dot.setSolidStroke(color);
            grippy.addChild(dot);
    
            startx = startx+gap;
            dot = new DvtLine(this.getCtx(), startx, (starty+1)+i*gap, startx, (starty+1)+i*gap+1, 'dot2'+i);
            dot.setSolidStroke(color);
            grippy.addChild(dot);
    
            startx = startx+gap;
            dot = new DvtLine(this.getCtx(), startx, starty+i*gap, startx, starty+i*gap+1, 'dot3'+i);
            dot.setSolidStroke(color);
            grippy.addChild(dot);
    
            startx = 3;
        }
    
        dot = new DvtLine(this.getCtx(), startx, starty+count*gap, startx, starty+count*gap+1, 'dot4');
        dot.setSolidStroke(color);
        grippy.addChild(dot);
        startx = startx+gap*2;
        dot = new DvtLine(this.getCtx(), startx, starty+count*gap, startx, starty+count*gap+1, 'dot5');
        dot.setSolidStroke(color);
        grippy.addChild(dot);
    }
    
    // Do not antialias the grippy
    grippy.setPixelHinting(true);
    
    return grippy;
}

DvtOverview.prototype.updateSlidingWindow = function (width, height)
{
    var vertical = this.isVertical();

    var window = this.getSlidingWindow();   
    var size = this.getOverviewSize();
    var actualSize = vertical ? this.Height:this.Width;

    var timelineWidth = this._width;
    var start = this._start;
    var end = this._end;
    var renderStart = this._renderStart;

    // first get the date using the width of timeline overview as position relative to the overall timeline
    var rangeStartTime = DvtTimeUtils.getPositionDate(start, end, 0, timelineWidth);
    var rangeEndTime = DvtTimeUtils.getPositionDate(start, end, actualSize, timelineWidth);

    // now find the position relative to the width of timeline overview
    var rangeStartPos = this.getDatePosition(rangeStartTime);
    var rangeEndPos = Math.min(actualSize, this.getDatePosition(rangeEndTime));
    var renderStartPos = this.getDatePosition(renderStart);

    var newLeft = renderStartPos;
    var newWidth = rangeEndPos - rangeStartPos;

    if (this.isRTL())
        this.setSlidingWindowPos(window, size - renderStartPos - newWidth);
    else
        this.setSlidingWindowPos(window, newLeft);
    this.setSlidingWindowSize(window, newWidth);
    
    this.ScrollTimeAxis();

    // update increment as well
    this._increment = this.calculateIncrement(size);
}

DvtOverview.prototype.createBorderAroundSlidingWindow = function(width, height)
{
    // add the left and right grip last since we want them over the markers
    var slidingWindow = this.getSlidingWindow();
    if (this.isVertical())
    {
        var top = slidingWindow.getY();
        var bottom = slidingWindow.getY()+slidingWindow.getHeight()-1;
        
        if (this.isFlashEnvironment() || DvtAgent.isPlatformWebkit())
        {
            var left = 0;
            var right = width - 1;
        }
        else
        {
            left = 1;
            right = width;
        }

        var leftHandle = new DvtLine(this.getCtx(), 0, top, width, top, "lh");
        var rightHandle = new DvtLine(this.getCtx(), 0, bottom, width, bottom, "rh");
                
        var leftTopBar = new DvtLine(this.getCtx(), left, 0, left, top, "ltb");
        var rightTopBar = new DvtLine(this.getCtx(), left, bottom, left, height, "rtb");
        
        var bottomBar = new DvtLine(this.getCtx(), right, top, right, bottom, "bb");
        var topBar = new DvtLine(this.getCtx(), left, top, left, bottom, "tb");
    }
    else
    {
        top = 1;
        if (this.isFlashEnvironment())
            top = 0;
        bottom = height - 1;
        left = slidingWindow.getX();
        right = slidingWindow.getX()+slidingWindow.getWidth()-1;
        leftHandle = new DvtLine(this.getCtx(), left, top, left, bottom, "lh");
        rightHandle = new DvtLine(this.getCtx(), right, top, right, bottom, "rh");
        
        /* This mode is not currently implemented ...
        if (this.isOverviewAbove())
        {
            leftTopBar = new DvtLine(this.getCtx(), 0, height-1, left, height-1, "ltb");
            rightTopBar = new DvtLine(this.getCtx(), right, height-1, width, height-1, "rtb");
            
            bottomBar = new DvtLine(this.getCtx(), left, 1, right, 1, "bb");
            topBar = new DvtLine(this.getCtx(), left, height-1, right, height-1, "tb");
        }
        else ... */
                
        // leftTopBar and rightTopBar are only visible in fusion skins
        leftTopBar = new DvtLine(this.getCtx(), 0, Math.max(0, top-1), left+1, Math.max(0, top-1), "ltb");
        rightTopBar = new DvtLine(this.getCtx(), right-1, Math.max(0, top-1), width, Math.max(0, top-1), "rtb");
        
        bottomBar = new DvtLine(this.getCtx(), left, bottom, right, bottom, "bb");
        topBar = new DvtLine(this.getCtx(), left, top, right, top, "tb");
    }
    
    // Do not antialias the sliding window borders
    leftHandle.setPixelHinting(true);
    rightHandle.setPixelHinting(true);
    leftTopBar.setPixelHinting(true);
    rightTopBar.setPixelHinting(true);
    bottomBar.setPixelHinting(true);
    topBar.setPixelHinting(true);
    
    if (this._windowBorderLeftStyle != 'none')
        leftHandle.setSolidStroke(this._windowBorderLeftColor);
    this.addChild(leftHandle);
    
    if (this._windowBorderRightStyle != 'none')
        rightHandle.setSolidStroke(this._windowBorderRightColor);
    this.addChild(rightHandle);
    
    if (this._borderTopStyle != 'none' && this._borderTopColor)
    {
        leftTopBar.setSolidStroke(this._borderTopColor);
        rightTopBar.setSolidStroke(this._borderTopColor);
    }
    this.addChild(leftTopBar);
    this.addChild(rightTopBar);
    
    if (this._windowBorderBottomStyle != 'none')
        bottomBar.setSolidStroke(this._windowBorderBottomColor);
    this.addChild(bottomBar);
    
    if (this._windowBorderTopStyle != 'none')
        topBar.setSolidStroke(this._windowBorderTopColor);
    this.addChild(topBar);
}

DvtOverview.prototype.createResizeArrow = function()
{
    if (this.isVertical())
    {
        var arrowCmds = DvtPathUtils.moveTo(6, 0) + 
                      DvtPathUtils.lineTo(0, 5) + 
                      DvtPathUtils.lineTo(5, 5) + 
                      DvtPathUtils.lineTo(5, 17) + 
                      DvtPathUtils.lineTo(0, 17) + 
                      DvtPathUtils.lineTo(6, 22) + 
                      DvtPathUtils.lineTo(12, 17) + 
                      DvtPathUtils.lineTo(7, 17) + 
                      DvtPathUtils.lineTo(7, 5) + 
                      DvtPathUtils.lineTo(12, 5) + 
                      DvtPathUtils.closePath();    
    }
    else
    {        
        arrowCmds = DvtPathUtils.moveTo(5, 0) + 
                      DvtPathUtils.lineTo(0, 6) + 
                      DvtPathUtils.lineTo(5, 12) + 
                      DvtPathUtils.lineTo(5, 7) + 
                      DvtPathUtils.lineTo(17, 7) + 
                      DvtPathUtils.lineTo(17, 12) + 
                      DvtPathUtils.lineTo(22, 6) + 
                      DvtPathUtils.lineTo(17, 0) + 
                      DvtPathUtils.lineTo(17, 4) + 
                      DvtPathUtils.lineTo(5, 4) + 
                      DvtPathUtils.lineTo(5, 0) + 
                      DvtPathUtils.closePath();    
    }

    var arrow = new DvtPath(this.getCtx(), arrowCmds, "arr");
    arrow.setSolidFill("#ffffff");            
    arrow.setSolidStroke("#000000");
    arrow.setVisible(false);
    this.addChild(arrow);    
    
    return arrow;
}

// orientation independent method
DvtOverview.prototype.setRectPos = function(rect, pos)
{
    if (this.isVertical())
        rect.setY(pos);
    else
        rect.setX(pos);
}

DvtOverview.prototype.getRectPos = function(rect)
{
    if (this.isVertical())
        return rect.getY();
    else
        return rect.getX();    
}

DvtOverview.prototype.getRectSize = function(rect)
{
    if (this.isVertical())
        return rect.getHeight();
    else
        return rect.getWidth();        
}

DvtOverview.prototype.setRectSize = function(rect, size)
{
    if (this.isVertical())
        rect.setHeight(size);
    else
        rect.setWidth(size);        
}

DvtOverview.prototype.getSlidingWindowPos = function(slidingWindow)
{
    if (this.isVertical())
        return slidingWindow.getTranslateY();    
    else
        return slidingWindow.getTranslateX();    
}

DvtOverview.prototype.setSlidingWindowPos = function(slidingWindow, pos)
{
    // make sure it cannot be negative
    pos = Math.max(0, pos);

    if (this.isVertical())
        slidingWindow.setTranslateY(pos);
    else
        slidingWindow.setTranslateX(pos);

    if (this.isLeftAndRightFilterRendered())
    {
        var leftBackground = this.getLeftBackground();
        leftBackground.setWidth(pos);
        var rightStart = pos+this.getSlidingWindowSize(slidingWindow);
        var rightBackground = this.getRightBackground();
        rightBackground.setX(rightStart);
        rightBackground.setWidth(Math.max(0, this.Width-rightStart));

        // updates the background resize handle for touch
        if (DvtTimeUtils.supportsTouch() && !this.isFeatureOff('zoom'))
        {
            var handleStart = this.getHandleStart();
            var leftBackgroundHandle = this.getLeftBackgroundHandle();
            leftBackgroundHandle.setX(pos-handleStart);
            var rightBackgroundHandle = this.getRightBackgroundHandle();
            rightBackgroundHandle.setX(rightStart);
        }
    }
}

DvtOverview.prototype.getSlidingWindowSize = function(slidingWindow)
{
    return this.getRectSize(slidingWindow);
}

DvtOverview.prototype.setSlidingWindowSize = function(slidingWindow, size)
{
    // make sure it's greater than the minimum window size
    size = Math.max(this.getMinimumWindowSize(), size);

    // make sure it does not exceed overview
    size = Math.min(this.isVertical() ? this.Height:this.Width, size);

    this.setRectSize(slidingWindow, size);

    // update left and right filter if one is specified
    if (this.isLeftAndRightFilterRendered())
    {
        var rightStart = this.getSlidingWindowPos(slidingWindow)+size;
        var rightBackground = this.getRightBackground();
        rightBackground.setX(rightStart);
        rightBackground.setWidth(Math.max(0, this.Width-rightStart));

        // updates the background resize handle for touch
        if (DvtTimeUtils.supportsTouch() && !this.isFeatureOff('zoom'))
        {
            var rightBackgroundHandle = this.getRightBackgroundHandle();
            rightBackgroundHandle.setX(rightStart);
        }
    }

    // if resize feature is off then there's nothing else to do
    if (this.isFeatureOff('zoom'))
        return;

    // update the resize handles
    var rightHandleBackground = slidingWindow.getChildAt(3);
    var rightHandle = slidingWindow.getChildAt(4);
    var rightGrippy = slidingWindow.getChildAt(5);
    if (this.isVertical())
    {
        rightHandle.setTranslateY(size);
        rightHandleBackground.setTranslateY(size-this.getHandleSize());
        rightGrippy.setTranslateY(size-this.getGrippySize());
    }
    else
    {
        rightHandle.setTranslateX(size);
        rightHandleBackground.setTranslateX(size-this.getHandleSize());
        rightGrippy.setTranslateX(size-this.getGrippySize());
    }
}

DvtOverview.prototype.calculateIncrement = function (overviewWidth)
{
    var timelineWidth = this._width;
    var start = this._start;
    var end = this._end;

    // get the date diff for 1 pixel
    var day1 = DvtTimeUtils.getPositionDate(start, end, 1, overviewWidth);
    var day2 = DvtTimeUtils.getPositionDate(start, end, 2, overviewWidth);

    // now map it back to whole timeline for position
    var pos1 = DvtTimeUtils.getDatePosition(start, end, day1, timelineWidth);
    var pos2 = DvtTimeUtils.getDatePosition(start, end, day2, timelineWidth);

    var inc = pos2 - pos1;
    return inc;
}

DvtOverview.prototype.updateTimeAxis = function (width, height)
{
    if (this._ticks == null)
        return;

    var vertical = this.isVertical();
    var size = this.getOverviewSize();
        
    var start = this._start;
    var end = this._end;

    for (var i=0; i<this._ticks.length; i++)
    {
        var child = this._ticks[i];        

        var time = parseInt(child.getAttr("time"), 10);            
        var time_pos = this.getDatePosition(time);            
        var label = child.getAttr("label");

        var maxWidth = 0;
        if (i+1 < this._ticks.length)
        {
            var next_time = parseInt(this._ticks[i+1].getAttr("time"), 10);            
            var next_time_pos = this.getDatePosition(next_time);
            maxWidth = next_time_pos - time_pos;
        }
        else
        {
            // last label
            maxWidth = size - time_pos;                
        }
        
        if (this.isRTL())
            time_pos = size - time_pos;

        this.addTick(time_pos, width, height, "tick"+i);
        this.addLabel(time_pos, label, width, height, maxWidth, "label"+i);
    }
}

// adds a tick mark
DvtOverview.prototype.addTick = function (pos, width, height, id)
{
    if (this.isVertical())
        var line = new DvtLine(this.getCtx(), 0, pos, width, pos, id);
    else
        line = new DvtLine(this.getCtx(), pos, 0, pos, height, id);
    var stroke = new DvtSolidStroke(this._timeIndicatorColor);
    stroke.setStyle(DvtStroke.DASHED, 3);
    line.setStroke(stroke);
    
    // Do not antialias tick marks
    line.setPixelHinting(true);
    
    this.addChild(line);
}

// add a label in time axis
DvtOverview.prototype.addLabel = function (pos, text, width, height, maxWidth, id)
{
    if (this.isVertical())
        var label = new DvtOutputText(this.getCtx(), text, width-this.getTimeAxisWidth()+2, pos, id);        
    else
    {
        if (this.isOverviewAbove())
            var y = 2;
        else
            y = height - this.getTimeAxisHeight() + 2;
        
        label = new DvtOutputText(this.getCtx(), text, pos+5, y, id);
    }

    label.setCSSStyle(new DvtCSSStyle("font-weight:bold"));
        
    DvtTextUtils.fitText(label, maxWidth, Infinity, this);
    
    // save the raw text for tooltip
    label._rawText = label.getUntruncatedTextString();
}

DvtOverview.prototype.updateCurrentTime = function (width, height)
{
    if (this._currentTime == null || isNaN(this._currentTime))
        return;

    var start = this._start;
    var end = this._end;
    var time_pos = this.getDatePosition(this._currentTime);            

    if (this.isVertical())    
        var line = new DvtLine(this.getCtx(), 0, time_pos, width, time_pos, "ocd");
    else
    {
        if (this.isRTL())
            time_pos = width - time_pos;
        line = new DvtLine(this.getCtx(), time_pos, 0, time_pos, height, "ocd");
    }
    line.setSolidStroke(this._currentTimeIndicatorColor);
    
    // Do not antialias current time line
    line.setPixelHinting(true);
    
    this.addChild(line);
}

DvtOverview.prototype.parseFilledTimeRangesXML = function (width, height)
{
    if (this._formattedTimeRanges == null)
        return;

    // draw filled time ranges so that it is over the sliding window but under the markers
    var start = this._start;
    var end = this._end;

    for (var i=0; i<this._formattedTimeRanges.length; i++)
    {
        var ftr = this._formattedTimeRanges[i];
        this.addFilledTimeRange(ftr, start, end, width, height);
    }
}

DvtOverview.prototype.addFilledTimeRange = function(elem, start, end, width, height)
{
    var rangeStart = parseInt(elem.getAttr("rs"), 10);
    var rangeEnd = parseInt(elem.getAttr("re"), 10);
    var color = elem.getAttr("c");    

    if (rangeStart != null && rangeEnd != null)
    {
        var size = this.getOverviewSize();

        var rangeStart_pos = this.getDatePosition(rangeStart);            
        var rangeEnd_pos = this.getDatePosition(rangeEnd);            
        var rangeWidth = rangeEnd_pos - rangeStart_pos;
        if (this.isRTL())
        {
            rangeStart_pos = size - rangeStart_pos - rangeWidth;
            rangeEnd_pos = size - rangeEnd_pos - rangeWidth;
        }

        if (this.isVertical())
            var displayable = new DvtRect(this.getCtx(), 0, rangeStart_pos, width-this.getTimeAxisWidth(), rangeWidth, "ftr");
        else
            displayable = new DvtRect(this.getCtx(), rangeStart_pos, this.isOverviewAbove() ? this.getTimeAxisHeight() : 0, rangeWidth, height-this.getTimeAxisHeight(), "ftr");

        if (color != null)
            displayable.setSolidFill(color, 0.4);            
        displayable.setCursor('move');
        
        // Do not antialias filled time range
        displayable.setPixelHinting(true);
        
        this.addChild(displayable);
    }
}

DvtOverview.prototype.parseDataXML = function (width, height)
{    
}

/************************** sliding window animation *********************************************/
DvtOverview.prototype.animateSlidingWindow = function (newLeft, newWidth)
{
    var slidingWindow = this.getSlidingWindow();        
    var handleBackground = slidingWindow.getChildAt(3);
    var handle = slidingWindow.getChildAt(4);
    var grippy = slidingWindow.getChildAt(5);
    
    // first check if sliding window move or resize at all
    if (newWidth == undefined && newLeft == this.getSlidingWindowPos(slidingWindow))
        return;        

    var leftHandle = this.getLeftHandle();
    var rightHandle = this.getRightHandle();
    var leftTopBar = this.getLeftTopBar();
    var rightTopBar = this.getRightTopBar();
    var bottomBar = this.getBottomBar();
    var topBar = this.getTopBar();

    if (this.isVertical())
    {
        var posGetter = slidingWindow.getTranslateY;
        var posSetter = slidingWindow.setTranslateY;
        var sizeGetter = slidingWindow.getHeight;
        var sizeSetter = slidingWindow.setHeight;
        var leftHandlePos1Getter = leftHandle.getY1;
        var leftHandlePos1Setter = leftHandle.setY1;
        var leftHandlePos2Getter = leftHandle.getY2;
        var leftHandlePos2Setter = leftHandle.setY2;
        var rightHandlePos1Getter = rightHandle.getY1;
        var rightHandlePos1Setter = rightHandle.setY1;
        var rightHandlePos2Getter = rightHandle.getY2;
        var rightHandlePos2Setter = rightHandle.setY2;
        var leftTopBarPosGetter = leftTopBar.getY2;
        var leftTopBarPosSetter = leftTopBar.setY2;
        var rightTopBarPosGetter = rightTopBar.getY1;
        var rightTopBarPosSetter = rightTopBar.setY1;
        var bottomBarPos1Getter = bottomBar.getY1;
        var bottomBarPos1Setter = bottomBar.setY1;
        var bottomBarPos2Getter = bottomBar.getY2;
        var bottomBarPos2Setter = bottomBar.setY2;
        var topBarPos1Getter = topBar.getY1;
        var topBarPos1Setter = topBar.setY1;
        var topBarPos2Getter = topBar.getY2;
        var topBarPos2Setter = topBar.setY2;

        if (handle != null && grippy != null)
        {
            var handleGetter = handle.getTranslateY;
            var handleSetter = handle.setTranslateY;
            var grippyGetter = grippy.getTranslateY;
            var grippySetter = grippy.setTranslateY;
        }
    }
    else
    {
        posGetter = slidingWindow.getTranslateX;
        posSetter = slidingWindow.setTranslateX;
        sizeGetter = slidingWindow.getWidth;
        sizeSetter = slidingWindow.setWidth;
        leftHandlePos1Getter = leftHandle.getX1;
        leftHandlePos1Setter = leftHandle.setX1;
        leftHandlePos2Getter = leftHandle.getX2;
        leftHandlePos2Setter = leftHandle.setX2;
        rightHandlePos1Getter = rightHandle.getX1;
        rightHandlePos1Setter = rightHandle.setX1;
        rightHandlePos2Getter = rightHandle.getX2;
        rightHandlePos2Setter = rightHandle.setX2;
        leftTopBarPosGetter = leftTopBar.getX2;
        leftTopBarPosSetter = leftTopBar.setX2;
        rightTopBarPosGetter = rightTopBar.getX1;
        rightTopBarPosSetter = rightTopBar.setX1;
        bottomBarPos1Getter = bottomBar.getX1;
        bottomBarPos1Setter = bottomBar.setX1;
        bottomBarPos2Getter = bottomBar.getX2;
        bottomBarPos2Setter = bottomBar.setX2;
        topBarPos1Getter = topBar.getX1;
        topBarPos1Setter = topBar.setX1;
        topBarPos2Getter = topBar.getX2;
        topBarPos2Setter = topBar.setX2;

        if (handle != null && grippy != null)
        {
            handleGetter = handle.getTranslateX;
            handleSetter = handle.setTranslateX;
            grippyGetter = grippy.getTranslateX;
            grippySetter = grippy.setTranslateX;
        }
    }

    // make sure it doesn't go over
    var minPos = this.getMinimumPosition();
    var maxPos = this.getMaximumPosition();
    var slidingWindowSize = this.getSlidingWindowSize(slidingWindow);
    if (newWidth != undefined)
        newLeft = Math.max(minPos, Math.min(maxPos - newWidth, newLeft));
    else
        newLeft = Math.max(minPos, Math.min(maxPos - slidingWindowSize, newLeft));

    // sliding window
    var animator = this.isAnimationOnClick() ? new DvtAnimator(this.getCtx(), 0.5, 0, DvtEasing.linear) : null;
    this.animateProperty(animator, slidingWindow, posGetter, posSetter, newLeft);
    if (newWidth != undefined)
    {
        this.animateProperty(animator, slidingWindow, sizeGetter, sizeSetter, newWidth);
        if (handle != null)
            this.animateProperty(animator, handle, handleGetter, handleSetter, newWidth);
        if (handleBackground != null)
            this.animateProperty(animator, handleBackground, handleGetter, handleSetter, newWidth-this.getHandleSize());
        if (grippy != null)
            this.animateProperty(animator, grippy, grippyGetter, grippySetter, newWidth-this.getGrippySize());
    }
    
    // left and right handles
    this.animateProperty(animator, leftHandle, leftHandlePos1Getter, leftHandlePos1Setter, newLeft);
    this.animateProperty(animator, leftHandle, leftHandlePos2Getter, leftHandlePos2Setter, newLeft);
    
    if (newWidth != undefined)
    {
        this.animateProperty(animator, rightHandle, rightHandlePos1Getter, rightHandlePos1Setter, newLeft+newWidth);
        this.animateProperty(animator, rightHandle, rightHandlePos2Getter, rightHandlePos2Setter, newLeft+newWidth);
    }
    else
    {
        this.animateProperty(animator, rightHandle, rightHandlePos1Getter, rightHandlePos1Setter, newLeft+slidingWindowSize);
        this.animateProperty(animator, rightHandle, rightHandlePos2Getter, rightHandlePos2Setter, newLeft+slidingWindowSize);
    }

    // left and right top bar
    this.animateProperty(animator, leftTopBar, leftTopBarPosGetter, leftTopBarPosSetter, newLeft+1);
    
    if (newWidth != undefined)
        this.animateProperty(animator, rightTopBar, rightTopBarPosGetter, rightTopBarPosSetter, newLeft+newWidth-1);
    else
        this.animateProperty(animator, rightTopBar, rightTopBarPosGetter, rightTopBarPosSetter, newLeft+slidingWindowSize-1);
    
    this.animateProperty(animator, bottomBar, bottomBarPos1Getter, bottomBarPos1Setter, newLeft);
    this.animateProperty(animator, topBar, topBarPos1Getter, topBarPos1Setter, newLeft);
    
    if (newWidth != undefined)
    {
        this.animateProperty(animator, bottomBar, bottomBarPos2Getter, bottomBarPos2Setter, newLeft+newWidth);
        this.animateProperty(animator, topBar, topBarPos2Getter, topBarPos2Setter, newLeft+newWidth);
    }
    else
    {
        this.animateProperty(animator, bottomBar, bottomBarPos2Getter, bottomBarPos2Setter, newLeft+slidingWindowSize);
        this.animateProperty(animator, topBar, topBarPos2Getter, topBarPos2Setter, newLeft+slidingWindowSize);
    }
    
    if (this.isLeftAndRightFilterRendered())
    {
        var leftBackground = this.getLeftBackground();
        var leftBackgroundGetter = leftBackground.getWidth;
        var leftBackgroundSetter = leftBackground.setWidth;
        this.animateProperty(animator, leftBackground, leftBackgroundGetter, leftBackgroundSetter, newLeft);

        var rightStart = newLeft+slidingWindowSize;
        var rightBackground = this.getRightBackground();
        var rightBackgroundGetter = rightBackground.getWidth;
        var rightBackgroundSetter = rightBackground.setWidth;
        var rightBackgroundPosGetter = rightBackground.getX;
        var rightBackgroundPosSetter = rightBackground.setX;

        if (this.isVertical())
            var timelineSize = this.Height;
        else
            timelineSize = this.Width;
        this.animateProperty(animator, rightBackground, rightBackgroundGetter, rightBackgroundSetter, timelineSize-rightStart);
        this.animateProperty(animator, rightBackground, rightBackgroundPosGetter, rightBackgroundPosSetter, rightStart);

        if (DvtTimeUtils.supportsTouch() && !this.isFeatureOff('zoom'))
        {
            var handleStart = this.getHandleStart();
            var leftBackgroundHandle = this.getLeftBackgroundHandle();
            var leftBackgroundHandleGetter = leftBackgroundHandle.getX;
            var leftBackgroundHandleSetter = leftBackgroundHandle.setX;
            var rightBackgroundHandle = this.getRightBackgroundHandle();
            var rightBackgroundHandleGetter = rightBackgroundHandle.getX;
            var rightBackgroundHandleSetter = rightBackgroundHandle.setX;

            this.animateProperty(animator, leftBackgroundHandle, leftBackgroundHandleGetter, leftBackgroundHandleSetter, newLeft-handleStart);
            this.animateProperty(animator, rightBackgroundHandle, rightBackgroundHandleGetter, rightBackgroundHandleSetter, rightStart);
        }
    }

    if (animator != null)
        animator.play();     
}

DvtOverview.prototype.animateProperty = function(animator, obj, getter, setter, value)
{
    if (animator != null)
        animator.addProp(DvtAnimator.TYPE_NUMBER, obj, getter, setter, value);
    else
        setter.call(obj, value);
}
/************************** end sliding window animation *********************************************/

/************************** event handling *********************************************/
DvtOverview.prototype.HandleShapeMouseOver = function (event)
{
    var drawable = this._findDrawable(event);
    // Return if no drawable is found
    if(!drawable || drawable.getId() == 'bg' || drawable.getId() == 'ocd')
        return;    

    // if it is a label, show a tooltip of the label if it is truncated
    if (drawable.getId().substr(0, 5) == 'label' && drawable instanceof DvtOutputText)
    {
        if (drawable.isTruncated())
            this.getCtx().getTooltipManager().showDatatip(event.pageX, event.pageY, drawable._rawText, "#000000");  
        return;
    }

    if (this._resizeArrow != null && this.isHandle(drawable))
    {
        var relPos = this.getCtx().pageToStageCoords(event.pageX, event.pageY);
        relPos = this.stageToLocal(relPos);
        if (this.isVertical())
        {
            this._resizeArrow.setTranslate(relPos.x+6, relPos.y-10);            
        }
        else
        {
            this._resizeArrow.setTranslate(relPos.x-6, relPos.y-20);
        }
        this._resizeArrow.setVisible(true);
    }
    
    if (drawable.getId() == 'window' || drawable.getId() == 'ftr' || drawable.getId() == 'arr' || this.isHandle(drawable))
    {
        if (this.isFlashEnvironment())
            this.setCursor('move');

        return;
    }

    return drawable;
}

DvtOverview.prototype.HandleShapeMouseOut = function (event)
{
    // don't change cursor yet if we are in a moving state
    if (this._moveDrawable == null)
        this.setCursor('default');

    var drawable = this._findDrawable(event);
    if (drawable == null)
        return;

    // dismiss resize arrow
    if (this.isHandle(drawable) && this._resizeArrow != null)
        this._resizeArrow.setVisible(false);

    return drawable;
}

DvtOverview.prototype.HandleShapeClick = function (event, pageX, pageY)
{
    // so that graph will not get a click event and clear selection
    event.stopPropagation();

    var drawable = this._findDrawable(event);  

    // Return if no drawable is found
    if(!drawable || drawable.getId() == 'window' || this.isHandle(drawable))
        return;    

    // if clicking anywhere on the overview scroll to the location
    if (drawable.getId() == 'bg' || drawable.getId().substr(0, 5) == 'label' || drawable.getId() == 'ocd' || drawable.getId() == 'lbg' || drawable.getId() == 'rbg')
    {
        if (pageX == undefined)
            pageX = event.pageX;
        if (pageY == undefined)
            pageY = event.pageY;
  
        var relPos = this.getCtx().pageToStageCoords(pageX, pageY);
        relPos = this.stageToLocal(relPos);
        if (this.isVertical())
        {
            var pos = relPos.y;
            var size = this.Height;
        }
        else
        {
            pos = relPos.x;
            size = this.Width;
        }

        // scroll sliding window
        var slidingWindow = this.getSlidingWindow();        
        var newPos = pos - this.getRectSize(slidingWindow)/2;    
        this.animateSlidingWindow(newPos);

        if (this.isRTL())
            pos = this.Width - pos;

        var time = this.getPositionDate(pos);

        // scroll timeline
        var evt = new DvtOverviewEvent(DvtOverviewEvent.SUBTYPE_SCROLL_TIME);
        evt.setTime(time);

        // make sure position is in bound
        newPos = Math.max(0, Math.min(newPos, size - this.getRectSize(slidingWindow)));

        var newStartTime = this.getPositionDate(newPos);
        var newEndTime = this.getPositionDate(newPos+this.getRectSize(slidingWindow));
        evt.setNewStartTime(newStartTime);
        evt.setNewEndTime(newEndTime);

        this.dispatchEvent(evt);

        return;
    }

    return drawable;
}

DvtOverview.prototype.HandleMouseDown = function(event)
{
    this.HandleMouseDownOrTouchStart(event);
}

DvtOverview.prototype.HandleMouseDownOrTouchStart = function(event)
{    
    // since we are stopping propagation, we'll need to detect and handle click event for Touch ourselves
    event.stopPropagation();

    var drawable = this._findDrawable(event);
    if (drawable != null && this.isMovable(drawable))
    {
        // if the drawable is the formatted time ranges, move the sliding window
        if (drawable.getId() == 'ftr' || drawable.getId() == 'sta')
            drawable = this.getSlidingWindow();

        this._initX = this.getPageX(event);
        this._initY = this.getPageY(event);

        if (this.isHandle(drawable))
        {
            var slidingWindow = this.getSlidingWindow();
            this._oldStartPos = slidingWindow.getX();
            this._oldEndPos = this._oldStartPos + slidingWindow.getWidth();            

            if (drawable.getParent().getId() == 'grpy')
                drawable = drawable.getParent();

            var drawableId = drawable.getId();

            if (drawableId == 'grpy')
            {
                drawable = slidingWindow.getChildBefore(drawable);
                drawableId = drawable.getId();
            }

            if (drawableId == 'lh' || drawableId == 'rh')
            {
                drawable = slidingWindow.getChildBefore(drawable);
                drawableId = drawable.getId();
            }

            if (drawableId == 'lbgrh')
                drawable = slidingWindow.getChildAt(0);

            if (drawableId == 'rbgrh')
                drawable = slidingWindow.getChildAt(slidingWindow.getNumChildren()-3);

            // drawable should be lhb or rhb
            // temporarily increase size of handle to capture wider area and prevent cursor from changing
            // only do this for non touch since we won't run into cursor issue
            if (!DvtTimeUtils.supportsTouch())
            {
                if (this.isVertical())
                {
                    drawable.setY(0-DvtOverview.HANDLE_PADDING_SIZE);
                    drawable.setHeight((drawable.getHeight()+DvtOverview.HANDLE_PADDING_SIZE)*2);
                }
                else 
                {
                    drawable.setX(0-DvtOverview.HANDLE_PADDING_SIZE);
                    drawable.setWidth((drawable.getWidth()+DvtOverview.HANDLE_PADDING_SIZE)*2);                
                }
            }

            // temporily change the cursor of other areas of overview so that
            // the cursor won't change when it is moved outside of the handle
            this.overrideCursors(drawable.getCursor());
        }
        
        this._moveDrawable = drawable;

        // ask the overview peer to notify us if the release happened outside of the overview
        // see stopDragAction method
        var evt = new DvtOverviewEvent(DvtOverviewEvent.SUBTYPE_PRE_RANGECHANGE);
        this.dispatchEvent(evt);
    }
}

// Change the cursor of the sliding window and the left and right backgrounds
DvtOverview.prototype.overrideCursors = function(cursor)
{
    var slidingWindow = this.getSlidingWindow();
    if (slidingWindow != null)
        slidingWindow.setCursor(cursor);

    if (this.isLeftAndRightFilterRendered())
    {
        var leftBackground = this.getLeftBackground();
        var rightBackground = this.getRightBackground();
        if (leftBackground != null && rightBackground != null)
        {
            leftBackground.setCursor(cursor);
            rightBackground.setCursor(cursor);
        }
    }
}

// reset the cursor to what it was original state
DvtOverview.prototype.resetCursors = function()
{
    var slidingWindow = this.getSlidingWindow();
    if (slidingWindow != null)
        slidingWindow.setCursor('move');

    if (this.isLeftAndRightFilterRendered())
    {
        var leftBackground = this.getLeftBackground();
        var rightBackground = this.getRightBackground();
        if (leftBackground != null && rightBackground != null)
        {
            leftBackground.setCursor('default');
            rightBackground.setCursor('default');
        }
    }
}

DvtOverview.prototype.HandleMouseUp = function(event)
{
    this.HandleMouseUpOrTouchEnd(event);    
}

DvtOverview.prototype.HandleMouseUpOrTouchEnd = function(event)
{
    // stop bubbling
    if (event != null)
      event.stopPropagation();

    if (this._moveDrawable != null)
    {
        if (this._moveDrawable.getId() == 'window')
            this.finishWindowDrag(event, 0, 0);
        else if (this.isHandle(this._moveDrawable))
        {
            this.finishHandleDrag(event, 0, 0);

            // reset the temporarily resized handle
            if (!DvtTimeUtils.supportsTouch())
            {
                if (this.isVertical())
                {
                    this._moveDrawable.setY(0);    
                    this._moveDrawable.setHeight(this.getHandleSize());
                }
                else 
                {
                    this._moveDrawable.setX(0);    
                    this._moveDrawable.setWidth(this.getHandleSize());                
                }
            }

            // reset cursors that were temporily changed
            this.resetCursors();
        }
        
        this._moveDrawable = null;
        this._initX = -1;
    }
}

DvtOverview.prototype.HandleMouseMove = function(event)
{
    this.HandleMouseMoveOrTouchMove(event);
}

DvtOverview.prototype.HandleMouseMoveOrTouchMove = function(event)
{
    event.stopPropagation();

    if (this._moveDrawable != null && this._initX != -1)
    {
        var pageX = this.getPageX(event);
        var pageY = this.getPageY(event);
        var diffX = pageX - this._initX;
        var diffY = pageY - this._initY;
        this._initX = pageX;
        this._initY = pageY;

        if (this._moveDrawable.getId() == 'window')
        {
            this.handleWindowDragPositioning(event, diffX, diffY);        
        }
        else if (this._moveDrawable.getId() == 'lh' || this._moveDrawable.getId() == 'lhb')
        {            
            this.handleLeftHandleDragPositioning(event, diffX, diffY);
        }
        else if (this._moveDrawable.getId() == 'rh' || this._moveDrawable.getId() == 'rhb')
        {            
            this.handleRightHandleDragPositioning(event, diffX, diffY);
        }
    }
}

DvtOverview.prototype.HandleTouchStart = function(event)
{
    var target = event.targetTouches[0];
    this._touchStartX = target.pageX;
    this._touchStartY = target.pageY;

    // see if this is a width change gesture
    if (event.targetTouches.length == 2)
    {
        // only prevent default if it is a multi-touch gesture otherwise we don't get click callback
        event.preventDefault();

        target = event.targetTouches[1];
        this._touchStartX2 = target.pageX;
        this._touchStartY2 = target.pageY;

        if (Math.abs(this._touchStartY-this._touchStartY2) < 20)
            this._counter = 0;
        else
        {
            this._touchStartX = null;
            this._touchStartY = null;
            this._touchStartX2 = null;
            this._touchStartY2 = null;            
        }
    }   
    else
    {
        this.HandleMouseDownOrTouchStart(event);
    }
}

DvtOverview.prototype.HandleTouchMove = function(event)
{
    event.preventDefault();

    // width change gesture
    if (this._touchStartX2 != null && this._touchStartY2 != null)
    {
        if (this._counter < 50)
        {
            // we can't do the dynamic update very often as it is very CPU intensive...
            this._counter++;
            return;
        }
        
        var target = event.targetTouches[1];

        var deltaX = target.pageX - this._touchStartX2;
        this.handleRightHandleDragPositioning(null, deltaX, 0);

        this._touchStartX2 = target.pageX;

        // reset        
        this._counter = 0;
    }
    else
    {
        // null out the var to signal that this is not a click event
        this._touchStartX = null;
        this._touchStartY = null;

        this.HandleMouseMoveOrTouchMove(event);
    }
}

DvtOverview.prototype.HandleTouchEnd = function(event)
{
    if (this._touchStartX2 != null && this._touchStartY2 != null)
    {
        // width change gesture
        this.finishHandleDrag(null, 0, 0);
    }
    else
    {
        if (this._moveDrawable != null && this.isHandle(this._moveDrawable))
            this._moveDrawable.setSolidFill(this._windowBackgroundColor, this._windowBackgroundAlpha);

        this.HandleMouseUpOrTouchEnd(event);

        if (this._touchStartX != null && this._touchStartY != null)
            this.HandleShapeClick(event, this._touchStartX, this._touchStartY);
    }

    this._touchStartX = null;
    this._touchStartY = null;
    this._touchStartX2 = null;
    this._touchStartY2 = null;
}

// called externally from overview peer to stop all dragging if the drop action happened outside of the overview
DvtOverview.prototype.stopDragAction = function()
{
    this.HandleMouseUpOrTouchEnd(null);  
}
/************************** end event handling *********************************************/

/***************************** window scrolling triggered by timeline *********************************************/
// called by peer
DvtOverview.prototype.ScrollToStart = function()
{
    var slidingWindow = this.getSlidingWindow();        
    var totalWidth = this.Width;
    if (this.isRTL())
        this.setSlidingWindowPos(slidingWindow, totalWidth - this.getSlidingWindowSize(slidingWindow));                
    else
        this.setSlidingWindowPos(slidingWindow, 0);

    this.ScrollTimeAxis();
}

DvtOverview.prototype.ScrollToEnd = function()
{
    var slidingWindow = this.getSlidingWindow();        
    var totalWidth = this.Width;
    if (this.isRTL())
        this.setSlidingWindowPos(slidingWindow, 0);
    else
        this.setSlidingWindowPos(slidingWindow, totalWidth - this.getSlidingWindowSize(slidingWindow));                

    this.ScrollTimeAxis();
}

DvtOverview.prototype.ScrollByAmount = function(amount)
{
    var slidingWindow = this.getSlidingWindow();        
    // todo: rounding makes this inaccurate at some point, perhaps a way to sync up the scroll pos with actual data points?
    var actualAmount = amount / this._increment;   
    if (this.isRTL())
        actualAmount = 0 - actualAmount;
  
    if (this.isVertical())
        var maxAmount = this.Height - slidingWindow.getHeight();
    else
        maxAmount = this.Width - slidingWindow.getWidth();

    this.setSlidingWindowPos(slidingWindow, Math.min(maxAmount, this.getSlidingWindowPos(slidingWindow) + actualAmount));    
    
    this.ScrollTimeAxis();
}

// called by timeline peer keyboard navigation methods
DvtOverview.prototype.longScrollToPos = function(pos)
{
    var actualAmount = pos / this._increment;   
    if (this.isRTL())
        actualAmount = 0 - actualAmount;

    this.animateSlidingWindow(actualAmount);    
}

// called by timeline peer on restore position after zoom
DvtOverview.prototype.ScrollToPos = function(pos)
{
    var slidingWindow = this.getSlidingWindow();        
    var actualAmount = pos / this._increment;   
    if (this.isRTL())
        actualAmount = 0 - actualAmount;

    this.setSlidingWindowPos(slidingWindow, actualAmount);        
    this.ScrollTimeAxis();
}

/**
 * Called by apps to scroll the overview window to a particular time
 * @public 
 */
DvtOverview.prototype.scrollToTime = function(time)
{
    var pos = Math.max(0, DvtTimeUtils.getDatePosition(this._start, this._end, time, this._width));
    this.longScrollToPos(pos);
}
/************************** end window scrolling triggered by timeline *********************************************/

/***************************** window scrolling and resizing *********************************************/
DvtOverview.prototype.handleWindowDragPositioning = function(event, deltaX, deltaY)
{
    this.fireScrollEvent(DvtOverviewEvent.SUBTYPE_SCROLL_POS, deltaX, deltaY);
}

DvtOverview.prototype.finishWindowDrag = function(event, deltaX, deltaY)
{
    this.fireScrollEvent(DvtOverviewEvent.SUBTYPE_SCROLL_END, deltaX, deltaY);
}

DvtOverview.prototype.fireScrollEvent = function(type, deltaX, deltaY)
{
    var slidingWindow = this.getSlidingWindow();        
    var pos = this.getSlidingWindowPos(slidingWindow);
    var size = this.getRectSize(slidingWindow);
    var minPos = this.getMinimumPosition();            
    var maxPos = this.getMaximumPosition();            

    if (this.isVertical())
        var delta = deltaY;
    else
        delta = deltaX;            

    if ((pos + delta) <= minPos)
    {
        // hit the top
        this.setSlidingWindowPos(slidingWindow, minPos);
        if (this.isRTL())
            var scrollTo = DvtOverviewEvent.END_POS;
        else
            scrollTo = DvtOverviewEvent.START_POS;
    }            
    else if (pos+size+delta >= maxPos)
    {
        // hit the bottom      
        this.setSlidingWindowPos(slidingWindow, maxPos - size);
        if (this.isRTL())
            scrollTo = DvtOverviewEvent.START_POS;
        else
            scrollTo = DvtOverviewEvent.END_POS;
    }
    else
    {
        this.setSlidingWindowPos(slidingWindow, pos+delta);
        if (this.isRTL())
            scrollTo = (maxPos - size - pos - this._leftMargin) * this._increment;
        else
            scrollTo =  (pos - this._leftMargin) * this._increment;
    }
    
    // sync window tima axis
    this.ScrollTimeAxis();

    // scroll timeline
    var evt = new DvtOverviewEvent(type);
    evt.setPosition(scrollTo);

    var newStartTime = this.getPositionDate(pos);
    var newEndTime = this.getPositionDate(pos+this.getRectSize(slidingWindow));
    evt.setNewStartTime(newStartTime);
    evt.setNewEndTime(newEndTime);

    this.dispatchEvent(evt);
}

DvtOverview.prototype.handleLeftHandleDragPositioning = function(event, deltaX, deltaY)
{
    this.handleLeftOrRightHandleDragPositioning(event, deltaX, deltaY, true);
}

DvtOverview.prototype.handleRightHandleDragPositioning = function(event, deltaX, deltaY)
{
    this.handleLeftOrRightHandleDragPositioning(event, deltaX, deltaY, false);
}

DvtOverview.prototype.handleLeftOrRightHandleDragPositioning = function(event, deltaX, deltaY, isLeft)
{
    var size = this.getOverviewSize();
    if (this.isVertical())
        var delta = deltaY;
    else
        delta = deltaX;
    
    if (delta == 0)
        return;

    var slidingWindow = this.getSlidingWindow();        
    var windowPos = this.getSlidingWindowPos(slidingWindow);
    var windowSize = this.getSlidingWindowSize(slidingWindow);
    if (isLeft)
    {
        // make sure width of sliding window is larger than minimum
        if (windowSize - delta <= this.getMinimumWindowSize())
            return;

        // make sure position of left handle is not less than minimum (delta is negative when moving handle to the left)
        if (windowPos + delta <= this.getMinimumPosition())
            return;

        // window should only resize when the cursor is back to where the handle is        
        if (this.isVertical())
            var relPos = this.getCtx().pageToStageCoords(this.getPageX(event), this.getPageY(event)).y;
        else
            relPos = this.getCtx().pageToStageCoords(this.getPageX(event), this.getPageY(event)).x;
        relPos = this.stageToLocal(relPos);
        
        if (delta > 0 && relPos <= windowPos)
            return;
        else if (delta < 0 && relPos >= windowPos)
            return;
            
        this.setSlidingWindowPos(slidingWindow, windowPos + delta);
        this.setSlidingWindowSize(slidingWindow, windowSize - delta);
    }
    else
    {
        // make sure width of sliding window is larger than minimum
        if (windowSize + delta <= this.getMinimumWindowSize())
            return;

        // make sure position of right handle is not less than minimum
        if (windowPos + windowSize + delta >= this.getMaximumPosition())
            return;

        // window should only resize when the cursor is back to where the handle is        
        if (this.isVertical())
            relPos = this.getCtx().pageToStageCoords(this.getPageX(event), this.getPageY(event)).y;
        else
            relPos = this.getCtx().pageToStageCoords(this.getPageX(event), this.getPageY(event)).x;
        relPos = this.stageToLocal(relPos);

        if (delta > 0 && relPos <= windowPos + windowSize)
            return;
        else if (delta < 0 && relPos >= windowPos + windowSize)
            return;                

        this.setSlidingWindowSize(slidingWindow, windowSize + delta);
    }
    
    // sync with time axis
    this.ScrollTimeAxis();

    // dynamically update contents of timeline (time axis, position of items etc.)
    var time = this.getPositionDate(this.getSlidingWindowSize(slidingWindow));

    // if we know the position and date we can calculate the new width
    var newSize = (size * (this._end - this._start)) / (time - this._start);

    // tell event handler that time range is changing
    if (this.isRangeChangingSupported())
    {
        var evt = new DvtOverviewEvent(DvtOverviewEvent.SUBTYPE_RANGECHANGING);
        evt.setNewSize(newSize);
        evt.setEndHandle(!isLeft);
        if (isLeft)
            evt.setExpand((delta < 0));
        else
            evt.setExpand((delta > 0));

        var newStartTime = this.getPositionDate(this.getSlidingWindowPos(slidingWindow));
        var newEndTime = this.getPositionDate(this.getSlidingWindowPos(slidingWindow)+this.getRectSize(slidingWindow));
        evt.setNewStartTime(newStartTime);
        evt.setNewEndTime(newEndTime);

        this.dispatchEvent(evt);
    }
}

// whether to fire a range changing event, which will be fired continuously when the sliding window is resize
DvtOverview.prototype.isRangeChangingSupported = function()
{
    return true;
}

DvtOverview.prototype.finishHandleDrag = function(event, deltaX, deltaY)
{
    var start = this._start;
    var end = this._end;
    var oldSize = this._width;
    var size = this.getOverviewSize();

    var slidingWindow = this.getSlidingWindow();        
    var time = this.getPositionDate(this.getRectSize(slidingWindow));

    // if we know the position and date we can calculate the new width
    var newSize = (size * (end - start)) / (time - start);

    var oldStartTime = this.getPositionDate(this._oldStartPos);
    var oldEndTime = this.getPositionDate(this._oldEndPos);
    var newStartTime = this.getPositionDate(this.getSlidingWindowPos(slidingWindow));
    var newEndTime = this.getPositionDate(this.getSlidingWindowPos(slidingWindow)+this.getRectSize(slidingWindow));

    // alert peer of time range change
    var evt = new DvtOverviewEvent(DvtOverviewEvent.SUBTYPE_RANGECHANGE);
    evt.setOldSize(oldSize);
    evt.setNewSize(newSize);
    evt.setOldStartTime(oldStartTime);
    evt.setOldEndTime(oldEndTime);
    evt.setNewStartTime(newStartTime);
    evt.setNewEndTime(newEndTime);
    this.dispatchEvent(evt);
}

// scroll time axis to match sliding window
// sync all parts of overview
DvtOverview.prototype.ScrollTimeAxis = function()
{
    var slidingWindow = this.getSlidingWindow();        

    var leftHandle = this.getLeftHandle();
    var rightHandle = this.getRightHandle();
    var leftTopBar = this.getLeftTopBar();
    var rightTopBar = this.getRightTopBar();
    var bottomBar = this.getBottomBar();
    var topBar = this.getTopBar();
    
    this.setLinePos(leftHandle, this.getSlidingWindowPos(slidingWindow), this.getSlidingWindowPos(slidingWindow));
    this.setLinePos(rightHandle, this.getSlidingWindowPos(slidingWindow)+this.getSlidingWindowSize(slidingWindow), this.getSlidingWindowPos(slidingWindow)+this.getSlidingWindowSize(slidingWindow));
    this.setLinePos(leftTopBar, -1, this.getSlidingWindowPos(slidingWindow)+1);
    this.setLinePos(rightTopBar, this.getLinePos1(rightHandle)-1, -1);
    this.setLinePos(bottomBar, this.getLinePos1(leftHandle), this.getLinePos1(rightHandle));
    this.setLinePos(topBar, this.getLinePos1(leftHandle), this.getLinePos1(rightHandle));
}
/**************************end window scrolling and resizing *********************************************/

/**
 * Dispatches the event to the callback function.  This enables callback function on the peer.
 * @param {object} event The event to be dispatched.
 */
DvtOverview.prototype.dispatchEvent = function(event) 
{
    DvtEventDispatcher.dispatchEvent(this._callback, this._callbackObj, this, event);
}
/**
 * Overview JSON Parser
 * @param {DvtOverview} overview The owning Overview component.
 * @class
 * @constructor
 * @extends {DvtObj}
 */
var DvtOverviewParser = function(view) 
{
    this.Init(view);
}

DvtObj.createSubclass(DvtOverviewParser, DvtObj, "DvtOverviewParser");

DvtOverviewParser.prototype.Init = function(view) 
{
    this._view = view;
} 

/**
 * Parses the JSON object and returns the root node of the timeRangeSelector
 * @param {data} JSON object describing the component.
 * @return {object} An object containing the parsed properties
 */
DvtOverviewParser.prototype.parse = function(data) 
{
    // for now all the JSON contains should be options and no data, that could change in the future.
    var options = data;
    
    var ret = this.ParseRootAttributes(options);
    return ret;
}

/**
 * Parses the attributes on the root node.
 * @param {DvtXmlNode} xmlNode The xml node defining the root
 * @return {object} An object containing the parsed properties
 * @protected
 */
DvtOverviewParser.prototype.ParseRootAttributes = function(options) 
{
    // The object that will be populated with parsed values and returned
    var ret = new Object();

    // animation related options    
    ret.animationOnClick = options['animationOnClick'];

    if (options['startTime'] != null)
        ret.start = options['startTime'];
    if (options['endTime'] != null)
        ret.end = options['endTime'];

    // start and end time are MANDATORY and start time must be before end time
    if (ret.start == null)
        ret.start = (new Date()).getTime();
    if (ret.end == null || ret.end <= ret.start)
        ret.end = ret.start + 1000*60*60*24;

    if (options['currentTime'] != null)
        ret.currentTime = options['currentTime'];
    if (options['initialFocusTime'] != null)
        ret.initialFocusTime = options['initialFocusTime'];
    
    ret.orientation = "horizontal";
    if (options['orientation'] != null)
        ret.orientation = options['orientation'];

    ret.featuresOff = options['featuresOff'];
    ret.minimumWindowSize = options['minimumWindowSize'];
    ret.leftMargin = options['leftMargin'];
    ret.rightMargin = options['rightMargin'];
    
    // the time where the viewport of the associated view ends and the width is also MANDATORY
    if (options['viewportEndTime'] != null)
    {
        var viewportEndTime = options['viewportEndTime'];
        var viewportStartTime = ret.start;

        // if viewport start time is specified
        if (options['viewportStartTime'] != null && options['viewportStartTime'] < viewportEndTime)
            viewportStartTime = options['viewportStartTime'];

        // calculate the overall width of the container (i.e. timeline/chart)
        // if viewportEndPos wasn't specified, use width of overview, this basically assumes the width of the overview is
        // the same as the width of the view that the overview is associated with (timeline or chart)
        if (options['viewportEndPos'] != null)
            ret.width = this.calculateWidth(ret.start, ret.end, viewportStartTime, viewportEndTime, options['viewportEndPos']); 
        else
            ret.width = this.calculateWidth(ret.start, ret.end, viewportStartTime, viewportEndTime, this._view.Width); 

        ret.renderStart = viewportStartTime;
    }
    else
        ret.renderStart = ret.start;

    if (ret.width == 0)
        ret.width = 1000; // just some arbitrary default...    

    ret.overviewPosition = "below";
    ret.selectionMode = "none";
    ret.isRtl = DvtAgent.isRightToLeft(this._view.getCtx()).toString();
    if (options['rtl'] != null)
        ret.isRtl = options['rtl'].toString();

    // should come from skin
    ret.handleFillColor = "#FFFFFF";
    ret.handleTextureColor = "#B3C6DB";
    ret.windowBackgroundColor = "#FFFFFF";
    ret.windowBackgroundAlpha = 1;
    ret.windowBorderTopStyle = "solid";
    ret.windowBorderRightStyle = "solid";
    ret.windowBorderBottomStyle = "solid";
    ret.windowBorderLeftStyle = "solid";
    ret.windowBorderTopColor = "#4F4F4F";
    ret.windowBorderRightColor = "#4F4F4F";
    ret.windowBorderBottomColor = "#4F4F4F";
    ret.windowBorderLeftColor = "#4F4F4F";    
    ret.overviewBackgroundColor = "#E6ECF3";
    ret.currentTimeIndicatorColor = "#C000D1";
    ret.timeIndicatorColor = "#BCC7D2";
    ret.leftFilterPanelColor = "#FFFFFF";
    ret.leftFilterPanelAlpha = 0.7;
    ret.rightFilterPanelColor = "#FFFFFF";
    ret.rightFilterPanelAlpha = 0.7;

    // apply any styles overrides
    if (options['style'] != null)
    {
        if (options['style']['handleFillColor'] != null)
            ret.handleFillColor = options['style']['handleFillColor'];

        if (options['style']['handleTextureColor'] != null)
            ret.handleTextureColor = options['style']['handleTextureColor'];
        
        if (options['style']['handleBackgroundImage'] != null)
            ret.handleBackgroundImage = options['style']['handleBackgroundImage'];

        if (options['style']['handleWidth'] != null)
            ret.handleWidth = options['style']['handleWidth'];
        
        if (options['style']['handleHeight'] != null)
            ret.handleHeight = options['style']['handleHeight'];

        if (options['style']['windowBackgroundColor'] != null)
            ret.windowBackgroundColor = options['style']['windowBackgroundColor'];

        if (options['style']['windowBackgroundAlpha'] != null)
            ret.windowBackgroundAlpha = options['style']['windowBackgroundAlpha'];

        if (options['style']['windowBorderTopStyle'] != null)
            ret.windowBorderTopStyle = options['style']['windowBorderTopStyle'];

        if (options['style']['windowBorderRightStyle'] != null)
            ret.windowBorderRightStyle = options['style']['windowBorderRightStyle'];

        if (options['style']['windowBorderBottomStyle'] != null)
            ret.windowBorderBottomStyle = options['style']['windowBorderBottomStyle'];

        if (options['style']['windowBorderLeftStyle'] != null)
            ret.windowBorderLeftStyle = options['style']['windowBorderLeftStyle'];

        if (options['style']['windowBorderTopColor'] != null)
            ret.windowBorderTopColor = options['style']['windowBorderTopColor'];

        if (options['style']['windowBorderRightColor'] != null)
            ret.windowBorderRightColor = options['style']['windowBorderRightColor'];

        if (options['style']['windowBorderBottomColor'] != null)
            ret.windowBorderBottomColor = options['style']['windowBorderBottomColor'];

        if (options['style']['windowBorderLeftColor'] != null)
            ret.windowBorderLeftColor = options['style']['windowBorderLeftColor'];    

        if (options['style']['overviewBackgroundColor'] != null)
            ret.overviewBackgroundColor = options['style']['overviewBackgroundColor'];

        if (options['style']['currentTimeIndicatorColor'] != null)
            ret.currentTimeIndicatorColor = options['style']['currentTimeIndicatorColor'];

        if (options['style']['timeIndicatorColor'] != null)
            ret.timeIndicatorColor = options['style']['timeIndicatorColor'];

        if (options['style']['leftFilterPanelColor'] != null)
            ret.leftFilterPanelColor = options['style']['leftFilterPanelColor'];

        if (options['style']['leftFilterPanelAlpha'] != null)
            ret.leftFilterPanelAlpha = options['style']['leftFilterPanelAlpha'];

        if (options['style']['rightFilterPanelColor'] != null)
            ret.rightFilterPanelColor = options['style']['rightFilterPanelColor'];

        if (options['style']['rightFilterPanelAlpha'] != null)
            ret.rightFilterPanelAlpha = options['style']['rightFilterPanelAlpha'];
    }
    
    return ret;
}

// convinient method to calculate the width based on start time/end time and viewport end time
DvtOverviewParser.prototype.calculateWidth = function(startTime, endTime, viewportStartTime, viewportEndTime, viewportEndPos)
{
    var number = viewportEndPos * (endTime - startTime);
    var denominator = (viewportEndTime - viewportStartTime);
    if (number == 0 || denominator == 0)
        return 0;

    return number / denominator;
}
/**
 * Encapsulates an event fired by Overview
 * @param {string} type The type of event fired by Overview
 * @class
 * @constructor
 */
var DvtOverviewEvent = function(type) {
  this.Init(DvtOverviewEvent.TYPE);
  this._subtype = type;
}

DvtObj.createSubclass(DvtOverviewEvent, DvtBaseComponentEvent, "DvtOverviewEvent");

DvtOverviewEvent.TYPE = "overview";

// fired when user initiate range change
DvtOverviewEvent.SUBTYPE_PRE_RANGECHANGE = "dropCallback";

// fired when user clicks on an empty area which cause overview to scroll to where user clicks
DvtOverviewEvent.SUBTYPE_SCROLL_TIME = "scrollTime";
// fired when user scrolls the overview window
DvtOverviewEvent.SUBTYPE_SCROLL_POS = "scrollPos";
// fired when user finish scrolling the overview window
DvtOverviewEvent.SUBTYPE_SCROLL_END = "scrollEnd";
// fired when user finish resizing the overview window
DvtOverviewEvent.SUBTYPE_RANGECHANGE = "rangeChange";
// fired when user resizes the overview window
DvtOverviewEvent.SUBTYPE_RANGECHANGING = "rangeChanging";

// keys to look up value
DvtOverviewEvent.TIME_KEY = "time";
DvtOverviewEvent.POS_KEY = "pos";

DvtOverviewEvent.OLD_SIZE_KEY = "oldSize";
DvtOverviewEvent.NEW_SIZE_KEY = "newSize";
DvtOverviewEvent.OLD_START_TIME_KEY = "oldStartTime";
DvtOverviewEvent.NEW_START_TIME_KEY = "newStartTime";
DvtOverviewEvent.OLD_END_TIME_KEY = "oldEndTime";
DvtOverviewEvent.NEW_END_TIME_KEY = "newEndTime";

DvtOverviewEvent.EXPAND_KEY = "expand";
DvtOverviewEvent.END_HANDLE_KEY = "endHandle";

DvtOverviewEvent.START_POS = -1;
DvtOverviewEvent.END_POS = -2;

DvtOverviewEvent.prototype.getSubType = function() 
{
    return this._subtype;
};

/****** scroll to time **************/
DvtOverviewEvent.prototype.setTime = function(time) 
{
    this.addParam(DvtOverviewEvent.TIME_KEY, time);
}

DvtOverviewEvent.prototype.getTime = function() 
{
  return this.getParamValue(DvtOverviewEvent.TIME_KEY);
}

/*********** range change ************/
DvtOverviewEvent.prototype.setOldSize = function(oldSize) 
{
    this.addParam(DvtOverviewEvent.OLD_SIZE_KEY, oldSize);
}

DvtOverviewEvent.prototype.getOldSize = function() 
{
    return this.getParamValue(DvtOverviewEvent.OLD_SIZE_KEY);
}

DvtOverviewEvent.prototype.setNewSize = function(newSize) 
{
    this.addParam(DvtOverviewEvent.NEW_SIZE_KEY, newSize);
}

DvtOverviewEvent.prototype.getNewSize = function() 
{
    return this.getParamValue(DvtOverviewEvent.NEW_SIZE_KEY);
}

DvtOverviewEvent.prototype.setOldStartTime = function(oldStartTime) 
{
    this.addParam(DvtOverviewEvent.OLD_START_TIME_KEY, oldStartTime);
}

DvtOverviewEvent.prototype.getOldStartTime = function() 
{
    return this.getParamValue(DvtOverviewEvent.OLD_START_TIME_KEY);
}

DvtOverviewEvent.prototype.setNewStartTime = function(newStartTime) 
{
    this.addParam(DvtOverviewEvent.NEW_START_TIME_KEY, newStartTime);
}

DvtOverviewEvent.prototype.getNewStartTime = function() 
{
    return this.getParamValue(DvtOverviewEvent.NEW_START_TIME_KEY);
}

DvtOverviewEvent.prototype.setOldEndTime = function(oldEndTime) 
{
    this.addParam(DvtOverviewEvent.OLD_END_TIME_KEY, oldEndTime);
}

DvtOverviewEvent.prototype.getOldEndTime = function() 
{
    return this.getParamValue(DvtOverviewEvent.OLD_END_TIME_KEY);
}

DvtOverviewEvent.prototype.setNewEndTime = function(newEndTime) 
{
    this.addParam(DvtOverviewEvent.NEW_END_TIME_KEY, newEndTime);
}

DvtOverviewEvent.prototype.getNewEndTime = function() 
{
    return this.getParamValue(DvtOverviewEvent.NEW_END_TIME_KEY);
}

/*********** range changing ************/
DvtOverviewEvent.prototype.setExpand = function(expand) 
{
    this.addParam(DvtOverviewEvent.EXPAND_KEY, expand);
}

DvtOverviewEvent.prototype.isExpand = function() 
{
    return this.getParamValue(DvtOverviewEvent.EXPAND_KEY);
}

DvtOverviewEvent.prototype.setEndHandle = function(endHandle) 
{
    this.addParam(DvtOverviewEvent.END_HANDLE_KEY, endHandle);
}

DvtOverviewEvent.prototype.isEndHandle = function() 
{
    return this.getParamValue(DvtOverviewEvent.END_HANDLE_KEY);
}

/************* scroll to pos ***************/
DvtOverviewEvent.prototype.setPosition = function(pos) 
{
    this.addParam(DvtOverviewEvent.POS_KEY, pos);
}

DvtOverviewEvent.prototype.getPosition = function() 
{
  return this.getParamValue(DvtOverviewEvent.POS_KEY);
}
/**
 * Axis component.  This class should never be instantiated directly.  Use the
 * newInstance function instead.
 * @class
 * @constructor
 * @extends {DvtBaseComponent}
 * @export
 */
var DvtAxis = function() {}

DvtObj.createSubclass(DvtAxis, DvtBaseComponent, "DvtAxis");

/**
 * Returns a new instance of DvtAxis.
 * @param {DvtContext} context The rendering context.
 * @param {string} callback The function that should be called to dispatch component events.
 * @param {object} callbackObj The optional object instance on which the callback function is defined.
 * @return {DvtAxis}
 * @export
 */
DvtAxis.newInstance = function(context, callback, callbackObj) {
  var axis = new DvtAxis();
  axis.Init(context, callback, callbackObj);
  return axis;
}

/**
 * Returns a copy of the default options for the specified skin.
 * @param {string} skin The skin whose defaults are being returned.
 * @return {object} The object containing defaults for this component.
 * @export
 */
DvtAxis.getDefaults = function(skin) 
{  
  return (new DvtAxisDefaults()).getDefaults(skin);
}

/**
 * @override
 * @protected
 */
DvtAxis.prototype.Init = function(context, callback, callbackObj) {
  DvtAxis.superclass.Init.call(this, context, callback, callbackObj);
  
  // Create the defaults object
  this.Defaults = new DvtAxisDefaults();
  
  // Create the event handler and add event listeners
  this._eventHandler = new DvtAxisEventManager(this);
  this._eventHandler.addListeners(this);
  
  this._labelTruncationNeeded = true;
}

/**
 * Minimum buffer for horizontal axis.
 */
DvtAxis.MINIMUM_AXIS_BUFFER = 10;

/**
 * @override
 * @protected
 */
DvtAxis.prototype.SetOptions = function(options) {
  if(options) // Combine the user options with the defaults and store
    this.Options = this.Defaults.calcOptions(options);
  else if(!this.Options) // Create a default options object if none has been specified
    this.Options = this.GetDefaults();
}

/**
 * Returns the preferred dimensions for this component given the maximum available space.
 * @param {object} options The object containing specifications and data for this component.
 * @param {Number} maxWidth The maximum width available.
 * @param {Number} maxHeight The maximum height available.
 * @return {DvtDimension} The preferred dimensions for the object.
 */
DvtAxis.prototype.getPreferredSize = function(options, maxWidth, maxHeight) {
  // Update the options object.
  this.SetOptions(options);

  // Set the layout flag to indicate this is a layout pass only
  this.__getOptions()['isLayout'] = true;

  // Ask the axis to render its context in the max space and find the space used
  this.render(null, maxWidth, maxHeight);
  var dims = this.getDimensions();
  
  // Clear the rendered contents and reset state
  this.__getOptions()['isLayout'] = false;
  this.removeChildren();
  
  // Return the height needed.  Reserve the full space along the edge of the axis.
  var position = this.__getOptions()['position'];
  if(position == "top" || position == "bottom") {
    if (dims.h <= maxHeight)
      this._labelTruncationNeeded = false;
    return new DvtDimension(maxWidth, Math.min(dims.h, maxHeight));
  } else {
    // In Chrome, when getDimensioins is called on DvtAxis the width will sometimes be less the widest text element
    // that is a child of it. When we actually render text labels can get dropped or truncated incorrectly. Work around 
    // is to add 10% to the width calculated. To see this, do not add 10% to the dims.w and render a default bar graph
    // in Chrome 13.0.782.215
    var extraWidth = Math.max(1, dims.w * .1);
    if (dims.w + extraWidth <= maxWidth)
      this._labelTruncationNeeded = false;
    return new DvtDimension(Math.min(dims.w + extraWidth, maxWidth), maxHeight);
  }
}

/**
 * Renders the component at the specified size.
 * @param {object} options The object containing specifications and data for this component.
 * @param {number} width The width of the component.
 * @param {number} height The height of the component.
 * @param {x} optional x position of the component.
 * @param {y} optional y position of the component.
 * @export
 */
DvtAxis.prototype.render = function(options, width, height, x, y) 
{  
  // Update the options object.
  this.SetOptions(options);
  
  this.Width = width;
  this.Height = height;
  
  // Clear any contents rendered previously  
  this.removeChildren();
  
  // Set default values to undefined properties.
  if(!x){
   x = 0;
  }      
  
  if(!y){
   y = 0;
  } 
  
  // Render the axis
  var availSpace = new DvtRectangle(x, y, width, height);
  DvtAxisRenderer.render(this, availSpace);
}

/**
 * Processes the specified event.  
 * @param {object} event
 * @param {object} source The component that is the source of the event, if available.
 */
DvtAxis.prototype.processEvent = function(event, source) {
  // Dispatch the event to the callback if it originated from within this component.
  if(this === source) {
    this.__dispatchEvent(event);
  }
}

/**
 * Returns the evaluated options object, which contains the user specifications
 * merged with the defaults.
 * @return {object} The options object.
 */
DvtAxis.prototype.__getOptions = function() {
  return this.Options;
}

/**
 * Returns the DvtEventManager for this component.
 * @return {DvtEventManager}
 */
DvtAxis.prototype.__getEventManager = function() {
  return this._eventHandler;
}

/**
 * Returns the axisInfo for the axis
 * @return {DvtAxisInfo} the axisInfo
 */
 DvtAxis.prototype.__getInfo = function() {
   return this.Info;
 }

/**
 * Sets the object containing calculated axis information and support
 * for creating drawables.
 * @param {DvtAxisInfo} axisInfo
 */
DvtAxis.prototype.__setInfo = function(axisInfo) {
  this.Info = axisInfo;
}

/**
 * Returns whether label truncation is needed for this axis
 * @return {Boolean}
 */
DvtAxis.prototype.__isLabelTruncationNeeded = function() {
  return this._labelTruncationNeeded;
}

/**
 * Returns the axis width
 * @return {number}
 */
DvtAxis.prototype.getWidth = function() {
  return this.Width;
}

/**
 * Returns the axis height
 * @return {number}
 */
DvtAxis.prototype.getHeight = function() {
  return this.Height;
}
/**
 * Axis Constants
 * @class
 * @export
 */
var DvtAxisConstants = {};

DvtObj.createSubclass(DvtAxisConstants, DvtObj, "DvtAxisConstants");

/**
 * @const
 * @export
 */
DvtAxisConstants.TICK_LABEL = "tickLabel";

/**
 * @const
 * @export
 */
DvtAxisConstants.TITLE = "title";
/**
 * Abstact formatter for an axis label value.
 *
 * @param {object} bundle translations bundle
 * @constructor
 */
var DvtAbstractAxisValueFormatter = function (bundle) {
  this._bundle = bundle;
}

DvtObj.createSubclass(DvtAbstractAxisValueFormatter, DvtObj, "DvtAbstractAxisValueFormatter");

/**
 * Abstract method which purpose is to format given numeric value.
 * @param {number} value value to be formatted
 * @return {string} formatted value as string
 */
DvtAbstractAxisValueFormatter.prototype.format = function (value) {
}

/**
 * Returns currently used bundle
 * @protected
 * @return {object} currently used bundle
 */
DvtAbstractAxisValueFormatter.prototype.GetBundle = function () {
  return this._bundle;
}
/**
 * Default values and utility functions for component versioning.
 * @class
 * @constructor
 * @extends {DvtBaseComponentDefaults}
 */
var DvtAxisDefaults = function() {
  this.Init({'skyros': DvtAxisDefaults.VERSION_1, 'alta': DvtAxisDefaults.SKIN_ALTA});
}

DvtObj.createSubclass(DvtAxisDefaults, DvtBaseComponentDefaults, "DvtAxisDefaults");

/**
 * Contains overrides for the 'alta' skin.
 */ 
DvtAxisDefaults.SKIN_ALTA = {
  'axisLine': {'lineColor': "#9E9E9E"},
  'majorTick': {'lineColor': "rgba(196,206,215,0.4)"},
  'minorTick': {'lineColor': "rgba(196,206,215,0.2)"},
  'tickLabel': {'style': new DvtCSSStyle("font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;")},
  'titleStyle': new DvtCSSStyle("font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 12px;")
}

/**
 * Defaults for version 1.
 */ 
DvtAxisDefaults.VERSION_1 = {
  'position': null,
  'baselineScaling': "zero",
  'axisLine': {'lineColor': "#8A8DAC", 'lineWidth': 1, 'rendered': "on"},
  'majorTick': {'lineColor': "rgba(138,141,172,0.4)", 'lineWidth': 1, 'rendered': "auto", 'lineStyle': "solid"},
  'minorTick': {'lineColor': "rgba(138,141,172,0.20)", 'lineWidth': 1, 'rendered': "off", 'lineStyle': "solid"},
  'tickLabel': {
    'scaling': "auto",
    'style': new DvtCSSStyle("font-size: 11px; color: #333333;"), 'rotation': "auto", 'rendered': "on"
  },
  'titleStyle': new DvtCSSStyle("font-size: 11px; color: #737373;"), 
  
  // For group axis, an optional offset expressed as a factor of the group size.
  'startGroupOffset': 0, 'endGroupOffset': 0,
  
  //*********** Internal Attributes *************************************************//
  'layout': {
    // Gap ratio is multiplied against all gap sizes
    'gapRatio': 1.0,
    'titleGap': 4,
    'verticalAxisGap': 3,
    'horizontalAxisGap': 5
  },
  
  '_useBaselineColor': false, // when true, will render the baseline in a slightly more prominent color
  
  'isLayout': false // true if rendering for layout purposes
}

/**
 * Scales down gap sizes based on the size of the component.
 * @param {object} options The object containing options specifications for this component.
 * @param {Number} defaultSize The default gap size.
 * @return {Number} 
 */
DvtAxisDefaults.getGapSize = function(options, defaultSize) {
  return Math.ceil(defaultSize * options['layout']['gapRatio']);
}
/**
 * Event Manager for DvtAxis.
 * @param {DvtAxis} axis
 * @class
 * @extends DvtEventManager
 * @constructor
 */
var DvtAxisEventManager = function (axis) {
  this.Init(axis.getCtx(), axis.processEvent, axis);
  this._axis = axis;
};

DvtObj.createSubclass(DvtAxisEventManager, DvtEventManager, "DvtAxisEventManager");

/**
 * Returns the parameters for the DvtComponentUIEvent for an object with the specified arguments.
 * @param {string} type The type of object that was the target of the event.
 * @param {object} [id] The id of the object, if one exists.
 */
DvtAxisEventManager.getUIEventParams = function(type, id) {
  return {'type': type, 'id': id};
}

/**
 * @override
 */
DvtAxisEventManager.prototype.FireUIEvent = function(type, logicalObj) {
  if(logicalObj instanceof DvtSimpleObjPeer && logicalObj.getParams() != null) 
    this.FireEvent(new DvtComponentUIEvent(type, logicalObj.getParams()), this._axis);
}
/**
 * Renderer for DvtAxis.
 * @class
 */
var DvtAxisRenderer = new Object();

DvtObj.createSubclass(DvtAxisRenderer, DvtObj, "DvtAxisRenderer");

DvtAxisRenderer._RADIAL_LABEL_GAP = 5;

/**
 * Renders the axis and updates the available space.
 * @param {DvtAxis} axis The axis being rendered.
 * @param {DvtRectangle} availSpace The available space.
 */
DvtAxisRenderer.render = function(axis, availSpace) {
  // Calculate the axis extents and increments
  var options = axis.__getOptions();
  var axisInfo = DvtAxisInfo.newInstance(axis.getCtx(), options, availSpace);
  axis.__setInfo(axisInfo);
  
  if (options['rendered'] == "off")
    return;
  
  // Render the title
  DvtAxisRenderer._renderTitle(axis, axisInfo, availSpace);
  
  // Render the tick labels
  DvtAxisRenderer._renderLabels(axis, axisInfo, availSpace);
}

/**
 * Renders the axis title and updates the available space.
 * @param {DvtAxis} axis The axis being rendered.
 * @param {DvtAxisInfo} axisInfo The axis model.
 * @param {DvtRectangle} availSpace The available space.
 * @private
 */
DvtAxisRenderer._renderTitle = function(axis, axisInfo, availSpace) {
  var options = axis.__getOptions();  
  
  if(!options['title'])
    return;
    
  // Create the title object and add to axis
  var position = options['position'];

  if (position == "radial" || position == "tangential")
    return; // polar chart doesn't have axis titles
  
  // In layout mode, treat "bottom" as "top" for space calculation
  if(options['isLayout'] && position == "bottom")
    position = "top";
    
  var title;
  if (position == "top" || position == "bottom")
    title = DvtAxisRenderer._createText(axis.__getEventManager(), axis, options['title'], options['titleStyle'], 
                                         0, 0, availSpace.w, availSpace.h, 
                                         DvtAxisEventManager.getUIEventParams(DvtAxisConstants.TITLE));
  else 
    title = DvtAxisRenderer._createText(axis.__getEventManager(), axis, options['title'], options['titleStyle'], 
                                         0, 0, availSpace.h, availSpace.w, 
                                         DvtAxisEventManager.getUIEventParams(DvtAxisConstants.TITLE));
 
  if (title) {
    // Position the title based on text size and axis position 
    var titleDims = title.measureDimensions();
    var gap = DvtAxisDefaults.getGapSize(options, options['layout']['titleGap']);
    
    // Position the label and update the space
    if(position == "top") {
      title.setX(availSpace.x + availSpace.w/2 - titleDims.w/2); 
      title.setY(availSpace.y);
      availSpace.y += (titleDims.h + gap);
      availSpace.h -= (titleDims.h + gap);
    }
    else if(position == "bottom") {
      title.setX(availSpace.x + availSpace.w/2 - titleDims.w/2); 
      title.setY(availSpace.y + availSpace.h - titleDims.h);
      availSpace.h -= (titleDims.h + gap);
    }
    else if(position == "left") {
      title.setRotation(3*Math.PI/2);
      title.setTranslate(availSpace.x, availSpace.y + availSpace.h/2 + titleDims.w/2);
      availSpace.x += (titleDims.h + gap);
      availSpace.w -= (titleDims.h + gap);
    }
    else if(position == "right") {
      title.setRotation(Math.PI/2);
      title.setTranslate(availSpace.x + availSpace.w, availSpace.y + availSpace.h/2 - titleDims.w/2);
      availSpace.w -= (titleDims.h + gap);
    }
  }
}

/**
 * Renders the tick labels and updates the available space.
 * @param {DvtAxis} axis The axis being rendered.
 * @param {DvtAxisInfo} axisInfo The axis model.
 * @param {DvtRectangle} availSpace The available space.
 * @private
 */
DvtAxisRenderer._renderLabels = function(axis, axisInfo, availSpace) {
  var options = axis.__getOptions();
  if(options['tickLabel']['rendered'] == "on") {
    // Axis labels are positioned based on the position of the axis.  In layout
    // mode, the labels will be positioned as close to the title as possible to
    // calculate the actual space used.
    var position = options['position'];
    if(position == "top" || position == "bottom") 
      DvtAxisRenderer._renderLabelsHoriz(axis, axisInfo, availSpace);
    else if (position == "tangential")
       DvtAxisRenderer._renderLabelsTangent(axis, axisInfo, availSpace);
    else 
      DvtAxisRenderer._renderLabelsVert(axis, axisInfo, availSpace);
  }
}

/**
 * Renders tick labels for a horizontal axis and updates the available space.
 * @param {DvtAxis} axis The axis being rendered.
 * @param {DvtAxisInfo} axisInfo The axis model.
 * @param {DvtRectangle} availSpace The available space.
 * @private
 */
DvtAxisRenderer._renderLabelsHoriz = function(axis, axisInfo, availSpace) {
  // Position and add the axis labels.  
  var labels = axisInfo.getLabels(axis.getCtx());
  var isLayout = axis.__getOptions()['isLayout'];
  var maxLv1Height = 0;
  
  // For BIDI
  var isRTL = DvtAgent.isRightToLeft(axis.getCtx());
  
  for (var i=0; i<labels.length; i++) {
    var label = labels[i];
    if (label == null) 
      continue;
    
    if (axisInfo.isLabelRotated()) {
      //truncate if necesssary
      if (!isLayout && axis.__isLabelTruncationNeeded()) {
        label = DvtTextUtils.fitText(label, availSpace.h, availSpace.w, axis) ? label : null; // swap h and w
      }
      if (!label)
        continue;
      
      //position and add the axis labels
      if (!isRTL)
        label.alignRight();
      else
        label.alignLeft();
      label.setTranslateY(availSpace.y);
    
    } else { // not rotated
      label.alignTop();
      label.setY(availSpace.y);
    }  
      
    // Associate with logical object to support DvtComponentUIEvent and tooltips
    var params = DvtAxisEventManager.getUIEventParams(DvtAxisConstants.TICK_LABEL, label.getTextString());
    axis.__getEventManager().associate(label, new DvtSimpleObjPeer(label.getUntruncatedTextString(), null, null, params));    
    
    axis.addChild(label);
    maxLv1Height = Math.max(maxLv1Height, DvtTextUtils.guessTextDimensions(label).h);
  }
  
  // Render the nested labels (level 2).
  var lv2Labels = axisInfo.getLabels(axis.getCtx(), 1);
  var offset = 0;
  
  if (lv2Labels != null) {
    for(i=0; i<lv2Labels.length; i++) {
      label = lv2Labels[i];
      if (label == null) 
        continue;
      
      // Associate with logical object to support DvtComponentUIEvent and tooltips
      axis.__getEventManager().associate(label, new DvtSimpleObjPeer(null, null, null, DvtAxisEventManager.getUIEventParams(DvtAxisConstants.TICK_LABEL, label.getTextString())));    
      
      // align with level 1 label
      if (labels[i] != null)
        offset = labels[i].measureDimensions().w / 2;   
      if (isRTL) {
        label.setX(label.getX() + offset);
      } else {
        label.setX(label.getX() - offset);
      }
      
      label.alignTop();
      label.setY(availSpace.y + maxLv1Height);
      axis.addChild(label);
    }
  }
}

/**
 * Renders tick labels for a vertical axis and updates the available space.
 * @param {DvtAxis} axis The axis being rendered.
 * @param {DvtAxisInfo} axisInfo The axis model.
 * @param {DvtRectangle} availSpace The available space.
 * @private
 */
DvtAxisRenderer._renderLabelsVert = function(axis, axisInfo, availSpace) {
  var options = axis.__getOptions();
  var isLayout = options['isLayout'];
  var position = options['position'];
  var isRTL = DvtAgent.isRightToLeft(axis.getCtx());
  
  var labelX;
  if (position == "radial") {
    labelX = availSpace.x + availSpace.w/2;
    labelX += DvtAxisRenderer._RADIAL_LABEL_GAP * (isRTL ? 1 : -1);
  }
  else {  
    // All vertical axis labels are aligned to the end, unless in layout mode
    labelX = availSpace.x + availSpace.w;
    if(isLayout && position == "left")
      labelX = availSpace.x;
  }

  var formatLabelVert = function(label) {
    if (!isLayout && axis.__isLabelTruncationNeeded()) {
      label = DvtTextUtils.fitText(label, availSpace.w, availSpace.h, axis) ? label : null;
    }
    if (!label)
      return;
    
    // Associate with logical object to support DvtComponentUIEvent and tooltips
    var params = DvtAxisEventManager.getUIEventParams(DvtAxisConstants.TICK_LABEL, label.getTextString());
    axis.__getEventManager().associate(label, new DvtSimpleObjPeer(label.getUntruncatedTextString(), null, null, params));  
      
    label.setX(labelX);
    label.alignRight();
    axis.addChild(label);

    if (position == "radial") {
      label.setY(availSpace.y + availSpace.h/2 - label.getY());
      if (isRTL)
        label.alignLeft(); // TODO: should be alignEnd and repositioned!
    }

    if(isLayout && position == "left")
      label.alignLeft();
  }
  
  // Position and add the axis labels (level 1).  
  var labels = axisInfo.getLabels(axis.getCtx());
  for(var i=0; i<labels.length; i++) {
    var label = labels[i];
    if (label != null)
      formatLabelVert(label);
  }
  
  // Render the nested labels (level 2).
  var lv2Labels = axisInfo.getLabels(axis.getCtx(), 1);
  if (lv2Labels != null) {  
    for(i=0; i<lv2Labels.length; i++) {
      label = lv2Labels[i];
      if (label != null)
        formatLabelVert(label);
    }
  }
}

/**
 * Renders tick labels for a tangential axis and updates the available space.
 * @param {DvtAxis} axis The axis being rendered.
 * @param {DvtAxisInfo} axisInfo The axis model.
 * @param {DvtRectangle} availSpace The available space.
 * @private
 */
DvtAxisRenderer._renderLabelsTangent = function(axis, axisInfo, availSpace) {
  var labels = axisInfo.getLabels(axis.getCtx());
  for(var i=0; i<labels.length; i++) {
    var label = labels[i];
    if (label != null) {
      // TODO: fit text
      var textBefore = label.getTextString();

      // Associate with logical object to support DvtComponentUIEvent and tooltips
      var params = DvtAxisEventManager.getUIEventParams(DvtAxisConstants.TICK_LABEL, textBefore);
      var tooltip = label.isTruncated() ? textBefore : null;
      axis.__getEventManager().associate(label, new DvtSimpleObjPeer(tooltip, null, null, params)); 

      label.setTranslateX(availSpace.x + availSpace.w/2);
      label.setTranslateY(availSpace.y + availSpace.h/2);
      axis.addChild(label);
    }
  }
}

/**
 * Creates and adds a DvtText object to a container. Will truncate and add tooltip as necessary.
 * @param {DvtEventManager} eventManager
 * @param {DvtContainer} container The container to add the text object to.
 * @param {String} textString The text string of the text object.
 * @param {DvtCSSStyle} cssStyle The css style to apply to the text object.
 * @param {number} x The x coordinate of the text object.
 * @param {number} y The y coordinate of the text object.
 * @param {number} width The width of available text space.
 * @param {number} height The height of the available text space.
 * @param {object} params Additional parameters that will be passed to the logical object.
 * @return {DvtOutputText} The created text object. Can be null if no text object could be created in the given space.
 */  
DvtAxisRenderer._createText = function(eventManager, container, textString, cssStyle, x, y, width, height, params) {
  var text = new DvtOutputText(container.getCtx(), textString, x, y);
  text.setCSSStyle(cssStyle);
  if (DvtTextUtils.fitText(text, width, height, container)) {
    // Associate with logical object to support DvtComponentUIEvent and truncation
    eventManager.associate(text, new DvtSimpleObjPeer(text.getUntruncatedTextString(), null, null, params));
    return text;
  }
  else
    return null;
}

/**
 * Calculated axis information and drawable creation.  This class should
 * not be instantiated directly.
 * @class
 * @constructor
 * @extends {DvtObj}
 */
var DvtAxisInfo = function() {}

DvtObj.createSubclass(DvtAxisInfo, DvtObj, "DvtAxisInfo");

/**
 * Creates an appropriate instance of DvtAxisInfo with the specified parameters.
 * @param {DvtContext} context
 * @param {object} options The object containing specifications and data for this component.
 * @param {DvtRectangle} availSpace The available space.
 * @return {DvtAxisInfo}
 */
DvtAxisInfo.newInstance = function(context, options, availSpace) {
  if(options['timeAxisType'] && options['timeAxisType'] != "disabled")
    return new DvtTimeAxisInfo(context, options, availSpace);
  else if(isNaN(options['dataMin']) && isNaN(options['dataMax']))
    return new DvtGroupAxisInfo(context, options, availSpace);
  else
    return new DvtDataAxisInfo(context, options, availSpace);
}

/**
 * Calculates and stores the axis information.
 * @param {DvtContext} context
 * @param {object} options The object containing specifications and data for this component.
 * @param {DvtRectangle} availSpace The available space.
 * @protected
 */
DvtAxisInfo.prototype.Init = function(context, options, availSpace) {
  this._context = context;

  // Figure out the start and end coordinate of the axis
  this.Position = options['position'];
  this._radius = options['_radius']; // for polar charts

  if(this.Position == "top" || this.Position == "bottom") {
    this.StartCoord = availSpace.x;
    this.EndCoord = availSpace.x + availSpace.w;
  }
  else if(this.Position == "left" || this.Position == "right") {
    this.StartCoord = availSpace.y;
    this.EndCoord = availSpace.y + availSpace.h;
  }
  else if(this.Position == "radial") {
    this.StartCoord = 0;
    this.EndCoord = this._radius;
  }
  else if(this.Position == "tangential") {
    if(DvtAgent.isRightToLeft(context)) {
      this.StartCoord = 2 * Math.PI;
      this.EndCoord = 0;
    }
    else {
      this.StartCoord = 0;
      this.EndCoord = 2 * Math.PI;
    }
  }
  
  // Axis min and max value. Subclasses should set.
  this.MinValue = null;
  this.MaxValue = null;
  this.GlobalMin = null;
  this.GlobalMax = null;
  this.DataMin = null;
  this.DataMax = null;
  
  // Set the maximum zoom for this axis
  this.MinViewportExtent = null;
  
  // The overflows at the two ends of the axis
  this.StartOverflow = 0;
  this.EndOverflow = 0;
  
  // Sets the buffers (the maximum amount the labels can go over before they overflow)
  if (options['leftBuffer'] == null)
    options['leftBuffer'] = Infinity;
  if (options['rightBuffer'] == null)
    options['rightBuffer'] = Infinity;
  
  // Store the options object
  this.Options = options;
}

/**
 * Returns the DvtContext associated with this instance.
 * @return {DvtContext}
 */
DvtAxisInfo.prototype.getCtx = function() {
  return this._context;
}

/**
 * Returns the options settings for the axis.
 * @return {object} The options for the axis.
 */
DvtAxisInfo.prototype.getOptions = function() {
  return this.Options;
}

/**
 * Returns an array containing the tick labels for this axis.
 * @param {DvtContext} context
 * @param {Number} levelIdx The level index (optional). 0 indicates the first level, 1 the second, etc. If skipped, 0 (the first level) is assumed.
 * @return {Array} The Array of DvtText objects.
 */
DvtAxisInfo.prototype.getLabels = function(context, levelIdx) {
  return null; // subclasses should override
}

/**
 * Returns the axis line for this axis.
 * @param {DvtContext} context
 * @return {DvtLine} The axis line.
 */
DvtAxisInfo.prototype.getAxisLine = function(context) {
  return null; // subclasses should override
}

/**
 * Returns an array containing the majorTick grid lines for this axis.  Objects
 * are returned in the desired z-order.
 * @param {DvtContext} context
 * @return {Array} The Array of DvtLine objects.
 */
DvtAxisInfo.prototype.getMajorGridLines = function(context) {
  return []; // subclasses should override
}

/**
 * Returns an array containing the minorTick grid lines for this axis.  Objects
 * are returned in the desired z-order.
 * @param {DvtContext} context
 * @return {Array} The Array of DvtLine objects.
 */
DvtAxisInfo.prototype.getMinorGridLines = function(context) {
  return []; // subclasses should override
}

/**
 * Returns the value for the specified coordinate along the axis.  Returns null
 * if the coordinate is not within the axis.
 * @param {number} coord The coordinate along the axis.
 * @return {object} The value at that coordinate.
 */
DvtAxisInfo.prototype.getValueAt = function(coord) {
  return null; // subclasses should override
}

/**
 * Returns the coordinate for the specified value.  Returns null if the value is
 * not within the axis.
 * @param {object} value The value to locate.
 * @return {number} The coordinate for the value.
 */
DvtAxisInfo.prototype.getCoordAt = function(value) {
  return null; // subclasses should override
}

/**
 * Returns the value for the specified coordinate along the axis.  If a coordinate
 * is not within the axis, returns the value of the closest coordinate within the axis.
 * @param {number} coord The coordinate along the axis.
 * @return {object} The value at that coordinate.
 */
DvtAxisInfo.prototype.getBoundedValueAt = function(coord) {
  return null; // subclasses should override
}

/**
 * Returns the coordinate for the specified value along the axis.  If a value
 * is not within the axis, returns the coordinate of the closest value within the axis.
 * @param {object} value The value to locate.
 * @return {number} The coordinate for the value.
 */
DvtAxisInfo.prototype.getBoundedCoordAt = function(value) {
  return null; // subclasses should override
}

/**
 * Returns the value for the specified coordinate along the axis.
 * @param {number} coord The coordinate along the axis.
 * @return {object} The value at that coordinate.
 */
DvtAxisInfo.prototype.getUnboundedValueAt = function(coord) {
  return null; // subclasses should override
}

/**
 * Returns the coordinate for the specified value.
 * @param {object} value The value to locate.
 * @return {number} The coordinate for the value.
 */
DvtAxisInfo.prototype.getUnboundedCoordAt = function(value) {
  return null; // subclasses should override
}

/**
 * Returns the baseline coordinate for the axis, if applicable.
 * @return {number} The baseline coordinate for the axis.
 */
DvtAxisInfo.prototype.getBaselineCoord = function() {
  return null;
}

/**
 * Returns if the labels of the horizontal axis are rotated by 90 degrees.
 * @return {boolean} Whether the labels are rotated.
 */
DvtAxisInfo.prototype.isLabelRotated = function() {
  return false;
}

/**
 * Creates a DvtText instance for the specified text label.
 * @param {DvtContext} context
 * @param {string} label The label string.
 * @param {number} coord The coordinate for the text.
 * @return {DvtOutputText} 
 * @protected
 */
DvtAxisInfo.prototype.CreateLabel = function(context, label, coord) {
  var text;
  
  if (this.Position == "tangential") {
    var vTol = 16/180 * Math.PI; // the mid area (15 degrees) where labels will be middle aligned.
    var hTol = 1/180 * Math.PI; // the tolerance (1 degree) where labels will be center aligned.
    
    var dist = this._radius + 5;
    if (coord < hTol || coord > 2*Math.PI - hTol)
      dist += 5; // avoild collision with radial label
    text = new DvtOutputText(context, label, dist * Math.sin(coord), -dist * Math.cos(coord));
    
    // Align the label according to the angular position
    if (coord < hTol || Math.abs(coord-Math.PI) < hTol || coord > 2*Math.PI - hTol)
      text.alignCenter();
    else if (coord < Math.PI)
      text.alignLeft();
    else
      text.alignRight();

    if (Math.abs(coord-Math.PI/2) < vTol || Math.abs(coord-3*Math.PI/2) < vTol)
      text.alignMiddle();
    else if (coord < Math.PI/2 || coord > 3*Math.PI/2)
      text.alignBaseline();
    else
      text.alignTop();
  }
  else {
    text = new DvtOutputText(context, label, coord, coord);
    text.alignMiddle();
    text.alignCenter();
  }

  text.setCSSStyle(this.Options['tickLabel']['style']);
  return text;
}

/**
 * Gets the points array for a polygon with n sides and radius r.
 * @param {number} n The number of sides.
 * @param {number} r the radius (distance from center to vertex).
 * @return {array} Points array.
 * @private
 */
DvtAxisInfo.getPolygonPoints = function(n, r) {
  var points = [];
  var angle;
  for (var i = 0; i < n; i++) {
    angle = i / n * 2 * Math.PI;
    points.push(r * Math.sin(angle), -r * Math.cos(angle))
  }
  return points;
}

/**
 * Creates a DvtShape instance with the specified stroke and coordinate.
 * @param {DvtContext} context
 * @param {DvtSolidStroke} stroke The stroke for the grid line.
 * @param {number} coord The coordinate for the grid line.
 * @return {DvtShape} 
 * @protected
 */
DvtAxisInfo.prototype.CreateGridLine = function(context, stroke, coord) {
  var line;
  if (this.Position == "radial") {
    if (this.Options['majorTick']['gridType'] == "straight") {
      var points = DvtAxisInfo.getPolygonPoints(this.Options['_numGroups'], coord);
      line = new DvtPolygon(context, points);
    }
    else
      line = new DvtCircle(context, 0, 0, coord);
    line.setInvisibleFill();
  }
  else if (this.Position == "tangential")
    line = new DvtLine(context, 0, 0, this._radius * Math.sin(coord), -this._radius * Math.cos(coord));
  else {
    line = new DvtLine(context, coord, coord, coord, coord);
    if (!DvtAgent.isTouchDevice() || DvtAgent.getDevicePixelRatio() > 1)
      line.setPixelHinting(true);
  }
  line.setStroke(stroke);
  line.setMouseEnabled(false);
  return line;
}

/**
 * Checks all the labels for the axis and returns whether they overlap.
 * @param {Array} labelDims An array of DvtRectangle objects that describe the x, y, height, width of the axis labels.
 * @param {number} skippedLabels The number of labels to skip. If skippedLabels is 1 then every other label will be skipped.
 * @return {boolean} True if any labels overlap.
 * @protected
 */
DvtAxisInfo.prototype.IsOverlapping = function(labelDims, skippedLabels) {
  // If there are no labels, return
  if(!labelDims || labelDims.length <= 0)
    return false;
  
  // Get font-size of label and create gap based on font-size
  // GroupAxis and TimeAxis have smaller gaps since these axes become less useable as more labels are dropped
  var fontSize = parseInt(this.Options['tickLabel']['style'].getStyle('font-size'));
  var gapHoriz = (this instanceof DvtDataAxisInfo) ? fontSize * 0.55 : fontSize * 0.3;
  var gapVert = (this instanceof DvtDataAxisInfo) ? fontSize * 0.35 : fontSize * 0.1;

  var isVert = (this.Position == "left" || this.Position == "right" || this.Position == "radial");
  var gap = (isVert || this.isLabelRotated()) ? gapVert : gapHoriz;

  var isRTL = DvtAgent.isRightToLeft(this.getCtx());
  
  var pointA1, pointA2, pointB1, pointB2;
  for (var j=0; j<labelDims.length; j+= skippedLabels+1) {
    if (labelDims[j] == null)
      continue;
    
    if (pointA1 == null || pointA2 == null) {
      // Set the first points
      if (isVert) {
        pointA1 = labelDims[j].y;
        pointA2 = labelDims[j].y + labelDims[j].h;
      } else {
        pointA1 = labelDims[j].x;
        pointA2 = labelDims[j].x + labelDims[j].w;
      }
      continue;
    }
    
    if (isVert) {
      pointB1 = labelDims[j].y;
      pointB2 = labelDims[j].y + labelDims[j].h;
      
      // Broken apart for clarity, next label may be above or below
      if(pointB1 >= pointA1 && pointB1 - gap < pointA2) // next label below
        return true;
      else if(pointB1 < pointA1 && pointB2 + gap > pointA1) // next label above
        return true;
    } 
    else {
      pointB1 = labelDims[j].x;
      pointB2 = labelDims[j].x + labelDims[j].w;
      
      // Broken apart for clarity, next label is on the right for non-BIDI, left for BIDI
      if(!isRTL && (pointB1 - gap < pointA2))
        return true;
      else if(isRTL && (pointB2 + gap > pointA1))
        return true;
    }
    
    // Otherwise start evaluating from label j
    pointA1 = pointB1;
    pointA2 = pointB2;
  }
  return false;
}

/**
 * Checks the labels for the axis and skips them as necessary.
 * @param {Array} labels An array of DvtText labels for the axis.
 * @param {Array} labelDims An array of DvtRectangle objects that describe the x, y, height, width of the axis labels.
 * @return {Array} The array of DvtText labels for the axis.
 * @protected
 */
DvtAxisInfo.prototype.SkipLabels = function(labels, labelDims) {
  var skippedLabels = 0;
  var bOverlaps = this.IsOverlapping(labelDims, skippedLabels);
  while (bOverlaps) {
    skippedLabels++;
    bOverlaps = this.IsOverlapping(labelDims, skippedLabels);
  }

  if (skippedLabels > 0) {
    var renderedLabels = [];
    for (var j=0; j<labels.length; j+= skippedLabels+1) {
      renderedLabels.push(labels[j]);
    }
    return renderedLabels;
  } else {
    return labels
  }
}

/**
 * Returns an array of DvtRectangle objects that describe the x, y, width, height of the axis labels.
 * @param {Array} labels An array of DvtText labels for the axis.
 * @param {DvtContainer} container
 * @return {Array} An array of DvtRectangle objects
 * @protected
 */
DvtAxisInfo.prototype.GetLabelDims = function(labels, container) {
  var labelDims = [];
  
  // Get the text dimensions
  for(var i=0; i<labels.length; i++) {
    var text = labels[i];
    if (text == null) {
      labelDims.push(null);
    } else {
      var dims = text.measureDimensions(container);
      labelDims.push(dims);
    }
  }
  
  return labelDims;
}

/**
 * Returns an array of DvtRectangle objects that contains a conservative guess the x, y, width, height of the axis labels.
 * Assumes that the labels are center-middle aligned.
 * @param {Array} labels An array of DvtText labels for the axis.
 * @param {DvtContainer} container
 * @param {Number} fudgeFactor (optional) A factor the would be multiplied to the text width. If not provided, assumed to be 1.
 * @return {Array} An array of DvtRectangle objects
 * @protected
 */
DvtAxisInfo.prototype.GuessLabelDims = function(labels, container, fudgeFactor) {
  var labelDims = [];
  if (typeof fudgeFactor == 'undefined')
    fudgeFactor = 1;
  
  // Get the text dimensions
  for(var i=0; i<labels.length; i++) {
    var text = labels[i];
    if (text == null) {
      labelDims.push(null);
    } else { 
      // get a conservative estimate of the dimensions
      container.addChild(text);
      var estimatedSize = DvtTextUtils.guessTextDimensions(text);
      var estW = estimatedSize.w * fudgeFactor;
      var estH = estimatedSize.h;
      container.removeChild(text);
      
      var dims;
      if (this.isLabelRotated()) {
        dims = new DvtRectangle(text.getTranslateX() - estH/2, text.getTranslateY() - estW/2, estH, estW);
      } else {
        dims = new DvtRectangle(text.getX() - estW/2, text.getY() - estH/2, estW, estH);
      }
      labelDims.push(dims);
    }
  }
  
  return labelDims;
}

/**
 * Returns the number of major tick counts for the axis.
 * @return {number} The number of major tick counts.
 */
DvtAxisInfo.prototype.getMajorTickCount = function() {
   return null; // subclasses that allow major gridlines should implement
}

/**
 * Sets the number of major tick counts for the axis.
 * @param {number} count The number of major tick counts.
 */
DvtAxisInfo.prototype.setMajorTickCount = function(count) {
  // subclasses that allow major gridlines should implement
}

/**
 * Returns the number of minor tick counts for the axis.
 * @return {number} The number of minor tick counts.
 */
DvtAxisInfo.prototype.getMinorTickCount = function() {
   return null; // subclasses that allow minor gridlines should implement
}

/**
 * Sets the number of minor tick counts for the axis.
 * @param {number} count The number of minor tick counts.
 */
DvtAxisInfo.prototype.setMinorTickCount = function(count) {
  // subclasses that allow minor gridlines should implement
}

/**
 * Returns the major increment for the axis.
 * @return {number} The major increment.
 */
DvtAxisInfo.prototype.getMajorIncrement = function() {
   return null; // subclasses that allow major gridlines should implement
}

/**
 * Returns the minor increment for the axis.
 * @return {number} The minor increment.
 */
DvtAxisInfo.prototype.getMinorIncrement = function() {
   return null; // subclasses that allow minor gridlines should implement
}

/**
 * Returns the global min value of the axis.
 * @return {number} The global min value.
 */
DvtAxisInfo.prototype.getGlobalMin = function() {
   return this.GlobalMin;
}

/**
 * Returns the global max value of the axis.
 * @return {number} The global max value.
 */
DvtAxisInfo.prototype.getGlobalMax = function() {
   return this.GlobalMax;
}

/**
 * Returns the viewport min value of the axis.
 * @return {number} The viewport min value.
 */
DvtAxisInfo.prototype.getViewportMin = function() {
   return this.MinValue;
}

/**
 * Returns the viewport max value of the axis.
 * @return {number} The viewport max value.
 */
DvtAxisInfo.prototype.getViewportMax = function() {
   return this.MaxValue;
}

/**
 * Returns the data min value of the axis.
 * @return {number} The data min value.
 */
DvtAxisInfo.prototype.getDataMin = function() {
   return this.DataMin;
}

/**
 * Returns the data max value of the axis.
 * @return {number} The data max value.
 */
DvtAxisInfo.prototype.getDataMax = function() {
   return this.DataMax;
}

/**
 * Returns the minimum extent of the axis, i.e. the (minValue-maxValue) during maximum zoom.
 * @return {number} The minimum extent.
 */
DvtAxisInfo.prototype.getMinimumExtent = function() {
  return 0;
}

/**
 * Returns how much the axis labels overflow over the start coord.
 * @return {number}
 */
DvtAxisInfo.prototype.getStartOverflow = function() {
  return this.StartOverflow;
}

/**
 * Returns how much the axis labels overflow over the end coord.
 * @return {number}
 */
DvtAxisInfo.prototype.getEndOverflow = function() {
  return this.EndOverflow;
}
/**
 * Calculated axis information and drawable creation for a data axis.
 * @param {DvtContext} context
 * @param {object} options The object containing specifications and data for this component.
 * @param {DvtRectangle} availSpace The available space.
 * @class
 * @constructor
 * @extends {DvtAxisInfo}
 */
var DvtDataAxisInfo = function(context, options, availSpace) {
  this.Init(context, options, availSpace);
}

DvtObj.createSubclass(DvtDataAxisInfo, DvtAxisInfo, "DvtDataAxisInfo");

DvtDataAxisInfo._MAX_NUMBER_OF_GRIDS_AUTO = 10;
DvtDataAxisInfo._MINOR_TICK_COUNT = 2;
DvtDataAxisInfo._MAX_ZOOM_FACTOR = 64;


/**
 * @override
 */
DvtDataAxisInfo.prototype.Init = function(context, options, availSpace) {
  DvtDataAxisInfo.superclass.Init.call(this, context, options, availSpace);

  // Figure out the coords for the min/max values
  if(this.Position == "top" || this.Position == "bottom") {
    // Provide at least the minimum buffer at each side to accommodate labels
    if (options['tickLabel']['rendered'] == "on") {
      this.StartOverflow = Math.max(DvtAxis.MINIMUM_AXIS_BUFFER - options['leftBuffer'], 0);
      this.EndOverflow = Math.max(DvtAxis.MINIMUM_AXIS_BUFFER - options['rightBuffer'], 0);
    }
    
    // Axis is horizontal, so flip for BIDI if needed
    if(DvtAgent.isRightToLeft(context)) {
      this._minCoord = this.EndCoord - this.EndOverflow;
      this._maxCoord = this.StartCoord + this.StartOverflow;
    }
    else {
      this._minCoord = this.StartCoord + this.StartOverflow;
      this._maxCoord = this.EndCoord - this.EndOverflow;
    }
  }
  else if(this.Position == "tangential" || this.Position == "radial") {
    this._minCoord = this.StartCoord;
    this._maxCoord = this.EndCoord;
  }
  else {
    this._minCoord = this.EndCoord;
    this._maxCoord = this.StartCoord;
  }

  this.GlobalMin = options['min'];
  this.GlobalMax = options['max'];
  this.MinValue = options['viewportMin'] == null ? this.GlobalMin : options['viewportMin'];
  this.MaxValue = options['viewportMax'] == null ? this.GlobalMax : options['viewportMax'];
  
  this._majorIncrement = options['step'];
  this._minorIncrement = options['minorStep'];
  this._minMajorIncrement = options['minStep'];
  this._converter = null;
  if (options['tickLabel'] != null) {
    this._converter = options['tickLabel']['converter'];
  }
  
  this.DataMin = options['dataMin'];
  this.DataMax = options['dataMax']
  this._calcAxisExtents();
}

/**
 * Returns the value correspoding to the first tick label (or gridline) of the axis.
 * @return {number} The value of the min label.
 */
DvtDataAxisInfo.prototype.getMinLabel = function() {
  if (this.Options['baselineScaling'] == 'zero' || (this.Options['_continuousExtent'] == "on" && this.Options['min'] == null)) {
    // the tickLabels and gridlines should be at integer intervals from zero
    return Math.ceil(this.MinValue/this._majorIncrement) * this._majorIncrement;
  } else {  
    // the tickLabels and gridlines should be at integer intervals from the globalMin
    return Math.ceil((this.MinValue-this.GlobalMin)/this._majorIncrement) * this._majorIncrement + this.GlobalMin;
  }
}

/**
 * @override
 */
DvtDataAxisInfo.prototype.getLabels = function(context, levelIdx) {
  if (levelIdx && levelIdx > 0) // data axis has only one level
    return null;

  var labels = [];
  var labelDims = [];
  var container = context.getStage();
  var isTangential = this.Position == "tangential";
  
  // when scaling is set then init formatter
  if(this.Options['tickLabel'] && this.Options['tickLabel']['scaling']){
    var autoPrecision = this.Options['tickLabel']['autoPrecision'] ? this.Options['tickLabel']['autoPrecision'] : 'on';
    this._axisValueFormatter = new DvtLinearScaleAxisValueFormatter(this.MinValue, this.MaxValue, this._majorIncrement, this.Options['tickLabel']['scaling'], autoPrecision);
  }
  
  // Iterate on an integer to reduce rounding error.  We use <= since the first
  // tick is not counted in the tick count.
  for(var i=0; i<=this._majorTickCount; i++) {
    var value = i*this._majorIncrement + this.getMinLabel();
    if (isTangential && value == this.MaxValue)
      continue; // the last label of tangential axis is skipped bc it overlaps the first.
    var label = this._formatValue(value);
    var coord = this.getUnboundedCoordAt(value);
    var text = this.CreateLabel(context, label, coord);
    labels.push(text);
  }
  
  if(!isTangential) {
    labelDims = this.GetLabelDims(labels, container);
    labels = this.SkipLabels(labels, labelDims);
  }

  return labels;
}

/**
 * @override
 */
DvtDataAxisInfo.prototype.getAxisLine = function(context) {
  var axisLineOptions = this.Options['axisLine'];
  if(axisLineOptions['rendered'] == "on") {
    // TODO hzhang Check Axis Line behavior for negative/mixed axes.
    var axisLineStroke = new DvtSolidStroke(axisLineOptions['lineColor'], 1, axisLineOptions['lineWidth']);
    return this.CreateGridLine(context, axisLineStroke, this._maxCoord);
  }
  else 
    return null;
}

/**
 * @override
 */
DvtDataAxisInfo.prototype.getMajorGridLines = function(context) {
  var gridlines = [];
  // Major Ticks
  var coord, line;
  
  var majorTickOptions = this.Options['majorTick'];
  if(majorTickOptions['rendered'] == "off")
    return gridlines;
    
  var majorTickStroke = new DvtSolidStroke(majorTickOptions['lineColor'], 1, majorTickOptions['lineWidth']);
  if(majorTickOptions['lineStyle'])
    majorTickStroke.setStyle(DvtStroke.convertTypeString(majorTickOptions['lineStyle']));
    
  var baselineStroke = majorTickStroke.clone();
  if(this.Options['_useBaselineColor']) {
    // Derive the baseline color from the axis line color and major tick color
    var axisLineColor = this.Options['axisLine']['lineColor'];
    var baselineColor = DvtColorUtils.setAlpha(axisLineColor, 0.75);
    baselineStroke.setColor(baselineColor);
  }
    
  // Iterate on an integer to reduce rounding error.  We use <= since the first
  // tick is not counted in the tick count.
  for(var i=0; i<=this._majorTickCount; i++) {
    var value = i*this._majorIncrement + this.getMinLabel();
    if (this.Position == "tangential" && value == this.MaxValue)
      continue;
    var stroke = (value == 0) ? baselineStroke : majorTickStroke;
    coord = this.getUnboundedCoordAt(value);
    line = this.CreateGridLine(context, stroke, coord);
    gridlines.push(line);
  }
  
  return gridlines;
}

/**
 * @override
 */
DvtDataAxisInfo.prototype.getMinorGridLines = function(context) {
  var gridlines = [];
  // Minor Ticks
  var coord, line;

  var minorTickOptions = this.Options['minorTick'];
  if(minorTickOptions['rendered'] != "on")
    return gridlines;
  
  var minorTickStroke = new DvtSolidStroke(minorTickOptions['lineColor'], 1, minorTickOptions['lineWidth']);
  if(minorTickOptions['lineStyle'])
    minorTickStroke.setStyle(DvtStroke.convertTypeString(minorTickOptions['lineStyle']));
    
  // Iterate on an integer to reduce rounding error.  We use <= since the first
  // tick is not counted in the tick count.
  // Start from i=-1 so that minorTicks that should get rendered before the first majorTick are evaluated
  for(var i=-1; i<=this._majorTickCount; i++) {
    var value = i*this._majorIncrement + this.getMinLabel();
    for (var j=1; j<this._minorTickCount; j++) {
      var minorValue = value+(j*this._minorIncrement);
      if(minorValue > this.MaxValue)
        break;
      if(minorValue < this.MinValue)
        continue;        
      coord = this.getUnboundedCoordAt(minorValue);
      line = this.CreateGridLine(context, minorTickStroke, coord);
      gridlines.push(line);
    }
  }
  return gridlines;
}

/**
 * @override
 */
DvtDataAxisInfo.prototype.getValueAt = function(coord) {
  var minCoord = Math.min(this._minCoord, this._maxCoord);
  var maxCoord = Math.max(this._minCoord, this._maxCoord);
  
  // Return null if the coord is outside of the axis
  if(coord < minCoord || coord > maxCoord)
    return null;

  return this.getUnboundedValueAt(coord);
}

/**
 * @override
 */
DvtDataAxisInfo.prototype.getCoordAt = function(value) {
  // Return null if the value is outside of the axis
  if(value < this.MinValue || value > this.MaxValue)
    return null;

  return this.getUnboundedCoordAt(value);
}

/**
 * @override
 */
DvtDataAxisInfo.prototype.getBoundedValueAt = function(coord) {
  var minCoord = Math.min(this._minCoord, this._maxCoord);
  var maxCoord = Math.max(this._minCoord, this._maxCoord);

  if(coord < minCoord)
    coord = minCoord;
  else if(coord > maxCoord)
    coord = maxCoord;

  return this.getUnboundedValueAt(coord);
}

/**
 * @override
 */
DvtDataAxisInfo.prototype.getBoundedCoordAt = function(value) {
  if(value < this.MinValue)
    value = this.MinValue;
  else if(value > this.MaxValue)
    value = this.MaxValue;

  return this.getUnboundedCoordAt(value);
}

/**
 * @override
 */
DvtDataAxisInfo.prototype.getUnboundedValueAt = function(coord) {
  var ratio = (coord - this._minCoord)/(this._maxCoord - this._minCoord);
  return this.MinValue + (ratio * (this.MaxValue - this.MinValue));
}

/**
 * @override
 */
DvtDataAxisInfo.prototype.getUnboundedCoordAt = function(value) {
  var ratio = (value - this.MinValue)/(this.MaxValue - this.MinValue);
  return this._minCoord + (ratio * (this._maxCoord - this._minCoord));
}

/**
 * @override
 */
DvtDataAxisInfo.prototype.getBaselineCoord = function() {
  // First find the value of the baseline
  var baseline = 0;
  if(this.MaxValue < 0)
    baseline = this.MaxValue;
  else if(this.MinValue > 0)
    baseline = this.MinValue;
    
  // Return its coordinate
  return this.getCoordAt(baseline);
}

/**
 * @private
 */
DvtDataAxisInfo.prototype._formatValue = function(value) {
  
  if (this._converter && this._converter.getAsString) {
    if (this._axisValueFormatter)
      return this._axisValueFormatter.format(value, this._converter);
    else
      return this._converter.getAsString(value);
  } 
  else if (this._converter && this._converter['format'])
    return this._converter['format'](value);
    
  else if (this._axisValueFormatter) 
    return this._axisValueFormatter.format(value);    
    
  else {
    // set the # of decimals of the value to the # of decimals of the major increment
    var t = Math.log(this._majorIncrement) / Math.log(10);
    var decimals = Math.max(Math.ceil(-t), 0);
    return value.toFixed(decimals);
  }
}

/**
 * Determines the number of major and minor tick counts and increments for the axis if values were not given.
 * The default minor tick count is 2.
 * @param {number} scaleUnit The scale unit of the axis.
 * @private
 */
DvtDataAxisInfo.prototype._calcMajorMinorIncr = function(scaleUnit) {
  this._majorIncrement = this._majorIncrement ? this._majorIncrement : scaleUnit;
  if(this._minMajorIncrement != null && this._majorIncrement < this._minMajorIncrement)
    this._majorIncrement = this._minMajorIncrement;
  
  this._majorTickCount = (this.MaxValue - this.getMinLabel())/this._majorIncrement;
  
  if (this._minorIncrement != null && this._majorIncrement/this._minorIncrement >= 2) {
    this._minorTickCount = this._majorIncrement/this._minorIncrement;
  } else {
    this._minorTickCount = DvtDataAxisInfo._MINOR_TICK_COUNT;
    this._minorIncrement = this._majorIncrement/this._minorTickCount;
  }
}

/**
 * Determines the axis extents based on given start and end value
 * or calculated from the min and max data values of the chart.
 * @private
 */
DvtDataAxisInfo.prototype._calcAxisExtents = function() {
  var zeroBaseline = this.Options['baselineScaling'] == "zero";
  var continuousExtent = this.Options['_continuousExtent'] == "on";
  
  // Include 0 in the axis if we're scaling from the baseline
  if(zeroBaseline) {
    this.DataMin = Math.min(0, this.DataMin);
    this.DataMax = Math.max(0, this.DataMax);
  }
  
  var scaleUnit = this._calcAxisScale((this.GlobalMin != null ? this.GlobalMin : this.DataMin), 
                                      (this.GlobalMax != null ? this.GlobalMax : this.DataMax));
                   
  // If there's only a single value on the axis, we need to adjust the
  // this.DataMin and this.DataMax to produce a nice looking axis with around 10 ticks.
  if(this.DataMin == this.DataMax) {
    scaleUnit = Math.pow(10, Math.floor(Math.log(this.DataMin)/Math.LN10)-1);
    this.DataMin -= 3*scaleUnit;
    this.DataMax += 2*scaleUnit;
  }
  
  // Set the default global min
  if (this.GlobalMin == null) {
    if (zeroBaseline && this.DataMin >= 0) {
      this.GlobalMin = 0;
    } else if (continuousExtent) { // allow smooth pan/zoom transition
      this.GlobalMin = this.DataMin - (this.DataMax - this.DataMin) * 0.1;
      if (this.DataMin >= 0)
        this.GlobalMin = Math.max(this.GlobalMin, 0);
    } else if (!zeroBaseline && this.GlobalMax != null) {
      this.GlobalMin = this.GlobalMax;
      while (this.GlobalMin > this.DataMin) 
        this.GlobalMin -= scaleUnit;
    } else {
      this.GlobalMin = Math.floor(this.DataMin/scaleUnit) * scaleUnit;
    }
  }
  
  // Set the default global max
  if (this.GlobalMax == null) {
    if (zeroBaseline && this.DataMax <= 0) {
      this.GlobalMax = 0;
    } else if (continuousExtent) { // allow smooth pan/zoom transition
      this.GlobalMax = this.DataMax + (this.DataMax - this.DataMin) * 0.1;
      if (this.DataMax <= 0)
        this.GlobalMax = Math.min(this.GlobalMax, 0);
    } else if (!zeroBaseline) {
      this.GlobalMax = this.GlobalMin;
      while (this.GlobalMax <= this.DataMax)
        this.GlobalMax += scaleUnit;
    } else {
      this.GlobalMax = (Math.floor(this.DataMax/scaleUnit)+1) * scaleUnit;
    }
  }
  
  if (this.GlobalMax == this.GlobalMin) { // happens if this.DataMin == this.DataMax == 0
    this.GlobalMax = 100;
    this.GlobalMin = 0;
    scaleUnit = (this.GlobalMax - this.GlobalMin) / DvtDataAxisInfo._MAX_NUMBER_OF_GRIDS_AUTO;
  }
  
  if (this.MinValue == null)
    this.MinValue = this.GlobalMin;
  if (this.MaxValue == null)
    this.MaxValue = this.GlobalMax;
  
  // Recalc the scale unit if the axis viewport is limited
  if (this.MinValue != this.GlobalMin || this.MaxValue != this.GlobalMax)
    scaleUnit = this._calcAxisScale(this.MinValue, this.MaxValue);
  
  // Calculate major and minor gridlines
  this._calcMajorMinorIncr(scaleUnit);
}

/**
 * Determines the scale unit of the axis based on a given start and end axis extent.
 * @param {number} min The start data value for the axis.
 * @param {number} max The end data value for the axis.
 * @return {number} The scale unit of the axis.
 * @private
 */
DvtDataAxisInfo.prototype._calcAxisScale = function(min, max) {
  if (this._majorIncrement)
    return this._majorIncrement;
  
  var spread =  max - min;
  var t = Math.log(spread)/Math.log(10);
  var testVal = Math.pow(10, Math.ceil(t) - 2);
  var first2Digits = Math.round(spread/testVal);
  
  // Aesthetically choose a scaling factor limiting to a max number of steps 
  var scaleFactor = 1;
  if (first2Digits >= 10 && first2Digits <= 14)
    scaleFactor = 2;
  else if (first2Digits >= 15 && first2Digits <= 19)
    scaleFactor = 3;
  else if (first2Digits >= 20 && first2Digits <= 24)
    scaleFactor = 4;
  else if (first2Digits >= 25 && first2Digits <= 45)
    scaleFactor = 5;
  else if (first2Digits >= 46 && first2Digits <= 80)
    scaleFactor = 10;
  else if (first2Digits >= 81 && first2Digits <= 99)
    scaleFactor = 15; 
  else
    scaleFactor = 20;
  
  return scaleFactor * testVal;
}

/**
 * @override
 */
DvtDataAxisInfo.prototype.getMajorTickCount = function() {
   return this._majorTickCount;
}

/**
 * @override
 */
DvtDataAxisInfo.prototype.setMajorTickCount = function(count) {
  this._majorTickCount = count;
  this._majorIncrement = (this.MaxValue - this.MinValue)/this._majorTickCount;
}

/**
 * @override
 */
DvtDataAxisInfo.prototype.getMinorTickCount = function() {
   return this._minorTickCount;
}

/**
 * @override
 */
DvtDataAxisInfo.prototype.setMinorTickCount = function(count) {
   this._minorTickCount = count;
   this._minorIncrement = this._majorIncrement/this._minorTickCount;
}

/**
 * @override
 */
DvtDataAxisInfo.prototype.getMajorIncrement = function() {
   return this._majorIncrement;
}

/**
 * @override
 */
DvtDataAxisInfo.prototype.getMinorIncrement = function() {
   return this._minorIncrement;
}

/**
 * @override
 */
DvtDataAxisInfo.prototype.getMinimumExtent = function() {
  return (this.GlobalMax - this.GlobalMin) / DvtDataAxisInfo._MAX_ZOOM_FACTOR;
}

/**
 * @override
 */
DvtDataAxisInfo.prototype.getStartOverflow = function() {
  if ((this.Position == "top" || this.Position == "bottom") && DvtAgent.isRightToLeft(this.getCtx()))
    return this.EndOverflow;
  else
    return this.StartOverflow;
}

/**
 * @override
 */
DvtDataAxisInfo.prototype.getEndOverflow = function() {
  if ((this.Position == "top" || this.Position == "bottom") && DvtAgent.isRightToLeft(this.getCtx()))
    return this.StartOverflow;
  else
    return this.EndOverflow;
}
/**
 * Calculated axis information and drawable creation for a group axis.
 * @param {DvtContext} context
 * @param {object} options The object containing specifications and data for this component.
 * @param {DvtRectangle} availSpace The available space.
 * @class
 * @constructor
 * @extends {DvtAxisInfo}
 */
var DvtGroupAxisInfo = function(context, options, availSpace) {
  this.Init(context, options, availSpace);
}

DvtObj.createSubclass(DvtGroupAxisInfo, DvtAxisInfo, "DvtGroupAxisInfo");

/**
 * @override
 */
DvtGroupAxisInfo.prototype.Init = function(context, options, availSpace) {
  DvtGroupAxisInfo.superclass.Init.call(this, context, options, availSpace);

  // Flip horizontal axes for BIDI
  var isRTL = DvtAgent.isRightToLeft(context);
  if((this.Position == "top" || this.Position == "bottom") && isRTL) {
    var temp = this.StartCoord;
    this.StartCoord = this.EndCoord;
    this.EndCoord = temp;
  }

  // Cache the groups
  this._groups = options['groups'];
  
  // Calculate the increment and add offsets if specified
  var endOffset = (options['endGroupOffset'] > 0) ? Number(options['endGroupOffset']) : 0;
  var startOffset = (options['startGroupOffset'] > 0) ? Number(options['startGroupOffset']) : 0;
  
  // Set the axis min/max
  this.DataMin = 0;
  this.DataMax = this._groups.length - 1;
  
  this.GlobalMin = options['min'] == null ? this.DataMin - startOffset : options['min'];
  this.GlobalMax = options['max'] == null ? this.DataMax + endOffset : options['max'];
  
  this.MinValue = options['viewportMin'] == null ? this.GlobalMin : options['viewportMin'];
  this.MaxValue = options['viewportMax'] == null ? this.GlobalMax : options['viewportMax'];
  
  // Set min/max by start/endGroup
  var startIndex = this.getIndexByLabel(options['viewportStartGroup']);
  var endIndex = this.getIndexByLabel(options['viewportEndGroup']);
  if (startIndex != -1)
    this.MinValue = startIndex - startOffset;
  if (endIndex != -1)
    this.MaxValue = endIndex + endOffset;
    
  this._startBuffer = isRTL ? options['rightBuffer'] : options['leftBuffer'];
  this._endBuffer = isRTL ? options['leftBuffer'] : options['rightBuffer'];
  
  this._isLabelRotated = false;
  
  this._renderGridAtLabels = options['_renderGridAtLabels'];
}

/**
 * Rotates the labels of the horizontal axis by 90 degrees and skips the labels if necessary.
 * @param {Array} labels An array of DvtText labels for the axis.
 * @param {DvtContainer} container
 * @param {number} overflow How much overflow the rotated labels will have.
 * @return {Array} The array of DvtText labels for the axis.
 * @private
 */
DvtGroupAxisInfo.prototype._rotateLabels = function(labels, container, overflow) {
  var text;
  var x;  
  var isRTL = DvtAgent.isRightToLeft(this.getCtx());
  
  this._isLabelRotated = true;
  this._setOverflow(overflow, overflow, labels);
  
  for(var i=0; i<labels.length; i++) {
    text = labels[i];
    if (text == null)
      continue;  
    x = text.getX();
    text.setX(0);
    text.setY(0);
    if (isRTL)
      text.setRotation(Math.PI/2);
    else
      text.setRotation(3*Math.PI/2); 
    text.setTranslateX(x);
  }
  
  var labelDims = this.GuessLabelDims(labels, container); // the guess returns the exact heights
  return this.SkipLabels(labels, labelDims);
}

/**
 * @override
 */
DvtGroupAxisInfo.prototype.isLabelRotated = function() {
  return this._isLabelRotated;
}

/**
 * Sets the start/end overflow of the axis.
 * @param {number} startOverflow How much the first label overflows beyond the start coord.
 * @param {number} endOverflow How much the last label overflows beyonod the end coord.
 * @param {array} labels An array of DvtText labels. The x of the labels will be adjusted according to the overflow amount.
 * @private
 */
DvtGroupAxisInfo.prototype._setOverflow = function(startOverflow, endOverflow, labels) {
  startOverflow = Math.max(startOverflow - this._startBuffer, 0);
  endOverflow = Math.max(endOverflow - this._endBuffer, 0);
  
  // Revert the start/endCoord to the original positions before applying the new overflow values
  var isRTL = DvtAgent.isRightToLeft(this.getCtx());
  this.StartCoord += (startOverflow - this.StartOverflow) * (isRTL ? -1 : 1);
  this.EndCoord -= (endOverflow - this.EndOverflow) * (isRTL ? -1 : 1);
  
  // Adjust the label coords
  for (var i=0; i<labels.length; i++) {
    var text = labels[i];
    if (text)
      text.setX(this.getCoordAt(i));
  }
  
  this.StartOverflow = startOverflow;
  this.EndOverflow = endOverflow;
}


/**
 * @override
 */
DvtGroupAxisInfo.prototype.getLabels = function(context, levelIdx) {
  if (levelIdx && levelIdx > 0) // group axis has only one level
    return null;

  var labels = [];
  var container = context.getStage();
  var isHoriz = this.Position == "top" || this.Position == "bottom";
  var isRTL = DvtAgent.isRightToLeft(context);
  
  // Iterate and create the labels
  var numLabels = this._groups.length;
  var firstLabel, lastLabel;
  for(var i=0; i<numLabels; i++) {
    // Get the label from the group
    var label = this.getLabelAt(i);
    
    // Create and position the label
    var coord = this.getCoordAt(i);
    if (coord != null) {
      var text = this.CreateLabel(context, label, coord);
      labels.push(text);
      
      // Store first and last label
      if (!firstLabel)
        firstLabel = text;
      lastLabel = text;
    }
    else
      labels.push(null);
  }

  if (this.Position == "tangential") // for polar charts, no further computation is needed
    return labels;

  var firstLabelDim = firstLabel.measureDimensions();
  
  if (isHoriz) {
    var startOverflow, endOverflow;
    if (this.Options['_startOverflow'] != null && this.Options['_endOverflow'] != null) {
      // Use the preset value if available (during z&s animation)
      startOverflow = this.Options['_startOverflow'];
      endOverflow = this.Options['_endOverflow'];
    }
    else {
      // Set the overflow depending on how much the first and the last label go over the bounds
      var lastLabelDim = lastLabel.measureDimensions();
      startOverflow = isRTL ? firstLabelDim.w + firstLabelDim.x - this.StartCoord : this.StartCoord - firstLabelDim.x;
      endOverflow = isRTL ? this.EndCoord - lastLabelDim.x : lastLabelDim.w + lastLabelDim.x - this.EndCoord;
    }
    
    if (startOverflow > this._startBuffer || endOverflow > this._endBuffer)
      this._setOverflow(startOverflow, endOverflow, labels);
  }
  
  var labelDims = []; // actual dims
  var minLabelDims = this.GuessLabelDims(labels, container, 0.3); // minimum estimate
  var maxLabelDims = this.GuessLabelDims(labels, container);      // maximum estimate
  
  if (!this.IsOverlapping(maxLabelDims, 0))
    return labels; // all labels can fit
  
  // Rotate and skip the labels if necessary
  if (isHoriz) { // horizontal axis
    if (this.Options['tickLabel']['rotation'] == "auto") {
      if (this.IsOverlapping(minLabelDims, 0)) {
        return this._rotateLabels(labels, container, firstLabelDim.h/2);
      } else {
        labelDims = this.GetLabelDims(labels, container);
        if (this.IsOverlapping(labelDims, 0))
          return this._rotateLabels(labels, container, firstLabelDim.h/2);
        else
          return labels;  // all labels can fit
      }
    } else { // no rotation
      labelDims = this.GetLabelDims(labels, container); // get actual dims for skipping
      return this.SkipLabels(labels, labelDims);
    }
  } else { // vertical axis
    return this.SkipLabels(labels, maxLabelDims); // maxLabelDims contain the actual heights
  }
}

/**
 * @override
 */
DvtGroupAxisInfo.prototype.getAxisLine = function(context) {
  var axisLineOptions = this.Options['axisLine'];
  if(axisLineOptions['rendered'] == "on") {
    // Create and return the axis line
    var axisLineStroke = new DvtSolidStroke(axisLineOptions['lineColor'], 1, axisLineOptions['lineWidth']);
    return this.CreateGridLine(context, axisLineStroke, 0);
  }
  else
    return null;
}

/**
 * @override
 */
DvtGroupAxisInfo.prototype.getMajorGridLines = function(context) {
  var gridlines = [];
  
  // Major Ticks
  var coord, line;
  
  var majorTickOptions = this.Options['majorTick'];
  var majorTickStroke = new DvtSolidStroke(majorTickOptions['lineColor'], 1, majorTickOptions['lineWidth']);
  if(majorTickOptions['lineStyle'])
    majorTickStroke.setStyle(DvtStroke.convertTypeString(majorTickOptions['lineStyle']));
  
  var rendered = majorTickOptions['rendered'];
  if(rendered == "on" || (rendered == "auto" && this.Position == "tangential")) {
    var numGroups = this._groups.length;
    
    for(var i=0; i<numGroups; i++) {
      /* If placing gridlines at labels, use the coordinates at the labels
       * Else if placing gridlines in between labels, use the value halfway between two consecutive coordinates*/
      if(this._renderGridAtLabels)
        coord = this.getCoordAt(i);
      else {
        // Check to see if we are not an edge case
        if(this.getCoordAt(i+.5))
          coord = this.getCoordAt(i+.5); 
        // If we are at edge case don't draw a gridline  
        else
          continue;
      }
      
      if(coord != null){
        line = this.CreateGridLine(context, majorTickStroke, coord);
        gridlines.push(line);
      }
      
    }
  }
  
  return gridlines;
}

/**
 * @return {number} The group index.
 * @override
 */
DvtGroupAxisInfo.prototype.getValueAt = function(coord) {
  var minCoord = Math.min(this.StartCoord, this.EndCoord);
  var maxCoord = Math.max(this.StartCoord, this.EndCoord);
  
  // Return null if the coord is outside of the axis
  if(coord < minCoord || coord > maxCoord)
    return null;

  return this.getUnboundedValueAt(coord);
}

/**
 * @param {number} value The group index.
 * @override
 */
DvtGroupAxisInfo.prototype.getCoordAt = function(value) {
  if (value < this.MinValue || value > this.MaxValue)
    return null;
  else
    return this.getUnboundedCoordAt(value);
}

/**
 * @return {number} The group index.
 * @override
 */
DvtGroupAxisInfo.prototype.getBoundedValueAt = function(coord) {
  var minCoord = Math.min(this.StartCoord, this.EndCoord);
  var maxCoord = Math.max(this.StartCoord, this.EndCoord);

  if(coord < minCoord)
    coord = minCoord;
  else if(coord > maxCoord)
    coord = maxCoord;

  return this.getUnboundedValueAt(coord);
}

/**
 * @param {number} value The group index.
 * @override
 */
DvtGroupAxisInfo.prototype.getBoundedCoordAt = function(value) {
  if (value < this.MinValue)
    value = this.MinValue;
  else if (value >= this.MaxValue)
    value = this.MaxValue;

  return this.getUnboundedCoordAt(value);
}

/**
 * @return {number} The group index.
 * @override
 */
DvtGroupAxisInfo.prototype.getUnboundedValueAt = function(coord) {
  var incr = (this.EndCoord - this.StartCoord)/(this.MaxValue - this.MinValue);
  return this.MinValue + (coord - this.StartCoord) / incr;
}

/**
 * @param {number} value The group index.
 * @override
 */
DvtGroupAxisInfo.prototype.getUnboundedCoordAt = function(value) {
  var incr = (this.EndCoord - this.StartCoord)/(this.MaxValue - this.MinValue);
  return this.StartCoord + (value - this.MinValue) * incr;
}

/**
 * Returns the group label for the specified group.
 * @param {number} index The group index.
 * @return {string} The group label.
 */
DvtGroupAxisInfo.prototype.getLabelAt = function(index) {
  index = Math.round(index);
  if (index < 0 || index >= this._groups.length)
    return null;
  
  var label = this._groups[index];
  if(label && label.name)
    label = label.name;
  return label;
}

/**
 * Returns the index for the specified group label.
 * @param {string} label The group label.
 * @return {number} The group index. -1 if the group doesn't exist.
 */
DvtGroupAxisInfo.prototype.getIndexByLabel = function(label) {
  if (label == null)
    return -1;
    
  var index = -1;
  var lb;
  for (var i = 0; i < this._groups.length; i++) {
    lb = this._groups[i];
    if (lb && lb.name)
      lb = lb.name;
    if (label == lb) {
      index = i;
      break;
    }
  }
  return index;
}

/**
 * @override
 */
DvtGroupAxisInfo.prototype.getMinimumExtent = function() {
  return 1;
}
/**
 * Formatter for an axis with a linear scale.
 * Following cases can occur:
 * 1. scaling is set to none:
 *    No scaling is used in this case.
 * 2. scaling is set to auto, null or undefined:
 *    Scaling is computed. The nearest (less or equal) known scale is used. Regarding fraction part, if autoPrecision equals "on" then the count of significant decimal places 
 *    is based on tickStep otherwise fraction part is not formatted.
 * 3. otherwise
 *    Defined scaling is used. 
 *    Examples (autoPrecision = "on"): 
 *    minValue = 0, maxValue=10000, tickStep=1000, scale="thousand" -> formatted axis values: 0K , ..., 10K
 *    minValue = 0, maxValue=100, tickStep=10, scale="thousand" -> formatted axis values: 0.00K, 0.01K, ..., 0.10K
 *
 * @param {object} bundle translations bundle
 * @param {number} minValue the minimum value on the axis
 * @param {number} maxValue the maximum value on the axis
 * @param {number} tickStep the tick step between values on the axis
 * @param {string} scale the scale of values on the axis; if null or undefined then auto scaling is used.
 * @param {string} autoPrecision "on" if auto precision should be applied otherwise "off"; if null or undefined then auto precision is applied.
 * @constructor
 */
var DvtLinearScaleAxisValueFormatter = function (minValue, maxValue, tickStep, scale, autoPrecision) {
  var bundle = new DvtUtilBundle();
  DvtAbstractAxisValueFormatter.call(this, bundle);
  this.Init(minValue, maxValue, tickStep, scale, autoPrecision);
};

DvtObj.createSubclass(DvtLinearScaleAxisValueFormatter, DvtAbstractAxisValueFormatter, "DvtLinearScaleAxisValueFormatter");

/**
 * Allowed scales that can be used as formatter scale param values
 */
DvtLinearScaleAxisValueFormatter.SCALE_NONE = "none";
DvtLinearScaleAxisValueFormatter.SCALE_AUTO = "auto";
DvtLinearScaleAxisValueFormatter.SCALE_THOUSAND = "thousand";
DvtLinearScaleAxisValueFormatter.SCALE_MILLION = "million";
DvtLinearScaleAxisValueFormatter.SCALE_BILLION = "billion";
DvtLinearScaleAxisValueFormatter.SCALE_TRILLION = "trillion";
DvtLinearScaleAxisValueFormatter.SCALE_QUADRILLION = "quadrillion";

/**
 * The scaling factor difference between successive scale values
 */
DvtLinearScaleAxisValueFormatter.SCALING_FACTOR_DIFFERENCE = 3;

/**
 * Initializes the instance.
 */
DvtLinearScaleAxisValueFormatter.prototype.Init = function (minValue, maxValue, tickStep, scale, autoPrecision) {
  // array of successive scale values
  this._scales = {
  };
  // array of scale values ordered by scale factor asc
  this._scalesOrder = [];
  // mapping of scale factors to corresponding scale objects
  this._factorToScaleMapping = {
  };

  this.InitScales();
  this.InitFormatter(minValue, maxValue, tickStep, scale, autoPrecision)
};

/**
 * Initializes scale objects.
 * @protected
 *
 */
DvtLinearScaleAxisValueFormatter.prototype.InitScales = function () {
  /**
   * Creates scale object and refreshes formatter properties using it.
   * @param {string} scaleName one of allowed scale names (e.g. DvtLinearScaleAxisValueFormatter.SCALE_THOUSAND)
   * @param {number} scaleFactor scale factor of corresponding scale, i.e. 'x' such that 10^x represents corresponding scale (e.g. for scale DvtLinearScaleAxisValueFormatter.SCALE_THOUSAND x = 3)
   * @param {string} scaleBundleSuffix translation key which value (translated) represents given scale (e.g. for DvtLinearScaleAxisValueFormatter.SCALE_THOUSAND an translated english suffix is 'K')
   */
  var createScale = function (scaleName, scaleFactor, scaleKey) {
    var suffix;
    if (this.GetBundle()) {
      if (scaleKey) {
        // when bundle and bundle suffix is defined then init suffix
        suffix = this.GetBundle().getTranslatedString(scaleKey, null);
      }
    }

    var scale = {
      scaleFactor : scaleFactor, localizedSuffix : suffix
    }

    // update private properties
    this._scales[scaleName] = scale;
    this._scalesOrder.push(scale);
    this._factorToScaleMapping[scaleFactor] = scale;
  };

  var diff = DvtLinearScaleAxisValueFormatter.SCALING_FACTOR_DIFFERENCE;

  createScale.call(this, DvtLinearScaleAxisValueFormatter.SCALE_NONE, 0 * diff);
  createScale.call(this, DvtLinearScaleAxisValueFormatter.SCALE_THOUSAND, 1 * diff, "SCALING_SUFFIX_THOUSAND");
  createScale.call(this, DvtLinearScaleAxisValueFormatter.SCALE_MILLION, 2 * diff, "SCALING_SUFFIX_MILLION");
  createScale.call(this, DvtLinearScaleAxisValueFormatter.SCALE_BILLION, 3 * diff, "SCALING_SUFFIX_BILLION");
  createScale.call(this, DvtLinearScaleAxisValueFormatter.SCALE_TRILLION, 4 * diff, "SCALING_SUFFIX_TRILLION");
  createScale.call(this, DvtLinearScaleAxisValueFormatter.SCALE_QUADRILLION, 5 * diff, "SCALING_SUFFIX_QUADRILLION");

  // sort _scalesOrder array
  this._scalesOrder.sort(function (scale1, scale2) {
    if (scale1.scaleFactor < scale2.scaleFactor) {
      return  - 1;
    }
    else if (scale1.scaleFactor > scale2.scaleFactor) {
      return 1;
    }
    else {
      return 0;
    }
  });
};

/**
 * Initializes properties used for values formatting (e.g. scale factor that should be applied etc.).
 *
 * @param {number} minValue the minimum value on the axis
 * @param {number} maxValue the maximum value on the axis
 * @param {number} tickStep the tick step between values on the axis
 * @param {string} scale the scale of values on the axis
 * @param {boolean} autoPrecision true if auto precision should be applied otherwise false
 * @protected
 *
 */
DvtLinearScaleAxisValueFormatter.prototype.InitFormatter = function (minValue, maxValue, tickStep, scale, autoPrecision) {
  var findScale = false, decimalPlaces, scaleFactor, useAutoPrecision = false;

  // if autoPrecision doesn't equal "off" (i.e. is "on", null, undefined) then auto precision should be used.
  if(!(autoPrecision === "off")){
    useAutoPrecision = true;
  } 
  // try to use scale given by "scale" param and if no scale factor is found find appropriate scale
  scaleFactor = this._getScaleFactor(scale);
  if ((typeof scaleFactor) !== "number") {
    findScale = true;
  }

  // base a default scale factor calculation on the order of
  // magnitude (power of ten) of the maximum absolute value on the axis
  if (findScale) {
    // get the axis endpoint with the largest absolute value,
    // and find its base 10 exponent
    var absMax = Math.max(Math.abs(minValue), Math.abs(maxValue));

    var power = this._getPowerOfTen(absMax);
    scaleFactor = this._findNearestLEScaleFactor(power);
  }

  if(useAutoPrecision === true){
    if(tickStep == 0 && minValue == maxValue) {
      // TODO: HZHANG Remove this hack for chart tooltips, which currently passes 0 as the tick step in all cases.
      // Workaround for now will be to add decimal places to show at least 1 and at most 4 significant digits
      var valuePowerOfTen = this._getPowerOfTen(maxValue);
      var scaleFactorDiff = scaleFactor - valuePowerOfTen;
      if(scaleFactorDiff <= 0) // Value is same or larger than the scale factor, ensure 4 significant digits.
        decimalPlaces = 3 + scaleFactorDiff;
      else // Value is smaller, ensure enough decimals to show 1 significant digit
        decimalPlaces = Math.max(scaleFactorDiff, 4);
    }
    else {  
      // get the number of decimal places in the number by subtracting
      // the order of magnitude of the tick step from the order of magnitude
      // of the scale factor
      // (e.g.: scale to K, tick step of 50 -> 3 - 1 = 2 decimal places)
      var tickStepPowerOfTen = this._getPowerOfTen(tickStep);
      decimalPlaces = Math.max(scaleFactor - tickStepPowerOfTen, 0);
    }
  }

  // init private properties with computed values
  this._useAutoPrecision = useAutoPrecision;
  this._scaleFactor = scaleFactor;
  this._decimalPlaces = decimalPlaces;
};

/**
 * Finds a scale factor 'x' such that x <= value (e.g. if value equals 4 then returned scale factor equals 3)
 * @param {number} value value representing an order of magnitude
 * @return {number} a scale factor 'x' such that x <= value
 * @private
 */
DvtLinearScaleAxisValueFormatter.prototype._findNearestLEScaleFactor = function (value) {
  var scaleFactor = 0;

  if (value <= this._scalesOrder[0].scaleFactor) {
    // if the number is less than 10, don't scale
    scaleFactor = this._scalesOrder[0].scaleFactor;
  }
  else if (value >= this._scalesOrder[this._scalesOrder.length - 1].scaleFactor) {
    // if the data is greater than or equal to 10 quadrillion, scale to quadrillions
    scaleFactor = this._scalesOrder[this._scalesOrder.length - 1].scaleFactor;
  }
  else {
    // else find the nearest scaleFactor such that scaleFactor <= value
    var end = this._scalesOrder.length - 1;
    for (var i = end;i >= 0;i--) {
      if (this._scalesOrder[i].scaleFactor <= value) {
        scaleFactor = this._scalesOrder[i].scaleFactor;
        break;
      }
    }
  }
  return scaleFactor;
};

/**
 * Returns scale factor of scale given by scale name.
 * @return scale factor of scale given by scale name
 * @private
 */
DvtLinearScaleAxisValueFormatter.prototype._getScaleFactor = function (scaleName) {
  // If no scaling factor defined, use auto by default.
  if(!scaleName)
    scaleName = DvtLinearScaleAxisValueFormatter.SCALE_AUTO;

  var scaleFactor, scale = this._scales[scaleName];
  if (scale) {
    scaleFactor = scale.scaleFactor;
  }
  return scaleFactor;
};

/**
 * Formats given value using previously computed scale factor and decimal digits count. In case that parsed value equals NaN an unformatted value is returned.
 * @override
 * @param {object} value to be formatted.
 * @return {string} formatted value as string
 */
DvtLinearScaleAxisValueFormatter.prototype.format = function (value, converter) {
  var parsed = parseFloat(value);
  if (!isNaN(parsed)) {
    // Find the suffix for the scale factor
    var suffix;
    if (this._scaleFactor > 0) {
      for (var i = 0;i < this._scaleFactor;i++) {
        parsed /= 10;
      }
      suffix = this._factorToScaleMapping[this._scaleFactor].localizedSuffix;
    }
    
    // Convert the number itself
    if (converter && converter.getAsString) {
      parsed = converter.getAsString(parsed);
    } 
    else if (converter && converter['format'])
      parsed = converter['format'](parsed);
    else if (this._useAutoPrecision && !isNaN(parseFloat(parsed))) {
      parsed = parseFloat(new Number(parsed).toFixed(this._decimalPlaces));
      parsed = this._formatFraction(parsed);
    }
    
    // Add the scale factor suffix
    if (typeof suffix === "string") {
      parsed += suffix;
    }
    return parsed;
  }
  else {
    return value;
  }
};

/**
 * Formats fraction part of given value (adds zeroes if needed).
 * @param {number} number to be formatted
 * @return {string} number with fraction part formatted as string
 * @private
 */
DvtLinearScaleAxisValueFormatter.prototype._formatFraction = function (value) {
  var formatted = "" + value;
  if (this._decimalPlaces > 0) {
    if (formatted.indexOf(".") ==  - 1) {
      formatted += ".";
    }
    var existingPlacesCount = formatted.substring(formatted.indexOf(".") + 1).length;

    while (existingPlacesCount < this._decimalPlaces) {
      formatted += "0";
      existingPlacesCount++;
    }
  }
  return formatted;
};

/**
 * Fro given value it returns its order of magnitude.
 * @param {number} value for which order of magnitude should be found
 * @return {number} order of magnitude for given value
 * @private
 */
DvtLinearScaleAxisValueFormatter.prototype._getPowerOfTen = function (value) {
  // more comprehensive and easier than working with value returned by Math.log(value)/Math.log(10)
  value = (value >= 0) ? value :  - value;
  var power = 0;

  // Check for degenerate and zero values
  if (value < 1E-15) {
    return 0;
  }
  else if (value == Infinity) {
    return Number.MAX_VALUE;
  }

  if (value >= 10) {
    // e.g. for 1000 the power should be 3
    while (value >= 10) {
      power += 1;
      value /= 10;
    }
  }
  else if (value < 1) {
    while (value < 1) {
      power -= 1;
      value *= 10;
    }
  }
  return power;
};
/**
 * Calculated axis information and drawable creation for a time axis.
 * @param {DvtContext} context
 * @param {object} options The object containing specifications and data for this component.
 * @param {DvtRectangle} availSpace The available space.
 * @class
 * @constructor
 * @extends {DvtAxisInfo}
 */
var DvtTimeAxisInfo = function (context, options, availSpace) {
  this.Init(context, options, availSpace);
}

DvtObj.createSubclass(DvtTimeAxisInfo, DvtAxisInfo, "DvtTimeAxisInfo");

// ------------------------
// Constants
//
DvtTimeAxisInfo.TIME_SECOND = 1000;
DvtTimeAxisInfo.TIME_MINUTE = 60 * DvtTimeAxisInfo.TIME_SECOND;
DvtTimeAxisInfo.TIME_HOUR = 60 * DvtTimeAxisInfo.TIME_MINUTE;
DvtTimeAxisInfo.TIME_DAY = 24 * DvtTimeAxisInfo.TIME_HOUR;
DvtTimeAxisInfo.TIME_MONTH_MIN = 28 * DvtTimeAxisInfo.TIME_DAY;// minimum # of days in a month
DvtTimeAxisInfo.TIME_MONTH = (365 / 12) * DvtTimeAxisInfo.TIME_DAY;// approx.
DvtTimeAxisInfo.TIME_YEAR = 365 * DvtTimeAxisInfo.TIME_DAY;

// For time localization. Not currently used yet.
DvtTimeAxisInfo.AM_INDEX = 12;
DvtTimeAxisInfo.PM_INDEX = 13;
DvtTimeAxisInfo.AMPM_BEFORE_INDEX = 14;
DvtTimeAxisInfo.DMY_ORDER_INDEX = 15;
DvtTimeAxisInfo.YEAR_TRAILING_CHAR_INDEX = 16;
DvtTimeAxisInfo.DAY_TRAILING_CHAR_INDEX = 17;

/**
 * @override
 */
DvtTimeAxisInfo.prototype.Init = function (context, options, availSpace) {
  DvtTimeAxisInfo.superclass.Init.call(this, context, options, availSpace);
  
  // Figure out the coords for the min/max values
  if (this.Position == "top" || this.Position == "bottom") {
    // Provide at least the minimum buffer at each side to accommodate labels
    if (!options['_isOverview'] && options['tickLabel']['rendered'] == "on") {
      this.StartOverflow = Math.max(DvtAxis.MINIMUM_AXIS_BUFFER - options['leftBuffer'], 0);
      this.EndOverflow = Math.max(DvtAxis.MINIMUM_AXIS_BUFFER - options['rightBuffer'], 0);
    }
    
    // Axis is horizontal, so flip for BIDI if needed
    if (DvtAgent.isRightToLeft(context)) {
      this._minCoord = this.EndCoord - this.EndOverflow;
      this._maxCoord = this.StartCoord + this.StartOverflow;
    }
    else {
      this._minCoord = this.StartCoord + this.StartOverflow;
      this._maxCoord = this.EndCoord - this.EndOverflow;
    }
  }
  else {
    // Vertical axis should go from top to bottom
    this._minCoord = this.StartCoord;
    this._maxCoord = this.EndCoord;
  }

  this._converter = null;
  if (options['tickLabel'] != null) {
    this._converter = options['tickLabel']['converter'];
  }

  this._groups = options['groups'];
  
  this.DataMin = options['dataMin'];
  this.DataMax = options['dataMax'];
  
  this._averageInterval = this._groups.length > 0 ? (this.DataMax - this.DataMin) / (this._groups.length - 1) : 0;
  
  // Calculate the increment and add offsets if specified
  var endOffset = options['endGroupOffset'] > 0 ? options['endGroupOffset'] * this._averageInterval : 0;
  var startOffset = options['startGroupOffset'] > 0 ? options['startGroupOffset'] * this._averageInterval : 0;
  
  this.GlobalMin = options['min'] != null ? options['min'] : this.DataMin - startOffset;
  this.GlobalMax = options['max'] != null ? options['max'] : this.DataMax + endOffset;
  
  this.MinValue = options['viewportMin'] == null ? this.GlobalMin : options['viewportMin'];
  this.MaxValue = options['viewportMax'] == null ? this.GlobalMax : options['viewportMax'];
  
  // Set min/max by start/endGroup
  if (options['viewportStartGroup'] != null)
    this.MinValue = options['viewportStartGroup'] - startOffset;
  if (options['viewportEndGroup'] != null)
    this.MaxValue = options['viewportEndGroup'] + endOffset;
  
  this._timeZoneOffset = 0;
  this._timeRange = this.MaxValue - this.MinValue;

  this._level1Labels = null;
  this._level2Labels = null;
  // Coordinates of labels need to be stored for gridline rendering
  this._level1Coords = null;
  this._level2Coords = null;
  this._isOneLevel = true;
  
  var bundle = new DvtUtilBundle();
  this._timeAxisResources = [
    bundle.getTranslatedString('MONTH_SHORT_JANUARY', null),
    bundle.getTranslatedString('MONTH_SHORT_FEBRUARY', null),
    bundle.getTranslatedString('MONTH_SHORT_MARCH', null),
    bundle.getTranslatedString('MONTH_SHORT_APRIL', null),
    bundle.getTranslatedString('MONTH_SHORT_MAY', null),
    bundle.getTranslatedString('MONTH_SHORT_JUNE', null),
    bundle.getTranslatedString('MONTH_SHORT_JULY', null),
    bundle.getTranslatedString('MONTH_SHORT_AUGUST', null),
    bundle.getTranslatedString('MONTH_SHORT_SEPTEMBER', null),
    bundle.getTranslatedString('MONTH_SHORT_OCTOBER', null),
    bundle.getTranslatedString('MONTH_SHORT_NOVEMBER', null),
    bundle.getTranslatedString('MONTH_SHORT_DECEMBER', null)
  ];
  
  this._renderGridAtLabels = options['_renderGridAtLabels'];
}

/**
 * Formats the label given an axis value (used for generating tooltips).
 * @param {Number} axisValue The axis value (in milliseconds)
 * @return {String} A formatted axis label
 */
DvtTimeAxisInfo.prototype.formatLabel = function (axisValue) {
  var date = new Date(axisValue + this._timeZoneOffset);
  var twoLabels = this._formatAxisLabel(date, null);
  if (twoLabels[1] != null)
    return twoLabels[0] + " " + twoLabels[1];
  else 
    return twoLabels[0];
}

/**
 * Formats the level 1 and level 2 axis labels
 * @param {Date} date The current date
 * @param {Date} prevDate The date of the previous set of labels
 * @return {Array} An array [level1Label, level2Label]
 * @private
 */
DvtTimeAxisInfo.prototype._formatAxisLabel = function (date, prevDate) {
  var label1 = null;// level 1 label
  var label2 = null;// level 2 label
  // If dateTimeFormatter is used, use it
  if (this._converter && this._converter.getAsString && this._converter.getAsObject) {
    label1 = this._converter.getAsString(date);
  }
  else if (this._converter && this._converter['format']) {
    label1 = this._converter['format'](date);
  }
  else if (this._averageInterval >= DvtTimeAxisInfo.TIME_YEAR) {
    label1 = this._formatDate(date, false, false, true);// Year
  }

  else if (this._timeRange >= DvtTimeAxisInfo.TIME_YEAR || this._averageInterval >= DvtTimeAxisInfo.TIME_MONTH_MIN) {
    if (prevDate == null || prevDate.getMonth() != date.getMonth())
      label1 = this._formatDate(date, false, true, false);// Month
    if (prevDate == null || prevDate.getYear() != date.getYear())
      label2 = this._formatDate(date, false, false, true);// Year
  }

  else if (this._timeRange >= DvtTimeAxisInfo.TIME_MONTH_MIN || this._averageInterval >= DvtTimeAxisInfo.TIME_DAY) {
    if (prevDate == null || prevDate.getDate() != date.getDate())
      label1 = this._formatDate(date, true, false, false);// Day
    if (prevDate == null || prevDate.getYear() != date.getYear())
      label2 = this._formatDate(date, false, true, true);// Year, Month
    else if (prevDate.getMonth() != date.getMonth())
      label2 = this._formatDate(date, false, true, false);// Month
  }

  else if (this._timeRange >= DvtTimeAxisInfo.TIME_HOUR || this._averageInterval >= DvtTimeAxisInfo.TIME_MINUTE) {
    if (prevDate == null || (prevDate.getHours() != date.getHours() || prevDate.getMinutes() != date.getMinutes()))
      label1 = this._formatTime(date, false);// HH:MM
    if (prevDate == null || prevDate.getMonth() != date.getMonth())
      label2 = this._formatDate(date, true, true, false);// Month, Day
    else if (prevDate.getDate() != date.getDate()) {
      if (this.Position == 'left' || this.Position == 'right')
        label2 = this._formatDate(date, true, true, false);// Month, Day
      else 
        label2 = this._formatDate(date, true, false, false);// Day
    }
  }

  else {
    if (prevDate == null || prevDate.getSeconds() != date.getSeconds())
      label1 = this._formatTime(date, true);// HH:MM:SS
    if (prevDate == null || prevDate.getMonth() != date.getMonth())
      label2 = this._formatDate(date, true, true, false);// Month, Day
    else if (prevDate.getDate() != date.getDate()) {
      if (this.Position == 'left' || this.Position == 'right')
        label2 = this._formatDate(date, true, true, false);// Month, Day
      else 
        label2 = this._formatDate(date, true, false, false);// Day
    }
  }

  return [label1, label2];
}

/**
 * Returns the date as a DMY string
 * @param {Date} date The date
 * @param {boolean} showDay Whether the day is shown
 * @param {boolean} showMonth Whether the month is shown
 * @param {boolean} showYear Whether the year is shown
 * @return {string} The formatted string
 * @private
 */
DvtTimeAxisInfo.prototype._formatDate = function (date, showDay, showMonth, showYear) {
  var yearStr = date.getFullYear();
  var monthStr;
  if (this._timeAxisResources && this._timeAxisResources.length >= 12)
    monthStr = this._timeAxisResources[date.getMonth()];
  else 
    monthStr = date.toString().split(" ")[1];// date.toString() returns "Day Mon Date HH:MM:SS TZD YYYY"
  var dayStr = date.getDate();
  
  // Add the day and year trailing characters if needed
  // TODO: Localize properly!
  if (this._timeAxisResources && this._timeAxisResources.length > DvtTimeAxisInfo.DAY_TRAILING_CHAR_INDEX) {
    var yearChar = this._timeAxisResources[DvtTimeAxisInfo.YEAR_TRAILING_CHAR_INDEX];
    var dayChar = this._timeAxisResources[DvtTimeAxisInfo.DAY_TRAILING_CHAR_INDEX];
    // These will be "" if not needed
    yearStr += yearChar;
    dayStr += dayChar;
  }

  // Process the DMY Order
  // TODO: Localize properly!
  var dmyOrder = "DMY";
  if (this._timeAxisResources && this._timeAxisResources.length > DvtTimeAxisInfo.DMY_ORDER_INDEX) {
    dmyOrder = this._timeAxisResources[DvtTimeAxisInfo.DMY_ORDER_INDEX];
  }

  var dateStr = "";

  for (var i = 0;i < dmyOrder.length;i++) {
    if (showDay && dmyOrder[i] == 'D') {
      dateStr += dayStr + " ";
    }
    else if (showMonth && dmyOrder[i] == 'M') {
      dateStr += monthStr + " ";
    }
    else if (showYear && dmyOrder[i] == 'Y') {
      dateStr += yearStr + " ";
    }
  }

  return dateStr.length > 0 ? dateStr.slice(0, dateStr.length - 1) : dateStr;
}

/**
 * Returns the date as an HH:MM:SS string
 * @param {Date} date The date
 * @param {boolean} showSecond Whether the second is shown
 * @return {string} The formatted string
 * @private
 */
DvtTimeAxisInfo.prototype._formatTime = function (date, showSecond) {
  var hours = date.getHours();
  var mins = date.getMinutes();
  var secs = date.getSeconds();

  var am = "";
  var pm = "";
  var ampmBefore = false;
  
  // TODO: Localize properly!
  if (this._timeAxisResources != null && this._timeAxisResources > DvtTimeAxisInfo.AMPM_BEFORE_INDEX) {
    am = this._timeAxisResources[DvtTimeAxis.AM_INDEX];
    pm = this._timeAxisResources[DvtTimeAxis.PM_INDEX];
    ampmBefore = this._timeAxisResources[DvtTimeAxisInfo.AMPM_BEFORE_INDEX] == "t";
  }

  var b12HFormat = (am != "" && pm != "");
  var ampm;

  if (b12HFormat) {
    ampm = pm;
    if (hours > 12) {
      hours -= 12;
      ampm = pm;
    }
    else if (hours == 0) {
      ampm = am;
      hours = 12;
    }
    else if (hours < 12) {
      ampm = am;
    }
  }

  var timeLabel = this._doubleDigit(hours) + ":" + this._doubleDigit(mins);

  if (showSecond) {
    timeLabel += ":" + this._doubleDigit(secs);
  }

  if (b12HFormat) {
    if (ampmBefore)
      return ampm + " " + timeLabel;
    else 
      return timeLabel + " " + ampm;
  }
  else {
    return timeLabel;
  }
}

/**
 * Creates a double-digit number string for the HH:MM:SS format
 * @param {Number} num A number less than 100
 * @return {String} A double-digit number string
 * @private
 */
DvtTimeAxisInfo.prototype._doubleDigit = function (num) {
  if (num < 10) {
    return "0" + num;
  }
  return "" + num;
}

/**
 * Returns the time label interval for mixed frequency data.
 * Makes sure that the interval is a regular time unit.
 * @return {number} The interval.
 * @private
 */
DvtTimeAxisInfo.prototype._getMixedFrequencyInterval = function() {
  if (this._averageInterval >= DvtTimeAxisInfo.TIME_YEAR)
    return DvtTimeAxisInfo.TIME_YEAR;
  if (this._averageInterval >= DvtTimeAxisInfo.TIME_MONTH)
    return DvtTimeAxisInfo.TIME_MONTH;
  if (this._averageInterval >= DvtTimeAxisInfo.TIME_DAY)
    return DvtTimeAxisInfo.TIME_DAY;
  if (this._averageInterval >= DvtTimeAxisInfo.TIME_HOUR)
    return DvtTimeAxisInfo.TIME_HOUR;
  if (this._averageInterval >= DvtTimeAxisInfo.TIME_MINUTE)
    return DvtTimeAxisInfo.TIME_MINUTE;
  return DvtTimeAxisInfo.TIME_SECOND;
}

/**
 * Generates the level 1 and level 2 tick labels
 * @param {DvtContext} context
 * @private
 */
DvtTimeAxisInfo.prototype._generateLabels = function (context) {
  var labels1 = []; 
  var labels2 = []; 
  var coords1 = [];
  var coords2 = [];
  var prevDate = null;
  var c1 = 0;// number of level 1 labels
  var c2 = 0;// number of level 2 labels
  var container = context.getStage(context);
  var isRTL = DvtAgent.isRightToLeft(context);
  var isVert = (this.Position == "left" || this.Position == "right");
  var scrollable = this.Options['zoomAndScroll'] != 'off';
 
  if (scrollable)
    var first = true;
  
  // Bug #17046187 : On Chrome, creating a gap value to be used for spacing level1 labels and level2 labels
  var levelsGap = 0; 
  if (isVert && DvtAgent.isBrowserChrome()) {
    levelsGap = parseInt(this.Options['tickLabel']['style'].getStyle('font-size')) * .2;
  }
  
  // Find the time positions where labels can be located
  var times = [];
  var minSkip = 0;
  if (this.Options['timeAxisType'] == "mixedFrequency") {
    var time = this.MinValue;
    var interval = this._getMixedFrequencyInterval();
    while (time <= this.MaxValue) {
      times.push(time);
      time += interval;
    }
    minSkip = Math.floor(this._averageInterval / interval) - 1; // to avoid label overcrowding
  }
  else
    times = this._groups;
  
  // Create and format the labels
  for (var i = 0; i < times.length; i++) {
    var time = times[i];
    var coord = this.getCoordAt(time);
    if (coord == null)
      continue;
        
    var date = new Date(time + this._timeZoneOffset);
    var twoLabels = this._formatAxisLabel(date, prevDate);
    
    var label1 = twoLabels[0];
    var label2 = twoLabels[1];
    //level 1 label
    if (label1 != null) { 
      // If level 2 exists put a levelsGap space between labels. levelsGap is only non-zero on Chrome.
      if(label2 != null) 
        labels1.push(this.CreateLabel(context, label1, coord + levelsGap));
      else 
        labels1.push(this.CreateLabel(context, label1, coord));
      coords1.push(coord);  
    }
    else {
      labels1.push(null);
      coords1.push(null);
    }
    
    if (scrollable) {
      if (first) {
        coord = this.MinValue ? this.getCoordAt(this.MinValue) : coord;
        first = false;
      }
    }
    
    //level 2 label    
    if (label2 != null) {
      var text = null;
      if(label2 != null)
        text = this.CreateLabel(context, label2, coord - levelsGap);
      else 
        text = this.CreateLabel(context, label2, coord);
      coords2.push(coord);
      if (!isVert) //set alignment now in order to determine if the labels will overlap
        isRTL ? text.alignRight() : text.alignLeft();
      labels2.push(text);
      this._isOneLevel = false;
    }
    else {
      labels2.push(null);
      coords2.push(null);
    }

    prevDate = date;
  }
  
  // skip level 1 labels every uniform interval
  c1 = this._skipLabelsUniform(labels1, this.GetLabelDims(labels1, container), minSkip);
  
  // skip level 2 labels greedily
  c2 = this._skipLabelsGreedy(labels2, this.GetLabelDims(labels2, container));

  if (!scrollable) {
    if (c1 <= 1.5 * c2 && c2 > 1) {
      // too few level 1 labels
      labels1 = labels2;
      labels2 = null; 
      // center align the new level1 labels
      for (var j = 0; j < labels1.length; j++) {
        if (labels1[j] != null)
          labels1[j].alignCenter();
      }
    }  
    else if (c2 < 2) {
      // too few level 2 labels
      labels2 = null;
    }
  }
  
  if (c2 < 2)
    this._isOneLevel = true;

  if (isVert && labels2 != null)
    this._skipVertLabels(labels1, labels2, container);

  this._level1Labels = labels1;
  this._level2Labels = labels2;

  // Store coordinates of labels for gridline rendering
  this._level1Coords = coords1;
  this._level2Coords = coords2;
}

/**
 * Determines if rectangle A (bounded by pointA1 and pointA2) and rectangle B (bounded by pointB1 and B2) overlap.
 * All the points should lie in one dimension.
 * @param {Number} pointA1
 * @param {Number} pointA2
 * @param {Number} pointB1
 * @param {Number} pointB2
 * @param {Number} gap The minimum gap between the two rectangles
 * @return {Boolean} whether rectangle A and B overlap
 * @private
 */
DvtTimeAxisInfo._isOverlapping = function (pointA1, pointA2, pointB1, pointB2, gap) {
  if (pointB1 >= pointA1 && pointB1 - gap < pointA2)
    return true;
  else if (pointB1 < pointA1 && pointB2 + gap > pointA1)
    return true;
  return false;
}

/**
 * Skip labels greedily. Delete all labels that overlap with the last rendered label.
 * @param {Array} labels An array of DvtText labels for the axis. This array will be modified by the method.
 * @param {Array} labelDims An array of DvtRectangle objects that describe the x, y, height, width of the axis labels.
 * @return {Number} The number of remaining labels after skipping.
 * @private
 */
DvtTimeAxisInfo.prototype._skipLabelsGreedy = function (labels, labelDims) {
  // If there are no labels, return
  if (!labelDims || labelDims.length <= 0)
    return false;

  var isVert = (this.Position == "left" || this.Position == "right");
  var gap = (isVert ? this.Options['layout']['verticalAxisGap'] : this.Options['layout']['horizontalAxisGap']);

  var count = 0;// the number of non-null labels 
  var pointA1, pointA2, pointB1, pointB2;

  if (labelDims[0] == null) {
    return count;
  }
  else {
    if (isVert) {
      pointA1 = labelDims[0].y;
      pointA2 = labelDims[0].y + labelDims[0].h;
    }
    else {
      pointA1 = labelDims[0].x;
      pointA2 = labelDims[0].x + labelDims[0].w;
    }
    count++;
  }

  for (var j = 1;j < labelDims.length;j++) {
    if (labelDims[j] == null)
      continue;

    if (isVert) {
      pointB1 = labelDims[j].y;
      pointB2 = labelDims[j].y + labelDims[j].h;

      if (DvtTimeAxisInfo._isOverlapping(pointA1, pointA2, pointB1, pointB2, gap))
        labels[j] = null;
    }
    else {
      pointB1 = labelDims[j].x;
      pointB2 = labelDims[j].x + labelDims[j].w;

      if (DvtTimeAxisInfo._isOverlapping(pointA1, pointA2, pointB1, pointB2, gap))
        labels[j] = null;
    }

    if (labels[j] != null) {
      // start evaluating from label j
      pointA1 = pointB1;
      pointA2 = pointB2;
      count++;
    }
  }

  return count;
}

/**
 * Skip labels uniformly (every regular interval).
 * @param {Array} labels An array of DvtText labels for the axis. This array will be modified by the method.
 * @param {Array} labelDims An array of DvtRectangle objects that describe the x, y, height, width of the axis labels.
 * @param {number} minSkip The minimum label skipping frequency.
 * @return {number} The number of remaining labels after skipping.
 * @private
 */
DvtAxisInfo.prototype._skipLabelsUniform = function(labels, labelDims, minSkip) {
  var shortLabelDims = []; // labelDims with null elements removed
  for (var j=0; j<labelDims.length; j++) {
    if (labelDims[j] != null)
      shortLabelDims.push(labelDims[j]);
  }

  var skippedLabels = minSkip;
  var bOverlaps = this.IsOverlapping(shortLabelDims, skippedLabels);
  while (bOverlaps) {
    skippedLabels++;
    bOverlaps = this.IsOverlapping(shortLabelDims, skippedLabels);
  }
  
  var count = shortLabelDims.length; // # of rendered labels
  if (skippedLabels > 0) {
    var n = 0; // non-null label counter
    for (var j=0; j<labels.length; j++) {
      if (labels[j] != null) {
        if (n % (skippedLabels+1) != 0) {
          labels[j] = null;
          count--;
        }
        n++;
      }
    }
  }
  return count;
}

/**
 * Format the alignments of the vertical axis labels and skip them accordingly so that level1 and level2 don't overlap.
 * @param {Array} labels1 An array of level 1 DvtText labels for the axis. This array will be modified by the method.
 * @param {Array} labels2 An array of level 2 DvtText labels for the axis. This array will be modified by the method.
 * @param {DvtContainer} container
 * @private
 */
DvtTimeAxisInfo.prototype._skipVertLabels = function (labels1, labels2, container) {
  // returns the dimensions of the label
  var getDims = function (label) {
    return label.measureDimensions();
  }

  var gap = parseInt(this.Options['tickLabel']['style'].getStyle('font-size')) * .1;

  // returns if two rectangles (dimsA and dimsB) overlap vertically
  var isOverlapping = function (dimsA, dimsB) {
    return DvtTimeAxisInfo._isOverlapping(dimsA.y, dimsA.y + dimsA.h, dimsB.y, dimsB.y + dimsB.h, gap);
  }

  var lastDims = null;
  var overlapping = false;

  // attempt to render both level 1 and level 2 and see if they fit on the axis
  for (var i = 0;i < labels1.length;i++) {
    if (labels1[i] && labels2[i]) {
      labels1[i].alignTop();
      labels2[i].alignBottom();
      if (lastDims && isOverlapping(lastDims, getDims(labels1[i]))) {
        overlapping = true;
        break;
      }
      else if(labels1[i+1] && isOverlapping(getDims(labels1[i]),getDims(labels1[i+1]))){
        overlapping = true;
        break;
      }
      else {
        lastDims = getDims(labels2[i]);
      }
    }
    else if (labels1[i] || labels2[i]) {
      var label = labels1[i] ? labels1[i] : labels2[i];
      if (lastDims && isOverlapping(lastDims, getDims(label))) {
        overlapping = true;
        break;
      }
      else {
        lastDims = getDims(label);
      }
    }
  }

  if (!overlapping)
    return;// if both levels fit, we're done
  var lastLv1Idx = null;
  var lastLv1Dims = null;
  var lastLv2Dims = null;
  var dims;

  // if they don't fit:
  // - for points that have level 2 labels, don't generate the level 1 (one level nesting)
  // - skip all level 1 labels that overlaps with level 2 labels
  for (i = 0;i < labels1.length;i++) {
    if (labels2[i]) {
      // if level 2 exists
      labels1[i] = null;// delete level 1
      labels2[i].alignMiddle();
      dims = getDims(labels2[i]);
      if (lastLv1Dims && isOverlapping(lastLv1Dims, dims)) {
        labels1[lastLv1Idx] = null;
      }
      lastLv2Dims = dims;
    }
    else if (labels1[i]) {
      // if level 1 exists but not level 2
      dims = getDims(labels1[i]);
      if (lastLv2Dims && isOverlapping(lastLv2Dims, dims)) {
        labels1[i] = null;
      }
      else {
        lastLv1Dims = dims;
        lastLv1Idx = i;
      }
    }
  }
}

/**
 * @override
 */
DvtTimeAxisInfo.prototype.getLabels = function (context, levelIdx) {
  if (levelIdx && levelIdx > 1)// time axis has no more than two levels
    return null;

  if (!this._level1Labels)
    this._generateLabels(context);
  
  if (levelIdx == 1) {
    return this._level2Labels;
  }

  return this._level1Labels;
}

/**
 * @override
 */
DvtTimeAxisInfo.prototype.getAxisLine = function (context) {
  var axisLineOptions = this.Options['axisLine'];
  if (axisLineOptions['rendered'] == "on") {
    // TODO hzhang Check Axis Line behavior for negative/mixed axes.
    var axisLineStroke = new DvtSolidStroke(axisLineOptions['lineColor'], 1, axisLineOptions['lineWidth']);
    return this.CreateGridLine(context, axisLineStroke, 10);
  }
  else 
    return null;
}

/**
 * Returns the grid line shift at index i.
 * @param {number} i
 * @return {number} Grid line shift.
 * @private
 */
DvtTimeAxisInfo.prototype._getGridLineShift = function(i) {
  if (this._renderGridAtLabels)
    return 0;
    
  var curr = this._level1Coords[i];
  var prev = null;
  for (var j = i-1; j >= 0; j--) { // find the coord before the current one
    if (this._level1Coords[j] != null) {
      prev = this._level1Coords[j];
      break;
    }
  }
  
  if (prev == null)
    return Infinity;
  
  return (curr - prev) / 2;
}

/**
 * @override
 */
DvtTimeAxisInfo.prototype.getMajorGridLines = function(context) {
  var majorTickOptions = this.Options['majorTick']; 
  if (majorTickOptions['rendered'] != "on")
    return [];
  
  var coords = [];
  if (this._isOneLevel){ // only one level, level1 is majorTick
    for (var i = 0; i < this._level1Coords.length; i++) {
      if (this._level1Coords[i] != null && this._level1Labels[i] != null)
        coords.push(this._level1Coords[i] - this._getGridLineShift(i));
    }
  }
  else { // level1 is minorTick, level2 is majorTick
    for (var i = 1; i < this._level2Coords.length; i++) { // don't draw first gridline for level2 label
      if (this._level2Coords[i] != null)
        coords.push(this._level2Coords[i] - this._getGridLineShift(i)); // render gridline even if label is skipped
    }
  }
  
  var majorTickStroke = new DvtSolidStroke(majorTickOptions['lineColor'], 1, majorTickOptions['lineWidth']);
  if (majorTickOptions['lineStyle'])
    majorTickStroke.setStyle(DvtStroke.convertTypeString(majorTickOptions['lineStyle']));
  
  var gridlines = [];
  for (var i = 0; i < coords.length; i++) {
    if (coords[i] >= this._minCoord && coords[i] <= this._maxCoord)
      gridlines.push(this.CreateGridLine(context, majorTickStroke, coords[i]));
  }
  
  return gridlines;
}

/**
 * @override
 */
DvtTimeAxisInfo.prototype.getMinorGridLines = function(context) {
  var minorTickOptions = this.Options['minorTick'];
  if (minorTickOptions['rendered'] != "on" || this._isOneLevel) // minorTick only applies on timeAxis if there is more than one level
    return [];
  
  var coords = [];
  for (var i = 0; i < this._level1Coords.length; i++) {
    if (this._level1Coords[i] != null && this._level1Labels[i] != null)
      coords.push(this._level1Coords[i] - this._getGridLineShift(i));
  }
  
  var minorTickStroke = new DvtSolidStroke(minorTickOptions['lineColor'], 1, minorTickOptions['lineWidth']);
  if (minorTickOptions['lineStyle'])
    minorTickStroke.setStyle(DvtStroke.convertTypeString(minorTickOptions['lineStyle'])); 
   
  var gridlines = [];
  for (var i = 0; i < coords.length; i++) {
    if (coords[i] >= this._minCoord && coords[i] <= this._maxCoord)
      gridlines.push(this.CreateGridLine(context, minorTickStroke, coords[i]));
  }
  
  return gridlines;
}

/**
 * @override
 */
DvtTimeAxisInfo.prototype.getValueAt = function (coord) {
  var minCoord = Math.min(this._minCoord, this._maxCoord);
  var maxCoord = Math.max(this._minCoord, this._maxCoord);
  
  // Return null if the coord is outside of the axis
  if(coord < minCoord || coord > maxCoord)
    return null;

  return this.getUnboundedValueAt(coord);
}

/**
 * @override
 */
DvtTimeAxisInfo.prototype.getCoordAt = function (value) {
  // Return null if the value is outside of the axis
  if (value < this.MinValue || value > this.MaxValue)
    return null;

  return this.getUnboundedCoordAt(value);
}

/**
 * @override
 */
DvtTimeAxisInfo.prototype.getBoundedValueAt = function (coord) {
  var minCoord = Math.min(this._minCoord, this._maxCoord);
  var maxCoord = Math.max(this._minCoord, this._maxCoord);

  if(coord < minCoord)
    coord = minCoord;
  else if(coord > maxCoord)
    coord = maxCoord;

  return this.getUnboundedValueAt(coord);
}

/**
 * @override
 */
DvtTimeAxisInfo.prototype.getBoundedCoordAt = function (value) {
  if (value < this.MinValue)
    value = this.MinValue;
  else if (value > this.MaxValue)
    value = this.MaxValue;

  return this.getUnboundedCoordAt(value);
}

/**
 * @override
 */
DvtTimeAxisInfo.prototype.getUnboundedValueAt = function (coord) {
  var ratio = (coord - this._minCoord) / (this._maxCoord - this._minCoord);
  return this.MinValue + (ratio * (this.MaxValue - this.MinValue));
}

/**
 * @override
 */
DvtTimeAxisInfo.prototype.getUnboundedCoordAt = function (value) {
  var ratio = (value - this.MinValue) / (this.MaxValue - this.MinValue);
  return this._minCoord + (ratio * (this._maxCoord - this._minCoord));
}

/**
 * Gets the width of a group (for rendering bar chart)
 * @return {Number} the width of a group
 */
DvtTimeAxisInfo.prototype.getGroupWidth = function () {
  return Math.abs(this.getUnboundedCoordAt(this.MinValue + this._averageInterval) - this.getUnboundedCoordAt(this.MinValue));
}

/**
 * @override
 */
DvtTimeAxisInfo.prototype.getMinimumExtent = function() {
  return this._averageInterval;
}

/**
 * @override
 */
DvtTimeAxisInfo.prototype.getStartOverflow = function() {
  if ((this.Position == "top" || this.Position == "bottom") && DvtAgent.isRightToLeft(this.getCtx()))
    return this.EndOverflow;
  else
    return this.StartOverflow;
}

/**
 * @override
 */
DvtTimeAxisInfo.prototype.getEndOverflow = function() {
  if ((this.Position == "top" || this.Position == "bottom") && DvtAgent.isRightToLeft(this.getCtx()))
    return this.StartOverflow;
  else
    return this.EndOverflow;
}
/**
 * Legend component.  This class should never be instantiated directly.  Use the
 * newInstance function instead.
 * @class
 * @constructor
 * @extends {DvtBaseComponent} 
 * @export
 */
var DvtLegend = function() {}

DvtObj.createSubclass(DvtLegend, DvtBaseComponent, "DvtLegend");

/**
 * Returns a new instance of DvtLegend.
 * @param {DvtContext} context The rendering context.
 * @param {string} callback The function that should be called to dispatch component events.
 * @param {object} callbackObj The optional object instance on which the callback function is defined.
 * @return {DvtLegend}
 * @export
 */
DvtLegend.newInstance = function(context, callback, callbackObj) {
  var legend = new DvtLegend();
  legend.Init(context, callback, callbackObj);
  return legend;
}

/**
 * Returns a copy of the default options for the specified skin.
 * @param {string} skin The skin whose defaults are being returned.
 * @return {object} The object containing defaults for this component.
 * @export
 */
DvtLegend.getDefaults = function(skin) 
{  
  return (new DvtLegendDefaults()).getDefaults(skin);
}

/**
 * @override
 * @protected
 */
DvtLegend.prototype.Init = function(context, callback, callbackObj) {
  DvtLegend.superclass.Init.call(this, context, callback, callbackObj);
  this.setId("legend" + 1000 + Math.floor(Math.random()*1000000000));
  
  // Create the defaults object
  this.Defaults = new DvtLegendDefaults();
  
  // Create the event handler and add event listeners
  this._eventManager = new DvtLegendEventManager(this);
  this._eventManager.addListeners(this);
    
  /** 
   * The array of logical objects for this legend.
   * @private 
   */
  this._peers = [];
  /** 
   * The array of scrollable legend sections for this legend.
   * @private 
   */
  this._scrollableSections = [];
}

/**
 * @override
 */
DvtLegend.prototype.SetOptions = function(options) {
  if(options) // Combine the user options with the defaults and store
    this.Options = this.Defaults.calcOptions(options);
  else if(!this.Options) // Create a default options object if none has been specified
    this.Options = this.GetDefaults();
}

/**
 * Returns the preferred dimensions for this component given the maximum available space.
 * @param {object} options The object containing specifications and data for this component.
 * @param {Number} maxWidth The maximum width available.
 * @param {Number} maxHeight The maximum height available.
 * @return {DvtDimension} The preferred dimensions for the object.
 */
DvtLegend.prototype.getPreferredSize = function(options, maxWidth, maxHeight) {
  // Update the options object.
  this.SetOptions(options);

  // Set the layout flag to indicate this is a layout pass only
  this.__getOptions()['isLayout'] = true;

  // Ask the legend to render its contents in the max space and find the space used. 
  var availSpace = new DvtRectangle(0, 0, maxWidth, maxHeight);
  var dim = DvtLegendRenderer.render(this, availSpace);
  
  // Clear the rendered contents and reset state
  this.__getOptions()['isLayout'] = false;
  
  // Return the space used
  return dim;
}

/**
 * @override
 * @export
 */
DvtLegend.prototype.render = function(options, width, height) 
{  
  // Update the options object.
  this.SetOptions(options);
  
  // Set the render flag to indicate we are rendering. Not being read correctly in flash - Bug 17310086 
  this.__getOptions()['isLayout'] = false;
  
  // Clear any contents rendered previously
  this.removeChildren();
  
  // Render the legend
  var availSpace = new DvtRectangle(0, 0, width, height);
  DvtLegendRenderer.render(this, availSpace);
}

/**
 * Highlights the specified categories.
 * @param {array} categories The array of categories whose data items will be highlighted. If null or empty, all 
 *                           highlighting will be removed.
 * @export
 */
DvtLegend.prototype.highlight = function(categories) {
  DvtCategoryRolloverHandler.highlight(categories, this.__getObjects());
}

/**
 * Processes the specified event.  
 * @param {object} event
 * @param {object} source The component that is the source of the event, if available.
 */
DvtLegend.prototype.processEvent = function(event, source) {
  var type = event.getType();
  if(type == DvtCategoryRolloverEvent.TYPE_OVER || type == DvtCategoryRolloverEvent.TYPE_OUT) {
    if(this.__getOptions()['hoverBehavior'] == "dim") 
      DvtCategoryRolloverHandler.processEvent(event, this.__getObjects());
      // For scrollable legend interactivty
      for (var i = 0; i < this._scrollableSections.length; i++)
        this._scrollableSections[i].processCategoryRollover(event);
  }
  
  // Dispatch the event to the callback if it originated from within this component or if it is a popup event.
  if(this == source || type == DvtShowPopupEvent.TYPE || type == DvtHidePopupEvent.TYPE) {
    this.__dispatchEvent(event);
  }
}

/**
 * Returns the evaluated options object, which contains the user specifications
 * merged with the defaults.
 * @return {object} The options object.
 */
DvtLegend.prototype.__getOptions = function() {
  return this.Options;
}

/**
 * Returns the DvtEventManager for this component.
 * @return {DvtEventManager}
 */
DvtLegend.prototype.__getEventManager = function() {
  return this._eventManager;
}

/**
 * Registers the object peer with the legend.  The peer must be registered to participate
 * in interactivity.
 * @param {DvtLegendObjPeer} peer
 */
DvtLegend.prototype.__registerObject = function(peer) {
  this._peers.push(peer);
}

/**
 * Returns the peers for all objects within the legend.
 * @return {array}
 */
DvtLegend.prototype.__getObjects = function() {
  return this._peers;
}

/**
 * Registers a scrollable legend section the legend. Used for interactivity.
 * @param {DvtScrollableLegend} section
 */
DvtLegend.prototype.__registerScrollableSection = function(section) {
  this._scrollableSections.push(section);
}
/**
 * Legend Constants
 * @class
 * @export
 */
var DvtLegendConstants = {};

DvtObj.createSubclass(DvtLegendConstants, DvtObj, "DvtLegendConstants");

/**
 * @const
 * @export
 */
DvtLegendConstants.BACKGROUND = "background";

/**
 * @const
 * @export
 */
DvtLegendConstants.LEGEND_ITEM = "legendItem";

/**
 * @const
 * @export
 */
DvtLegendConstants.TITLE = "title";
/**
 * Default values and utility functions for component versioning.
 * @class
 * @constructor
 * @extends {DvtBaseComponentDefaults}
 */
var DvtLegendDefaults = function() {
  this.Init({'skyros': DvtLegendDefaults.VERSION_1, 'alta': DvtLegendDefaults.SKIN_ALTA});
}

DvtObj.createSubclass(DvtLegendDefaults, DvtBaseComponentDefaults, "DvtLegendDefaults");

/**
 * Contains overrides for the 'alta' skin.
 */ 
DvtLegendDefaults.SKIN_ALTA = {
  'skin': DvtCSSStyle.SKIN_ALTA,
  'textStyle': new DvtCSSStyle("font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;"),
  'titleStyle': new DvtCSSStyle("font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 11px; color: #333333;"),
  'colors': DvtCSSStyle.COLORS_ALTA
}

/**
 * Defaults for version 1.
 */ 
DvtLegendDefaults.VERSION_1 = {
  'skin': DvtCSSStyle.SKIN_SKYROS,
  'orientation': "vertical",
  'position': null,
  'backgroundColor': null, 
  'borderColor': null,
  'textStyle': new DvtCSSStyle("font-size: 11px; color: #333333;"), 
  'titleStyle': new DvtCSSStyle("font-size: 12px; color: #003d5b;"), 
  'titleHalign': "start",
  'hideAndShowBehavior': "none",
  'hoverBehavior': "none",
  'scrolling': "asNeeded",
  
  // default color ramp, marker shape, and line width, for internal use
  'colors': DvtCSSStyle.COLORS_SKYROS,
  'markerShape': "square",
  'lineWidth': 3,
  
  //*********** Internal Attributes *************************************************//
  'layout': {
    // Gap ratio is multiplied against all gap sizes
    'gapRatio': 1.0,
    'outerGapWidth': 3, 'outerGapHeight': 3, // Used by Treemap for legend creation
    'titleGap': 3,
    'markerSize': 10, 'markerGap': 5,
    'rowGap': 0, 'columnGap': 8,
    'sectionGap': 6
  },
  
  'isLayout': false // true if rendering for layout purposes
}

/**
 * Scales down gap sizes based on the size of the component.
 * @param {object} options The object containing options specifications for this component.
 * @param {Number} defaultSize The default gap size.
 * @return {Number} 
 */
DvtLegendDefaults.getGapSize = function(options, defaultSize) {
  return Math.ceil(defaultSize * options['layout']['gapRatio']);
}
/**
 * Event Manager for DvtLegend.
 * @param {DvtLegend} legend
 * @class
 * @extends DvtEventManager
 * @constructor
 */
var DvtLegendEventManager = function (legend) {
  this.Init(legend.getCtx(), legend.processEvent, legend);
  this._legend = legend;
};

DvtObj.createSubclass(DvtLegendEventManager, DvtEventManager, "DvtLegendEventManager");

/**
 * Returns the parameters for the DvtComponentUIEvent for an object with the specified arguments.
 * @param {string} type The type of object that was the target of the event.
 * @param {object} [id] The id of the object, if one exists.
 */
DvtLegendEventManager.getUIEventParams = function(type, id) {
  return {'type': type, 'id': id};
}

/**
 * @override
 */
DvtLegendEventManager.prototype.FireUIEvent = function(type, logicalObj) {
  var params = null;
  if(logicalObj instanceof DvtSimpleObjPeer && logicalObj.getParams() != null) 
    params = logicalObj.getParams();
  else if(logicalObj instanceof DvtLegendObjPeer) 
    params = DvtLegendEventManager.getUIEventParams(DvtLegendConstants.LEGEND_ITEM, logicalObj.getId());
  
  this.FireEvent(new DvtComponentUIEvent(type, params), this._legend);
}

/**
 * @override
 */
DvtLegendEventManager.prototype.OnClick = function (event) {
  DvtLegendEventManager.superclass.OnClick.call(this, event);

  var obj = this.GetLogicalObject(event.target);
  if (!obj)
    return;
  
  var hideShow = this._processHideShowEvent(obj);
  var action = this._processActionEvent(obj);
    
  // If a hide/show or action occurs, the event should not bubble.
  if (hideShow || action)
    event.stopPropagation();
}

/**
 * @override
 */
DvtLegendEventManager.prototype.OnMouseOver = function (event) {
  DvtLegendEventManager.superclass.OnMouseOver.call(this, event);

  var obj = this.GetLogicalObject(event.target);
  if (!obj)
    return;

  // Category Rollover Support.  If rollover occurs, the event should not bubble.
  if(this._processRolloverEvent(obj, true))
    event.stopPropagation();
}

/**
 * @override
 */
DvtLegendEventManager.prototype.OnMouseOut = function (event) {
  DvtLegendEventManager.superclass.OnMouseOut.call(this, event);

  var obj = this.GetLogicalObject(event.target);
  if (!obj)
    return;

  // Category Rollover Support.  If rollover occurs, the event should not bubble.
  if(this._processRolloverEvent(obj, false))
    event.stopPropagation();
}

/**
 * @override
 */
DvtLegendEventManager.prototype.HandleTouchClickInternal = function (evt) {
  var obj = this.GetLogicalObject(evt.target);
  if (!obj) 
    return;

  // bug 13810791: if hideAndShow/action is enabled, it takes precedence over series highlighting
  var touchEvent = evt.touchEvent;
  var hideShow = this._processHideShowEvent(obj);
  var action = this._processActionEvent(obj);
  if ((hideShow || action) && touchEvent)
    touchEvent.preventDefault();
}

/**
 * @override
 */
DvtLegendEventManager.prototype.HandleTouchHoverStartInternal = function (event) {
  var obj = this.GetLogicalObject(event.target);
  if(this._processRolloverEvent(obj, true))
    event.stopPropagation();
}

DvtLegendEventManager.prototype.HandleTouchHoverEndInternal = function (event) {
  var obj = this.GetLogicalObject(event.target);
  if(this._processRolloverEvent(obj, false)) 
    event.stopPropagation();
}

/**
 * @override
 */
DvtLegendEventManager.prototype.HandleTouchHoverOverInternal = function (event) {
  var obj = this.GetLogicalObject(event.target);
  if(this._processRolloverEvent(obj, true)) 
    event.stopPropagation();
}

/**
 * @override
 */
DvtLegendEventManager.prototype.HandleTouchHoverOutInternal = function (event) {
  // Category Rollover Support.  If rollover occurs, the event should not bubble.
  var obj = this.GetLogicalObject(event.target);
  if(this._processRolloverEvent(obj, false)) 
    event.stopPropagation();
}

/**
 * Processes a hide and show action on the specified legend item.  Returns true if a hide or
 * show has been performed.
 * @param {DvtLegendObjPeer} obj The legend item that was clicked.
 * @return {boolean} True if an event was fired.
 * @private
 */
DvtLegendEventManager.prototype._processHideShowEvent = function (obj) {
  // Don't continue if not enabled
  if (this._legend.__getOptions()['hideAndShowBehavior'] == "none")
    return false;

  var categories = obj.getCategories ? obj.getCategories() : null;
  if (!categories || categories.length <= 0)
    return false;

  // Update the legend markers
  var displayables = obj.getDisplayables();
  for (var i = 0;i < displayables.length;i++) {
    var displayable = displayables[i];
    if (displayable instanceof DvtMarker)// setHollow is a toggle
      displayable.setHollow(obj.getColor());
  }

  // Update the state and create the event
  var id = categories[0];
  var dataItem = obj.getData();
  var visibility = dataItem['categoryVisibility'];
  if (visibility == "hidden") {
    // Currently hidden, show
    dataItem['categoryVisibility'] = "visible";
    this.FireEvent(new DvtCategoryHideShowEvent(DvtCategoryHideShowEvent.TYPE_SHOW, id), this._legend);
  }
  else {
    // Currently visible, hide
    dataItem['categoryVisibility'] = "hidden";
    this.FireEvent(new DvtCategoryHideShowEvent(DvtCategoryHideShowEvent.TYPE_HIDE, id), this._legend);
  }

  // Return true since an event was fired
  return true;
}

/**
 * Processes an action on the specified legend item.  Returns true if an action event is fired.
 * @param {DvtLegendObjPeer} obj The legend item that was clicked.
 * @return {boolean} True if an event was fired.
 * @private
 */
DvtLegendEventManager.prototype._processActionEvent = function (obj) {
  if(obj && obj.getAction && obj.getAction()) {
    this.FireEvent(new DvtActionEvent(DvtActionEvent.SUBTYPE_ACTION, obj.getAction(), obj.getId()), this._legend);
    return true;
  }
  return false;
}

/**
 * Processes a rollover action on the specified legend item.  Returns true if a rollover
 * event has been fired.
 * @param {DvtLegendObjPeer} obj The legend item that was the target of the event.
 * @param {boolean} bOver True if this is a rollover, false if this is a rollout.
 * @return {boolean} True if an event was fired.
 * @private
 */
DvtLegendEventManager.prototype._processRolloverEvent = function (obj, bOver) {
  // Don't continue if not enabled
  if (this._legend.__getOptions()['hoverBehavior'] == "none")
    return false;

  var categories = (obj && obj.getCategories) ? obj.getCategories() : null;
  if (!categories || categories.length <= 0)
    return false;

  // Fire the rollover event
  var eventType = bOver ? DvtCategoryRolloverEvent.TYPE_OVER : DvtCategoryRolloverEvent.TYPE_OUT;
  this.FireEvent(new DvtCategoryRolloverEvent(eventType, categories[0]), this._legend);
  return true;
}
/**
 * Logical object for legend data object displayables.
 * @param {DvtLegend} legend The owning legend instance.
 * @param {array} displayables The array of associated DvtDisplayables.
 * @param {string} id The id of the legend item.
 * @param {string} tooltip The tooltip of the legend item.
 * @class
 * @constructor
 * @implements {DvtLogicalObject}
 * @implements {DvtCategoricalObject}
 */
var DvtLegendObjPeer = function(legend, displayables, id, tooltip) {
  this.Init(legend, displayables, id, tooltip);
}

DvtObj.createSubclass(DvtLegendObjPeer, DvtObj, "DvtLegendObjPeer");

/**
 * @param {DvtLegend} legend The owning legend instance.
 * @param {array} displayables The array of associated DvtDisplayables.
 * @param {object} item The definition of the legend item.
 * @param {string} tooltip The tooltip of the legend item.
 */
DvtLegendObjPeer.prototype.Init = function(legend, displayables, item, tooltip) {
  this._legend = legend;
  this._displayables = displayables;
  this._item = item;
  this._id = item['id'] ? item['id'] : item['text'];
  this._action = item['action'];
  this._spb = item['_spb']; // popup support
  this._tooltip = tooltip;
  
  // Apply the cursor for the action if specified
  if (this._action) {
    for (var i = 0;i < this._displayables.length;i++) {
      this._displayables[i].setCursor(DvtSelectionEffectUtils.getSelectingCursor());
    }
  }
}

/**
 * Creates a data item to identify the specified displayable and registers it with the legend.
 * @param {array} displayables The displayables to associate.
 * @param {DvtLegend} legend The owning legend instance.
 * @param {object} item The definition of the legend item.
 * @param {string} tooltip The tooltip of the legend item.
 * @return {DvtLegendObjPeer}
 */
DvtLegendObjPeer.associate = function(displayables, legend, item, tooltip) {
  // Item must have displayables and an id to be interactive.
  if(!displayables || !item)
    return null;
    
  // Create the logical object. 
  var identObj = new DvtLegendObjPeer(legend, displayables, item, tooltip);
  
  // Register with the legend
  legend.__registerObject(identObj);
  
  // Finally associate using the event manager  
  for(var i=0; i<displayables.length; i++) 
    legend.__getEventManager().associate(displayables[i], identObj);
    
  return identObj;
}

/**
 * Returns the data object defining this legend item.
 * @return {object} The data object defining this legend item.
 */
DvtLegendObjPeer.prototype.getData = function() {
  return this._item;
}

/**
 * Returns the primary data color for this legend item.
 * @return {string} The color string.
 */
DvtLegendObjPeer.prototype.getColor = function () { 
  return this._item['color'];
}

/**
 * Returns the id for this legend item.
 * @return {object} The id for this legend item.
 */
DvtLegendObjPeer.prototype.getId = function() {
  return this._id;
}

//---------------------------------------------------------------------//
// Rollover and Hide/Show Support: DvtLogicalObject impl               //
//---------------------------------------------------------------------//

/**
 * @override
 */
DvtLegendObjPeer.prototype.getDisplayables = function () {
  return this._displayables;
}

//---------------------------------------------------------------------//
// Rollover and Hide/Show Support: DvtCategoricalObject impl           //
//---------------------------------------------------------------------//

/**
 * @override
 */
DvtLegendObjPeer.prototype.getCategories = function (category) {
  return [this._id];
};

/**
 * @override
 */
DvtLegendObjPeer.prototype.getTooltip = function(target) {
  return this._tooltip;
};

/**
 * Return the action string for the legend item, if any exists.
 * @returns {string} the action outcome for the legend item.
 */
DvtLegendObjPeer.prototype.getAction = function () {
  return this._action;
}

//---------------------------------------------------------------------//
// Popup Support: DvtPopupSource impl                                  //
//---------------------------------------------------------------------//

/**
 * @override
 */
DvtLegendObjPeer.prototype.getShowPopupBehaviors = function() {
  return this._spb;
}
/**
 * Renderer for DvtLegend.
 * @class
 */
var DvtLegendRenderer = new Object();

DvtObj.createSubclass(DvtLegendRenderer, DvtObj, "DvtLegendRenderer");

DvtLegendRenderer._DEFAULT_ITEM_WIDTH = 10;
DvtLegendRenderer._MAX_LINE_WIDTH = 5;
DvtLegendRenderer._MAX_LINE_WIDTH_WITH_MARKER = 2;
DvtLegendRenderer._LINE_MARKER_SIZE = 6;

/**
 * Renders the legend.
 * @param {DvtLegend} legend The legend being rendered.
 * @param {DvtRectangle} availSpace The available space.
 * @return {DvtDimension} The dimension of the legend.
 */
DvtLegendRenderer.render = function (legend, availSpace) {
  var options = legend.__getOptions();
  
  var gapWidth = DvtLegendDefaults.getGapSize(options, options['layout']['outerGapWidth']);
  var gapHeight = DvtLegendDefaults.getGapSize(options, options['layout']['outerGapHeight']);
  var legendSpace = new DvtRectangle(availSpace.x + gapWidth, availSpace.y + gapHeight,
      availSpace.w - 2*gapWidth, availSpace.h - 2*gapHeight);
  
  // return if there's no space
  if (legendSpace.w <= 0)
    return new DvtDimension(0, 0);
  
  var background;
  if (!options['isLayout'])
    background = DvtLegendRenderer._createBackground(legend, availSpace);

  var isHoriz = (options['orientation'] == "vertical" ? false : true);

  var titleDim = DvtLegendRenderer._renderTitle(legend, options['title'], legendSpace, null);
  legendSpace.y += titleDim.h;
  // Bug 17368977: IE9 attributes slightly too much height for the legend title
  legendSpace.h -= Math.floor(titleDim.h);
  
  // Row heights are same across all section so just calc once for all sections
  var rowHeight = DvtLegendRenderer._getRowHeight(legend);

  var bScrollable = (options['scrolling'] !== "off");
  
  var sectionsDim;
  if (!isHoriz) 
    sectionsDim = DvtLegendRenderer._renderVerticalSections(legend, legendSpace, rowHeight, bScrollable);
  else 
    sectionsDim = DvtLegendRenderer._renderHorizontalSections(legend, legendSpace, rowHeight);

  var totalDim = titleDim.getUnion(sectionsDim);
  
  // TODO hzhang Make the reparenting work with a scrollable container and stop illegal private access
  if(legend._scrollableSections.length <= 0) {
    // All objects above are rendered directly into the legend itself.  Reparent to a child container so that we can 
    // center the contents.  We need to use a while loop since the child list is being modified.
    var container = new DvtContainer(legend.getCtx());
    while(legend.getNumChildren() > 0) {
      container.addChild(legend.getChildAt(0));
    }
    legend.addChild(container);
  
    // Center the child container
    // TODO (panho): totalDim.h is incorrect
    container.setTranslateX((availSpace.w-totalDim.w)/2 - totalDim.x);
    //container.setTranslateY((availSpace.h-totalDim.h)/2 - totalDim.y);
  }
  
  // Render the background.  This is done here to avoid interfering with the centering of legend content.
  if(background)
    legend.addChildAt(background, 0);
  
  if (options['isLayout']) {
    // Return the preferred dimension (not the actual one)
    return new DvtDimension(Math.max(titleDim.w, sectionsDim.w) + 2*gapWidth, totalDim.h + 2*gapHeight);
  } else {
    // Return the actual dimension 
    return new DvtDimension(totalDim.w + 2*gapWidth, totalDim.h + 2*gapHeight);
  }
}

/**
 * Creates and returns the legend background/border colors and updates the available space.
 * @param {DvtLegend} legend The legend being rendered.
 * @param {DvtRectangle} availSpace The available space.
 * @return {DvtDisplayable} The background for the legend.
 * @private
 */
DvtLegendRenderer._createBackground = function (legend, availSpace) {
  var options = legend.__getOptions();

  var rect;
  if (options['backgroundColor']) {
    rect = (rect ? rect : new DvtRect(legend.getCtx(), availSpace.x, availSpace.y, availSpace.w, availSpace.h));
    rect.setSolidFill(options['backgroundColor']);
  }

  if (options['borderColor']) {
    rect = (rect ? rect : new DvtRect(legend.getCtx(), availSpace.x, availSpace.y, availSpace.w, availSpace.h));
    rect.setSolidStroke(options['borderColor']);
    rect.setPixelHinting(true);
  }
  
  // Associate with logical object to support DvtComponentUIEvent
  if(rect) {
    var params = DvtLegendEventManager.getUIEventParams(DvtLegendConstants.BACKGROUND);
    legend.__getEventManager().associate(rect, new DvtSimpleObjPeer(null, null, null, params));
  }

  return rect;
}

/**
 * Renders the legend title and updates the available space.
 * @param {DvtLegend} legend The legend being rendered.
 * @param {string} titleStr
 * @param {DvtRectangle} availSpace The available space.
 * @param {object} section The section attributes, if this is a section
 * @return {DvtRectangle} The dimension of the title.
 */
DvtLegendRenderer._renderTitle = function (legend, titleStr, availSpace, section) {
  var options = legend.__getOptions();
 
  if (!titleStr)
    return new DvtRectangle(availSpace.x, availSpace.y, 0, 0);
  
  // Create the title object and add to legend  
  var title = new DvtOutputText(legend.getCtx(), titleStr, availSpace.x, availSpace.y);
  var titleStyle = (section && section['titleStyle']) ? new DvtCSSStyle(section['titleStyle']) : options['titleStyle'];
  title.setCSSStyle(titleStyle);

  if(DvtTextUtils.fitText(title, availSpace.w, availSpace.h, legend)) {
    // Associate with logical object to support DvtComponentUIEvent and tooltips
    var params = DvtLegendEventManager.getUIEventParams(DvtLegendConstants.TITLE);
    legend.__getEventManager().associate(title, new DvtSimpleObjPeer(title.getUntruncatedTextString(), null, null, params));

    // Position the title based on text size and legend position 
    var titleDims = title.measureDimensions();
    var gap = DvtLegendDefaults.getGapSize(options, options['layout']['titleGap']);

    if (!options['isLayout']) {
      var titleHalign = (section && section['titleHalign']) ? section['titleHalign'] : options['titleHalign'];
      DvtLayoutUtils.align(availSpace, titleHalign, title, titleDims.w);
    }
    else {
      legend.removeChild(title);
    }

    titleDims.h += gap;
    return titleDims;
  }
  else {
    return new DvtRectangle(availSpace.x, availSpace.y, 0, 0);  
  }
}

DvtLegendRenderer._getLegendSections = function (section, sections) {
  var nestedSections = section['sections'];
  sections.push(section);
  if (nestedSections) {
    for (var i = 0;i < nestedSections.length;i++)
      DvtLegendRenderer._getLegendSections(nestedSections[i], sections);
  }
}

/**
 * Renders a vertical legend.
 * @param {DvtLegend} legend The legend being rendered.
 * @param {DvtRectangle} availSpace The available space.
 * @param {number} rowHeight The height of a legend row.
 * @param {boolean} bScrollable Whether the legend may be scrollable.
 * @return {DvtRectangle} The total dimension of the sections
 * @private
 */
DvtLegendRenderer._renderVerticalSections = function (legend, availSpace, rowHeight, bScrollable) {
  var options = legend.__getOptions();
  var sectionHeights = DvtLegendRenderer._calcSectionHeights(legend, availSpace, rowHeight, bScrollable);
  
  var legendSections = [];
  for (var i = 0; i < options['sections'].length; i++) {
    DvtLegendRenderer._getLegendSections(options['sections'][i], legendSections);
  }
  
  var numSections = legendSections.length;
  var sectionGap = DvtLegendDefaults.getGapSize(options, options['layout']['sectionGap']);
  
  var sectionSpace = availSpace.clone();
  var totalDim = null;
  var sectionDim;
  for (i = 0; i < legendSections.length; i++) {
    sectionSpace.h = sectionHeights[i];
    sectionDim = DvtLegendRenderer._renderSection(legend, legendSections[i], i, sectionSpace, rowHeight, bScrollable);
    if (i != numSections - 1 && legendSections[i]['items'])
      sectionSpace.y += sectionDim.h + sectionGap;
    totalDim = totalDim ? totalDim.getUnion(sectionDim) : sectionDim;
  }
  
  return totalDim;
}

/**
 * Renders a horizontal legend.
 * @param {DvtLegend} legend The legend being rendered.
 * @param {DvtRectangle} availSpace The available space.
 * @param {number} rowHeight The height of a legend row.
 * @return {DvtRectangle} The total dimension of the sections
 * @private
 */
DvtLegendRenderer._renderHorizontalSections = function (legend, availSpace, rowHeight) {
  // TODO (panho): Clean up this function
  // TODO (panho): Fix section width calculation
  
  var options = legend.__getOptions();
  var isRTL = DvtAgent.isRightToLeft(legend.getCtx());

  var legendWidth = 0;
  var legendSections = [];
  for (var i = 0; i < options['sections'].length; i++)
    DvtLegendRenderer._getLegendSections(options['sections'][i], legendSections);
  var numSections = legendSections.length;

  var totalItems = 0;
  for (var j = 0; j < legendSections.length; j++) {
    if (legendSections[j]['items'])
      totalItems += legendSections[j]['items'].length;
  }

  var sectionGap = DvtLegendDefaults.getGapSize(options, options['layout']['sectionGap']);
  var maxWidth = availSpace.w - sectionGap * (numSections - 1);
  
  var sectionSpace;    // avail space for the section
  var sectionMaxWidth; // maximum width of the section
  var sectionDim;      // actual dim of the section
  var totalDim;        // total dim of the sections

  // Pass in a percentage of max height/width based on proportion that legend section items account for
  if (options['sections']) {
    var nestedSectionCounter = 0;
    var outerSectionTitleHeight = 0;
    for (var i = 0; i < numSections; i++) {
      // Compute the available space for this section
      sectionSpace = availSpace.clone();
      var sectionItems = legendSections[i]['items'];
      if (sectionItems) {
        sectionMaxWidth = Math.round((sectionItems.length / totalItems) * maxWidth);
        sectionSpace.w = sectionMaxWidth;
        if (isRTL) {
          sectionSpace.x = availSpace.x + availSpace.w - legendWidth - sectionSpace.w;
        } else {
          sectionSpace.x = availSpace.x + legendWidth;
        }
        if (nestedSectionCounter > 0) {
          sectionSpace.y += outerSectionTitleHeight;
          sectionSpace.h -= outerSectionTitleHeight;
        }
        
        sectionDim = DvtLegendRenderer._renderSection(legend, legendSections[i], i, sectionSpace, rowHeight, false);
        if (nestedSectionCounter > 0) {
          sectionSpace.h += outerSectionTitleHeight;
          nestedSectionCounter--;
        }
        legendWidth += sectionDim.w;
        if (i != numSections - 1) {
          legendWidth += sectionGap;
        }
      }
      else { // Render section title for nested sections
        sectionSpace.w = availSpace.w - legendWidth;
        if (isRTL) {
          sectionSpace.x = availSpace.x;
        } else {
          sectionSpace.x = availSpace.x + legendWidth;
        }
        sectionDim = DvtLegendRenderer._renderSection(legend, legendSections[i], i, sectionSpace, rowHeight, false);
        outerSectionTitleHeight = sectionDim.h;
        nestedSectionCounter = legendSections[i]['sections'].length;
      }
      
      totalDim = totalDim ? totalDim.getUnion(sectionDim) : sectionDim;
    }
  }

  return totalDim;
}

/**
 * Renders the specified section.
 * @param {DvtLegend} legend The legend being rendered.
 * @param {object} section The data for the section to render.
 * @param {number} sectionIndex The index of the section being rendered.
 * @param {DvtRectangle} availSectionSpace The available space.
 * @param {number} rowHeight The height of a legend row.
 * @param {boolean} bScrollable True if scrolling is allowed.
 * @return {DvtRectangle} The dim of the section
 * @private
 */
DvtLegendRenderer._renderSection = function (legend, section, sectionIndex, availSectionSpace, rowHeight, bScrollable) {
  // TODO (panho): Clean up this method
  // TODO (panho): Set the column widths optimally
  
  // Section must exist to be rendered
  if (!section)
    return;
  
  var availSpace = new DvtRectangle(availSectionSpace.x, availSectionSpace.y, availSectionSpace.w, availSectionSpace.h);

  // Cache useful fields
  var options = legend.__getOptions();
  var context = legend.getCtx();
  var initAvailY = availSpace.y;
  var markerSize = options['layout']['markerSize'];
  var markerGap = DvtLegendDefaults.getGapSize(options, options['layout']['markerGap']);
  var rowGap = DvtLegendDefaults.getGapSize(options, options['layout']['rowGap']);
  var colGap = DvtLegendDefaults.getGapSize(options, options['layout']['columnGap']);
  
  // Determine legend section title
  var titleDim = DvtLegendRenderer._renderTitle(legend, section['title'], availSpace, section);
  availSpace.y += titleDim.h;
  
  // See if this is a section group which contains more legend sections
  if (!section['items']) {
    availSpace.h = titleDim.h;
    return;
  }
  
  //Title should always be on its own row
  availSpace.h -= titleDim.h;
  initAvailY += titleDim.h;

  // Determine needed cols and rows
  var legendInfo = DvtLegendRenderer._calcSectionSpace(legend, availSpace, rowHeight, section['items'], bScrollable);
  var numCols = legendInfo['numCols'];
  var numRows = legendInfo['numRows'];
  var colWidth = legendInfo['width'];
  
  // Update availSpace with space required for regular or scrollable legend
  var legendHeight = numRows * (rowHeight + rowGap) - rowGap;
  // Bug 1736897: availSpace.h is rounded up to fix bug in IE9 & Chrome
  availSpace.h = Math.ceil(Math.min(availSpace.h, legendHeight) + titleDim.h);
  availSpace.w = (colWidth * numCols) + (colGap * (numCols - 1));
  
  // No need to render during layout pass
  if(options['isLayout']) {
    if(numRows == 1) {
      var totalWidth = 0;
      for (var i = 0;i < section['items'].length;i++) {
        var item = section['items'][i];
        var itemTextWidth = Math.ceil(DvtLegendRenderer._getTextWidth(legend, item.text));
        totalWidth += itemTextWidth + markerSize + markerGap + colGap;
      }
      availSpace.w = totalWidth - colGap;
    }
    
    return availSpace;
  }
  
  // Don't render if not enough space
  if (numRows == 0 || numCols == 0)
    return availSpace;

  // If rendering, check to see if scrolling is allowed. If it is, create a DvtScrollableLegend if needed
  // We currently only support scrolling for vertical legends.
  var scrollableLegend = null;
  var container = legend;
  var fullLegendHeight = numRows * (rowHeight + rowGap) - rowGap + titleDim.h;
  var numItems = section['items'].length;
  if (options['orientation'] === "vertical" && bScrollable && fullLegendHeight > availSpace.h) 
  {
    var handle = DvtLegendRenderer._createHandle(legend, context, availSpace, sectionIndex);
    scrollableLegend = DvtLegendRenderer._createScrollableLegend(legend, context, availSpace, handle, fullLegendHeight, numItems);
    legend.__registerScrollableSection(scrollableLegend);
    container = handle;
  }

  // For text truncation
  var textSpace = colWidth - markerSize - markerGap;

  // For BIDI
  var isRTL = DvtAgent.isRightToLeft(legend.getCtx());

  // Render the items one by one
  var currRow = 0;
  var currCol = 1;

  // Sections with a single row of legend items
  if(numRows == 1) {
    // Calculate the unused space if all space was assigned equally
    var extraTextSpace = 0;
    for (var i = 0;i < numItems;i++) {
      var item = section['items'][i];
      var itemTextWidth = Math.ceil(DvtLegendRenderer._getTextWidth(legend, item.text));
      if (itemTextWidth < textSpace)
        extraTextSpace += textSpace - itemTextWidth;
    }

    for (var i = 0;i < numItems;i++) {
      var item = section['items'][i];

      var markerX = isRTL ? availSpace.x + availSpace.w - markerSize : availSpace.x;
      var textX = isRTL ? availSpace.x + availSpace.w - markerSize - markerGap : availSpace.x + markerSize + markerGap;
      
      // Create legend marker
      var marker = DvtLegendRenderer._createLegendMarker(legend, markerX, availSpace.y, rowHeight, markerSize, item, i)

      // Create legend text
      var label = item['text'];
      var itemTextWidth = Math.ceil(DvtLegendRenderer._getTextWidth(legend, item.text));
      var text = null;
      if (label) {
        if (itemTextWidth < textSpace) {
          text = DvtLegendRenderer._createLegendText(legend, context, availSpace, textSpace, label, options['textStyle']);
        }
        else {
          text = DvtLegendRenderer._createLegendText(legend, context, availSpace, textSpace + extraTextSpace, label, options['textStyle']);
          if (text != null) {
            itemTextWidth = Math.ceil(DvtLegendRenderer._getTextWidth(legend, text.getTextString()));
            extraTextSpace -= (textSpace-itemTextWidth);
          }

        }
        
        itemTextWidth = text != null ? Math.ceil(DvtLegendRenderer._getTextWidth(legend, text.getTextString())) : 0;
        
        if(text) {
          text.setX(textX);
          text.setY(availSpace.y + rowHeight/2);
          if (isRTL)
            text.alignRight();
        }
      }

      // Add legend marker to legend. Legend text has been added by _createLegendText.
      legend.addChild(marker);
        
      // Draw a rectangle on top of the legend item.  This rectangle is used for interactivity and to ensure that
      // rollover is smooth when moving across legend items.
      colWidth = itemTextWidth + markerSize + markerGap;
      var startX = Math.min(markerX, textX);
      var itemWidth = (currCol == numCols) ? colWidth : colWidth + colGap;
      var itemRect = new DvtRect(context, startX, availSpace.y, itemWidth, rowHeight);
      itemRect.setInvisibleFill();
      container.addChild(itemRect);  

      // Associate for interactivity. Scrollable legend doesn't handle eventing.
      var tooltip = text != null ? text.getUntruncatedTextString() : null;
      var peer = DvtLegendObjPeer.associate([itemRect, marker, text], legend, item, tooltip);  

      // Legend item visibility support
      if (item['categoryVisibility'] == "hidden" && peer)
        marker.setHollow(peer.getColor());

      // Update coordiantes for next row  
      availSpace.y += (rowHeight + rowGap);
      currRow++;

      if (currRow === numRows && currCol !== numCols) {
        availSpace.y = initAvailY;
        if (isRTL)
          availSpace.w -= colWidth + colGap;
        else 
          availSpace.x += colWidth + colGap;
        currRow = 0;
        currCol++;
      }
    }
  }
  else {
    // iterate through items
    for (var i = 0;i < numItems;i++) {
      var item = section['items'][i];
      var markerX = isRTL ? availSpace.x + availSpace.w - markerSize : availSpace.x;
      var textX = isRTL ? availSpace.x + availSpace.w - markerSize - markerGap : availSpace.x + markerSize + markerGap;

      // Create legend marker
      var marker = DvtLegendRenderer._createLegendMarker(legend, markerX, availSpace.y, rowHeight, markerSize, item, i)

      // Create legend text
      var label = item.text;
      var text = null;
      if (label) {
        text = DvtLegendRenderer._createLegendText(container, context, availSpace, textSpace, label, options['textStyle']);
        if(text) {
          text.setX(textX);
          text.setY(availSpace.y + rowHeight / 2);
          if (isRTL)
            text.alignRight();
        }
      }
      
      // Add legend items to legend. Legend text has been added by _createLegendText.
      container.addChild(marker);
        
      // Draw a rectangle on top of the legend item.  This rectangle is used for interactivity and to ensure that
      // rollover is smooth when moving across legend items.
      var startX = Math.min(markerX, textX);
      var itemWidth = (currCol == numCols) ? colWidth : colWidth + colGap;
      var itemRect = new DvtRect(context, startX, availSpace.y, itemWidth, rowHeight);
      itemRect.setInvisibleFill();
      container.addChild(itemRect);  

      // Associate for interactivity. Scrollable legend doesn't handle eventing.
      var tooltip = text != null ? text.getUntruncatedTextString() : null;
      var peer = DvtLegendObjPeer.associate([itemRect, marker, text], legend, item, tooltip);

      // For scrollable legend interactivity
      if (scrollableLegend && peer instanceof DvtLegendObjPeer)
        scrollableLegend.__registerObject(peer);

      // Legend item visibility support
      if (item['categoryVisibility'] == "hidden" && peer)
        marker.setHollow(peer.getColor());

      // Update coordinates for next row  
      availSpace.y += (rowHeight + rowGap);
      currRow++;
      if (currRow === numRows && currCol !== numCols) {
        availSpace.y = initAvailY;
        if (isRTL)
          availSpace.w -= colWidth + colGap;
        else 
          availSpace.x += colWidth + colGap;
        currRow = 0;
        currCol++;
      }
    }
  }
  
  // Set the y to the bottom of the section for rendering the next section
  availSpace.y = initAvailY + availSpace.h - titleDim.height;
  return new DvtRectangle(availSectionSpace.x, initAvailY - titleDim.height, availSectionSpace.w, availSpace.h);
}

/**
 * Calculates the heights of the legend sections.
 * @param {DvtLegend} legend The legend being rendered.
 * @param {DvtRectangle} availSpace The available space.
 * @param {number} rowHeight The height of a legend row.
 * @param {boolean} bScrollable True if scrolling is allowed.
 * @return {array} The array of the heights of the sections.
 */
DvtLegendRenderer._calcSectionHeights = function (legend, availSpace, rowHeight, bScrollable) {
  //TODO (panho): Clean up this method
  var options = legend.__getOptions();

  var isLayout = options['isLayout'];
  options['isLayout'] = true;

  var legendHeight = 0;
  var legendWidth = 0;
  var legendX = availSpace.x;
  var legendY = availSpace.y;

  var legendSections = [];
  for (var i = 0;i < options['sections'].length;i++)
    DvtLegendRenderer._getLegendSections(options['sections'][i], legendSections);
  var numSections = legendSections.length;

  var sectionGap = DvtLegendDefaults.getGapSize(options, options['layout']['sectionGap']);
  var maxHeight = availSpace.h - sectionGap * (numSections - 1);
  var maxWidth = availSpace.w;

  var arSectionSpace = [];
  var sectionDim;
  // Give each section max legend space and determine the space needed
  for (var i = 0;i < numSections;i++) {
    availSpace.h = maxHeight;
    availSpace.w = maxWidth;
    sectionDim = DvtLegendRenderer._renderSection(legend, legendSections[i], i, availSpace, rowHeight, bScrollable);
    arSectionSpace[i] = sectionDim.h;
  }

  // Give each section equal space and determine leftover/needed space
  arSectionSpaceNeeded = [];
  numShortSections = 0;
  extraSpace = 0;
  var equalSpace = maxHeight / numSections;
  for (i = 0;i < numSections;i++) {
    var spaceNeeded = arSectionSpace[i] - equalSpace;
    if (spaceNeeded <= 0) {
      arSectionSpaceNeeded[i] = 0;
      extraSpace -= spaceNeeded;// Keep track of unused space
    }
    else {
      arSectionSpace[i] = equalSpace;
      arSectionSpaceNeeded[i] = spaceNeeded;
      numShortSections++;
    }
  }

  // If there is unused space, distribute evenly across all sections that need it until there is no more
  while (extraSpace > 0 && numShortSections > 0) {
    var splitSpace = extraSpace / numShortSections;

    for (i = 0;i < numSections;i++) {
      if (arSectionSpaceNeeded[i] > 0) {
        spaceNeeded = arSectionSpaceNeeded[i] - splitSpace;
        if (spaceNeeded <= 0) {
          arSectionSpace[i] += arSectionSpaceNeeded[i];// Filled space needs, update
          arSectionSpaceNeeded[i] = 0;
          extraSpace = extraSpace - (splitSpace + spaceNeeded);// Keep track of unused space
          numShortSections--;// Decrement sections that still need space
        }
        else {
          arSectionSpace[i] += splitSpace;
          extraSpace -= splitSpace;
          arSectionSpaceNeeded[i] = spaceNeeded;
        }
      }
    }
  }

  // Pre render again in new allocated space
  availSpace.x = legendX;
  availSpace.y = legendY;
  availSpace.w = maxWidth;
  for (i = 0;i < numSections;i++) {
    availSpace.h = arSectionSpace[i];
    DvtLegendRenderer._renderSection(legend, legendSections[i], i, availSpace, rowHeight, bScrollable);
    availSpace.x = legendX;
    legendWidth = Math.max(availSpace.w, legendWidth);
    legendHeight += availSpace.h;
    if (i != numSections - 1) {
      availSpace.y = availSpace.h + legendY + sectionGap;
      legendHeight += sectionGap;
    }
  }

  availSpace.w = legendWidth;
  availSpace.h = legendHeight;
  availSpace.x = legendX;
  availSpace.y = legendY;
  options['isLayout'] = isLayout;

  return arSectionSpace;
}

/**
 * Returns the space required for a legend section.
 * @param {DvtLegend} legend The legend being rendered.
 * @param {DvtRectangle} availSpace The available space.
 * @param {number} rowHeight The height of a legend row.
 * @param {object} items The legend items to be rendered.
 * @param {boolean} bScrollable True if scrolling is allowed.
 * @return {object} Map containing width, rows and columns in the legend.
 * @private
 */
DvtLegendRenderer._calcSectionSpace = function (legend, availSpace, rowHeight, items, bScrollable) {
  var options = legend.__getOptions();

  // Use widest text since using # of chars can be wrong for unicode
  var textWidth = 0;
  for (var i = 0;i < items.length;i++) {
    var item = items[i];
    var tempWidth = DvtLegendRenderer._getTextWidth(legend, item.text);
    if (tempWidth > textWidth) {
      textWidth = tempWidth;
    }
  }

  // Row variables
  var markerSize = options['layout']['markerSize'];
  var markerGap = DvtLegendDefaults.getGapSize(options, options['layout']['markerGap']);
  var rowGap = DvtLegendDefaults.getGapSize(options, options['layout']['rowGap']);
  var colGap = DvtLegendDefaults.getGapSize(options, options['layout']['columnGap']);

  var numRows;
  var colWidth;
  var numCols;
  var fullColWidth = (options['isLayout'] ? Math.ceil(markerSize + markerGap + textWidth) : availSpace.w);

  var isHoriz = (options['orientation'] == "vertical" ? false : true);
  if (isHoriz) {
    // For horizontal layouts, try to go all the way across using fullColWidth, if not enough space, 
    // maximize depth and then determine cols to reduce text truncation
    var fullNumCols = Math.floor(availSpace.w / fullColWidth);
    numCols = Math.min(fullNumCols, items.length);
    numRows = Math.ceil((((fullColWidth + colGap) * items.length) - colGap) / availSpace.w);
    if ((numRows * (rowHeight + rowGap)) - rowGap > availSpace.h) {
      // Bug 17369106: Math.ceil(availSpace.h + rowGap) stops IE9 from calculating numRows as 0
      // so that labels in horizontal lengends with titles get rendered.
      numRows = Math.floor(Math.ceil(availSpace.h + rowGap) / (rowHeight + rowGap));
      numCols = Math.ceil(items.length / numRows);
    }
  }
  else {
    // For scrollable legends, don't wrap legend items into more than one column
    if (bScrollable) {
      numCols = 1;
      numRows = items.length;
    }
    else {
      // For vertical layouts use full depth and then increase cols as necessary
      numRows = Math.min(Math.floor((availSpace.h + rowGap) / (rowHeight + rowGap)), items.length);
      numCols = Math.ceil(items.length / numRows);
    }
  }
  var maxColWidth = (availSpace.w - (colGap * (numCols - 1))) / numCols;
  colWidth = Math.min(fullColWidth, maxColWidth);

  if (colWidth < markerSize)
    return {'width' : 0, 'height' : 0, 'numCols' : 0, 'numRows' : 0};

  return {'width' : colWidth, 'numCols' : numCols, 'numRows' : numRows};
}

/**
 * Returns the height of a single item in the legend.
 * @param {DvtLegend} legend The legend being rendered.
 * @return {number} The height of a legend item.
 */
DvtLegendRenderer._getRowHeight = function (legend) {
  var options = legend.__getOptions();

  // Figure out the legend item height
  var text = new DvtOutputText(legend.getCtx(), "Test");
  text.setCSSStyle(options['textStyle']);
  text.alignMiddle();
  var dims = DvtTextUtils.guessTextDimensions(text);
  return Math.ceil(Math.max(dims.h, options['layout']['markerSize']));
}

/**
 * Returns the width of a text object in the legend with legend CSS styles applied.
 * @param {DvtLegend} legend The legend being rendered.
 * @param {string} label The text to be rendered.
 * @return {number} The width of the text object.
 */
DvtLegendRenderer._getTextWidth = function (legend, label) {
  var options = legend.__getOptions();

  // Figure out the legend item height
  var text = new DvtOutputText(legend.getCtx(), label);
  text.setCSSStyle(options['textStyle']);
  var dims = text.measureDimensions();
  return dims.w;
}

/**
 * Creates a legend item. Adds the text to the legend if it's not empty.
 * @param {DvtLegend} legend The legend being rendered.
 * @param {DvtContext} context The context in which to create the legend item.
 * @param {DvtRectangle} availSpace The available space.
 * @param {number} textSpace The width allowed for text.
 * @param {String} label The content of the text object.
 * @param {String} style The CSS style string to apply to the text object.
 * @return {DvtText}
 * @private
 */
DvtLegendRenderer._createLegendText = function (legend, context, availSpace, textSpace, label, style) {
  // Draw the legend text.
  var text = new DvtOutputText(context, label);
  text.alignMiddle();
  text.setCSSStyle(style);
  text = DvtTextUtils.fitText(text, textSpace, availSpace.h, legend) ? text : null;
  return text;
}

/**
 * Creates a legend item.
 * @param {DvtLegend} legend The legend being rendered.
 * @param {number} x The x coordinate of the legend marker.
 * @param {number} y The y coordinate of the legend marker.
 * @param {number} rowHeight The height of the legend item.
 * @param {number} markerSize The size of the legend item.
 * @param {object} item The data for the legend item.
 * @param {number} i The index of the legend marker. Used for determining the default color.
 * @return {DvtShape}
 * @private
 */
DvtLegendRenderer._createLegendMarker = function (legend, x, y, rowHeight, markerSize, item, i) {
  // Apply the default styles
  var legendOptions = legend.__getOptions();
  if (!item['markerShape'])
    item['markerShape'] = legendOptions['markerShape'];
    
  if (!item['color']) {
    var colorRamp = legendOptions['colors'];
    item['color'] = colorRamp[i % colorRamp.length];
  }
  
  if (!item['lineWidth'])
    item['lineWidth'] = legendOptions['lineWidth'];
  
  var marker;
  if (item['type'] == "line") {
    item['lineWidth'] = Math.min(item['lineWidth'], DvtLegendRenderer._MAX_LINE_WIDTH);
    marker = DvtLegendRenderer._createLine(legend.getCtx(), x, y, rowHeight, item);
  }
  else if (item['type'] == "lineWithMarker") {
    item['lineWidth'] = Math.min(item['lineWidth'], DvtLegendRenderer._MAX_LINE_WIDTH_WITH_MARKER);
    marker = DvtLegendRenderer._createLine(legend.getCtx(), x, y, rowHeight, item);
    
    // Only create the marker if the legend item corresponds to a visible category
    if(item['categoryVisibility'] != "hidden")
      marker.addChild(DvtLegendRenderer._createMarker(legend, x, y, rowHeight, DvtLegendRenderer._LINE_MARKER_SIZE, item));
  }
  else {
    marker = DvtLegendRenderer._createMarker(legend, x, y, rowHeight, markerSize, item)
  }
  return marker;
}

/**
 * Creates a marker item.
 * @param {DvtLegend} legend The legend being rendered.
 * @param {number} x The x coordinate of the legend marker.
 * @param {number} y The y coordinate of the legend marker.
 * @param {number} rowHeight The height of the legend item.
 * @param {number} itemSize The size of the legend item
 * @param {object} item The data for the legend item.
 * @return {DvtMarker}
 * @private
 */
DvtLegendRenderer._createMarker = function (legend, x, y, rowHeight, itemSize, item) {
  var context = legend.getCtx();
  var legendOptions = legend.__getOptions();

  // Find the style values
  var itemShape = item['markerShape'];
  var itemColor = item['markerColor'] ? item['markerColor'] : item['color'];
  var itemPattern = item['pattern'];

  // Create the marker
  var markerY = y + (rowHeight - itemSize) / 2;
  var markerX = (item['type'] == "lineWithMarker" ? x + (DvtLegendRenderer._DEFAULT_ITEM_WIDTH - itemSize) / 2 : x);

  var legendMarker;
  if(itemPattern) {
    // Pattern markers must be translated, since the pattern starts at the origin of the shape
    legendMarker = new DvtMarker(context, itemShape, legendOptions['skin'], 0, 0, itemSize, itemSize);
    legendMarker.setFill(new DvtPatternFill(itemPattern, itemColor, "#FFFFFF"));
    legendMarker.setTranslate(markerX, markerY);
  }
  else {
    legendMarker = new DvtMarker(context, itemShape, legendOptions['skin'], markerX, markerY, itemSize, itemSize);
    legendMarker.setSolidFill(itemColor);
  }

  if(item['borderColor'])
    legendMarker.setSolidStroke(item['borderColor']);
    
  // Use pixel hinting for crisp squares  
  if(itemShape == "square")
    legendMarker.setPixelHinting(true);

  return legendMarker;
}

/**
 * Creates a line item.
 * @param {DvtContext} context The context in which to create the legend item.
 * @param {number} x The x coordinate of the legend marker.
 * @param {number} y The y coordinate of the legend marker.
 * @param {number} rowHeight The height of the legend item.
 * @param {object} item The data for the legend item.
 * @return {DvtLine}
 * @private
 */
DvtLegendRenderer._createLine = function (context, x, y, rowHeight, item) {
  var textY = y + rowHeight / 2;
  var line = new DvtLine(context, x, textY, x + DvtLegendRenderer._DEFAULT_ITEM_WIDTH, textY);
  var stroke = new DvtSolidStroke(item['color'], 1, item['lineWidth']);
  
  // Set the line style. The size and the spacing of the dash/dot has to be shrunk so that it's readable inside the 10px box.
  var style = item['lineStyle'];
  if (style == "dashed")
    stroke.setType(DvtStroke.convertTypeString(style), "4,2,4");
  else if (style == "dotted")
    stroke.setType(DvtStroke.convertTypeString(style), "2");
  
  line.setStroke(stroke);
  line.setPixelHinting(true);
  return line;
}

/**
 * Creates a handle for a scrollable legend.
 * @param {DvtLegend} legend The legend being rendered
 * @param {DvtContext} context The context in which to create the legend item.
 * @param {DvtRectangle} availSpace The available space.
 * @param {String} id The handle id.
 * @return {DvtHandle}
 * @private
 */
DvtLegendRenderer._createHandle = function (legend, context, availSpace, id) {
  var boundRect = [availSpace.x, availSpace.y, availSpace.x + availSpace.w, availSpace.y + availSpace.h];
  var clipRect = availSpace.clone();
  var clipId = legend.getId() + "_" + id;
  var handle = new DvtHandle(context, "legendHandler", boundRect, clipRect, clipId);
  legend.addChild(handle);
  return handle;
}

/**
 * Creates a scrollable legend and registers it with the parent legend container.
 * @param {DvtLegend} legend The legend being rendered.
 * @param {DvtContext} context The context in which to create the legend item.
 * @param {DvtRectangle} availSpace The available space.
 * @param {DvtHandle} handle The legend handle to associate with.
 * @param {number} legendHeight The height of all the legend items.
 * @param {number} numItems The number of legend rows.
 * @return {DvtScrollableLegend}
 * @private
 */
DvtLegendRenderer._createScrollableLegend = function (legend, context, availSpace, handle, legendHeight, numItems) {
  var scrollableLegend = new DvtScrollableLegend(context, availSpace.x, availSpace.y, availSpace.w, availSpace.h, legendHeight, handle, numItems);
  scrollableLegend.setTouchManager(legend.__getEventManager().getTouchManager());
  legend.addChild(scrollableLegend);
  handle.render();// rendering must occur after scrollabe legend has created and set the clip path on the handle
  return scrollableLegend;
}
// Copyright (c) 2011, 2014, Oracle and/or its affiliates. All rights reserved.
/**
  *  Creates a selectable shape using SVG path commands.
  *  @extends DvtArc
  *  @class DvtGraphSelectableArc  Creates an arbitrary shape using SVG path commands.
  *  @constructor
  *  @param {DvtContext} context 
  *  @param {number} cx  The center x position.
  *  @param {number} cy  The center y position.
  *  @param {number} rx  The horizontal radius of the ellipse.
  *  @param {number} ry  The vertical radius of the ellipse.
  *  @param {number} sa  The starting angle in degrees (following the normal anti-clockwise is positive convention).
  *  @param {number} ae  The angle extent in degrees (following the normal anti-clockwise is positive convention).
  *  @param {String} clos  An optional closure type for the arc. Closures are "OPEN" (the default), "SEGMENT", and "CHORD".
  *  @param {String} id  Optional ID for the shape (see {@link  DvtDisplayable#setId}).
  */
var  DvtGraphSelectableArc = function(context, cx, cy, rx, ry, sa, ae, clos, id)
{
   this.Init(context, cx, cy, rx, ry, sa, ae, clos, id) ;
};

DvtObj.createSubclass(DvtGraphSelectableArc, DvtArc, "DvtGraphSelectableArc") ;

/**
  *  Object initializer.
  *  @protected
  */
DvtGraphSelectableArc.prototype.Init = function(context, cx, cy, rx, ry, sa, ae, clos, id)
{
  DvtGraphSelectableArc.superclass.Init.call(this, context, cx, cy, rx, ry, sa, ae, clos, id) ;
  //properties related to selection
  this._bSelected = false;
  this._bSelecting = false;
  this._selectionEffects = null;
  this._bSelectedShadow = true;
  this._dataColor = "#000000";
  this._innerColor = null;
  this._outerColor = null;
  
  this._savedStroke = null;
  this._bSavedStroke = false;
  this._relatedLogicalObjects = null;
  this._applyStrokeTimer  = null;
  
  this._bZorder = true;
  this._zOrderManager = null;

  this._selectionType = context.getDocumentUtils().isFilterSupported() ? DvtSelectionEffectUtils.SEL_TYPE_STROKE_FILTERS : DvtSelectionEffectUtils.SEL_TYPE_STROKE_NO_FILTERS;
}

/**
 * Show the selection hover effect.
 */
DvtGraphSelectableArc.prototype.showHoverEffect = function()
{
  this.SetSelectionMouseOver(true);
};


/**
 * Hide the selection hover effect.
 */
DvtGraphSelectableArc.prototype.hideHoverEffect = function()
{
  this.SetSelectionMouseOver(false);
};


/**
 * Determine if the selection hover effect is shown.
 * 
 * @type boolean
 */
DvtGraphSelectableArc.prototype.isHoverEffectShown = function()
{
  return this._bSelecting;
};


/**
 * @protected
 * Set whether the selection mouse hover effect is shown.
 * 
 * @param bOver {boolean}  bOver  true if the mouse is over the object,
 *        false otherwise
 */
DvtGraphSelectableArc.prototype.SetSelectionMouseOver = function(bOver)
{
  this.SetSelectionMouseOverSelf(bOver);

  //set selection on related parts of this marker also
  if (this._relatedLogicalObjects)
  {
    for (var i = 0; i < this._relatedLogicalObjects.length; i++)
    {
      if (this._relatedLogicalObjects[i].SetSelectionMouseOverSelf)
      {
        this._relatedLogicalObjects[i].SetSelectionMouseOverSelf(bOver);
      }
    }
  }
}

/**
 * @protected
 * Set whether the selection mouse hover effect is shown.
 * 
 * @param bOver {boolean}  bOver  true if the mouse is over the object,
 *        false otherwise
 */
DvtGraphSelectableArc.prototype.SetSelectionMouseOverSelf = function(bOver)
{
  if (this._bSelecting != bOver)
  {
    this._bSelecting = bOver;
    if (this._bZorder)
    {   
      if (this._bSelecting && this._zOrderManager)
      {
        this._zOrderManager.bringToFrontOfSelection(this);
      }
      else if (!this._bSelected)
      {
        this._zOrderManager.pushToBackOfSelection(this);
      }
    }
    
    DvtSelectionEffectUtils.applyHoverState(this, this._dataColor);
  }
};


/**
 * Determine whether this object is selected.
 * 
 * @type boolean
 */
DvtGraphSelectableArc.prototype.isSelected = function()
{
  return this._bSelected;
};

/**
 * Set whether the selection effect is shown.
 * 
 * @param bOver {boolean}  bSel  true if the object is selected,
 *        false otherwise
 */
DvtGraphSelectableArc.prototype.setSelected = function(bSel)
{
  this.SetSelectedSelf(bSel);

  //set selection on related parts of this marker also
  if (this._relatedLogicalObjects)
  {
    for (var i = 0; i < this._relatedLogicalObjects.length; i++)
    {
      if (this._relatedLogicalObjects[i].SetSelectedSelf)
      {
        this._relatedLogicalObjects[i].SetSelectedSelf(bSel);
      }
    }
  }
};

/**
 * @protected
 * Set whether the selection effect is shown.
 * 
 * @param bOver {boolean}  bSel  true if the object is selected,
 *        false otherwise
 */
DvtGraphSelectableArc.prototype.SetSelectedSelf = function(bSel)
{
  if (this._bSelected != bSel)
  {
    this._bSelected = bSel;
    if (this._bZorder)
    {
      if (this._bSelected && this._zOrderManager)
      {
        this._zOrderManager.bringToFrontOfSelection(this);
      }
      else if (!this._bSelecting && this._zOrderManager)
      {
        this._zOrderManager.pushToBackOfSelection(this);
      }
    }
    
    DvtSelectionEffectUtils.applySelectionState(this, this._dataColor, this._innerColor, this._outerColor);
  }
};

/**
 * Add a related object of this det object.
 *
 * @param {DvtDisplayable} displayable A DvtDisplayable object related to this one
 */
DvtGraphSelectableArc.prototype.addRelatedObject = function(displayable)
{
  if (!this._relatedLogicalObjects)
    this._relatedLogicalObjects = [];

  this._relatedLogicalObjects.push(displayable);
};


/**
 * Set whether a drop shadow is shown when this object is selected.
 *
 * @param {boolean}  bShadow  true if a selection drop shadow should be shown,
 *        false if not
 */
DvtGraphSelectableArc.prototype.setSelectedShadow = function(bShadow)
{
  this._bSelectedShadow = bShadow;
};

/**
 * Specifies the color of the data item and its selection feedback, if different from the default.
 * @param {string} dataColor The CSS color string of the primary color of the data item.
 * @param {string} innerColor The CSS color string of the inner color of the selection effect.
 * @param {string} outerColor The CSS color string of the outer color of the selection effect.
 */
DvtGraphSelectableArc.prototype.setDataColor = function(dataColor, innerColor, outerColor)
{ 
  this._dataColor = dataColor;
  this._innerColor = innerColor;
  this._outerColor = outerColor;
}

/**
 * Sets whether the z order of an object should be adjusted for selection.
 *
 * @param {boolean}  yesNo true if zorder is to change
 */
DvtGraphSelectableArc.prototype.setZorder = function(yesNo)
{
  this._bZorder = yesNo;
};

DvtGraphSelectableArc.prototype.setZOrderManager = function(manager) 
{
  this._zOrderManager = manager;
}

/**
 * @override
 */
DvtGraphSelectableArc.prototype.UpdateSelectionEffect = function() {}
// Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved.
/** 
  *  A marker object for selectable invisible markers.
  *  @class DvtChartLineMarker A marker object for selectable scatter and bubble charts.
  *  @extends DvtChartLineMarker
  *  @constructor
  *  @param {DvtContext} context
  *  @param {number} type The type of the marker (see {@link DvtMarker}).
  *  @param {number} x  The x position of the top left corner of the marker.
  *  @param {number} y  The y position of the top left corner of the marker.
  *  @param {number} size  The size of the marker.
  */
var DvtChartLineMarker = function(context, type, x, y, size)
{
   this.Init(context, type, null, x, y, size, size) ;
}

DvtObj.createSubclass(DvtChartLineMarker, DvtMarker, "DvtChartLineMarker") ;

DvtChartLineMarker._SELECTED_FILL = new DvtSolidFill('#FFFFFF');
DvtChartLineMarker._SELECTED_STROKE = new DvtSolidStroke('#5A5A5A', 1, 1.5);

/**
 * @override
 */
DvtChartLineMarker.prototype.setDataColor = function(dataColor)
{ 
  this._dataColor = dataColor;
  this._hoverStroke = new DvtSolidStroke(dataColor, 1, 1.5);
}

/**
 * @override
 */
DvtChartLineMarker.prototype.getDataColor = function()
{
  return this._dataColor;
}

/**
 * @override
 */
DvtChartLineMarker.prototype.showHoverEffect = function()
{
  this.IsShowingHoverEffect = true;
  this.setStroke(this._hoverStroke);
}

/**
 * @override
 */
DvtChartLineMarker.prototype.hideHoverEffect = function()
{
  this.IsShowingHoverEffect = false;
  this.setStroke(this.isSelected() ? DvtChartLineMarker._SELECTED_STROKE : null);
}

/**
 * @override
 */
DvtChartLineMarker.prototype.setSelected = function(selected)
{  
  if (this.IsSelected == selected)
    return;
  
  this.IsSelected = selected;
  if (this.isSelected()) {
    this.setFill(DvtChartLineMarker._SELECTED_FILL);
    this.setStroke(this.isHoverEffectShown() ? this._hoverStroke : DvtChartLineMarker._SELECTED_STROKE);
  }
  else {
    this.setInvisibleFill();
    this.setStroke(this.isHoverEffectShown() ? this._hoverStroke : null);
  }
}

/**
 * @override
 */
DvtChartLineMarker.prototype.UpdateSelectionEffect = function() {
  // noop: Selection effects fully managed by this class
}
// Copyright (c) 2011, 2014, Oracle and/or its affiliates. All rights reserved.
/**
  *  Creates a selectable shape using SVG path commands.
  *  @extends DvtPath
  *  @class DvtGraphSelectablePath  Creates an arbitrary shape using SVG path commands.
  *  @constructor
  *  @param {DvtContext} context 
  *  @param {Object} cmds  Optional string of SVG path commands (see comment for
  *                        {@link DvtPath#setCmds}), or an array containing
  *                        consecutive command and coordinate entries (see comment
  *                        for {@link DvtPath#setCommands}).
  * @param {String} id  Optional ID for the shape (see {@link  DvtDisplayable#setId}).
  */
var  DvtGraphSelectablePath = function(context, cmds, id)
{
   this.Init(context, cmds, id) ;
};

DvtObj.createSubclass(DvtGraphSelectablePath, DvtPath, "DvtGraphSelectablePath") ;

/**
  *  Object initializer.
  *  @protected
  */
DvtGraphSelectablePath.prototype.Init = function(context, cmds, id)
{
  DvtGraphSelectablePath.superclass.Init.call(this, context, cmds, id) ;
  
  this._bSelected = false;
  this._bSelecting = false;
  this._selectionEffects = null;
  this._bSelectedShadow = true;
  this._dataColor = "#000000";
  this._innerColor = null;
  this._outerColor = null;
  
  //properties related to selection
  this._savedStroke = null;
  this._bSavedStroke = false;
  this._relatedLogicalObjects = null;
  this._applyStrokeTimer = null;
  
  this._bZorder = true;
  this._zOrderManager = null;
  this._selectionType = context.getDocumentUtils().isFilterSupported() ? DvtSelectionEffectUtils.SEL_TYPE_STROKE_FILTERS : DvtSelectionEffectUtils.SEL_TYPE_STROKE_NO_FILTERS;
}

/**
 * Show the selection hover effect.
 */
DvtGraphSelectablePath.prototype.showHoverEffect = function()
{
  this.SetSelectionMouseOver(true);
};


/**
 * Hide the selection hover effect.
 */
DvtGraphSelectablePath.prototype.hideHoverEffect = function()
{
  this.SetSelectionMouseOver(false);
};


/**
 * Determine if the selection hover effect is shown.
 * 
 * @type boolean
 */
DvtGraphSelectablePath.prototype.isHoverEffectShown = function()
{
  return this._bSelecting;
};


/**
 * @protected
 * Set whether the selection mouse hover effect is shown.
 * 
 * @param bOver {boolean}  bOver  true if the mouse is over the object,
 *        false otherwise
 */
DvtGraphSelectablePath.prototype.SetSelectionMouseOver = function(bOver)
{
  this.SetSelectionMouseOverSelf(bOver);

  //set selection on related parts of this marker also
  if (this._relatedLogicalObjects)
  {
    for (var i = 0; i < this._relatedLogicalObjects.length; i++)
    {
      if (this._relatedLogicalObjects[i].SetSelectionMouseOverSelf)
      {
        this._relatedLogicalObjects[i].SetSelectionMouseOverSelf(bOver);
      }
    }
  }
}

/**
 * @protected
 * Set whether the selection mouse hover effect is shown.
 * 
 * @param bOver {boolean}  bOver  true if the mouse is over the object,
 *        false otherwise
 */
DvtGraphSelectablePath.prototype.SetSelectionMouseOverSelf = function(bOver)
{
  if (this._bSelecting != bOver)
  {
    this._bSelecting = bOver;
    if (this._bZorder)
    {
      if (this._bSelecting && this._zOrderManager) {
        this._zOrderManager.bringToFrontOfSelection(this);
      }
      else if (!this._bSelected && this._zOrderManager) {
        this._zOrderManager.pushToBackOfSelection(this);
      }
    }
    
    DvtSelectionEffectUtils.applyHoverState(this, this._dataColor);
  }
};


/**
 * Determine whether this object is selected.
 * 
 * @type boolean
 */
DvtGraphSelectablePath.prototype.isSelected = function()
{
  return this._bSelected;
};

/**
 * Set whether the selection effect is shown.
 * 
 * @param bOver {boolean}  bSel  true if the object is selected,
 *        false otherwise
 */
DvtGraphSelectablePath.prototype.setSelected = function(bSel)
{
  this.SetSelectedSelf(bSel);

  //set selection on related parts of this marker also
  if (this._relatedLogicalObjects)
  {
    for (var i = 0; i < this._relatedLogicalObjects.length; i++)
    {
      if (this._relatedLogicalObjects[i].SetSelectedSelf)
      {
        this._relatedLogicalObjects[i].SetSelectedSelf(bSel);
      }
    }
  }
};

/**
 * @protected
 * Set whether the selection effect is shown.
 * 
 * @param bOver {boolean}  bSel  true if the object is selected,
 *        false otherwise
 */
DvtGraphSelectablePath.prototype.SetSelectedSelf = function(bSel)
{
  if (this._bSelected != bSel) {
    this._bSelected = bSel;
    if (this._bZorder)
    {
      if (this._bSelected && this._zOrderManager) {
        this._zOrderManager.bringToFrontOfSelection(this);
      }
      else if (!this._bSelecting && this._zOrderManager) {
        this._zOrderManager.pushToBackOfSelection(this);
      }
    }
    
    DvtSelectionEffectUtils.applySelectionState(this, this._dataColor, this._innerColor, this._outerColor);
  }
};

/**
 * Add a related object of this det object.
 *
 * @param {DvtDisplayable} displayable A DvtDisplayable object related to this one
 */
DvtGraphSelectablePath.prototype.addRelatedObject = function(displayable)
{
  if (!this._relatedLogicalObjects)
  {
    this._relatedLogicalObjects = [];
  }

  this._relatedLogicalObjects.push(displayable);
};


/**
 * Set whether a drop shadow is shown when this object is selected.
 *
 * @param {boolean}  bShadow  true if a selection drop shadow should be shown,
 *        false if not
 */
DvtGraphSelectablePath.prototype.setSelectedShadow = function(bShadow)
{
  this._bSelectedShadow = bShadow;
};

/**
 * Specifies the color of the data item and its selection feedback, if different from the default.
 * @param {string} dataColor The CSS color string of the primary color of the data item.
 * @param {string} innerColor The CSS color string of the inner color of the selection effect.
 * @param {string} outerColor The CSS color string of the outer color of the selection effect.
 */
DvtGraphSelectablePath.prototype.setDataColor = function(dataColor, innerColor, outerColor)
{ 
  this._dataColor = dataColor;
  this._innerColor = innerColor;
  this._outerColor = outerColor;
}

/**
 * Sets whether the z order of an object should be adjusted for selection.
 *
 * @param {boolean}  yesNo true if zorder is to change
 */
DvtGraphSelectablePath.prototype.setZorder = function(yesNo)
{
  this._bZorder = yesNo;
};

DvtGraphSelectablePath.prototype.setZOrderManager = function(manager) 
{
  this._zOrderManager = manager;
}

/**
 * @override
 */
DvtGraphSelectablePath.prototype.UpdateSelectionEffect = function() {}
/**
  * Creates a selectable polygon from an array of consecutive (x,y) coordinates.
  * @extends DvtPolygon
  * @constructor  
  * @param {DvtContext} context 
  * @param {Array} ar  An array of consecutive x,y coordinate pairs.
  * @param {String} id  Optional ID for the shape (see {@link  DvtDisplayable#setId}).
  */
var DvtGraphSelectablePolygon = function(color, context, arPoints, id)
{
   this.Init(color, context, arPoints, id) ;
}

DvtObj.createSubclass(DvtGraphSelectablePolygon, DvtPolygon, "DvtGraphSelectablePolygon") ;

/**
  *  Object initializer.
  *  @protected
  */
DvtGraphSelectablePolygon.prototype.Init = function(context, arPoints, id)
{
  DvtGraphSelectablePolygon.superclass.Init.call(this, context, arPoints, id) ;
  this._dataColor = "#000000";
  this._innerColor = null;
  this._outerColor = null;
  
  this._bSelected = false;
  this._bSelecting = false;
  this._selectionEffects = null;
  this._bSelectedShadow = true;
  
  //properties related to selection
  this._savedStroke = null;
  this._bSavedStroke = false;
  this._relatedLogicalObjects = null;
  this._applyStrokeTimer = null;
  
  this._bZorder = true;
  this._zOrderManager = null;  
  this._selectionType = context.getDocumentUtils().isFilterSupported() ? DvtSelectionEffectUtils.SEL_TYPE_STROKE_FILTERS : DvtSelectionEffectUtils.SEL_TYPE_STROKE_NO_FILTERS;
}

/**
 * Show the selection hover effect.
 */
DvtGraphSelectablePolygon.prototype.showHoverEffect = function()
{
  this.SetSelectionMouseOver(true);
};


/**
 * Hide the selection hover effect.
 */
DvtGraphSelectablePolygon.prototype.hideHoverEffect = function()
{
  this.SetSelectionMouseOver(false);
};


/**
 * Determine if the selection hover effect is shown.
 * 
 * @type boolean
 */
DvtGraphSelectablePolygon.prototype.isHoverEffectShown = function()
{
  return this._bSelecting;
}

/**
 * @protected
 * Set whether the selection mouse hover effect is shown.
 * 
 * @param bOver {boolean}  bOver  true if the mouse is over the object,
 *        false otherwise
 */
DvtGraphSelectablePolygon.prototype.SetSelectionMouseOver = function(bOver)
{
  this.SetSelectionMouseOverSelf(bOver);

  //set selection on related parts of this marker also
  if (this._relatedLogicalObjects)
  {
    for (var i = 0; i < this._relatedLogicalObjects.length; i++)
    {
      if (this._relatedLogicalObjects[i].SetSelectionMouseOverSelf)
      {
        this._relatedLogicalObjects[i].SetSelectionMouseOverSelf(bOver);
      }
    }
  }
}

/**
 * @protected
 * Set whether the selection mouse hover effect is shown.
 * 
 * @param bOver {boolean}  bOver  true if the mouse is over the object,
 *        false otherwise
 */
DvtGraphSelectablePolygon.prototype.SetSelectionMouseOverSelf = function(bOver)
{
  if (this._bSelecting != bOver)
  {
    this._bSelecting = bOver;
    if (this._bZorder)
    {
      if (this._bSelecting && this._zOrderManager)
      {
        this._zOrderManager.bringToFrontOfSelection(this);
      }
      else if (!this._bSelected && this._zOrderManager)
      {
        this._zOrderManager.pushToBackOfSelection(this);
      }
    }
    
    DvtSelectionEffectUtils.applyHoverState(this, this._dataColor);
  }
};

/**
 * Determine whether this object is selected.
 * 
 * @type boolean
 */
DvtGraphSelectablePolygon.prototype.isSelected = function()
{
  return this._bSelected;
}

/**
 * Set whether the selection effect is shown.
 * 
 * @param bOver {boolean}  bSel  true if the object is selected,
 *        false otherwise
 */
DvtGraphSelectablePolygon.prototype.setSelected = function(bSel)
{
  this.SetSelectedSelf(bSel);

  //set selection on related parts of this marker also
  if (this._relatedDetObjects)
  {
    for (var i = 0; i < this._relatedDetObjects.length; i++)
    {
      if (this._relatedDetObjects[i].SetSelectedSelf)
      {
        this._relatedDetObjects[i].SetSelectedSelf(bSel);
      }
    }
  }
}

/**
 * @protected
 * Set whether the selection effect is shown.
 * 
 * @param bOver {boolean}  bSel  true if the object is selected,
 *        false otherwise
 */
DvtGraphSelectablePolygon.prototype.SetSelectedSelf = function(bSel)
{
  if (this._bSelected != bSel)
  {
    this._bSelected = bSel;
    if (this._bZorder)
    {
      if (this._bSelected && this._zOrderManager)
      {
        this._zOrderManager.bringToFrontOfSelection(this);
      }
      else if (!this._bSelecting && this._zOrderManager)
      {
        this._zOrderManager.pushToBackOfSelection(this);
      }
    }
    
    DvtSelectionEffectUtils.applySelectionState(this, this._dataColor, this._innerColor, this._outerColor);
  }
}

/**
 * Add a related object of this logical object.
 *
 * @param {DvtDisplayable} displayable A DvtDisplayable object related to this one
 */
DvtGraphSelectablePolygon.prototype.addRelatedObject = function(displayable)
{
  if (!this._relatedLogicalObjects)
  {
    this._relatedLogicalObjects = [];
  }

  this._relatedLogicalObjects.push(displayable);
}


/**
 * Set whether a drop shadow is shown when this object is selected.
 *
 * @param {boolean}  bShadow  true if a selection drop shadow should be shown,
 *        false if not
 */
DvtGraphSelectablePolygon.prototype.setSelectedShadow = function(bShadow)
{
  this._bSelectedShadow = bShadow;
}

/**
 * Specifies the color of the data item and its selection feedback, if different from the default.
 * @param {string} dataColor The CSS color string of the primary color of the data item.
 * @param {string} innerColor The CSS color string of the inner color of the selection effect.
 * @param {string} outerColor The CSS color string of the outer color of the selection effect.
 */
DvtGraphSelectablePolygon.prototype.setDataColor = function(dataColor, innerColor, outerColor)
{ 
  this._dataColor = dataColor;
  this._innerColor = innerColor;
  this._outerColor = outerColor;
}

/**
 * Sets whether the z order of an object should be adjusted for selection.
 *
 * @param {boolean}  yesNo true if zorder is to change
 */
DvtGraphSelectablePolygon.prototype.setZorder = function(yesNo)
{
  this._bZorder = yesNo;
}

DvtGraphSelectablePolygon.prototype.setZOrderManager = function(manager) 
{
  this._zOrderManager = manager;
}

/**
 * @override
 */
DvtGraphSelectablePolygon.prototype.UpdateSelectionEffect = function() {}
// Copyright (c) 2011, 2014, Oracle and/or its affiliates. All rights reserved.
/** 
  *  A selectable bar for charting.
  *  @class DvtChartBar
  *  @extends DvtPolygon
  *  @constructor
  *  @param {DvtContext} context
  *  @param {boolean} bHoriz true if the bar grows horizontally.
  *  @param {boolean} bStacked true if the bar is part of a stacked series.
  *  @param {number} baselineCoord The location from which the bar grows.
  *  @param {number} endCoord The location where the bar length ends.
  *  @param {number} x1 The left coord of a vertical bar, or the top of a horizontal bar.
  *  @param {number} x2 The right coord of a vertical bar, or the bottom of a horizontal bar.
  */
var DvtChartBar = function(context, bHoriz, bStacked, baselineCoord, endCoord, x1, x2)
{
  // Initialize the polygon
  this.Init(context);
  
  // Calculate the points array and apply to the polygon
  this._bHoriz = bHoriz;
  this._bStacked = bStacked;
  this._setBarCoords(baselineCoord, endCoord, x1, x2);
}

DvtObj.createSubclass(DvtChartBar, DvtPolygon, "DvtChartBar") ;

/** @private */
DvtChartBar._OUTER_BORDER_WIDTH = 2;
/** @private */
DvtChartBar._INNER_BORDER_WIDTH = 1.5;
/** @private */
DvtChartBar._INDICATOR_OFFSET = 8;

/**
 * Specifies the colors needed to generate the selection effect.
 * @param {DvtFill} fill
 * @param {DvtStroke} stroke
 * @param {string} hoverColor The color of the hover border.
 * @param {string} innerColor The color of the inner selection border.
 * @param {string} outerColor The color of the outer selection border.
 */
DvtChartBar.prototype.setStyleProperties = function(fill, stroke, hoverColor, innerColor, outerColor)
{ 
  this._fill = fill;
  this._stroke = stroke;
  this._hoverColor = hoverColor;
  this._innerColor = innerColor;
  this._outerColor = outerColor;
  
  // Apply the fill and stroke
  this.setFill(fill);
  if(stroke)
    this.setStroke(stroke);
}

/**
 * @override
 */
DvtChartBar.prototype.showHoverEffect = function()
{
  this.IsShowingHoverEffect = true;
  this._showNestedBorders(this._hoverColor, this.isSelected() ? this._innerColor : null);
}

/**
 * @override
 */
DvtChartBar.prototype.hideHoverEffect = function()
{
  this.IsShowingHoverEffect = false;
  if(this.isSelected())
    this._showNestedBorders(this._outerColor, this._innerColor);
  else 
    this._showNestedBorders();
}

/**
 * @override
 */
DvtChartBar.prototype.setSelected = function(selected)
{  
  if (this.IsSelected == selected)
    return;
  
  this.IsSelected = selected;
  if (this.isSelected()) 
    this._showNestedBorders(this.isHoverEffectShown() ? this._hoverColor : this._outerColor, this._innerColor);
  else 
    this._showNestedBorders(this.isHoverEffectShown() ? this._hoverColor : null);
}

/**
 * @override
 */
DvtChartBar.prototype.UpdateSelectionEffect = function() {
  // noop: Selection effects fully managed by this class
}

/**
 * Returns the layout parameters for the current animation frame.
 * @return {array} The array of layout parameters.
 */
DvtChartBar.prototype.getAnimationParams = function() {
  return [this._baselineCoord, this._endCoord, this._x1, this._x2];
}

/**
 * Sets the layout parameters for the current animation frame.
 * @param {array} params The array of layout parameters.
 * @param {DvtDisplayable} [indicator] The animation indicator, whose geometry is centered at (0,0).
 */
DvtChartBar.prototype.setAnimationParams = function(params, indicator) {
  this._setBarCoords(params[0], params[1], params[2], params[3]);
  
  // Update animation indicator if present.
  if (indicator) {
    var indicatorPosition = this.getIndicatorPosition();
    indicator.setTranslate(indicatorPosition.x, indicatorPosition.y);

    // Reparent to keep indicator on top
    indicator.getParent().addChild(indicator);
  }
}

/**
 * Returns a DvtPlayable containing the animation of the bar to its initial data value.
 * @param {number} duration The duration of the animation in seconds.
 * @return {DvtPlayable} A playable for the initial bar animation.
 */
DvtChartBar.prototype.getDisplayAnimation = function (duration) {
  // Current state is the end state
  var endState = this.getAnimationParams();
  
  // Initialize the start state. To grow the bar, just set the end coord to the baseline coord.
  this.setAnimationParams([this._baselineCoord, this._baselineCoord, this._x1, this._x2]);

  // Create and return the playable
  var nodePlayable = new DvtCustomAnimation(this.getCtx(), this, duration);
  nodePlayable.getAnimator().addProp(DvtAnimator.TYPE_NUMBER_ARRAY, this, this.getAnimationParams, this.setAnimationParams, endState);
  return nodePlayable;
}

/**
 * Returns a DvtPlayable containing the animation to delete the bar.
 * @param {number} duration The duration of the animation in seconds.
 * @return {DvtPlayable}
 */
DvtChartBar.prototype.getDeleteAnimation = function (duration) {
  // End state is for the bar length to shrink to 0
  var endState = [this._baselineCoord, this._baselineCoord, this._x1, this._x2];

  // Create and return the playable
  var nodePlayable = new DvtCustomAnimation(this.getCtx(), this, duration);
  nodePlayable.getAnimator().addProp(DvtAnimator.TYPE_NUMBER_ARRAY, this, this.getAnimationParams, this.setAnimationParams, endState);
  nodePlayable.getAnimator().addProp(DvtAnimator.TYPE_NUMBER, this, this.getAlpha, this.setAlpha, 0);
  return nodePlayable;
}

/**
 * Returns a DvtPlayable containing the insert animation of the bar.
 * @param {number} duration The duration of the animation in seconds.
 * @return {DvtPlayable}
 */
DvtChartBar.prototype.getInsertAnimation = function(duration) {
  // Initialize the alpha to fade in the bar
  this.setAlpha(0);

  // Create the playable
  var nodePlayable = this.getDisplayAnimation(duration);
  nodePlayable.getAnimator().addProp(DvtAnimator.TYPE_NUMBER, this, this.getAlpha, this.setAlpha, 1);
  return nodePlayable;
}

/**
 * Returns the position where the value change indicator should be displayed.
 * @param {number} offset The number of pixels to leave between the end of the bar and the indicator.
 * @return {DvtPoint}
 */
DvtChartBar.prototype.getIndicatorPosition = function() {
  var widthCoord = (this._x1 + this._x2)/2;
  var x, y;
  if(this._bStacked) {
    // Center the indicator within the stacked bar
    var midLength = (this._endCoord + this._baselineCoord)/2;
    x = this._bHoriz ? midLength : widthCoord;
    y = this._bHoriz ? widthCoord : midLength;
  }
  else {
    var lengthCoord = (this._endCoord >= this._baselineCoord) ? this._endCoord + DvtChartBar._INDICATOR_OFFSET : 
                                                                this._endCoord - DvtChartBar._INDICATOR_OFFSET;
    x = this._bHoriz ? lengthCoord : widthCoord;
    y = this._bHoriz ? widthCoord : lengthCoord;
  }
  
  return new DvtPoint(x, y);
}

/**
 * Stores the point coords defining the bar.
 * @param {number} baselineCoord The location from which the bar grows.
 * @param {number} endCoord The location where the bar length ends.
 * @param {number} x1 The left coord of a vertical bar, or the top of a horizontal bar.
 * @param {number} x2 The right coord of a vertical bar, or the bottom of a horizontal bar.
 * @return {array}
 * @private
 */
DvtChartBar.prototype._setBarCoords = function(baselineCoord, endCoord, x1, x2) {
  // Store the geometry values
  this._baselineCoord = baselineCoord;
  this._endCoord = endCoord;
  this._x1 = x1;
  this._x2 = x2;
  
  // Calculate the bounding rectangle for optimized getDimensions calls
  if(this._bHoriz) {
    this._bounds = new DvtRectangle(Math.min(baselineCoord, endCoord), Math.min(x1, x2), 
                                    Math.abs(baselineCoord - endCoord),  Math.abs(x1 - x2));
  }
  else {
    this._bounds = new DvtRectangle(Math.min(x1, x2), Math.min(baselineCoord, endCoord),
                                    Math.abs(x1 - x2), Math.abs(baselineCoord - endCoord)); 
  }
  
  // Calculate the points array for the outer shape
  var points = this._createPointsArray();
  this.setPoints(points);
  
  // If the inner shapes are already defined, update them as well
  if(this._outerChild)
    this._outerChild.setPoints(this._createPointsArray(DvtChartBar._OUTER_BORDER_WIDTH));
    
  if(this._innerChild)
    this._innerChild.setPoints(this._createPointsArray(DvtChartBar._OUTER_BORDER_WIDTH + DvtChartBar._INNER_BORDER_WIDTH));
}

/**
 * Returns the points array for the polygon used to render the bar. An optional inset can be provided to show nested
 * border effects.
 * @param {number} [inset] The number of pixels to inset the polygon.  Defaults to 0.
 * @return {array}
 * @private
 */
DvtChartBar.prototype._createPointsArray = function(inset) {
  var baselineCoord = this._baselineCoord;
  var endCoord = this._endCoord;
  var x1 = this._x1;
  var x2 = this._x2;

  // Check the inset if specified
  if(inset > 0) {
    // Ensure there's enough space for the inset
    if((Math.abs(x1-x2) < 2*inset) || (Math.abs(baselineCoord-endCoord) < 2*inset))
      return [];
  
    // x1 is always less than x2
    x1 += inset;
    x2 -= inset;
    
    // Relationship between baseline and endCoord aren't so static
    if(endCoord < baselineCoord) {
      baselineCoord -= inset;
      endCoord += inset;
    }
    else {
      baselineCoord += inset;
      endCoord -= inset;
    }
  }

  if(this._bHoriz)
    return [endCoord, x1, endCoord, x2, baselineCoord, x2, baselineCoord, x1];
  else
    return [x1, endCoord, x2, endCoord, x2, baselineCoord, x1, baselineCoord];
}

/**
 * Helper function that creates and adds the shapes used for displaying hover and selection effects. Should only be 
 * called on hover or select operations, since it assumes that the fill, stroke, and shape size are already determined. 
 * @private
 */
DvtChartBar.prototype._initializeSelectionEffects = function() {
  // Don't continue if already initialized
  if(this._outerChild)
    return;

  var outerChildPoints = this._createPointsArray(DvtChartBar._OUTER_BORDER_WIDTH);
  this._outerChild = new DvtPolygon(this.getCtx(), outerChildPoints);
  this._outerChild.setInvisibleFill();
  this._outerChild.setMouseEnabled(true);
  this.addChild(this._outerChild);
  
  var innerChildPoints = this._createPointsArray(DvtChartBar._OUTER_BORDER_WIDTH + DvtChartBar._INNER_BORDER_WIDTH);
  this._innerChild = new DvtPolygon(this.getCtx(), innerChildPoints);
  this._innerChild.setInvisibleFill();
  this._innerChild.setMouseEnabled(true);
  this.addChild(this._innerChild);
}

/**
 * Helper function to apply border colors for hover and selection.
 * @param {string} [outerBorderColor]
 * @param {string} [innerBorderColor]
 * @private
 */
DvtChartBar.prototype._showNestedBorders = function(outerBorderColor, innerBorderColor) {
  // Ensure that selection and hover shapes are created
  this._initializeSelectionEffects();

  // Modify the shapes based on which borders should be shown
  if(innerBorderColor) {
    this.setSolidFill(outerBorderColor)
    this.setStroke(null);
    this._outerChild.setSolidFill(innerBorderColor);
    this._innerChild.setFill(this._fill);
  }
  else if(outerBorderColor) {
    this.setSolidFill(outerBorderColor)
    this.setStroke(null);
    this._outerChild.setFill(this._fill);
    this._innerChild.setInvisibleFill();
  }
  else {
    this.setFill(this._fill);
    this.setStroke(this._stroke);
    this._outerChild.setInvisibleFill();
    this._innerChild.setInvisibleFill();
  }
}

/**
 * Returns the bounds of the displayable relative to the target coordinate space.  If the target
 * coordinate space is not specified, returns the bounds relative to this displayable.  This function does not take
 * into account any child displayables.
 * @param {DvtDisplayable} targetCoordinateSpace The displayable defining the target coordinate space.
 * @return {DvtRectangle} The bounds of the displayable relative to the target coordinate space.
 */
DvtChartBar.prototype.getDimensionsSelf = function (targetCoordinateSpace) {
  // Note: In the near future, we will not support children for shapes, so this routine will be refactored into the
  //       existing getDimensions calls.  For now, components must be aware of the presence of children to use this.
  return this.ConvertCoordSpaceRect(this._bounds, targetCoordinateSpace);
}
// Copyright (c) 2013, 2014, Oracle and/or its affiliates. All rights reserved.
/**
  *  Creates a funnel shape.
  *  @extends DvtPath
  *  @class DvtFunnelSlice  Creates a funnel slice object.
  *  @constructor
  *  @param {DvtChartImpl} chart  The chart being rendered.
  *  @param {number} seriesIndex  The index of this slice.
  *  @param {number} numDrawnSeries  The number of series already drawn. Should be total number of series - seriesIndex - 1 if none are skipped.
  *  @param {number} funnelWidth The available width for the whole funnel. 
  *  @param {number} funnelHeight The available height for the whole funnel.
  *  @param {number} startPercent The cumulative value of all the slices that come before. The start/leftmost value of the slice.
  *  @param {number} valuePercent The percent value for the slice. Dictates the width.
  *  @param {number} fillPercent The actual/target value, how much of the slice is filled.
  *  @param {number} gap The gap distance between slices.
  */
var DvtFunnelSlice = function (chart, seriesIndex, numDrawnSeries, funnelWidth, funnelHeight, startPercent, valuePercent, fillPercent, gap) {
  this.Init(chart, seriesIndex, numDrawnSeries, funnelWidth, funnelHeight, startPercent, valuePercent, fillPercent, gap);
};

DvtObj.createSubclass(DvtFunnelSlice, DvtPath, "DvtFunnelSlice");

/**
 *  Object initializer.
 *  @protected
 */
DvtFunnelSlice.prototype.Init = function (chart, seriesIndex, numDrawnSeries, funnelWidth, funnelHeight, startPercent, valuePercent, fillPercent, gap) {
  DvtFunnelSlice.superclass.Init.call(this, chart.getCtx());
  this._chart = chart;
  this._seriesIndex = seriesIndex;
  this._numDrawnSeries = numDrawnSeries;
  this._funnelWidth = funnelWidth;
  this._funnelHeight = funnelHeight;
  this._startPercent = startPercent;
  this._valuePercent = valuePercent;
  this._fillPercent = fillPercent;
  this._gap = gap;
  var cmds = this._getPath();
  this._dataColor = DvtChartStyleUtils.getColor(this._chart, this._seriesIndex, 0);
  this._backgroundColor = chart.getOptions()['styleDefaults']['backgroundColor'];
  if (!this._backgroundColor)
    this._backgroundColor = DvtFunnelSlice._BACKGROUND_COLOR;
  
  this.setCmds(cmds['slice']);
  if (cmds['bar']) {
    this._bar = new DvtPath(this.getCtx(), cmds['bar']);
    this.addChild(this._bar);
    this._bar.setMouseEnabled(false); // want the mouse interaction to only be with the slice.
  }
  
  this._setColorProperties(cmds['sliceBounds']);
  this._label = this._getSliceLabel(cmds['sliceBounds'], cmds['barBounds']);
  
  if (this._label!= null){ 
    this._label.setMouseEnabled(false);
    this.addChild(this._label);
  }
};

DvtFunnelSlice._FUNNEL_3D_WIDTH_RATIO = .12;
DvtFunnelSlice._FUNNEL_ANGLE_2D = DvtMath.degreesToRads(31);
DvtFunnelSlice._FUNNEL_ANGLE_3D = DvtMath.degreesToRads(29);
DvtFunnelSlice._FUNNEL_RATIO = 6 / 22;
DvtFunnelSlice._BORDER_COLOR = "#FFFFFF";
DvtFunnelSlice._BACKGROUND_COLOR = "#EDEDED";
DvtFunnelSlice._MIN_CHARS_DATA_LABEL = 3;
DvtFunnelSlice._SELECTION_DISPLACEMENT = 3;

/**
 * Creates the path commands that represent this slice
 * @return {object} The commands for drawing this slice. An object containing the sliceCommands, barCommands, sliceBounds and barBounds
 * @private
 */
DvtFunnelSlice.prototype._getPath = function () {
  var options = this._chart.getOptions();
  var is3D = ((options['styleDefaults']['threeDEffect'] == "on") ? true : false);
  var isBiDi = DvtAgent.isRightToLeft(this.getCtx());
  var gapCount = DvtChartDataUtils.getSeriesCount(this._chart);
  var offset = (this._numDrawnSeries+1) * this._gap;

  if (is3D) { // creating the drawing command for the the 3D slices.
    var rx = (this._funnelWidth - (gapCount * this._gap)) / Math.sin(DvtFunnelSlice._FUNNEL_ANGLE_2D);
    var ry = this._funnelHeight / Math.sin(DvtFunnelSlice._FUNNEL_ANGLE_3D);
    var ratio = this._funnelWidth/this._funnelHeight * DvtFunnelSlice._FUNNEL_3D_WIDTH_RATIO;
    var delta = DvtFunnelSlice._FUNNEL_ANGLE_3D * (1 - this._startPercent);
    var gamma = DvtFunnelSlice._FUNNEL_ANGLE_3D * (1 - this._startPercent - this._valuePercent);
    var c1 = (1 + DvtFunnelSlice._FUNNEL_RATIO)/2 * this._funnelHeight + ry;
    var c2 = (1 - DvtFunnelSlice._FUNNEL_RATIO)/2 * this._funnelHeight - ry;
    var ar;
    var arcDir1 = 1;
    var arcDir2 = 0;
    if (isBiDi) {
      ar = [rx * Math.sin(delta) + offset, c1 - ry * Math.cos(delta), rx * Math.sin(gamma) + offset, c1 - ry * Math.cos(gamma), rx * Math.sin(gamma) + offset, c2 + ry * Math.cos(gamma), rx * Math.sin(delta) + offset, c2 + ry * Math.cos(delta)];
      arcDir1 = 0;
      arcDir2 = 1;
    } else {
      ar = [this._funnelWidth - offset - rx * Math.sin(delta), c1 - ry * Math.cos(delta), this._funnelWidth - offset - rx * Math.sin(gamma), c1 - ry * Math.cos(gamma), this._funnelWidth - offset - rx * Math.sin(gamma), c2 + ry * Math.cos(gamma), this._funnelWidth - offset - rx * Math.sin(delta), c2 + ry * Math.cos(delta)];
    }
    
    var pathCommands = DvtPathUtils.moveTo(ar[0], ar[1]);
    var barCommands = null;
    pathCommands += DvtPathUtils.arcTo(ratio * (ar[1] - ar[7]) / 2, (ar[1] - ar[7]) / 2, Math.PI, arcDir2, ar[6], ar[7]);
    pathCommands += DvtPathUtils.arcTo(ratio * (ar[1] - ar[7]) / 2, (ar[1] - ar[7]) / 2, Math.PI, arcDir2, ar[0], ar[1]);
    pathCommands += DvtPathUtils.arcTo(rx, ry, DvtFunnelSlice._FUNNEL_ANGLE_3D, arcDir1, ar[2], ar[3]);
    pathCommands += DvtPathUtils.arcTo(ratio * (ar[3] - ar[5]) / 2, (ar[3] - ar[5]) / 2, Math.PI, arcDir2, ar[4], ar[5]);
    pathCommands += DvtPathUtils.arcTo(rx, ry, DvtFunnelSlice._FUNNEL_ANGLE_3D, arcDir1, ar[6], ar[7]);
    var sliceBounds = new DvtRectangle(Math.min(ar[0], ar[2]), ar[5], Math.abs(ar[0]-ar[2]), Math.abs(ar[3]- ar[5]));

    if (this._fillPercent != null) { // creating the bar commands for 3D slices if applicable
      var percent = Math.max(Math.min(this._fillPercent, 1), 0);
      var alpha = isBiDi ?  - percent * Math.PI : percent * Math.PI;

      barCommands = DvtPathUtils.moveTo(ar[0], ar[1]);
      barCommands += DvtPathUtils.arcTo(rx, ry, DvtFunnelSlice._FUNNEL_ANGLE_3D, arcDir1, ar[2], ar[3]);
      barCommands += DvtPathUtils.arcTo(ratio * (ar[3] - ar[5]) / 2, (ar[3] - ar[5]) / 2, alpha, arcDir2, ar[2] + ratio * (ar[3] - ar[5]) / 2 * Math.sin(alpha), (ar[5] + ar[3]) / 2 + (ar[3] - ar[5]) / 2 * Math.cos(alpha));
      barCommands += DvtPathUtils.arcTo(rx, ry, DvtFunnelSlice._FUNNEL_ANGLE_3D, arcDir1, ar[6] + ratio * (ar[1] - ar[7]) / 2 * Math.sin(alpha), (ar[7] + ar[1]) / 2 + (ar[1] - ar[7]) / 2 * Math.cos(alpha));
      barCommands += DvtPathUtils.arcTo(ratio * (ar[1] - ar[7]) / 2, (ar[1] - ar[7]) / 2, alpha, arcDir1, ar[0], ar[1]);
      var barBounds = new DvtRectangle(Math.min(ar[0], ar[2]), ar[5] + Math.abs(ar[3]- ar[5])* (1-percent), Math.abs(ar[0]-ar[2]), Math.abs(ar[3]- ar[5])* percent);
    }
    return {'slice': pathCommands, 'bar': barCommands, 'sliceBounds': sliceBounds, 'barBounds': barCommands? barBounds: sliceBounds};
  }
  else { // creating the drawing commands for the the 2D slices
    var rx = (this._funnelWidth - (gapCount * this._gap)) / Math.sin(DvtFunnelSlice._FUNNEL_ANGLE_2D);
    var ry = this._funnelHeight / Math.sin(DvtFunnelSlice._FUNNEL_ANGLE_2D);
    var delta = DvtFunnelSlice._FUNNEL_ANGLE_2D * (1 - this._startPercent);
    var gamma = DvtFunnelSlice._FUNNEL_ANGLE_2D * (1 - this._startPercent - this._valuePercent);
    var c1 = (1 + DvtFunnelSlice._FUNNEL_RATIO)/2 * this._funnelHeight + ry;
    var c2 = (1 - DvtFunnelSlice._FUNNEL_RATIO)/2 * this._funnelHeight - ry;
    var ar;
    var arcDir1 = 1;
    var arcDir2 = 0;
    if (isBiDi) {
      ar = [rx * Math.sin(delta) + offset, c1 - ry * Math.cos(delta), rx * Math.sin(gamma) + offset, c1 - ry * Math.cos(gamma), 
            rx * Math.sin(gamma) + offset, c2 + ry * Math.cos(gamma), rx * Math.sin(delta) + offset, c2 + ry * Math.cos(delta)];
      arcDir1 = 0;
      arcDir2 = 1;
    } else {
      ar = [this._funnelWidth - offset - rx * Math.sin(delta), c1 - ry * Math.cos(delta), this._funnelWidth - offset - rx * Math.sin(gamma), c1 - ry * Math.cos(gamma), 
            this._funnelWidth - offset - rx * Math.sin(gamma), c2 + ry * Math.cos(gamma), this._funnelWidth - offset - rx * Math.sin(delta), c2 + ry * Math.cos(delta)];
    }
    
    var pathCommands = DvtPathUtils.moveTo(ar[0], ar[1]);
    var barCommands = null;
    pathCommands += DvtPathUtils.arcTo(rx, ry, DvtFunnelSlice._FUNNEL_ANGLE_2D, arcDir1, ar[2], ar[3]);
    pathCommands += DvtPathUtils.lineTo(ar[4], ar[5]);
    pathCommands += DvtPathUtils.arcTo(rx, ry, DvtFunnelSlice._FUNNEL_ANGLE_2D, arcDir1, ar[6], ar[7]);
    pathCommands += DvtPathUtils.closePath();
    var sliceBounds = new DvtRectangle(Math.min(ar[0], ar[2]), ar[5], Math.abs(ar[0]-ar[2]), Math.abs(ar[3]- ar[5]));

    if (this._fillPercent != null) { // creating the bar commands for 2D slices if applicable
      var percent = Math.max(Math.min(this._fillPercent, 1), 0);
      barCommands = DvtPathUtils.moveTo(ar[0], ar[1]);
      barCommands += DvtPathUtils.arcTo(rx, ry, DvtFunnelSlice._FUNNEL_ANGLE_2D, arcDir1, ar[2], ar[3]);
      barCommands += DvtPathUtils.lineTo(ar[4], ar[3] + percent * (ar[5] - ar[3]));
      // Edge cases require different bar shapes so they don't spill out of the slice.
      if (this._fillPercent > .95)
        barCommands += DvtPathUtils.arcTo(rx, ry, DvtFunnelSlice._FUNNEL_ANGLE_2D, arcDir1, ar[6], ar[1] + percent * (ar[7] - ar[1]));
      else if (this._fillPercent < .05)
        barCommands += DvtPathUtils.arcTo(rx, ry, DvtFunnelSlice._FUNNEL_ANGLE_2D, arcDir2, ar[6], ar[1] + percent * (ar[7] - ar[1]));
      else
        barCommands += DvtPathUtils.lineTo(ar[6], ar[1] + percent * (ar[7] - ar[1]));
      barCommands += DvtPathUtils.closePath();
      var barBounds = new DvtRectangle(Math.min(ar[0], ar[2]), ar[5] + Math.abs(ar[3]- ar[5])* (1-percent), Math.abs(ar[0]-ar[2]), Math.abs(ar[3]- ar[5])* percent);
    }
    
  return {'slice': pathCommands, 'bar': barCommands, 'sliceBounds': sliceBounds, 'barBounds': barCommands? barBounds: sliceBounds};
  }
}

/**
 * Creates a single slice label DvtText object associated with this slice.
 * @param {DvtRectangle} sliceBounds The space occupied by the slice this is associated with.
 * @param {DvtRectangle} barBounds The space occupied by the colored bar this is associated with. Could affect the color.
 * @private
 */
DvtFunnelSlice.prototype._getSliceLabel = function (sliceBounds, barBounds) {
  // Get and create the label string
  var labelString = DvtChartDataUtils.getSeriesLabel(this._chart, this._seriesIndex);
  if (!labelString)
    return;

  var label = new DvtOutputText(this.getCtx(), labelString, 0, 0);
  
  // Truncating text and dropping if doesn't fit.
  if (! DvtTextUtils.fitText(label, sliceBounds.h, sliceBounds.w, this, DvtFunnelSlice._MIN_CHARS_DATA_LABEL))
    return; 
    
  var textDim = label.measureDimensions();  
  // Checking if the text starts within the bounding box of the colored bar.
  var labelColor = (DvtChartStyleUtils.getPattern(this._chart, this._seriesIndex, 0) != null) ? "#0000000" :
                   barBounds.containsPoint(sliceBounds.x , sliceBounds.y + (sliceBounds.h - textDim.w)/2 )? 
                   DvtColorUtils.getContrastingTextColor(this._dataColor) : DvtColorUtils.getContrastingTextColor(this._backgroundColor);
  var labelStyleArray =[new DvtCSSStyle("color: " + labelColor + ";"), this._chart.getOptions()['styleDefaults']['sliceLabelStyle'], 
                        new DvtCSSStyle(DvtChartDataUtils.getDataItem(this._chart, this._seriesIndex, 0)['labelStyle'])];
  label.setCSSStyle(DvtCSSStyle.mergeStyles(labelStyleArray));
  label.setMatrix(this._getSliceLabelPosition(sliceBounds));
  label.alignCenter();
  label.alignMiddle();
  return label;
}

/**
 * Calculates the position of the text within this slice. Comes up with the translation/rotation matrix.
 * @param {DvtRectangle} sliceBounds The space occupied by the slice.
 * @return {DvtMatrix} The matrix representing the transformation for placing the text.
 * @private
 */
DvtFunnelSlice.prototype._getSliceLabelPosition = function (sliceBounds) {
  var displacement = (this._chart.getOptions()['styleDefaults']['threeDEffect'] == "on")? sliceBounds.h * this._funnelWidth/this._funnelHeight * DvtFunnelSlice._FUNNEL_3D_WIDTH_RATIO / 2: 0; // to make up for the 3D funnel opening
  // Rotate the text
  var rotationMatrix = new DvtMatrix();
  if (DvtAgent.isRightToLeft(this.getCtx())){
    rotationMatrix.rotate(Math.PI / 2);
    rotationMatrix.translate(sliceBounds.x + sliceBounds.w / 2 - displacement, sliceBounds.y + sliceBounds.h / 2);
  }
  else{
    rotationMatrix.rotate(3* Math.PI / 2);
    rotationMatrix.translate(sliceBounds.x + sliceBounds.w / 2 + displacement, sliceBounds.y + sliceBounds.h / 2);
  }
  return rotationMatrix;
}

/**
 * Gets the percent values associated with the slice for animation
 * @return {array} the start, value, fill percents, and alpha for this slice.
 */
DvtFunnelSlice.prototype.getAnimationParams = function () {
  return [this._startPercent, this._valuePercent, this._fillPercent, this.getAlpha()];
}

/**
 * Sets the percent values associated with the slice for animation
 * @param {array} ar The new start, value, and fill percents for this slice
 */
DvtFunnelSlice.prototype.setAnimationParams = function (ar) {
  this._startPercent = ar[0];
  this._valuePercent = ar[1];
  this._fillPercent = ar[2];
  this.setAlpha(ar[3]);
  var cmds = this._getPath();
  this.setCmds(cmds['slice']);
  if (cmds['bar'] && this._bar) 
    this._bar.setCmds(cmds['bar']);
  if (this._label)
    this._label.setMatrix(this._getSliceLabelPosition(cmds['sliceBounds']));
}

/**
 * Passing on the colors for the funnel slice object. Sets the slice fill and border color, as well as the selection and hover colors by reading them from the chart.
 * @param {DvtRectangle} sliceBounds The space occupied by the slice. This is used for calculating the gradient effect bounds.
 */
DvtFunnelSlice.prototype._setColorProperties = function(sliceBounds){
  var sliceFill = DvtChartSeriesEffectUtils.getFunnelSliceFill(this._chart, this._seriesIndex, this._dataColor, sliceBounds);
  var sliceBorder = DvtChartStyleUtils.getBorderColor(this._chart, this._seriesIndex, 0);
  var backgroundFill = DvtChartSeriesEffectUtils.getFunnelSliceFill(this._chart, this._seriesIndex, this._backgroundColor, sliceBounds, true);
  if (this._bar) {
    this.setFill(backgroundFill);
    this._bar.setFill(sliceFill);
  }
  else 
    this.setFill(sliceFill);
    
  this.setSolidStroke((sliceBorder != null)? sliceBorder : DvtFunnelSlice._BORDER_COLOR);
  this.OriginalStroke = this.getStroke(); // saving the original border stroke

  if (this._chart.isSelectionSupported()) {
    // Set the selection strokes  
    var hoverColor = DvtChartSeriesEffectUtils.getHoverColor(this._chart, this._dataColor);
    var innerColor = DvtChartStyleUtils.getSelectedInnerColor(this._chart);
    var outerColor = DvtChartStyleUtils.getSelectedOuterColor(this._chart) ? DvtChartStyleUtils.getSelectedOuterColor(this._chart) : this._dataColor;
    var shapeForSelection = this._bar != null ? this._bar : this;
    shapeForSelection.setHoverStroke(new DvtSolidStroke(hoverColor, 1, 2));
    shapeForSelection.setSelectedStroke(new DvtSolidStroke(innerColor, 1, 1.5), new DvtSolidStroke(outerColor, 1, 4.5));
    shapeForSelection.setSelectedHoverStroke(new DvtSolidStroke(innerColor, 1, 1.5), new DvtSolidStroke(hoverColor, 1, 4.5));
  
    this.setCursor(DvtSelectionEffectUtils.getSelectingCursor());
  }
}

/**
 * @override
 */
DvtFunnelSlice.prototype.setSelected = function (selected) {
  if (this._bar != null) {
    if (this.IsSelected == selected)
      return;
    this.IsSelected = selected;
    this._bar.setSelected(selected);
  }
  else 
    DvtFunnelSlice.superclass.setSelected.call(this, selected);
  
  var dims = this.getDimensions();
  var shapeForSelection = (this._bar != null) ? this._bar : this;
  // To make the selection effect more apparent - make the bars slightly smaller
  var w = dims.w;
  if (selected){
    shapeForSelection.setScaleX((w-DvtFunnelSlice._SELECTION_DISPLACEMENT)/w);
    shapeForSelection.setTranslateX(Math.ceil(DvtFunnelSlice._SELECTION_DISPLACEMENT/2) + DvtFunnelSlice._SELECTION_DISPLACEMENT/w*dims.x);
  } else {
    shapeForSelection.setScaleX(1);
    shapeForSelection.setTranslateX(0);
  }
};

/**
 * @override
 */
DvtFunnelSlice.prototype.showHoverEffect = function () {
  if (this._bar != null) {
    this._bar.showHoverEffect();
  }
  else 
    DvtFunnelSlice.superclass.showHoverEffect.call(this);
};

/**
 * @override
 */
DvtFunnelSlice.prototype.hideHoverEffect = function () {
  if (this._bar != null) {
    this._bar.hideHoverEffect();
  }
  else 
    DvtFunnelSlice.superclass.hideHoverEffect.call(this);
};

/**
 * @override
 */
DvtFunnelSlice.prototype.copyShape = function () {
  return new DvtFunnelSlice(this._chart, this._seriesIndex, this._numDrawnSeries, this._funnelWidth, this._funnelHeight, this._startPercent, this._valuePercent, this._fillPercent, this._gap);
}
// Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.
/*---------------------------------------------------------------------*/
/*   DvtPieChart                                                       */
/*---------------------------------------------------------------------*/

/*
 * Call chain:
 * 
 * DvtPieChart.init gets called to create each logical DvtPieSlice object. Setting up the slice's size, location,
 * fill, label, label layout and the creation of the physical shapes are NOT done at this step.
 * 
 * DvtPieChart.render then gets called to 
 * 
 * 1. create and layout the physical pie surface objects and physical labels
 * 2. order the slices for rendering
 * 3. layout the slice labels and feelers
 * 4. render the actual slices (add them to this DvtPieChart)
 * 5. render the slice labels and feelers.
 */

/**
 * Creates an instance of DvtPieChart
 * @param {DvtChartImpl} chart The chart object.
 * @param {DvtRectangle} availSpace The available space to render the chart.
 * @param {function} callback A function that responds to events
 * @param {object} callbackObj The optional object instance that the callback function is defined on.
 *  @class DvtPieChart
 *  @extends DvtContainer
 *  @constructor
 */
var DvtPieChart = function (chart, availSpace, callback, callbackObj) {
  this.Init(chart, availSpace, callback, callbackObj);
};

// Private pie rendering constants
DvtPieChart._THREED_TILT = 0.59;
DvtPieChart._THREED_DEPTH = 0.1;
DvtPieChart._RADIUS = 0.45;
DvtPieChart._RADIUS_LABELS = 0.38;

// constants for pie explode/unite
/** final @type number */
DvtPieChart.EXPLODE = 0;
/** final @type number */
DvtPieChart.UNITE = 1;

DvtObj.createSubclass(DvtPieChart, DvtContainer, "DvtPieChart");

/*----------------------------------------------------------------------*/
/* Init()                                                               */
/*----------------------------------------------------------------------*/
/**
 * Object initializer
 * @protected
 * @param {DvtChartImpl} chart The chart object.
 * @param {DvtRectangle} availSpace The available space to render the chart.
 * @param {function} callback A function that responds to events
 * @param {object} callbackObj The optional object instance that the callback function is defined on.
 */
DvtPieChart.prototype.Init = function (chart, availSpace, callback, callbackObj) {
  DvtPieChart.superclass.Init.call(this, chart.getCtx());
  
  this.chart = chart;
  this._options = chart.getOptions();
  this._frame = availSpace.clone();
  chart.pieChart = this; // store reference to itself for interactivity
  
  this._labelPosition = this._options['styleDefaults']['sliceLabelPosition'];
  if (this._labelPosition == "auto")
    this._labelPosition = "outside";
  
  // Set position attributes
  this._center = new DvtPoint(availSpace.x + Math.floor(availSpace.w / 2), availSpace.y + Math.floor(availSpace.h / 2));
  var radiusScale = this._labelPosition == "outside" ? DvtPieChart._RADIUS_LABELS : DvtPieChart._RADIUS;
  this._radiusX = Math.floor(Math.min(availSpace.w, availSpace.h) * radiusScale);
  this._radiusY = this._radiusX;
  this._depth = 0;
  this._anchorOffset = 90;
  
  if (this.is3D()) {
    // Set depth as percentage of window height
    this._depth = availSpace.h * DvtPieChart._THREED_DEPTH; 
    this._center.y -= Math.floor(this._depth/2);
    this._radiusY *= DvtPieChart._THREED_TILT;
  }
  
  // Create slices and set initial selection
  this._slices = this._createSlices();

  // a DvtContainer where we add parts of the pie and feeler lines
  // any special filters (currently, drop shadow effect for 2D pies)
  // affecting the pie are added to this container  
  this._shapesContainer = new DvtContainer(this.getCtx());

  // Support for changing z-order for selection
  this._numFrontObjs = 0;
  this._numSelectedObjsInFront = 0;
};

/**
 * Returns the options object of this pie chart.
 * @return {object}
 */
DvtPieChart.prototype.getOptions = function () {
  return this._options;
}

/**
 * Processes an event that has been dispatched from a container or peer.
 * @param {object} event
 */
DvtPieChart.prototype.processEvent = function (event) {
  var type = event.getType();
  if (type == DvtCategoryHideShowEvent.TYPE_HIDE || type == DvtCategoryHideShowEvent.TYPE_SHOW)
    DvtHideShowCategoryHandler.processEvent(event, this._slices);
  else if (type == DvtCategoryRolloverEvent.TYPE_OVER || type == DvtCategoryRolloverEvent.TYPE_OUT)
    DvtCategoryRolloverHandler.processEvent(event, this._slices);
};

/**
 * Highlights the specified categories.
 * @param {array} categories The array of categories whose data items will be highlighted. If null or empty, all 
 *                           highlighting will be removed.
 * @export
 */
DvtPieChart.prototype.highlight = function(categories) {
  DvtCategoryRolloverHandler.highlight(categories, this._slices);
}

/**
 * Create pie slices.
 * @private
 */
DvtPieChart.prototype._createSlices = function () {
  // Iterate through the data and create the slice objects
  var slices = [];
  var slice;
  
  var seriesIndices = DvtPieChartUtils.getRenderedSeriesIndices(this.chart);
  var seriesIndex;
  var otherValue = DvtPieChartUtils.getOtherValue(this.chart);
  
  for (var i = 0; i < seriesIndices.length; i++) {
    seriesIndex = seriesIndices[i];
     
    // Skip the series if it shouldn't be rendered
    if(!DvtChartStyleUtils.isSeriesRendered(this.chart, seriesIndex))
      continue;
    
    slice = new DvtPieSlice(this, seriesIndex);
    
    // Do not render if the value is not positive
    if (slice.getValue() <= 0)
      continue;
    
    slices.push(slice);
  }
  
  // Create an "Other" slice if needed
  if (otherValue > 0)
    slices.push(new DvtPieSlice(this));

  // Reverse the slices for BIDI
  if (DvtAgent.isRightToLeft(this.getCtx()))
    slices.reverse();
  
  return slices;
}

/**
 * Sets initial selection of the chart.
 * @private
 */
DvtPieChart.prototype._setInitialSelection = function() {
  var handler = this.chart.getSelectionHandler();
  if(!handler)
    return;
  
  var selected = DvtChartDataUtils.getInitialSelection(this.chart);
  var selectedIds = [];
  for (var i = 0; i < selected.length; i++) {
    for (var j = 0; j < this._slices.length; j++) {
      var peerId = this._slices[j].getId();
      if (peerId && ((selected[i]['id'] && peerId.getId() == selected[i]['id']) ||
          (peerId.getSeries() == selected[i]['series'] && peerId.getGroup() == selected[i]['group']))) {
        selectedIds.push(peerId);
        continue;
      }
    }
  }
  
  // Add other slice to the list if all series in the "other" slice is selected
  if (DvtPieChartUtils.isOtherSliceSelected(this.chart, selected)) {
    var otherPeerId = DvtPieChartUtils.getOtherSliceId(this.chart);
    selectedIds.push(otherPeerId);
  }
  
  handler.processInitialSelections(selectedIds, this._slices);
}

/**
 * Renders the pie chart.
 */
DvtPieChart.prototype.render = function () {
  var shadow;
  if (!this.contains(this._shapesContainer)) {
    if (!this._shapesContainer) {
      this._shapesContainer = new DvtContainer(this.getCtx());
    }
    this.addChild(this._shapesContainer);

    if (!this.is3D() && this.getSkin() == DvtCSSStyle.SKIN_SKYROS) {
      var shadowRGBA = DvtColorUtils.makeRGBA(78, 87, 101, 0.45);

      shadow = new DvtShadow(shadowRGBA, 4, // distance
          7, // blurX
          7, // blurY
          54, // angle of the shadow
          2, // strength or the imprint/spread
          3, // quality
          false, // inner shadow
          false, // knockout effect
          false// hide object
      );
    }
  }

  // Set each slice's angle start and angle extent
  // The order in which these slices are rendered is determined in the later call to orderSlicesForRendering
  DvtPieChart._layoutSlices(this._slices, this._anchorOffset);

  // create the physical surface objects and labels
  var len = this._slices.length;
  for (var i = 0;i < len;i++) {
    var slice = this._slices[i];
    slice.preRender();
  }

  // we order the slices for rendering, such that
  // the "front-most" slice, the one closest to the user
  // is redered last.  each slice is then responsible
  // for properly ordering each of its surfaces before 
  // the surfaces are rendered.
  var zOrderedSlices = DvtPieChart._orderSlicesForRendering(this._slices);
  
  if (!this._duringAnim)
    DvtPieLabelUtils.layoutLabelsAndFeelers(this);

  // now that everything has been laid out, tell the slices to 
  // render their surfaces 
  len = zOrderedSlices.length;
  for (var i = 0;i < len;i++) {
    var slice = zOrderedSlices[i];
    slice.render();
  }

  // Bug fix 12958165: Don't render shadows in Chrome SVG
  if (!DvtAgent.isPlatformWebkit()) {
    //BUG FIX #12427741: apply shadow after rendering slices because
    //shadow effect may depend on bounding box
    if (shadow)
      this._shapesContainer.addDrawEffect(shadow);
  }
  
  // perform initial selection
  this._setInitialSelection();
};

/**
 * Returns the total value of the pie
 * @return {number} The total value of all pie slices
 */
DvtPieChart.prototype.getTotalValue = function () {
  var total = 0;
  for (var i = 0;i < this._slices.length;i++) {
    var sliceValue = this._slices[i].getValue();
    if (sliceValue >= 0)// Ignore negative slice values
      total += sliceValue;
  }
  return total;
}

// ported over from PieChart.as
/**
 * Sets the location of each slice in the pie. That is, each slice in the input slices array has its angle start and
 * angle extent set.  Label layout is not handled in this method.
 *
 * @param {Array} slices An array of DvtPieSlice objects
 * @param {number} anchorOffset The initial rotation offset for the pie, measured in degrees with 0 being the standard
 *                              0 from which trigonometric angles are measured. Thus, 90 means the first pie slice is
 *                              at the 12 o'clock position
 *
 * @private
 */
DvtPieChart._layoutSlices = function (slices, anchorOffset) {
  var i;
  var slice;
  var angle;

  var arc = 0;

  var nSlices = (slices) ? slices.length : 0;

  if (anchorOffset > 360)
    anchorOffset -= 360;

  if (anchorOffset < 0)
    anchorOffset += 360;

  var percentage = 0;
  var dataTotal = 0;
  if (nSlices > 0) {
    dataTotal = slices[0].getPieChart().getTotalValue();
  }

  for (i = 0;i < nSlices;i++) {
    slice = slices[i];

    value = slice.getValue();
    percentage = (dataTotal == 0) ? 0 : ((Math.abs(value) / dataTotal) * 100);

    arc = percentage * 3.60;// 3.60 = 360.0 / 100.0 - percentage of a 360 degree circle
    angle = anchorOffset - arc;

    if (angle < 0)
      angle += 360;

    slice.setAngleStart(angle);
    slice.setAngleExtent(arc);

    anchorOffset = slice.getAngleStart();// update anchor position for next slice
  }

}

/**
 * Sort slices by walking slices in a clockwise and then counterclockwise fashion,
 * processing the bottom-most slice last.  Each slice is responsible for sorting its
 * own surfaces so that they get rendered in the proper order.
 *
 * @param {Array} slices The array of DvtPieSlices to order
 * @return {Array} A z-ordered array of DvtPieSlices
 *
 * @private
 */
DvtPieChart._orderSlicesForRendering = function (slices) {
  var zOrderedSlices = [];
  var i;
  var nSlices = (slices) ? slices.length : 0;
  var slice;

  var rotateIdx =  - 1;
  var angleStart;
  var angleExtent;
  var sliceSpanEnd;

  // the amount of the slice, in degrees, by which the slice that spans the 12 o'clock position spans 
  // counterclockwise from 12 o'clock (i.e., how much of the slice is "before noon")
  var sliceSpanBeforeNoon;

  // if we have any sort of pie rotation, then we need to rotate a copy of the _slices array
  // so that the first entry in the array is at 12 o'clock, or spans 12 o'clock position
  // to do this, we just check the angle start and angle extent of each slice. The first element in
  // the array would be that angle whose start + extent = 90 or whose start < 90 and 
  // start + extent > 90.
  // find the index of the slice that spans the 12 o'clock position
  for (i = 0;i < nSlices;i++) {
    slice = slices[i];
    angleStart = slice.getAngleStart();
    angleExtent = slice.getAngleExtent();
    sliceSpanEnd = angleStart + angleExtent;

    if (sliceSpanEnd > 360)
      sliceSpanEnd -= 360;

    if (sliceSpanEnd < 0)
      sliceSpanEnd += 360;

    if ((sliceSpanEnd == 90) || ((angleStart < 90) && (sliceSpanEnd > 90))) {
      rotateIdx = i;
      sliceSpanBeforeNoon = sliceSpanEnd - 90;
      break;
    }
  }

  // now create an array in which the slices are ordered clockwise from the 12 o'clock position
  var rotatedSlices = [];
  for (i = rotateIdx;i < nSlices;i++) {
    rotatedSlices.push(slices[i]);
  }
  for (i = 0;i < rotateIdx;i++) {
    rotatedSlices.push(slices[i]);
  }

  //total accumulated angle of slice so far
  var accumAngle = 0;

  // the bottom-most slice index, whose extent either spans the two bottom
  // quadrants across the 270 degree mark (the "6 o'clock" position), 
  // or is tangent to the 270 degree mark
  var lastSliceIndexToProcess = 0;

  //
  // process slices clockwise, starting at the top, series 0
  //    
  var accumAngleThreshold = 180 + sliceSpanBeforeNoon;
  for (i = 0;i < nSlices;i++) {
    slice = rotatedSlices[i];

    if (slice) {
      // if this slice makes the accumAngle exceed 180 degrees, 
      // then save it for processing later because this is the
      // bottom-most slice (it crosses the 6 o'clock mark), 
      // which means it should be in front in the z-order
      if (accumAngle + slice.getAngleExtent() > accumAngleThreshold) {
        lastSliceIndexToProcess = i;
        break;
      }

      // add this slice to the rendering queue for slices
      zOrderedSlices.push(slice);

      //add the current slice extent to the accumulated total
      accumAngle += slice.getAngleExtent();
    }
  }

  for (i = nSlices - 1;i >= lastSliceIndexToProcess;i--) {
    slice = rotatedSlices[i];
    if (slice) {
      zOrderedSlices.push(slice);
    }
  }

  return zOrderedSlices;
}

/**
 * Returns a boolean indicating if the DvtPieChart is a 3D pie
 *
 * @return {boolean} true If the pie is to be rendered as a 3D pie
 */
DvtPieChart.prototype.is3D = function () {
  return this._options['styleDefaults']['threeDEffect'] == "on";
}

/**
 * Determine the maximum distance a pie slice can be exploded from the pie
 *
 * @return {number} The maximum distance a pie slice can be exploded from the pie
 */
DvtPieChart.prototype.__calcMaxExplodeDistance = function () {
  var maxExplodeRatio = 0.5/DvtPieChart._RADIUS - 1; ///ensures that the exploded pie doesn't go outside the frame
  return this._radiusX * maxExplodeRatio;
}

/**
 * Explode all pie slices
 */
DvtPieChart.prototype.explodeAll = function () {
  this.animateExplode(0,  - 1);// explode all
}

/**
 * Unite all pie slices
 */
DvtPieChart.prototype.uniteAll = function () {
  this.animateExplode(1,  - 1);// unite/implode all
}

/**
 * Convenience function to explode a single slice by slice id
 *
 * @param {number} op Either DvtPieChart.EXPLODE or DvtPieChart.UNITE
 * @param {String} sliceId
 */
DvtPieChart.prototype.animateSingleSliceExplode = function (op, sliceId) {
  // find the seriedIdx corresponding to this sliceId
  var i;
  var slice;
  var length = this._slices.length;
  var seriesIdx =  - 1;

  for (i = 0;i < length;i++) {
    slice = this._slices[i];
    if (slice.getId() == sliceId) {
      seriesIdx = i;
      break;
    }
  }

  if (seriesIdx >  - 1)
    this.animateExplode(op, seriesIdx);
}

/**
 * Returns the animation duration for this pie.
 * @return {number}
 */
DvtPieChart.prototype.getAnimationDuration = function () {
  return DvtChartStyleUtils.getAnimationDuration(this.chart);
}

/**
 * Animate the explode/unite for a single slice, or for all slices
 *
 * @param {number} op Either DvtPieChart.EXPLODE or DvtPieChart.UNITE
 * @param {number} seriesIdx Either -1 for all slices, or the specific slice
 */
DvtPieChart.prototype.animateExplode = function (op, seriesIdx) {
  var length = this._slices.length;
  var slice;
  var i;

  // Animate the explode
  this._animationDuration = 2;

  // The defualt animation duration is 2 seconds. However, due to bug 12622757, we need 
  // to shorten the animation duration in order to get smooth slice animation without jitter.
  // Bug 12622757 is specific to Google Chrome, and it requires us to poke the DOM element 
  // that contains a filter in order to show animation of children of that DOM element.
  // However, due to bug 12715889, just poking the DOM also causes jitter in the
  // slice animation.  To get rid of the jitter, we round the amount of the translation we
  // apply to the pie slice and we also shorten the duration of the animation to visually
  // smooth out the effect of the rounding
  // Bug fix 12715889
  if (DvtAgent.isPlatformWebkit()) {
    this._animationDuration = 1;
  }

  var animator = new DvtAnimator(this.getCtx(), this._animationDuration);

  var exEnd = 0;

  var extent = this.__calcMaxExplodeDistance();// bug fix 8394428
  exEnd = (op == DvtPieChart.EXPLODE) ? extent : 0;

  if (seriesIdx ==  - 1) {
    var arPoints = [];
    for (i = 0;i < length;i++) {
      arPoints[i] = exEnd;
    }
    // have the animator animate all slices
    animator.addProp(DvtAnimator.TYPE_NUMBER_ARRAY, this, this._getSliceExplodes, this._setSliceExplodes, arPoints);
  }
  else if (seriesIdx >= 0 && seriesIdx < length) {
    slice = this._slices[seriesIdx];

    // animate just one slice
    animator.addProp(DvtAnimator.TYPE_NUMBER, slice, slice.getExplode, slice.explodeSlice, exEnd);
  }

  animator.play();
}

/**
 * Performs initial display animation.  Called by DvtAnimOnDisplay.
 */
DvtPieChart.prototype.doDisplayAnimation = function () {
  this._duringAnim = true; // flag to prevent label/feeler relayout
  var handler = new DvtDataAnimationHandler(this.getCtx(), this);
  
  // Construct fade in animation for labels and feelers
  var ar = [];
  for (var i = 0; i < this._slices.length; i++) {
    ar = ar.concat(this._slices[i].getLabelAndFeeler());
  }
  var labelAnim = new DvtAnimFadeIn(this._context, ar, this.getAnimationDuration());
  handler.add(labelAnim, 0);
  
  // Construct animation to grow the slices like a fan.
  // A filler slice is needed to fill in the empty space not occupied by the slices while growing.
  var fillerSlice = DvtPieSlice.createFillerSlice(this, this.getTotalValue());
  this._slices.push(fillerSlice);
  
  // Add animation to shrink the filler slice
  var fillerAnim = new DvtCustomAnimation(this.getCtx(), fillerSlice, this.getAnimationDuration());
  fillerAnim.getAnimator().addProp(DvtAnimator.TYPE_NUMBER_ARRAY, fillerSlice, fillerSlice.GetAnimationParams, fillerSlice.SetAnimationParams, [0, 0, 0]);
  fillerAnim.setOnEnd(fillerSlice._removeDeletedSlice, fillerSlice);
  handler.add(fillerAnim, 0);
  
  // Add animation to grow the actual slices
  for (var i=0; i<this._slices.length-1; i++) { // don't include filler slice
    this._slices[i].animateInsert(handler);
  }

  // Construct the animation to render the pie using the updated values
  var renderAnim = new DvtCustomAnimation(this.getCtx(), this, this.getAnimationDuration());
  renderAnim.getAnimator().addProp(DvtAnimator.TYPE_NUMBER_ARRAY, this, this._getAnimationParams, this._setAnimationParams, this._getAnimationParams());
  handler.add(renderAnim, 0);
  
  // Initialize to the start state
  this._setAnimationParams([1]);
  
  var anim = handler.getAnimation();
  anim.setOnEnd(this._restoreLabelPosition, this); // restore label position
  anim.play();
}

/**
 * Restores the label position at the end of the display animation.
 * @private
 */
DvtPieChart.prototype._restoreLabelPosition = function() {
  this._duringAnim = false;
}

/** Getters and setters **/

/**
 * @return {DvtPoint} The center of this pie chart
 */
DvtPieChart.prototype.getCenter = function () {
  return this._center;
}

/**
 * @return {DvtRectangle} This DvtPieChart's pie frame
 */
DvtPieChart.prototype.__getFrame = function () {
  return this._frame;
}

/**
 * @return {number} the length of the pie chart's x-radius
 */
DvtPieChart.prototype.getRadiusX = function () {
  return this._radiusX;
}

/**
 * @return {number} the length of the pie chart's y-radius
 */
DvtPieChart.prototype.getRadiusY = function () {
  return this._radiusY;
}

/**
 * @return {number} The pie chart's depth
 */
DvtPieChart.prototype.getDepth = function () {
  return this._depth;
}

/**
 * Return the top surface displayable belonging to the slice with the given seriesIdx.
 * Internal API used for Automation purposes.
 *
 * @param {Number} seriesIdx
 * @return {DvtDisplayable}
 * @private
 */
DvtPieChart.prototype._getSliceDisplayable = function (seriesIdx) {
  if (seriesIdx >= 0 && seriesIdx < this._slices.length) {
    var topSurface = this._slices[seriesIdx].getTopSurface();
    if (topSurface && topSurface.length > 0)
      return topSurface[0];
  }

  return null;
}

/**
 * @return {DvtContainer} The DvtContainer where we add pie shapes and feeler lines to
 */
DvtPieChart.prototype.__getShapesContainer = function () {
  return this._shapesContainer;
}

/**
 * @return {Array} An array containing the DvtPieSlice objects in this pie chart
 */
DvtPieChart.prototype.__getSlices = function () {
  return this._slices;
}

//---------------------------------------------------------------------//
// Animation Support                                                   //
//---------------------------------------------------------------------//
/**
 * Creates the update animation for this object.
 * @param {DvtDataAnimationHandler} handler The animation handler, which can be used to chain animations.
 * @param {DvtPieChart} oldPie The old pie state to animate from.
 */
DvtPieChart.prototype.animateUpdate = function (handler, oldPie) {
  // Create a new handler for the slices.  This handler is created to provide
  // access to the new chart for deleted objects, and to isolate the playables
  // for the pie animation from the other playables in the handler.
  var sliceHandler = new DvtDataAnimationHandler(this.getCtx(), this);

  // Construct the animation to update slice values for the children
  sliceHandler.constructAnimation(oldPie.__getSlices(), this.__getSlices());
  var sliceAnim = sliceHandler.getAnimation();

  // Construct the animation to render the pie using the updated values
  var renderAnim = new DvtCustomAnimation(this.getCtx(), this, this.getAnimationDuration());
  renderAnim.getAnimator().addProp(DvtAnimator.TYPE_NUMBER_ARRAY, this, this._getAnimationParams, this._setAnimationParams, this._getAnimationParams());

  // Combine and add to the chart handler
  var anim = new DvtParallelPlayable(this.getCtx(), sliceAnim, renderAnim);
  anim.setOnEnd(this.render, this);

  handler.add(anim, 0);
  
  // Initialize to the start state
  this._setAnimationParams([1]);
}

/**
 * Creates the insert animation for this object.
 * @param {DvtDataAnimationHandler} handler The animation handler, which can be used to chain animations.
 */
DvtPieChart.prototype.animateInsert = function (handler) {
  // This should never get called, since animation is only supported for a single pie
}

/**
 * Creates the delete animation for this object.
 * @param {DvtDataAnimationHandler} handler The animation handler, which can be used to chain animations.
 * @param {DvtContainer} container The container where deletes should be moved for animation.
 */
DvtPieChart.prototype.animateDelete = function (handler, container) {
  // This should never get called, since animation is only supported for a single pie
}

/**
 * @private
 */
DvtPieChart.prototype._getAnimationParams = function () {
  return [1];
}

/**
 * Called by the animation loop with a dummy parameter to force the chart to re-render.
 * @private
 */
DvtPieChart.prototype._setAnimationParams = function (params) {

  // First delete the current contents
  this.removeChildren();

  if (this._shapesContainer)
    this._shapesContainer.destroy();

  // Clear references to the removed displayables
  this._shapesContainer = null;

  // Then render the new ones
  this.render();
}

//---------------------------------------------------------------------//
// End Animation Support                                               //
//---------------------------------------------------------------------//
/**
 * Pseudo-method used for animation (see animateExplode)
 *
 * @return {Array} An array containing the explode values for each slice in the pie chart
 * @private
 */
DvtPieChart.prototype._getSliceExplodes = function () {
  var explodeValues = [];
  var len = this._slices.length;
  for (var i = 0;i < len;i++) {
    explodeValues[i] = this._slices[i].getExplode();
  }

  return explodeValues;
}

/**
 * Pseudo-method used for animation (see animateExplode)
 *
 * @param {Array} newExplodeValues An array of numbers corresponding to the explode values for each slice
 * @private
 */
DvtPieChart.prototype._setSliceExplodes = function (newExplodeValues) {
  // check if the new explode value is different from the old, and if so, update   
  var len = this._slices.length;
  for (var i = 0;i < len;i++) {
    var slice = this._slices[i];
    var newExplodeVal = newExplodeValues[i];

    if (slice.getExplode() != newExplodeVal) {
      slice.explodeSlice(newExplodeVal);
    }
  }
}

//---------------------------------------------------------------------//
// Ordering Support: ZOrderManager impl                                //
//---------------------------------------------------------------------//
/**
 * @override
 */
DvtPieChart.prototype.bringToFrontOfSelection = function (slice) {
  var par = slice.getPieChart()._shapesContainer;
  if (par) {
    var parentChildCount = par.getNumChildren();
    if (parentChildCount - this._numFrontObjs > 1) {
      // Only change z-order for top surface
      par.removeChild(slice._topSurface[0]);
      var newIndex = parentChildCount - this._numFrontObjs - 1;
      par.addChildAt(slice._topSurface[0], newIndex);
    }
  }
};

/**
 * @override
 */
DvtPieChart.prototype.pushToBackOfSelection = function (slice) {
  var len = this._slices.length;
  var counter = 0;
  for (i = 0;i < len;i++) {
    if (this._slices[i].isSelected())
      counter++;
  }
  this._numSelectedObjsInFront = counter;
  //move the object to the first z-index before the selected objects
  var par = slice.getPieChart()._shapesContainer;
  if (par) {
    var parentChildCount = par.getNumChildren();
    var newIndex = parentChildCount - this._numFrontObjs - 1 - this._numSelectedObjsInFront;
    if (newIndex >= 0) {
      par.removeChild(slice._topSurface[0]);
      par.addChildAt(slice._topSurface[0], newIndex);
    }
  }
};

/**
 * @override
 */
DvtPieChart.prototype.setNumFrontObjs = function (num) {
  this._numFrontObjs = num;
};

DvtPieChart.prototype.getShapesForViewSwitcher = function(bOld) {
  var shapes = {};
  
  if (this._slices) {
    for (var iSlice = 0; iSlice < this._slices.length; iSlice++) {
      var slice = this._slices[iSlice];
      if (slice) {
        var chartDataItem = slice.getId();
        if (chartDataItem) {
          var id = chartDataItem.getId();
          if (id) {
            if (slice._topSurface && slice._topSurface.length > 0) {
              var topShape = slice._topSurface[0];
              shapes[id] = topShape;
            }
            //if (slice._crustSurface && slice._crustSurface.length > 0) {
            //  var crustShape = slice._crustSurface[0];
            //  shapes[id + "_crust"] = crustShape;
            //}
            //if (slice._leftSurface && slice._leftSurface.length > 0) {
            //  var leftShape = slice._leftSurface[0];
            //  shapes[id + "_left"] = leftShape;
            //}
            //if (slice._rightSurface && slice._rightSurface.length > 0) {
            //  var rightShape = slice._rightSurface[0];
            //  shapes[id + "_right"] = rightShape;
            //}
          }
        }
      }
    }
  }
  
  return shapes;
}

/**
 * Returns the location of the labels
 * @return {string} "auto", "none", "inside", or "outside"
 */
DvtPieChart.prototype.getLabelPosition = function () {
  return this._labelPosition;
}

/**
 * Return the skin to use for rendering.  If the value is not 'skyros', the simplified gradient effects will be used.
 * @return {string} skin
 */
DvtPieChart.prototype.getSkin = function () {
  return this._options['skin'];
}
// Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.
/*---------------------------------------------------------------------*/
/*   DvtPieSlice                                                       */
/*---------------------------------------------------------------------*/

/*
 * Call chain:
 * 
 * DvtPieChart creates each logical DvtPieSlice object.  The physical surface objects are 
 * then created in DvtPieChart.render, by calling DvtPieSlice.preRender()
 * 
 * In DvtPieSlice.preRender() we
 * 
 * 1. setup the gradient used for this DvtPieSlice
 * 2. create the physical objects representing each surface
 * 
 * The labels are then created and laid out by DvtSliceLabelLayout.layoutLabelsAndFeelers.
 * 
 * After the label layout is complete, DvtPieChart then calls
 * 
 * 1. render() to render the pie slice itself
 * 2. renderLabelAndFeeler() to render the pie label and feeler (if necessary)
 * 
 */

/**
 * Creates an instance of DvtPieSlice
 *
 * @param {DvtChartImpl} chart A reference to the DvtChartImpl that contains the pie chart.
 * @param {number} [seriesIndex] The series index of this slice. If not provided, the slice is an "Other" slice.
 * @class DvtPieSlice
 * @constructor
 * @implements {DvtLogicalObject}
 * @implements {DvtCategoricalObject}
 * @implements {DvtSelectable}
 * @implements {DvtTooltipSource}
 * @implements {DvtPopupSource}
 */
var DvtPieSlice = function (pieChart, seriesIndex) {
  this.Init(pieChart, seriesIndex);
}

DvtObj.createSubclass(DvtPieSlice, DvtObj, "DvtPieSlice");

/**
 * Object initializer
 *
 * @param {DvtChartImpl} chart A reference to the DvtChartImpl that contains the pie chart.
 * @param {number} [seriesIndex] The series index of this slice. If not provided, the slice is an "Other" slice.
 * @private
 */
DvtPieSlice.prototype.Init = function (pieChart, seriesIndex) {
  this._pieChart = pieChart;
  this._chart = pieChart.chart;

  this._angleStart = 0;
  this._angleExtent = 0;

  this._topSurface = null;// an array of DvtShapes representing the top of the slice
  this._leftSurface = null;// an array of DvtShapes representing the left side of the slice 
  // ("left" as seen from the tip of the slice)
  this._rightSurface = null;// an array of DvtShapes representing the right side of the slice 
  // ("right" as seen from the tip of the slice)
  this._crustSurface = null;// an array of DvtShapes representing the crust of the slice                              
  
  this._explodeOffsetX = 0;
  this._explodeOffsetY = 0;

  this._sliceLabel = null;
  this._sliceLabelPosition = null;
  this._sliceLabelString = null;

  this._hasFeeler = false;
  this._feelerRad = null;// the section of the feeler closest to the pie
  this._feelerHoriz = null;// the section of the feeler closest to the label
  this._outsideFeelerStart = null;// a point class with x and y fields. This represents the point on the pie 
  // from which the feeler originates in the unexploded state
  this._outsideFeelerMid = null;// a point class with x and y fields. This represents the point on the pie 
  // from which the feeler bends                           
  this._outsideFeelerEnd = null;// a point class with x and y fields. This represents the point not on the pie 
  // at which the feeler ends
  this._selected = false;
  this._selecting = false;

  this._radiusX = this._pieChart.getRadiusX();
  this._radiusY = this._pieChart.getRadiusY();
  this._explode = 0;
  
  // Set rendering constants
  var options = this._chart.getOptions();
  if (seriesIndex != null) { // not "Other" slice
    var dataItem = DvtChartDataUtils.getDataItem(this._chart, seriesIndex, 0);
    this._value = DvtChartDataUtils.getValue(this._chart, seriesIndex, 0);
    this._initExplode = DvtPieChartUtils.getSliceExplode(this._chart, seriesIndex);
    this._fillColor = DvtChartStyleUtils.getColor(this._chart, seriesIndex);
    this._fillPattern = DvtChartStyleUtils.getPattern(this._chart, seriesIndex, 0);
    this._strokeColor = DvtChartStyleUtils.getBorderColor(this._chart, seriesIndex);
    this._customLabel = dataItem['label'];
    this._seriesLabel = DvtChartDataUtils.getSeries(this._chart, seriesIndex);
    this._tooltip = DvtChartTooltipUtils.getDatatip(null, this._chart, seriesIndex, 0);
    this._action = dataItem['action'];
    this._showPopupBehaviors = this._chart.getShowPopupBehaviors(dataItem['_id']);
    this._id = DvtPieChartUtils.getSliceId(this._chart, seriesIndex);
  }
  else { // "Other" slice
    this._value = DvtPieChartUtils.getOtherValue(this._chart);
    this._initExplode = 0;
    this._fillColor = options['styleDefaults']['otherColor'];
    this._fillPattern = null;
    this._strokeColor = options['styleDefaults']['borderColor'];
    this._customLabel = null;
    this._seriesLabel = this._chart.getBundle().getTranslatedString('LABEL_OTHER', null);
    this._tooltip = DvtChartTooltipUtils.getOtherSliceDatatip(this._chart, this._value, 0);
    this._action = null;
    this._showPopupBehaviors = DvtPieChartUtils.getOtherSliceShowPopupBehaviors(this._chart);
    this._id = DvtPieChartUtils.getOtherSliceId(this._chart);
  }
};

/**
 * Returns the owning DvtPieChart object.
 * @return {DvtPieChart}
 */
DvtPieSlice.prototype.getPieChart = function () {
  return this._pieChart;
}

/**
 * Render the pie slice only; rendering of label and feeler
 * occurs in DvtPieSlice.renderLabelAndFeelers
 */
DvtPieSlice.prototype.render = function () {
  var sortedSurfaces = DvtPieSlice._sortPieSurfaces(this._topSurface, this._leftSurface, this._rightSurface, this._crustSurface, this._angleStart, this._angleExtent);
  var len = sortedSurfaces.length;
  for (var i = 0;i < len;i++) {
    var shapeArray = sortedSurfaces[i];
    // shapeArray is an array of DvtShapes representing the given surface. 
    // Iterate through this array and add each shape to the pieChart
    shapeCount = shapeArray.length;
    for (var j = 0;j < shapeCount;j++) {
      var shapesContainer = this._pieChart.__getShapesContainer();
      shapesContainer.addChild(shapeArray[j]);
      if (shapeArray[j].render)// render is only defined on certain shape subclasses
        shapeArray[j].render();
    }
  }
  
  // Render label and feeler
  // assume that all layout and text truncation has already been done
  // so in theory, we just need to call addChild with the feeler and label
  var sliceLabel = this._sliceLabel;
  if (sliceLabel) {
    this._pieChart.addChild(this._sliceLabel);

    // Associate the shapes with the slice for use during event handling
    DvtPieRenderUtils.associate(this, [this._sliceLabel]);

    if (this._pieChart.getLabelPosition() == "outside")
      this._renderOutsideFeeler();
  }
  
  // Perform initial explosion
  this.explodeSlice(this._initExplode);
  
  // Apply the correct cursor if action is defined
  if (this._action) {
    var sliceDisplayables = this.getDisplayables();
    for (var i = 0; i < sliceDisplayables.length; i++) {
      sliceDisplayables[i].setCursor(DvtSelectionEffectUtils.getSelectingCursor());
    }
  }
};

/**
 * Create a feeler from pt1 to pt2.
 * @param {DvtPoint} pt1`
 * @param {DvtPoint} pt2
 * @return {DvtLine} feeler
 * @private
 */
DvtPieSlice.prototype._feelerFromPts = function (pt1, pt2) {
  var feeler = new DvtLine(this._pieChart.getCtx(), pt1.x, pt1.y, pt2.x, pt2.y);
  var color = this._pieChart.getOptions()['styleDefaults']['pieFeelerColor'];
  var stroke = new DvtSolidStroke(color);
  feeler.setStroke(stroke);
  this._pieChart.addChild(feeler);
  return feeler;
}

/**
 * Render a feeler outside the slice.
 * @private
 */
DvtPieSlice.prototype._renderOutsideFeeler = function () {
  if (!this._hasFeeler) {
    return;
  }

  var feelerRad = this._feelerFromPts(this._outsideFeelerStart, this._outsideFeelerMid);
  var feelerHoriz = this._feelerFromPts(this._outsideFeelerMid, this._outsideFeelerEnd);

  // Store a reference to it so that we can remove
  this._feelerRad = feelerRad;
  this._feelerHoriz = feelerHoriz;
}

/**
 * Creates the gradients and physical shapes for the pie surfaces. Z-Ordering of the shapes
 * and layout and creation of the pie label is done elsewhere.
 */
DvtPieSlice.prototype.preRender = function () {
  var fillType = this._bFillerSlice ? "color" : DvtChartStyleUtils.getSeriesEffect(this._chart);
  var color = this.getFillColor();
  var pattern = this.getFillPattern();
  
  // Create the fills
  var topFill, lateralFill;
  if (fillType == "pattern" || pattern != null) 
    topFill = new DvtPatternFill(pattern, color);
  else if (fillType == "gradient") {
    var skin = this._pieChart.getSkin();
    var grAngle = (skin == DvtCSSStyle.SKIN_SKYROS) ? 297 : 270;
    var style = (!this._pieChart.is3D()) ? "2D" : "3D";

    var arColors = DvtPieRenderUtils.getGradientColors(DvtColorUtils.getRGB(color), style, skin);
    var arAlphas = DvtPieRenderUtils.getGradientAlphas(DvtColorUtils.getAlpha(color), style);
    var arRatios = DvtPieRenderUtils.getGradientRatios(style, skin);
    var arBounds = [Math.floor(this._pieChart.getCenter().x - this._radiusX), 
                    Math.floor(this._pieChart.getCenter().y - this._radiusY), 
                    Math.ceil(2 * this._radiusX), 
                    Math.ceil(2 * this._radiusY)];

    topFill = new DvtLinearGradientFill(grAngle, arColors, arAlphas, arRatios, arBounds);
  }
  else {
    topFill = new DvtSolidFill(color);
    lateralFill = new DvtSolidFill(DvtColorUtils.getDarker(color, 0.60));
  }

  // Create the Top Surface
  this._topSurface = DvtPieRenderUtils.createTopSurface(this, topFill);

  // 3D Effect Support
  if (this._pieChart.is3D() && (this._pieChart.getDepth() > 0 || this._radiusX != this.radiusY)) {
    var useGradientFill = (fillType == "gradient" || fillType == "pattern");
    var sideFill = useGradientFill ? DvtPieRenderUtils.generateLateralGradientFill(this, DvtPieRenderUtils.SIDE) : lateralFill;
    var crustFill = useGradientFill ? DvtPieRenderUtils.generateLateralGradientFill(this, DvtPieRenderUtils.CRUST) : lateralFill;

    // Create the side surfaces for the slice, which will be sorted later
    this._leftSurface = DvtPieRenderUtils.createLateralSurface(this, DvtPieRenderUtils.SURFACE_LEFT, sideFill);
    this._rightSurface = DvtPieRenderUtils.createLateralSurface(this, DvtPieRenderUtils.SURFACE_RIGHT, sideFill);
    this._crustSurface = DvtPieRenderUtils.createLateralSurface(this, DvtPieRenderUtils.SURFACE_CRUST, crustFill);
  }
}

// This logic is ported over from PieChart.sortSliversBySlice, and pushed
// from the PieChart to the PieSlice
/**
 * Sorts this DvtPieSlice's surfaces by z-order
 * 
 * @param {Array} topSurface An array of DvtShapes representing the top of this DvtPieSlice
 * @param {Array} leftSurface An array of DvtShapes representing the left side of this DvtPieSlice (as seen from
                  the tip of the slice)
 * @param {Array} rightSurface An array of DvtShapes representing the right side of this DvtPieSlice (as seen from
                  the tip of the slice)
 * @param {Array} crustSurface An array of DvtShapes representing the crust of this DvtPieSlice
 * @param {number} angleStart The starting position of this pie slice
 * @param {number} angleExtent The angular size of this pie slice
 * 
 * @return {Array} A sorted array of arrays (two-dimensional array) of DvtShape objects for this slice to render.
 * @private
 */
DvtPieSlice._sortPieSurfaces = function (topSurface, leftSurface, rightSurface, crustSurface, angleStart, angleExtent) {
  var sortedSurfaces = [];

  if (leftSurface && rightSurface && crustSurface) {
    // ported from PieChart.sortSliversBySlice
    // NOTE that instead of relying on the order in which the surfaces were 
    // originally created, we just get them from associative array by name    
    // the last slice to render, 
    // or if a slice starts at 270 degrees/6 o'clock (Fix for BUG 12577691)
    if (angleStart <= 270 && (angleStart + angleExtent > 270)) {
      //we're in the bottom-most slice, so add surfaces in back-to-front z-order:
      //left edge, right edge, crust
      sortedSurfaces.push(leftSurface);
      sortedSurfaces.push(rightSurface);
      sortedSurfaces.push(crustSurface);
    }

    // right-side of the pie
    else if (angleStart > 270 || (angleStart + angleExtent <= 90)) {
      //we're in the right side of the pie, so add surfaces in back-to-front z-order:
      //left edge, crust, right edge
      sortedSurfaces.push(leftSurface);
      sortedSurfaces.push(crustSurface);
      sortedSurfaces.push(rightSurface);
    }

    else {
      //we're in the left side of the pie, so add surfaces in back-to-front z-order:
      //right edge, crust, left edge
      sortedSurfaces.push(rightSurface);
      sortedSurfaces.push(crustSurface);
      sortedSurfaces.push(leftSurface);
    }

  }

  // top is rendered last
  sortedSurfaces.push(topSurface);

  return sortedSurfaces;
}

/**
 * Returns true if (x-y1) and (x-y2) have different signs
 */
DvtPieSlice.oppositeDirection = function (x, y1, y2) {
  var positive1 = (x - y1) > 0;
  var positive2 = (x - y2) > 0;
  return positive1 != positive2;
}

/**
 * Explodes the DvtPieSlice and feeler line by the given explode amount from the center of the pie.
 *
 * @param {number} explode Amount by which to explode this DvtPieSlice out. 0 means slice is not exploded.
 */
DvtPieSlice.prototype.explodeSlice = function (explode) {
  this._explode = explode;

  if (explode != 0) {
    var arc = this._angleExtent;
    var angle = this._angleStart;
    var fAngle = angle + (arc / 2);
    var radian = (360 - fAngle) * DvtMath.RADS_PER_DEGREE;
    var tilt = this._pieChart.is3D() ? DvtPieChart._THREED_TILT : 1;
    
    var explodeOffset = explode * this._pieChart.__calcMaxExplodeDistance();
    this._explodeOffsetX = Math.cos(radian) * explodeOffset;
    this._explodeOffsetY = Math.sin(radian) * tilt * explodeOffset;

    // To work around bug 12715831, in the 2D pie case, we need to poke the 
    // DOM element that contains the shadow filter that is applied to the pie slices.
    // However, due to bug 12715889, just poking the DOM also causes jitter in the
    // slice animation.  To get rid of the jitter, we round the amount of the translation we
    // apply to the pie slice and we also shorten the duration of the animation to visually smooth
    // out the result of the rounding.
    // Bug fix 12715889
    if (DvtAgent.isPlatformWebkit()) {
      this._explodeOffsetX = Math.round(this._explodeOffsetX);
      this._explodeOffsetY = Math.round(this._explodeOffsetY);
    }
  }
  else {
    this._explodeOffsetX = 0;
    this._explodeOffsetY = 0;
  }

  // now update each surface
  if (this._topSurface) {
    DvtPieSlice._translateShapes(this._topSurface, this._explodeOffsetX, this._explodeOffsetY);
  }

  if (this._rightSurface) {
    DvtPieSlice._translateShapes(this._rightSurface, this._explodeOffsetX, this._explodeOffsetY);
  }

  if (this._leftSurface) {
    DvtPieSlice._translateShapes(this._leftSurface, this._explodeOffsetX, this._explodeOffsetY);
  }

  if (this._crustSurface) {
    DvtPieSlice._translateShapes(this._crustSurface, this._explodeOffsetX, this._explodeOffsetY);
  }

  // update the feeler line
  if (this._hasFeeler) {
    // get current starting x and y, and then update the feeler line only
    var oldStartX = this._outsideFeelerStart.x;
    var oldStartY = this._outsideFeelerStart.y;

    var newStartX = oldStartX + this._explodeOffsetX;
    var newStartY = oldStartY + this._explodeOffsetY;

    this._feelerRad.setX1(newStartX);
    this._feelerRad.setY1(newStartY);

    var oldMidX = this._outsideFeelerMid.x;
    var oldMidY = this._outsideFeelerMid.y;

    //The midpoint of the feeler has to be updated if the new radial feeler is pointing towards an opposite direction;
    //otherwise, the feeler will go through the slice.
    //The easy solution is to set the x/y of the midPt to be the same as startPt.
    if (DvtPieSlice.oppositeDirection(oldMidX, oldStartX, newStartX)) {
      this._feelerRad.setX2(newStartX);
      this._feelerHoriz.setX1(newStartX);
    }
    else {
      this._feelerRad.setX2(oldMidX);
      this._feelerHoriz.setX1(oldMidX);
    }

    if (DvtPieSlice.oppositeDirection(oldMidY, oldStartY, newStartY)) {
      this._feelerRad.setY2(newStartY);
      this._feelerHoriz.setY1(newStartY);
    }
    else {
      this._feelerRad.setY2(oldMidY);
      this._feelerHoriz.setY1(oldMidY);
    }

  }
  
  //update the label position
  if (this._sliceLabel) {
    this._sliceLabel.setTranslate(this._explodeOffsetX, this._explodeOffsetY);
  }
}

/**
 * Translates each element in an array of shapes by the same delta x and delta y
 *
 * @param {Array} shapes An array of DvtShape objects to translate
 * @param {number} tx
 * @param {number} ty
 *
 * @private
 */
DvtPieSlice._translateShapes = function (shapes, tx, ty) {
  if (!shapes)
    return;

  var len = shapes.length;

  for (var i = 0;i < len;i++) {
    var shape = shapes[i];
    shape.setTranslate(tx, ty);
  }

}


/** Getters and setters **/

/**
 * @return {number} The size of this pie slice's angle
 */
DvtPieSlice.prototype.getAngleExtent = function () {
  return this._angleExtent;
}

/**
 * @param {number} extent The size of this pie slice's angle
 */
DvtPieSlice.prototype.setAngleExtent = function (extent) {
  this._angleExtent = extent;
}

/**
 * @return {number} The starting angle location of this pie slice
 */
DvtPieSlice.prototype.getAngleStart = function () {
  return this._angleStart;
}

/**
 * @param {number} start The starting angle location of this pie slice
 */
DvtPieSlice.prototype.setAngleStart = function (start) {
  this._angleStart = start;
}

/**
 * @return {number} The x-offset for this pie slice. Zero if the slice is not exploded.
 */
DvtPieSlice.prototype.__getExplodeOffsetX = function () {
  return this._explodeOffsetX;
}

/**
 * @return {number} The y-offset for this pie slice. Zero if the slice is not exploded.
 */
DvtPieSlice.prototype.__getExplodeOffsetY = function () {
  return this._explodeOffsetY;
}

/**
 * Set the points for a feeler outside the slice.
 *
 * @param {object} startPt The starting point of the feeler, located on the pie slice. Point has an x and y field
 * @param {object} midPt The mid point of the feeler, located between the slice and the label. Point has an x and y field
 * @param {object} endPt The ending point of the feeler, located on the pie label. Point has an x and y field
 */
DvtPieSlice.prototype.setOutsideFeelerPoints = function (startPt, midPt, endPt) {
  this._outsideFeelerStart = startPt;
  this._outsideFeelerMid = midPt;
  this._outsideFeelerEnd = endPt;
  this._hasFeeler = true;
}

/**
 * Set the slice without feeler.
 */
DvtPieSlice.prototype.setNoOutsideFeeler = function () {
  this._outsideFeelerStart = null;
  this._outsideFeelerMid = null;
  this._outsideFeelerEnd = null;
  this._hasFeeler = false;
}

/**
 * Returns an array containing the label and feeler objects of the slice.
 * @return {array}
 */
DvtPieSlice.prototype.getLabelAndFeeler = function() {
  var ar = [];
  if (this._sliceLabel)
    ar.push(this._sliceLabel);
  if (this._feelerRad)
    ar.push(this._feelerRad);
  if (this._feelerHoriz)
    ar.push(this._feelerHoriz);
  return ar;
}

/**
 * @return {DvtTextArea} The label for this slice
 */
DvtPieSlice.prototype.getSliceLabel = function () {
  return this._sliceLabel;
}

/**
 * @param {DvtTextArea} sliceLabel
 */
DvtPieSlice.prototype.setSliceLabel = function (sliceLabel) {
  this._sliceLabel = sliceLabel;
}

/**
 * @return {String} Untruncated slice label if slice label is truncated.
 */
DvtPieSlice.prototype.getSliceLabelString = function () {
  return this._sliceLabelString;
}

/**
 * @param {String} labelStr Untruncated slice label if slice label is truncated.
 */
DvtPieSlice.prototype.setSliceLabelString = function (labelStr) {
  this._sliceLabelString = labelStr;
}

/**
 * @return {Array} The top surface displayables of this Pie Slice
 */
DvtPieSlice.prototype.getTopSurface = function () {
  return this._topSurface;
}

/**
 * Returns the numeric data value associated with this slice
 * @return {number}
 */
DvtPieSlice.prototype.getValue = function () {
  return this._value;
}

/**
 * @return {String} The series id
 */
DvtPieSlice.prototype.getId = function () {
  return this._id;
}

/**
 * Returns true if this slice contains the given bounding box, used for labels.
 * @param {object} bbox The bounding box to check containment for.
 * @param {DvtPieSlice} node The pie slice on which to check containment.
 */
DvtPieSlice.containsRect = function(bbox, slice) {
  return (slice.contains(bbox.x, bbox.y) && slice.contains(bbox.x + bbox.w, bbox.y) && 
          slice.contains(bbox.x + bbox.w, bbox.y + bbox.h) && slice.contains(bbox.x, bbox.y + bbox.h));
}

/**
 * Returns true if the specified displayable can be selected or hovered.
 * @param {DvtDisplayable} displayable
 * @return {boolean}
 */
DvtPieSlice._shapeIsSelectable = function(shape) {
  return ((shape instanceof DvtGraphSelectableArc) 
    || (shape instanceof DvtGraphSelectablePolygon)
    || (shape instanceof DvtGraphSelectablePath));
}

/**
 * Returns true if this slice contains the given coordinates.
 * @param {number} x
 * @param {number} y
 * @return {boolean}
 */
DvtPieSlice.prototype.contains = function(x, y) {
  var c = this._pieChart.getCenter();
  var cos = (x - c.x) / this._radiusX;
  var sin = (y - c.y) / this._radiusY;
  
  // Compute the angle
  var angle = -Math.atan2(sin, cos) * (180/Math.PI); // in degrees
  // First adjust angle to be greater than the start angle.
  while(angle < this._angleStart)
    angle += 360;
  // Then adjust to be within 360 degrees of it  
  while(angle - this._angleStart >= 360)
    angle -= 360;
  
  var containsRadius = Math.pow(cos, 2) + Math.pow(sin, 2) <= 1;
  var containsAngle = angle <= this._angleStart + this._angleExtent;
  return containsRadius && containsAngle;
}

//---------------------------------------------------------------------//
// Animation Support                                                   //
//---------------------------------------------------------------------//
DvtPieSlice.prototype.GetAnimationParams = function () {
  return [this._value, this._radiusX, this._radiusY];
}

DvtPieSlice.prototype.SetAnimationParams = function (params) {
  this._value = params[0];
  this._radiusX = params[1];
  this._radiusY = params[2];
}

/**
 * Creates the update animation for this object.
 * @param {DvtDataAnimationHandler} handler The animation handler, which can be used to chain animations.
 * @param {DvtPieSlice} oldSlice The old pie state to animate from.
 */
DvtPieSlice.prototype.animateUpdate = function (handler, oldSlice) {
  var startState = oldSlice.GetAnimationParams();
  var endState = this.GetAnimationParams();

  if (!DvtArrayUtils.equals(startState, endState)) {
    // Create the animation
    var anim = new DvtCustomAnimation(this._pieChart.getCtx(), this, this.getPieChart().getAnimationDuration());
    anim.getAnimator().addProp(DvtAnimator.TYPE_NUMBER_ARRAY, this, this.GetAnimationParams, this.SetAnimationParams, endState);
    handler.add(anim, 0);

    // Initialize to the start state
    this.SetAnimationParams(startState);
  }
}

/**
 * Creates the insert animation for this object.
 * @param {DvtDataAnimationHandler} handler The animation handler, which can be used to chain animations.
 */
DvtPieSlice.prototype.animateInsert = function (handler) {
  // Create the animation
  var anim = new DvtCustomAnimation(this._pieChart.getCtx(), this, this.getPieChart().getAnimationDuration());
  anim.getAnimator().addProp(DvtAnimator.TYPE_NUMBER_ARRAY, this, this.GetAnimationParams, this.SetAnimationParams, this.GetAnimationParams());
  handler.add(anim, 0);

  // Initialize to the start state
  this.SetAnimationParams([0, 0, 0]);
}

/**
 * Creates the delete animation for this object.
 * @param {DvtDataAnimationHandler} handler The animation handler, which can be used to chain animations.
 * @param {DvtPieChart} container The new container where the pie slice should be moved for animation.
 */
DvtPieSlice.prototype.animateDelete = function (handler, container) {
  var newSlices = container.__getSlices();
  var oldSlices = this.getPieChart().__getSlices();
  
  // Add the deleted slice to the new pie in the right spot
  var oldIndex = DvtArrayUtils.getIndex(oldSlices, this);
  var prevIndex = oldIndex - 1;
  if (prevIndex >= 0) {
    var prevId = oldSlices[prevIndex].getId();
    // Find the location of the previous slice
    for (var i = 0;i < newSlices.length;i++) {
      if (newSlices[i].getId().equals(prevId)) {
        newSlices.splice(i + 1, 0, this);
        break;
      }
    }
  }
  else 
    newSlices.splice(0, 0, this);
  
  this._pieChart = container; // reparent this slice to the new pie
  
  // Create the animation to delete the slice
  var anim = new DvtCustomAnimation(container.getCtx(), this, this.getPieChart().getAnimationDuration());
  anim.getAnimator().addProp(DvtAnimator.TYPE_NUMBER_ARRAY, this, this.GetAnimationParams, this.SetAnimationParams, [0, 0, 0]);

  // Set the onEnd listener so that the slice can be deleted
  anim.setOnEnd(this._removeDeletedSlice, this);

  // Finally add the animation
  handler.add(anim, 0);
}

/**
 * Removes a deleted slice from the owning pie chart.  A re-render must be performed for the
 * results to be visible.
 */
DvtPieSlice.prototype._removeDeletedSlice = function () {
  var slices = this.getPieChart().__getSlices();
  var index = DvtArrayUtils.getIndex(slices, this);

  if (index >= 0)
    slices.splice(index, 1);
}

//---------------------------------------------------------------------//
// DvtLogicalObject impl                                               //
//---------------------------------------------------------------------//
/**
 * @override
 */
DvtPieSlice.prototype.getDisplayables = function () {
  var ret = new Array();

  if (this._topSurface)
    ret = ret.concat(this._topSurface);

  if (this._leftSurface)
    ret = ret.concat(this._leftSurface);

  if (this._rightSurface)
    ret = ret.concat(this._rightSurface);

  if (this._crustSurface)
    ret = ret.concat(this._crustSurface);

  if (this._sliceLabel)
    ret.push(this._sliceLabel);

  if (this._feelerRad)
    ret.push(this._feelerRad);

  if (this._feelerHoriz)
    ret.push(this._feelerHoriz);

  return ret;
}

//---------------------------------------------------------------------//
// Selection Support: DvtSelectable impl                               //
//---------------------------------------------------------------------//
/**
 * @return return the physical shape
 */
DvtPieSlice.prototype.getPhysicalShape = function (obj) {
  obj.setDataColor(this.getFillColor(), DvtChartStyleUtils.getSelectedInnerColor(this._chart), DvtChartStyleUtils.getSelectedOuterColor(this._chart));
  obj.setZorder(false);
  obj.setSelectedShadow(false);
  obj.setCursor(DvtSelectionEffectUtils.getSelectingCursor());
  return obj;
}
/**
 * @override
 */
DvtPieSlice.prototype.isSelectable = function () {
  // Only called by the selection manager when selection is enabled
  return true;
};

/**
 * @override
 */
DvtPieSlice.prototype.isSelected = function () {
  return this._selected;
};

/**
 * @override
 */
DvtPieSlice.prototype.setSelected = function (bSelected) {
  this._selected = bSelected;
  if (this._selected) {
    this._pieChart.bringToFrontOfSelection(this);
  }
  else if (!this._selecting) {
    this._pieChart.pushToBackOfSelection(this);
  }
  var shapeArr = this.getDisplayables();
  for (i = 0;i < shapeArr.length;i++) {
    if (DvtPieSlice._shapeIsSelectable(shapeArr[i])) {
      var shape = this.getPhysicalShape(shapeArr[i]);
      shape.setSelected(bSelected);
    }
  }
};

/**
 * @override
 */
DvtPieSlice.prototype.showHoverEffect = function () {
  this._selecting = true;
  this._pieChart.bringToFrontOfSelection(this);
  var shapeArr = this.getDisplayables();
  for (i = 0;i < shapeArr.length;i++) {
    if (DvtPieSlice._shapeIsSelectable(shapeArr[i])) {
      var shape = this.getPhysicalShape(shapeArr[i]);
      shape.showHoverEffect();
    }
  }
};

/**
 * @override
 */
DvtPieSlice.prototype.hideHoverEffect = function () {
  this._selecting = false;
  if (!this._selected) {
    this._pieChart.pushToBackOfSelection(this);
  }
  var shapeArr = this.getDisplayables();
  for (i = 0;i < shapeArr.length;i++) {
    if (DvtPieSlice._shapeIsSelectable(shapeArr[i])) {
      var shape = this.getPhysicalShape(shapeArr[i]);
      shape.hideHoverEffect();
    }
  }
};

//---------------------------------------------------------------------//
// Tooltip Support: DvtTooltipSource impl                              //
//---------------------------------------------------------------------//
/**
 * @override
 */
DvtPieSlice.prototype.getDatatip = function (target, x, y) {
  if (target == this._sliceLabel) {
    if (this._sliceLabel && this._sliceLabel.isTruncated())
      return this.getSliceLabelString();
  }
  return this.getTooltip();
};

/**
 * @override
 */
DvtPieSlice.prototype.getDatatipColor = function () {
  return this.getFillColor();
};

//---------------------------------------------------------------------//
// Rollover and Hide/Show Support: DvtCategoricalObject impl           //
//---------------------------------------------------------------------//
/**
 * @override
 */
DvtPieSlice.prototype.getCategories = function () {
  return [this.getId().getSeries()];
};

//---------------------------------------------------------------------//
// Keyboard Support: DvtKeyboardNavigables impl                        //
//---------------------------------------------------------------------//
/**
 * @override
 */
DvtPieSlice.prototype.getNextNavigable = function(event) 
{
  if(event.type == DvtMouseEvent.CLICK)
  {
    return this;
  }
  else if(event.keyCode == DvtKeyboardEvent.SPACE && event.ctrlKey)
  {
    // multi-select node with current focus; so we navigate to ourself and then let the selection handler take
    // care of the selection
    return this;
  }
  
  var slices = this._pieChart.__getSlices();
  var idx = slices.indexOf(this);
  var next = null;

  if (event.keyCode == DvtKeyboardEvent.RIGHT_ARROW) {
  	if (idx < slices.length-1) 
      	  next = slices[idx+1];
  	else
          next = slices[0];
  } else if (event.keyCode == DvtKeyboardEvent.LEFT_ARROW) {
	if (idx == 0) 
	  next = slices[slices.length - 1];
	else
          next = slices[idx-1];
  }
  return next;
}

/**
 * @override
 */
DvtPieSlice.prototype.getKeyboardBoundingBox = function () {
  var displayables = this.getDisplayables();
  if (displayables[0])
    return displayables[0].getDimensions();
  else 
    return new DvtRectangle(0, 0, 0, 0);
}

/**
 * @override
 */
DvtPieSlice.prototype.showKeyboardFocusEffect = function() 
{
  this._isShowingKeyboardFocusEffect = true;
  this.showHoverEffect();

};

/**
 * @override
 */
DvtPieSlice.prototype.hideKeyboardFocusEffect = function() 
{
  this._isShowingKeyboardFocusEffect = false;
  this.hideHoverEffect();
};

/**
 * @override
 */
DvtPieSlice.prototype.isShowingKeyboardFocusEffect = function () {
  return this._isShowingKeyboardFocusEffect;
}

/**
 * Returns the current explode value for this pie slice
 *
 * @return {number}
 */
DvtPieSlice.prototype.getExplode = function () {
  return this._explode;
}

/**
 * Returns the user-defined label for this pie slice.
 *
 * @return {string}
 */
DvtPieSlice.prototype.getCustomLabel = function () {
  return this._customLabel;
}

/**
 * Returns the default series label for this pie slice.
 *
 * @return {string}
 */
DvtPieSlice.prototype.getSeriesLabel = function () {
  return this._seriesLabel;
}

/**
 * Returns the color of this pie slice, represented as a String
 *
 * @return {String}
 */
DvtPieSlice.prototype.getFillColor = function () {
  return this._fillColor;
}

/**
 * Returns the name of the fill pattern for this pie slice
 *
 * @return {string}
 */
DvtPieSlice.prototype.getFillPattern = function () {
  return this._fillPattern;
}

/**
 * Returns the color of this pie slice border
 *
 * @return {String}
 */
DvtPieSlice.prototype.getStrokeColor = function () {
  return this._strokeColor;
}

/**
 * Returns the tooltip string associated with this slice
 *
 * @return {String}
 */
DvtPieSlice.prototype.getTooltip = function () {
  return this._tooltip;
}

/**
 * Return the action string for the data item, if any exists.
 * @return {string} the action outcome for the data item.
 */
DvtPieSlice.prototype.getAction = function () {
  return this._action;
}

/**
 * Returns the popup behaviors for this pie.
 * @return {array}
 */
DvtPieSlice.prototype.getShowPopupBehaviors = function () {
  return this._showPopupBehaviors;
}

/**
 * Creates a filler slice (for fan effect in display animation).
 * @return {DvtPieSlice} filler slice.
 */
DvtPieSlice.createFillerSlice = function(pieChart, value) {
  var slice = new DvtPieSlice(pieChart);
  slice._value = value;
  slice._bFillerSlice = true;
  slice._fillColor = "rgba(255,255,255,0)";
  slice._strokeColor = "rgba(255,255,255,0)";
  slice._tooltip = null;
  slice._id = null;
  return slice;
}
// Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.
/**
 *   Animation on Display funtionality.
 *   @class
 */
var DvtAnimOnDisplay = function () {};

DvtObj.createSubclass(DvtAnimOnDisplay, DvtObj, "DvtAnimOnDisplay");

/**
 *  Creates a DvtPlayable that performs initial animation for a chart.
 *  @param {DvtChartImpl} chart
 *  @param {string} type The animation type.
 *  @param {number} duration The duration of the animation in seconds.
 *  @return {DvtPlayable} The animation of the chart objects that are subject to animation.
 */
DvtAnimOnDisplay.createAnimation = function (chart, type, duration) {
  var arPlayables = [];

  if (DvtChartTypeUtils.isBLAC(chart)) {
    DvtAnimOnDisplay._animBarLineArea(chart, duration, arPlayables);
  }
  else if (DvtChartTypeUtils.isScatterBubble(chart) || DvtChartTypeUtils.isFunnel(chart)) {
    DvtAnimOnDisplay._animBubbleScatterFunnel(chart, duration, arPlayables);
  }
  else if(DvtChartTypeUtils.isPie(chart) && chart.pieChart) {
    // Delegate to the pie to do the animation.  Return null since it's fully handled within the pie.
    chart.pieChart.doDisplayAnimation();
    return null; 
  }
    
  return ((arPlayables.length > 0) ? new DvtParallelPlayable(chart.getCtx(), arPlayables) : null);
};

/**
 *  Adds a list of playables that animates the chart on initial display, for
 *  the bar and line/area components (including visible markers) to the
 *  supplied array.
 *  @param {DvtChartImpl} chart
 *  @param {number} duration The duration of the animation in seconds.
 *  @param {Array} arPlayables The array to which the playables should be added.
 */
DvtAnimOnDisplay._animBarLineArea = function (chart, duration, arPlayables) {
  var objs = chart.getObjects();
  var objCount = objs ? objs.length : 0;

  if (objCount) {
    var obj, peer;
    var nodePlayable;

    for (var i = 0;i < objCount;i++) {
      peer = objs[i];
      obj = peer.getDisplayables()[0];

      nodePlayable = null;
      if (obj instanceof DvtPolyline) {
        nodePlayable = DvtAnimOnDisplay._getLinePlayable(chart, obj, duration);
      }
      else if(obj instanceof DvtChartBar)
        nodePlayable = obj.getDisplayAnimation(duration);
      else if (obj instanceof DvtPolygon) {
        if (peer.getSeriesType() === 'area')
          nodePlayable = DvtAnimOnDisplay._getAreaPlayable(chart, obj, duration);
      }
      else {
        if (peer.getSeriesItem()['markerDisplayed'] != 'on') {
          continue;
        }
        // Fade-in the marker near the end of the line/area animation
        nodePlayable = new DvtAnimFadeIn(chart.getCtx(), obj, (duration - 0.8), 0.8);
      }

      if (nodePlayable) {
        arPlayables.push(nodePlayable);
      }
    } // end for
  } // end if objs
};

/**
 *  Adds a list of playables that animates the chart on initial display, for
 *  the bubble and scatter components to the supplied array.
 *  @param {DvtChartImpl} chart
 *  @param {number} duration The duration of the animation in seconds.
 *  @param {Array} arPlayables The array to which the playables should be added.
 */
DvtAnimOnDisplay._animBubbleScatterFunnel = function (chart, duration, arPlayables) {
  var objs = chart.getObjects();
  var objCount = objs ? objs.length : 0;
  var chartType = chart.getType();

  if (objCount) {
    var obj, peer;
    var nodePlayable;

    for (var i = 0;i < objCount;i++) {
      peer = objs[i];
      obj = peer.getDisplayables()[0];

      if (obj instanceof DvtMarker) {
        nodePlayable = (chartType === 'bubble') ? DvtAnimOnDisplay._getBubblePlayable(chart, obj, duration) : DvtAnimOnDisplay._getScatterPlayable(chart, obj, duration);
      }
      else if (obj instanceof DvtFunnelSlice) {
        nodePlayable = DvtAnimOnDisplay._getFunnelPlayable(chart, obj, duration);
      }
      if (nodePlayable)
        arPlayables.push(nodePlayable);
    }
  }
}

/**
 *   Returns a DvtPlayable representing the animation of an area polygon
 *   to its initial data value.
 *   @param {DvtChartImpl} chart
 *   @param {DvtPolygon} area  the area polygon to be animated.
 *   @param {number} duration The duration of the animation in seconds.
 *   @return {DvtPlayable} a playable representing the animation of the area
 *   polygon to its initial data value.
 */
DvtAnimOnDisplay._getAreaPlayable = function (chart, area, duration) {
  //  The last 2 coords of the area polygon just connect the last data
  //  point to the baseline and to the leftside of the plot area and
  //  are not data coords.
  var arPoints = area.getPoints();
  var endState = arPoints.slice(0); // copy, we will update the original
  var len = arPoints.length;

  if (len <= 4) { // (2 coords = 4 array entries)
    return null; // bale out for this area - no data points.
  }
  var yBase = arPoints[len - 1]; // y value of base line
  len -= 4; // get count of actual data points
  for (j = 0;j < len;j += 2) {
    arPoints[j + 1] = yBase;
  }
  area.setPoints(arPoints); // set initial position
  var nodePlayable = new DvtCustomAnimation(chart.getCtx(), area, duration);
  nodePlayable.getAnimator().addProp(DvtAnimator.TYPE_NUMBER_ARRAY, area, area.getPoints, area.setPoints, endState);

  return nodePlayable;
}

/**
 *   Returns a DvtPlayable representing the animation of a funnel slice to
 *   its initial data value and location.
 *   @param {DvtChartImpl} chart
 *   @param {DvtFunnelSlice} slice  The funnel slice to be animated.
 *   @param {number} duration The duration of the animation in seconds.
 *   @return {DvtPlayable} a playable representing the animation of the slice
 *   polygon to its initial data value.
 */
DvtAnimOnDisplay._getFunnelPlayable = function (chart, slice, duration) {
  var arPoints = slice.getAnimationParams();
  var endState = arPoints.slice(0); // copy, we will update the original
  arPoints[0] = 0;
  arPoints[2] = 0;

  slice.setAnimationParams(arPoints); // set initial position
  var nodePlayable = new DvtCustomAnimation(chart.getCtx(), slice, duration);
  nodePlayable.getAnimator().addProp(DvtAnimator.TYPE_NUMBER_ARRAY, slice, slice.getAnimationParams, slice.setAnimationParams, endState);

  return nodePlayable;
};

/**
 *   Returns a DvtPlayable representing the animation of a chart's
 *   bubble marker to its initial data value.
 *   @param {DvtChartImpl} chart
 *   @param {DvtMarker} marker  the DvtMarker to be animated.
 *   @param {number} duration The duration of the animation in seconds.
 *   @return {DvtPlayable} a playable representing the animation of the marker
 *   to its initial data value.
 */
DvtAnimOnDisplay._getBubblePlayable = function (chart, marker, duration) {
  var context = chart.getCtx();
  var endScale = new DvtPoint(marker.getScaleX(), marker.getScaleY());
  marker.setScale(1, 1);

  var p1 = new DvtAnimScaleBy(context, marker, endScale, duration);
  var p2 = new DvtAnimFadeIn(context, marker, duration);

  // Create a translation animation to grow the bubbles from the center.
  var size = marker.getSize();
  var matrix = marker.getMatrix().clone();
  matrix.translate(size/2, size/2);
  marker.setMatrix(matrix);
  var p3 = new DvtAnimMoveBy(context, marker, new DvtPoint( - size/2,  - size/2), duration);

  return new DvtParallelPlayable(context, [p1, p2, p3]);
};

/**
 *   Returns a DvtPlayable representing the animation of the line to
 *   its initial data value.
 *   @param {DvtChartImpl} chart
 *   @param {DvtPolyline} line  the polyline to be animated.
 *   @param {number} duration The duration of the animation in seconds.
 *   @return {DvtPlayable} a playable representing the animation of the line
 *   polyline to its initial data value.
 */
DvtAnimOnDisplay._getLinePlayable = function (chart, line, duration) {
  var arPoints = line.getPoints();
  var endState = arPoints.slice(0); // copy, we will update the original
  DvtAnimOnDisplay._getMeanPoints(arPoints); // update arPoints to initial coords
  line.setPoints(arPoints); // set initial position
  var nodePlayable = new DvtCustomAnimation(chart.getCtx(), line, duration);
  nodePlayable.getAnimator().addProp(DvtAnimator.TYPE_NUMBER_ARRAY, line, line.getPoints, line.setPoints, endState);

  return nodePlayable;
};

/**
 *   Returns a DvtPlayable representing the animation of a chart's
 *   scatter marker to its initial data value.
 *   @param {DvtChartImpl} chart
 *   @param {DvtMarker} marker  the DvtMarker to be animated.
 *   @param {number} duration The duration of the animation in seconds.
 *   @return {DvtPlayable} a playable representing the animation of the marker
 *   to its initial data value.
 */
DvtAnimOnDisplay._getScatterPlayable = function (chart, marker, duration) {
  return new DvtAnimPopIn(chart.getCtx(), marker, true, duration);
};

/**
 *   Updates the supplied array of line coordinates to reflect the mean y
 *   position of the line data.
 *   @param {Array} arPoints  the line vertex coordinates.
 */
DvtAnimOnDisplay._getMeanPoints = function (arPoints) {
  var mean = 0;
  var min = Number.MAX_VALUE;
  var max = Number.MIN_VALUE;
  var len = arPoints.length;
  var i;

  for (i = 1;i < len;i += 2) { // find largest and smallest y-values
    var v = arPoints[i]; // and their sum.
    if (v < min) {
      min = v;
    }
    if (v > max) {
      max = v;
    }
    mean += v;
  }

  if (len > 4) { // if more than 2 data points
    mean -= min;// discard smallest and largest
    mean -= max;// values to get a generally
    mean /= (len -4)/ 2;// more representative mean.
  }
  else { // 2 points only, make the second
    mean = arPoints[1];// grow from the first.
    arPoints[2] = arPoints[0];
  }
  mean = Math.round(mean);

  for (i = 1;i < len;i += 2) {
    arPoints[i] = mean;
  }
};
// Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.

/**
  *   Animation on Datachange functionality.
  *   @class
  */
var DvtAnimOnDC = function() {};

DvtObj.createSubclass(DvtAnimOnDC, DvtObj, "DvtAnimOnDC");

/**
  *  Creates a DvtPlayable that performs animation between a chart's data states.
  *  @param {DvtChartImpl} chart
  *  @param {string} type The animation type.
  *  @param {number} duration The duration of the animation in seconds.
  *
  * @return {DvtPlayable}
  */
DvtAnimOnDC.createAnimation = function(oldChart, newChart, type, duration, delContainer)
{
   var playable = null ;      // return value

   if (! DvtAnimOnDC._canAnimate(oldChart, newChart)) {
     return null ;
   }

   var  ctx  = newChart.getCtx() ;

   // Build arrays of old and new data change handlers.

   var  arOldList   = [];
   var  arNewList   = [];
   if (newChart.getType() === 'pie') {
     arOldList.push(oldChart.pieChart);
     arNewList.push(newChart.pieChart);
   } else {
     DvtAnimOnDC._buildAnimLists(ctx, arOldList, oldChart, arNewList, newChart, duration) ;
   }

   //  Walk the datachange handler arrays, and create animators for risers
   //  that need to be updated/deleted/inserted.

   var  ah  = new DvtDataAnimationHandler(ctx, delContainer) ;
   ah.constructAnimation(arOldList, arNewList) ;

   if (ah.getNumPlayables() > 0) {
     playable = ah.getAnimation() ;
   }

   return playable ;
};


/**
  *  Builds two (supplied) arrays of data change handlers (such as {@link DvtDC3DBar}
  *  for the old and new charts. Also creates this._Y1Animation list of gridline
  *  playables if axis scale change.
  *  @private
  */ 
DvtAnimOnDC._buildAnimLists = function(ctx, arOldList, oldChart, arNewList, newChart, duration)
{
  var  ar = oldChart['peers'] ;
   var  aLen = ar.length
   if ((aLen <= 0) && (newChart.getObjects().length <= 0)) {
     return ;
   }

   //  Create a list of DC handlers in arOldPeers and arNewPeers for the old and new peers.

   var  i,j ;
   var  aOut ;
   var  peer, obj ;
   var  chartType ;
   var  seriesType ;
   var  dch ;
   var  chartType = oldChart.type ;
   var  bBarChart = ((chartType.indexOf("bar") >= 0) || (chartType.indexOf("Bar") >= 0)) ;

   aOut = arOldList ;                    // start on old peers first
   for (i = 0; i < 2; i++) {             // loop over old peers and new peers
      for (j = 0; j < aLen; j++) {
         peer = ar[j] ;
         obj  = peer.getDisplayables()[0] ;
         dch  = null ;

         if (obj instanceof DvtFunnelSlice){
           dch = new DvtDCFunnelSlice(peer, duration);
         }
         else if (obj instanceof DvtPolyline) {
           dch = new DvtDCChartLineArea(peer, duration) ;
         }
         else  if (obj instanceof DvtPolygon) {
           seriesType = peer.getSeriesType();
           if (seriesType === 'bar') 
             dch  = new DvtDCChart2DBar(peer, duration) ;
           else if (seriesType === 'area') 
             dch  = new DvtDCChartLineArea(peer, duration) ;
         }   
         else  if (obj instanceof DvtMarker) {
           if (chartType === 'scatter' || chartType === 'bubble') {
             bMarkerDisplayed = true ;
           }
           else {
             if (i == 1)
               bMarkerDisplayed = peer.getSeriesItem()['markerDisplayed'] == 'on';
             else {          // need to look in old data block
               bMarkerDisplayed = DvtChartDataUtils.getSeriesItem(oldChart, peer.getSeriesIndex())['markerDisplayed'] == 'on';
             }
           }
           if (bMarkerDisplayed) {
             dch  = new DvtDCChartMarker(peer, duration) ;
           }
         }

         if (dch) {
           aOut.push(dch) ;
           dch.setOldChart(oldChart) ;
         }
      }

      aOut = arNewList ;               //  repeat on
      ar   = newChart.getObjects() ;   //  the new
      aLen = ar.length ;               //  chart's peers
   }
};


/**
  *  Checks if animation between the two charts is possible.
  *  @returns {boolean} true if animation can be performed, else false.
  *  @private
  */
DvtAnimOnDC._canAnimate = function(oldChart, newChart)
{
  //  Test for conditions for which we will not animate.
  
  var  oldType = oldChart.type ;
  var  newType = newChart.getType() ;
  
  if (oldType !== newType) 
    return false;
  else if (oldChart.type === 'pie' && (!oldChart || !newChart))
    return false;
  else if (oldChart.type !== 'pie' && (oldChart['peers'].length === 0 || newChart.getObjects().length === 0))
    return false;
  else 
    return true;
} ;
// Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
/*--------------------------------------------------------------------*/
/*   DvtDCChartAbstract      Abstract class for data change animation      */
/*--------------------------------------------------------------------*/
/*  Data Change Handlers must support the following methods:          */
/*                                                                    */
/*      getId()                                                       */
/*      animateUpdate()                                               */
/*      animateInsert()                                               */
/*      animateDelete()                                               */
/*--------------------------------------------------------------------*/

/**
  *  Abstract Data change handler for a chart object peer.
  *  @extends DvtObj
  *  @class DvtDCChartAbstract  Data change Handler for a chart object peer.
  *  @constructor  
  *  @param {DvtChartObjPeer} peer  The chart object peer to be animated on datachange.
  *  @param {Number} duration  the duration of the animation in seconds.
  *  <p>
  *  @returns {DvtDCChartAbstract} A new DvtDCChartAbstract derived object.
  */
var  DvtDCChartAbstract = function(peer, duration)
{
   this.Init(peer, duration) ;
};

DvtObj.createSubclass(DvtDCChartAbstract, DvtObj, "DvtDCChartAbstract");



/*--------------------------------------------------------------------*/
/*  animateUpdate()                                                   */
/*--------------------------------------------------------------------*/
/**
  * Creates an update animation from the old node to this node.
  * @param {DvtDataAnimationHandler} handler The animation handler, which can
  *                                  be used to chain animations. Animations
  *                                  created should be added via
  *                                  DvtDataAnimationHandler.add()
  * @param {DvtDCChartAbstract} oldNode The old node state to animate from.
  */
DvtDCChartAbstract.prototype.animateUpdate = function(handler, oldNode) {
};

/*--------------------------------------------------------------------*/
/*  animateInsert()                                                   */
/*--------------------------------------------------------------------*/
/**
  * Creates an insert animation for this node.
  * @param {DvtDataAnimationHandler} handler The animation handler, which can
  *                                  be used to chain animations. Animations
  *                                  created should be added via
  *                                  DvtDataAnimationHandler.add()
  */
DvtDCChartAbstract.prototype.animateInsert = function(handler)
{
};


/*--------------------------------------------------------------------*/
/*  animateDelete()                                                   */
/*--------------------------------------------------------------------*/
/**
  * Creates a delete animation for this node.
  * @param {DvtDataAnimationHandler} handler The animation handler, which can
  *                                  be used to chain animations. Animations
  *                                  created should be added via
  *                                  DvtDataAnimationHandler.add()
  * @param {DvtContainer} delContainer   The container to which deleted objects can
  *                                      be moved for animation.
  */
DvtDCChartAbstract.prototype.animateDelete = function(handler, delContainer)
{
};


/*---------------------------------------------------------------------*/
/*  getId()                                                            */
/*---------------------------------------------------------------------*/
/** 
  *  @returns {String}  a unique Id for object comparison during
  *  datachange animation of two charts.
  */
DvtDCChartAbstract.prototype.getId = function()
{
   return  this._animId ;
};


/*---------------------------------------------------------------------*/
/*  Init()                                                             */
/*---------------------------------------------------------------------*/
/**
  *  Object initializer.
  */
DvtDCChartAbstract.prototype.Init = function(peer, duration)
{
  this._peer     = peer ;
  this._duration = duration ;
  this._shape    = peer.getDisplayables()[0] ;
  this._animId   = peer.getSeries() + '/' + peer.getGroup() ;
};

/**
  *   Saves the psuedo old chart object.
  *   @param {Object} chart  a synopsis object created by DvtChart before
  *   the chart object is updated and rendered with new data.
  */
DvtDCChartAbstract.prototype.setOldChart = function(chart)
{
   this._oldChart = chart ;
};
// Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
/**
 *  Data change Handler for 2D Bar Riser (implements DvtDCChartAbstract).
 *  @extends DvtDCChartAbstract
 *  @class DvtDCChart2DBar  Data change Handler for 2D Bar Riser.
 *  @constructor
 *  @param {DvtChartObjPeer} peer The chart object peer for the shape to be animated.
 *  @param {Number} duration  the animation duration is seconds.
 *  @returns {DvtDCChart2DBar} A new DvtDCChart2DBar object.
 */
var DvtDCChart2DBar = function (peer, duration) {
  this.Init(peer, duration);
}

DvtObj.createSubclass(DvtDCChart2DBar, DvtDCChartAbstract, "DvtDCChart2DBar");

/**
 * Object initializer.
 */
DvtDCChart2DBar.prototype.Init = function (peer, duration) {
  DvtDCChart2DBar.superclass.Init.call(this, peer, duration);

  this._indicator = null;
  this._bHoriz = DvtChartTypeUtils.isHorizontal(peer.getChart());
}

/**
 * Creates and returns the insert animation for this bar.
 * @param {DvtDataAnimationHandler} handler
 * @return {DvtPlayable}
 */
DvtDCChart2DBar.prototype.animateInsert = function (handler) {
  var playable = this._shape.getInsertAnimation(this._duration);
  handler.add(playable, 0);
}

/**
 * Creates the delete animation for this 2D Bar.
 * @param {DvtDataAnimationHandler} handler The animation handler, which can be used to
 *                                          chain animations.
 * @param {DvtContainer} delContainer   The container to which the deleted objects should
 *                                      be moved for animation.
 * @returns {DvtPlayable} The animation to perform for this delete.
 */
DvtDCChart2DBar.prototype.animateDelete = function (handler, delContainer) {
  // Move from the old chart to the new chart
  delContainer.addChild(this._shape);

  // Create the delete animation
  var playable = this._shape.getDeleteAnimation(this._duration);
  handler.add(playable, 0);
}

/**
 * Creates the update animation for this 2D Bar.
 * @param {DvtDataAnimationHandler} handler
 * @param {DvtDCChart2DBar} oldNode The old node state to animate from.
 */
DvtDCChart2DBar.prototype.animateUpdate = function (handler, oldDC) {
  var startState = oldDC._getAnimationParams();
  var endState = this._getAnimationParams();

  if (DvtArrayUtils.equals(startState, endState))// If no bar geometry change,
    return;// nothing to animate.
    
  var oldChart = this._oldChart;
  var newChart = this._peer.getChart();

  var newSIdx = this._peer.getSeriesIndex();
  var oldSIdx = oldDC._peer.getSeriesIndex();
  var newGIdx = this._peer.getGroupIndex();
  var oldGIdx = oldDC._peer.getGroupIndex();

  //  Create an animate indicator if requested
  if (DvtChartStyleUtils.getAnimationIndicators(newChart) !== 'none') 
    this._makeDirPointer(startState, oldChart, oldSIdx, oldGIdx, newChart, newSIdx, newGIdx);

  // Create the animator for this bar update
  this._setAnimationParams(startState);
  var nodePlayable = new DvtCustomAnimation(this._shape.getCtx(), this, this._duration);
  nodePlayable.getAnimator().addProp(DvtAnimator.TYPE_NUMBER_ARRAY, this, this._getAnimationParams, this._setAnimationParams, endState);
  if (this._indicator) {
    nodePlayable.setOnEnd(this._onEndAnimation, this);
  }

  handler.add(nodePlayable, 0);// create the playable
}

/**
 * Returns the geometry of the bar.
 * @returns {Array}
 * @private
 */
DvtDCChart2DBar.prototype._getAnimationParams = function () {
  return this._shape.getAnimationParams();
}

/**
 * Updates the geometry of the bar.
 * @param {Array} ar  an array containing the polygon points.
 * @private
 */
DvtDCChart2DBar.prototype._setAnimationParams = function (ar) {
  this._shape.setAnimationParams(ar, this._indicator);
}

/**
 * Creates an update value direction pointer and positions it.
 */
DvtDCChart2DBar.prototype._makeDirPointer = function (startState, oldChart, oldSIdx, oldGIdx, newChart, newSIdx, newGIdx) {
  var uiDirection = DvtDCChartUtils.getDirection(oldChart, oldSIdx, oldGIdx, newChart, newSIdx, newGIdx);
  if (uiDirection !== DvtDCChartUtils.DIR_NOCHANGE) {
    var bDown = (uiDirection === DvtDCChartUtils.DIR_DOWN);
    fc = bDown ? DvtChartStyleUtils.getAnimationDownColor(newChart) : DvtChartStyleUtils.getAnimationUpColor(newChart);

    //  Create a path object that draws the indicator (it will be positioned in _setAnimationParams).
    var dirptr = DvtDCChartUtils.drawBarPointer(this._shape.getCtx(), bDown, this._bHoriz, fc);
    newChart.getPlotArea().addChild(dirptr);
    this._indicator = dirptr;
  }
}

/**
 * Callback to remove the indicator object at the end of the animation.
 * @private
 */
DvtDCChart2DBar.prototype._onEndAnimation = function () {
  this._indicator.getParent().removeChild(this._indicator);
  this._indicator = null;
}
// Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.
/*--------------------------------------------------------------------*/
/*   DvtDCChartLineArea    Data change Handler for Line and Area Risers    */
/*--------------------------------------------------------------------*/

/**
  *  Data change Handler for Area Riser (implements DvtDCChartAbstract).
  *  @extends DvtObj
  *  @class DvtDCChartLineArea  Data change Handler for Line and Area Risers.
  *  @constructor  
  *  @param {DvtChartObjPeer} peer  The chart object peer for the shape to be animated.
  *  @param {Number} duration  the animation duration is seconds.
  *  <p>
  *  @returns {DvtDCChartLineArea} A new DvtDCChartLineArea object.
  */
var  DvtDCChartLineArea = function(peer, duration)
{
   this.Init(peer, duration) ;
};

DvtObj.createSubclass(DvtDCChartLineArea, DvtDCChartAbstract, "DvtDCChartLineArea");


/*--------------------------------------------------------------------*/
/*  animateUpdate()      override of DvtDCChartAbstract.animateUpdate()    */
/*--------------------------------------------------------------------*/
/**
 * Creates the update animation for this Line or Area. Insert/delete of
 * groups within an existing series is treated as a special case of animateUpdate.
 * @param {DvtDataAnimationHandler} handler The animation handler, which can be
 *                                          used to chain animations.
 * @param {DvtDCChartLineArea} oldDC   The old node DC Handler to animate from.
 */
DvtDCChartLineArea.prototype.animateUpdate = function(handler, oldDC) {

   //-----------------------------------------------------------------------------//
   //  Animation summary :                                                        //
   //                                                                             //
   //  Updates  - just perform regular animation from oldState to newState        //
   //                                                                             //
   //  Inserts  - initially position the inserted point into the old point list   //
   //             with an x,y position proportionally between, and on the line    //
   //             connecting, the two non-inserted points on either side in the   //
   //             new initial line.  It can then be tweened to its final position //
   //             in the new list.                                                //
   //                                                                             //
   //  Deletes  - perform the reverse of an insert. The deleted point is inserted //
   //             into the new point list in its original position in the old     //
   //             list. It can then be tweened to an x,y position proportionally  //
   //             between, and on the line connecting, the final position of the  //
   //             two non-deleted points on either side in the new line.          //
   //             It can then be tweened from its original position to its final  //
   //             position on the connecting line.                                //         
   //-----------------------------------------------------------------------------//

   var startState   = oldDC._getAnimationParams();
   var endState     = this._getAnimationParams();
   this._finalState = null;

   if (DvtArrayUtils.equals(startState, endState)) {   // any geometry changes ?
     return ;                                          // no, nothing to animate.
   }

   var oldChart = this._oldChart ;
   var newChart = this._peer.getChart() ;

   //  Summarize the group changes as inserts/deletes/updates.

   var arOldGroups = DvtChartDataUtils.getGroups(oldChart) ;
   var arNewGroups = DvtChartDataUtils.getGroups(newChart) ;
   var oldGroupLen = arOldGroups.length;
   var newGroupLen = arNewGroups.length;

   var arCompare     = DvtDCChartUtils.compareGroups(arOldGroups, arNewGroups, true);
   var arUpdates     = arCompare[0];                                     // updated groups
   var arInserts     = arCompare[1];                                     // inserted groups
   var arDeletes     = arCompare[2];                                     // deleted groups
   var bInsertDelete = ((arInserts.length > 0) || (arDeletes.length > 0)) ;

   //  Create an array that represents the type of point (e.g. DvtDCChartUtils.INSERT,
   //  DvtDCChartUtils.DELETE, or DvtDCChartUtils.UPDATE in the initial new polyline/polygon.

   var arPointType = [] ;           // holds the point type for each line vertex.
   var iPT = 0;                     // index into arPointType

   // Create 2 arrays for old and new points of the same length for animation.
   // Inserted and deleted points will exist in both (but with different coords).
   // At the end of the animation, the original new points will be applied to 
   // the polyline/polygon, to remove the redundant deleted points.

   var arOldPt = null ;
   var arNewPt = null ;

   if (bInsertDelete) {
     arOldPt = [] ;
     arNewPt = [] ;
   }

   //  Create an array of logical direction indicators and directions, if
   //  indicator support requested. 

   this._arPointers  = null;         // updated for 
   this._arDirection = null;         // updates only.

   if ((DvtChartStyleUtils.getAnimationIndicators(newChart) !== 'none') && (arUpdates.length > 0)) {
     this._arPointers  = [] ;
     this._arDirection = [] ;
   }

   var aptsOld = oldDC._getAnimationParams();       // the old and new points to loop
   var aptsNew = this._getAnimationParams();        // over while populating arOldPt
   var aptsOldLen = aptsOld.length;                 // and arNewPt.
   var aptsNewLen = aptsNew.length;                  
                                                    
   var newSIdx = this._peer.getSeriesIndex();
   var oldSIdx = oldDC._peer.getSeriesIndex();

   var ixOld    = 0;             // index into the old group list
   var ixNew    = 0;             // index into the new group list
   var ixOldPts = 0;             // index into aptsOld
   var ixNewPts = 0;             // index into aptsNew


   //  Loop over both sets of groups.  If inserts/deletes, also build 2 new arrays of
   //  start and end states for the polyline/polygon vertices in arOldPt and arNewPt.

   while ((ixOld < oldGroupLen) || (ixNew < newGroupLen)) {   // loop over both sets of groups
        if (ixOld < oldGroupLen && ixNew < newGroupLen && ixOldPts < aptsOldLen && ixNewPts < aptsNewLen)    {
          if (arOldGroups[ixOld] === arNewGroups[ixNew])    { // same group = not an insert/delete
            arPointType[iPT] = DvtDCChartUtils.UPDATE;
            
            var xPos = aptsOld[ixOldPts++];    // get vertice old (x,y) 
            var yPos = aptsOld[ixOldPts++];
            
            if (this._arPointers != null){
              this._makeDirPointer(xPos, yPos, oldChart, oldSIdx, ixOld,
                                               newChart, newSIdx, ixNew, iPT);
            }
            ixOld++;
            ixNew++;
            iPT++;

            if (! bInsertDelete) {
              continue
            }

            arOldPt.push(xPos);                 // old x      // add old points to
            arOldPt.push(yPos);                 // old y      // anim start points array
            arNewPt.push(aptsNew[ixNewPts++]);  // new x      // add corresponding new points
            arNewPt.push(aptsNew[ixNewPts++]);    // new y      // to anim new points array.
         
           }
           else if (DvtArrayUtils.getIndex(arDeletes, arOldGroups[ixOld]) > -1) {
              // its a delete
              arPointType[iPT] = DvtDCChartUtils.DELETE ;
            
              arOldPt.push(aptsOld[ixOldPts++]);  // old x
              arOldPt.push(aptsOld[ixOldPts++]);    // old y
              arNewPt.push(0);                    // placeholder new x
              arNewPt.push(0);                    // placeholder new y
            
              ixOld++;

              if (this._arPointers != null) {
                this._arPointers[iPT]  = null;    // dummy
                this._arDirection[iPT] = null;    // entries
              }
              iPT++;
           }
           else if (DvtArrayUtils.getIndex(arInserts, arNewGroups[ixNew]) > -1) {
              // its an insert
              arPointType[iPT] = DvtDCChartUtils.INSERT;
            
              arOldPt.push(0);                    // placeholder old x
              arOldPt.push(0);                    // placeholder old y
              arNewPt.push(aptsNew[ixNewPts++]);  // new x
              arNewPt.push(aptsNew[ixNewPts++]);    // new y
            
              ixNew++;

              if (this._arPointers != null) {
                this._arPointers[iPT]  = null;    // dummy
                this._arDirection[iPT] = null;    // entries
              }
              iPT++;
           }
           else {
              ixOld++;
              ixNew++;
           }
       }
       else if (ixOld < oldGroupLen && ixOldPts < aptsOldLen) {             // if we've run out of new entries
           while (ixOld < oldGroupLen && ixOldPts < aptsOldLen){
              arPointType[iPT] = DvtDCChartUtils.DELETE = 1; // the remaining old entries must be deletes
              
              arOldPt.push(aptsOld[ixOldPts++]) ;  // old x
              arOldPt.push(aptsOld[ixOldPts++]) ;    // old y
              arNewPt.push(0) ;                    // placeholder new x
              arNewPt.push(0) ;                    // placeholder new y
            
              ixOld++;

              if (this._arPointers != null) {
                this._arPointers[iPT]  = null;     // dummy
                this._arDirection[iPT] = null;     // entries
              }
              iPT++;
           }
           break;
       }
       else {                                      // we must have run out of old entries
           while (ixNew < newGroupLen && ixNewPts < aptsNewLen) {
              arPointType[iPT] = DvtDCChartUtils.INSERT; // the remaining new entries must be inserts
              
              arOldPt.push(0) ;                    // placeholder old x
              arOldPt.push(0) ;                    // placeholder old y
              arNewPt.push(aptsNew[ixNewPts++]) ;  // new x
              arNewPt.push(aptsNew[ixNewPts++]) ;    // new y
            
              ixNew++;

              if (this._arPointers != null) {
                this._arPointers[iPT]  = null;    // dummy
                this._arDirection[iPT] = null;    // entries
              }
              iPT++;
           }
           break;
       }
   } // end while


   //  If we have inserts and/or deletes, we now need to calculate and fill in
   //  the null placeholder values set above in arOldPt and arNewPt.


   //--------------------------------------------------------------------------//
   //  At this point  arPointType contains an entry for each data point in     //
   //  the polyline/polygon on initial display (i.e. before animations start). //
   //  Each entry contains :                                                   //
   //    DvtDCChartUtils.UPDATE  = entry is unchanged or updated                    //
   //    DvtDCChartUtils.DELETE  = entry is deleted and will be animated out        //
   //    DvtDCChartUtils.INSERT  = entry is inserted and will be animated in        //
   //                                                                          //
   //  Also the initial and final tween positions have been generated for the  //
   //  the non-insert/delete entries, the initial postions only have been      //
   //  generated for the delete entries, and the final positions only for the  //
   //  insert entries.                                                         //
   //--------------------------------------------------------------------------//

   if (bInsertDelete) {

     var pt1x   = 0;                   // for computation of a line segment's middle point.
     var pt1y   = 0;
     var pt2x   = 0;
     var pt2y   = 0;
     var xInc   = 0;                   // x and y increments for
     var yInc   = 0;                   // proportional placement
     var iPTLen = arPointType.length;
       
     for (var i = 0; i < iPTLen; i++) {            // loop over arPointType
        if (arPointType[i] == DvtDCChartUtils.UPDATE)   // ignore non-insert/delete entries
          continue;
           
        //  Count the # of consecutive entries of the same type
        var n = arPointType[i];          // note the type
        var iConsec = 1;                 // # of consecutive entries
        var ix;                          // temp index
        for (ix = i+1; ix < iPTLen; ix++) {
           if (arPointType[ix] != n)
               break;
           iConsec++;
        }

        //  The iConsec's worth of points might be the last (rightmost) points
        //  in the line.
        var bFinalGroup = (ix ===iPTLen);   // note if so

        //  If this is the first or last entry, need to do edge case special handling

                                               //-----------------------//
        if (i === 0)                           // is it the first entry //
        {                                      //-----------------------//

           if (n === DvtDCChartUtils.INSERT)       // is it an insert
           {                                  // yes, fill-in its initial position
              //  Use the (x,y) coords of the first non-inserted point on the initial
              //  display line position as the initial inserted point(s) position.

              n = (i + iConsec) * 2 ;         // get 1st non-inserted index

              pt1x  =  arOldPt[n] ;
              pt1y  =  arOldPt[n +1] ;

              for (ix = 0; ix < iConsec; ix++)
              {
                 if (ix > 0)
                   i++ ;
                 n = i * 2 ;

                 arOldPt[n++] =  pt1x ;
                 arOldPt[n]   =  pt1y ;
              }
           }
           else                                // its a delete
           {
              //  Use the (x,y) coords of the first non-deleted point on the final
              //  display line position as the final delete point(s) positions.

              n = (i + iConsec) * 2 ;        // get 1st non-deleted index

              pt1x  =  arNewPt[n] ;
              pt1y  =  arNewPt[n +1] ;

              for (ix = 0; ix < iConsec; ix++)
              {
                 if (ix > 0)
                   i++ ;
                 n = i * 2 ;

                 arNewPt[n++] =  pt1x ;
                 arNewPt[n]   =  pt1y ;
              }
           }
        }                                                   //---------------------------//
        else  if ( (i === (iPTLen -1) )  || bFinalGroup)    // is it the right-end entry //
        {                                                   // or final right hand group //
                                                            //---------------------------//
           if (n === DvtDCChartUtils.INSERT)      // is it an insert
           {                                 // yes, fill-in its initial position
              //  Use the (x,y) coords of the last non-inserted point on the initial
              //  display line position as the initial inserted position.

              n = (i -1) * 2 ;               // get index of previous entry

              pt1x  =  arOldPt[n] ;
              pt1y  =  arOldPt[n +1] ;

              n = i * 2 ;                   // get index of last entry
              arOldPt[n++] =  pt1x ;
              arOldPt[n]   =  pt1y ;
           }
           else
           {
              //  Use the (x,y) coords of the first non-deleted point on the final
              //  display line position as the final delete point(s) positions.
      
              n = (i -1) * 2 ;              // get previous non-deleted index
              pt1x  =  arNewPt[n] ;         // and the x and
              pt1y  =  arNewPt[n +1] ;      // y pos.

              for (ix = 0; ix < iConsec; ix++)
              {
                 if (ix > 0)
                   i++ ;
                 n = i * 2 ;

                 arNewPt[n++] =  pt1x ;
                 arNewPt[n]   =  pt1y ;
              }
           }
        }                                      //---------------------------//
        else                                   // must be an internal entry //
        {                                      //---------------------------//

           if (n === DvtDCChartUtils.INSERT)        // is it an insert
           {                                   // yes, fill-in its initial position

              //  Get the (x,y) coords of the points on either side of this
              //  group (in their initial display positions) and place the
              //  insert initial positions proportionately on the line joining them.

              //  Have a group of inserts that are not all on the right hand end

              ix = (i -1) * 2 ;              // get previous entry of any type
      
              pt1x  =  arOldPt[ix++] ;
              pt1y  =  arOldPt[ix] ;

              ix    = (i + iConsec) * 2 ;
      
              pt2x  =  arOldPt[ix++] ;
              pt2y  =  arOldPt[ix] ;

              xInc  = (pt2x - pt1x) / (iConsec + 1) ;
              yInc  = (pt2y - pt1y) / (iConsec + 1) ;    // (note can be -ve)

              for (ix = 0; ix < iConsec; ix++)
              {
                 if (ix > 0)
                   i++ ;
                 n = i * 2 ;        // get index into old tween points array

                 pt1x += xInc ;
                 pt1y += yInc ;

                 arOldPt[n++] =  pt1x ;
                 arOldPt[n]   =  pt1y ;
              }
           }
           else                              // its a delete
           {                                 // yes, fill-in its final position

              //  Have a group of deletes that are not all on the right hand end

              //  Get the (x,y) coords of the points on either side of this
              //  group (in their final display positions) and place the
              //  deleted initial positions proportionately on the line joing them.

              ix = (i -1) * 2 ;              // get previous entry of any type

              pt1x  =  arNewPt[ix++] ;
              pt1y  =  arNewPt[ix] ;

              ix    = (i + iConsec) * 2 ;

              pt2x  =  arNewPt[ix++] ;
              pt2y  =  arNewPt[ix] ;

              xInc  = (pt2x - pt1x) / (iConsec + 1) ;
              yInc  = (pt2y - pt1y) / (iConsec + 1) ;      // (note can be -ve)

              for (ix = 0; ix < iConsec; ix++)
              {
                 if (ix > 0)
                   i++ ;
                 n = i * 2 ;        // get index into old tween points array

                 pt1x += xInc ;
                 pt1y += yInc ;

                 arNewPt[n++] =  pt1x ;
                 arNewPt[n]   =  pt1y ;
              }
           }
        }
      }      // end loop over arPointType for inserts/deletes


      //  Finally, if this is an area chart or a combo area series, need to 
      //  add the polygon's closing coords to the  starting and ending points.

      var chartType = newChart.getType() ;
      if(this._peer.getSeriesType() === 'area') {
        ixOldPts = aptsOld.length - 4 ;
        ixNewPts = aptsNew.length - 4 ;
        arOldPt.push(aptsOld[ixOldPts]) ;
        arOldPt.push(aptsOld[++ixOldPts]) ;
        arOldPt.push(aptsOld[++ixOldPts]) ;
        arOldPt.push(aptsOld[++ixOldPts]) ;
        arNewPt.push(aptsNew[ixNewPts]) ;
        arNewPt.push(aptsNew[++ixNewPts]) ;
        arNewPt.push(aptsNew[++ixNewPts]) ;
        arNewPt.push(aptsNew[++ixNewPts]) ;
      }

      //  Start and end array generation complete.

      startState  = arOldPt;           // the starting points for animation
      if (arDeletes.length > 0) {      // if there are deletes, save the original end
        this._finalState = endState;   // state so we can reset points after animating.
      }
      endState  = arNewPt;             // the ending points for animation


   } //end if have inserts/deletes


   //  Final processing

   this._setAnimationParams(startState);    // initialize the start state

   //  Create the animator

   var nodePlayable = new DvtCustomAnimation(this._shape.getCtx(), this, this._duration);
   nodePlayable.getAnimator().addProp(DvtAnimator.TYPE_NUMBER_ARRAY, this,
                                      this._getAnimationParams, this._setAnimationParams, endState);
   
   // Post-processing for clean-up of redundant deleted vertices and
   // update direction indicators.

   nodePlayable.setOnEnd(this._onEndAnimation, this);

   handler.add(nodePlayable, 0);            // create the playable
};



/**
 * Function to be added on end of animation to reset the area's points
 */
DvtDCChartLineArea.prototype._onEndAnimation = function(){

   if (this._finalState) {                     // if deletes
     this._shape.setPoints(this._finalState);  // remove redundant delete vertices.
   }
   // Should remove pointers regardless of whether there was a deletion.
   if (this._arPointers !== null){
     var arPointers = this._arPointers;
     var len  = arPointers.length ;
     var plot = this._peer.getChart().getPlotArea() ;
     var ptr ;
     for (var i = 0; i < len; i++){
       ptr = arPointers[i] ;
       if (ptr) {
         plot.removeChild(ptr);
       }
     }
     this._arPointers   = null;
     this._arDirections = null ;
   }
};

/*--------------------------------------------------------------------*/
/*  animateInsert()      override of DvtDCChartAbstract.animateInsert()    */
/*--------------------------------------------------------------------*/
/**
 * Creates the insert animation for this Line or Area.
 * @param {DvtDataAnimationHandler} handler The animation handler, which can be used to chain animations.
 * @return {DvtPlayable} The animation to perform for this insert.
 */
DvtDCChartLineArea.prototype.animateInsert = function(handler)
{
   var nodePlayable = new DvtAnimFadeIn(this._shape.getCtx(), this._shape, this._duration);
 
   handler.add(nodePlayable, 0);
};


/*--------------------------------------------------------------------*/
/*  animateDelete()       override of DvtDCChartAbstract.animateDelete()   */
/*--------------------------------------------------------------------*/
/**
 * Creates the delete animation for this Line or Area
 * @param {DvtDataAnimationHandler} handler The animation handler, which can be used to
 *                                          chain animations.
 * @param {DvtContainer} delContainer   The container to which the deleted objects should
 *                                      be moved for animation.
 * @returns {DvtPlayable} The animation to perform for this delete.
 */
DvtDCChartLineArea.prototype.animateDelete = function(handler, delContainer)
{
   delContainer.addChild(this._shape);   // Move from the old chart to the delete
                                         // container on top of the new chart.

   var nodePlayable = new DvtAnimFadeOut(this._shape.getCtx(), this._shape, this._duration);
   handler.add(nodePlayable, 0);
};



/*--------------------------------------------------------------------*/
/*  _getAnimationParams()                                             */
/*--------------------------------------------------------------------*/
/**
  *   Returns the geometry of the Area.
  *   @returns {Array} an array containing the points of the Area
  */
DvtDCChartLineArea.prototype._getAnimationParams = function()
{
   return this._shape.getPoints();
};



/*---------------------------------------------------------------------*/
/*  Init()                override of DvtDCChartAbstract.Init()             */
/*---------------------------------------------------------------------*/
/**
  *  Object initializer.
  */
DvtDCChartLineArea.prototype.Init = function(peer, duration)
{
  DvtDCChartLineArea.superclass.Init.call(this, peer, duration) ;
  
  //  We ignore the group for a polyline, only interested in seeing if the
  //  series matches. All changes to a line are considered to be an update.

  this._animId = peer.getSeries();
} ;


/*---------------------------------------------------------------------*/
/*   _makeDirPointer                                                   */
/*---------------------------------------------------------------------*/

DvtDCChartLineArea.prototype._makeDirPointer = function(xPos, yPos, oldChart, oldSIdx, oldGIdx,
                                                   newChart, newSIdx, newGIdx, iPT)
{
    var dirptr = null;              // return value

    var bDown  = false;
    var iDirection ;
    var fc ;
    iDirection = DvtDCChartUtils.getDirection(oldChart, oldSIdx, oldGIdx, newChart,
                                         newSIdx, newGIdx) ;
    if (iDirection !== DvtDCChartUtils.DIR_NOCHANGE) {
      bDown = (iDirection == DvtDCChartUtils.DIR_DOWN);
      
      fc = bDown?  DvtChartStyleUtils.getAnimationDownColor(newChart) :
                   DvtChartStyleUtils.getAnimationUpColor(newChart) ;

      var  stroke = this._shape.getStroke() ;
      var  lw = stroke ? stroke.getWidth() : 5 ;

      //  Create a direction pointer object
      dirptr = DvtDCChartUtils.drawDirectionPointer(bDown, xPos, yPos, lw, fc, this._shape.getCtx(), false);
      newChart.getPlotArea().addChild(dirptr);
    }

    this._arPointers[iPT]  = dirptr ;
    this._arDirection[iPT] = bDown;
};


/*--------------------------------------------------------------------*/
/*  _setAnimationParams()                                             */
/*--------------------------------------------------------------------*/
/**
  *   Updates the geometry of the Area.
  *   @param {Array} ar  an array containing the Area's points.
  */
DvtDCChartLineArea.prototype._setAnimationParams = function(ar)
{
    this._shape.setPoints(ar);

    if (this._arPointers !== null) {
                                        // move pointer and keep in the front.
      var ptr ;
      var offset ;
      var plotArea = this._peer.getChart().getPlotArea() ;
      var len = this._arPointers.length ;

      for (var i = 0; i < len; i++) {
         ptr = this._arPointers[i] ;
         if (ptr) {
           plotArea.removeChild(ptr) ;
           offset = this._arDirection ? 12 : -12 ;
           ptr.setTranslateX(ar[i*2]);
           ptr.setTranslateY(ar[i*2 +1] + offset);
           plotArea.addChild(ptr) ;
         }
      } 
    }
};
// Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
/*--------------------------------------------------------------------*/
/*   DvtDCChartMarker           Data change Handler for Markers            */
/*--------------------------------------------------------------------*/

/**
  *  Data change Handler for markers.
  *  @extends DvtDCChartAbstract
  *  @class DvtDCChartMarker  Data change Handler for markers.
  *  @constructor  
  *  @param {DvtChartObjPeer} peer  The chart object peer for the shape to be animated.
  *  @param {Number} duration  The animation duration is seconds.
  *  <p>
  *  @returns {DvtDCChartMarker} A new DvtDCChartMarker object.
  */
var  DvtDCChartMarker = function(peer, duration)
{
   this.Init(peer, duration) ;
};

DvtObj.createSubclass(DvtDCChartMarker, DvtDCChartAbstract, "DvtDCChartMarker");



/*--------------------------------------------------------------------*/
/*  animateUpdate()                                                   */
/*--------------------------------------------------------------------*/
/**
 * Creates the update animation for this marker.
 * @param {DvtDataAnimationHandler} handler The animation handler, which can be
 *                                          used to chain animations.
 * @param {DvtDCChartMarker} oldDC The old node state to animate from.
 */
DvtDCChartMarker.prototype.animateUpdate = function(handler, oldDC)
{
   var oldObj = oldDC._shape;
   var newObj = this._shape;

   // Transform to the old state and animate to the new one
   var endMatrix = newObj.getMatrix();
   var startMatrix = new DvtMatrix();
   startMatrix.translate(-newObj.getX(), -newObj.getY());
   startMatrix.scale(oldObj.getWidth()/newObj.getWidth(), oldObj.getHeight()/newObj.getHeight());
   startMatrix.translate(oldObj.getX(), oldObj.getY());
   
   // If the text's geometry has changed, animate the change.

   if (endMatrix.equals(startMatrix)) {        // if the geometry has not
     return ;                                  // changed, nothing to animate.
   }

   // Create the animator for this node

   var nodePlayable = new DvtCustomAnimation(this._shape.getCtx(), this, this._duration);

   this._shape.setMatrix(startMatrix);    // initialize the start state

   nodePlayable.getAnimator().addProp(DvtAnimator.TYPE_MATRIX, this._shape,
                                      this._shape.getMatrix, this._shape.setMatrix, endMatrix);
                                     
   //  If animation indicators required, and the value changed, add visual effect to marker.

   if (this.isValueChange(oldDC) && (DvtChartStyleUtils.getAnimationIndicators(this._peer.getChart()) !== 'none')) {

     // Create the color changing effect when the marker moves

     var overlay   = oldDC._shape ;
     var chartType = oldDC._peer.getChart().getType() ;
     var fill, fc, fa ;

     if (chartType === 'scatter') {
       fc = "#FFFF2B" ;                     // brighter yellow for smaller objects
       fa = 0.7 ;
     }
     else {
       fc = "#D5D500" ;                     // dimmer yellow and alpha for bigger
       fa = 0.4 ;                           // objects for a less intrusive effect.
     }
     fill   = new DvtSolidFill(fc, fa);
     var alpha  = this._shape.getAlpha() ;  // end marker alpha
     this._shape.setAlpha(0);               // set initial marker to 0

     overlay.setFill(fill);  
     this._peer.getChart().getPlotArea().addChild(overlay);
     
     // Move the overlay
     var overlayEndMatrix = new DvtMatrix();
     overlayEndMatrix.translate(-oldObj.getX(), -oldObj.getY());
     overlayEndMatrix.scale(newObj.getWidth()/oldObj.getWidth(), newObj.getHeight()/oldObj.getHeight());
     overlayEndMatrix.translate(newObj.getX(), newObj.getY());

     //  Fade in new obj
     nodePlayable.getAnimator().addProp(DvtAnimator.TYPE_NUMBER, this._shape,
                                        this._shape.getAlpha, this._shape.setAlpha, alpha);
     //  move overlay (old object)
     nodePlayable.getAnimator().addProp(DvtAnimator.TYPE_MATRIX, overlay,
                                        overlay.getMatrix, overlay.setMatrix, overlayEndMatrix);
     //  fade out overlay
     nodePlayable.getAnimator().addProp(DvtAnimator.TYPE_NUMBER, overlay,
                                        overlay.getAlpha,  overlay.setAlpha, 0);

     this._overlay = overlay ;
     nodePlayable.setOnEnd(this._onEndAnimation, this) ;   // to remove overlay at the end
   }

   handler.add(nodePlayable, 0);
   
};

/*--------------------------------------------------------------------*/
/*  animateInsert()                                                   */
/*--------------------------------------------------------------------*/
/**
 * Creates the insert animation for this marker.
 * @param {DvtDataAnimationHandler} handler The animation handler, which
 *                                          can be used to chain animations.
 * @return {DvtPlayable} The animation to perform for this insert.
 */
DvtDCChartMarker.prototype.animateInsert = function(handler)
{
   var nodePlayable = new DvtAnimFadeIn(this._shape.getCtx(), this._shape, this._duration);
   
   handler.add(nodePlayable, 0);
};


/*--------------------------------------------------------------------*/
/*  animateDelete()                                                   */
/*--------------------------------------------------------------------*/
/**
 * Creates the delete animation for this marker.
 * @param {DvtDataAnimationHandler} handler The animation handler, which can be used to
 *                                          chain animations.
 * @param {DvtContainer} delContainer   The container to which the deleted objects should
 *                                      be moved for animation.
 * @returns {DvtPlayable} The animation to perform for this delete.
 */
DvtDCChartMarker.prototype.animateDelete = function(handler, delContainer)
{
   delContainer.addChild(this._shape);   // Move from the old chart to the delete
                                         // container on top of the new chart.

   var nodePlayable = new DvtAnimFadeOut(this._shape.getCtx(), this._shape, this._duration);
   
   handler.add(nodePlayable, 0);
};



/*--------------------------------------------------------------------*/
/*  isValueChange()                                                   */
/*--------------------------------------------------------------------*/
/**
 * Check if there is data change.
 * @param {DvtDCChartMarker} oldDC    The old node state to animate from.
 * @returns {boolean}  true if node data has changed.
 */
DvtDCChartMarker.prototype.isValueChange = function(oldDC)
{
  var bRet = false ;

  if (oldDC) {

    var oldSIdx  = oldDC._peer.getSeriesIndex();
    var oldGIdx  = oldDC._peer.getGroupIndex();
    var newSIdx  = this._peer.getSeriesIndex();
    var newGIdx  = this._peer.getGroupIndex();
    var oldData  = oldDC._oldChart.getOptions() ;
    var newData  = this._peer.getChart().getOptions() ;

    var oldX  = oldData['series'][oldSIdx]['items'][oldGIdx]['x'] ;
    var oldY  = oldData['series'][oldSIdx]['items'][oldGIdx]['y'] ;
    var oldZ  = oldData['series'][oldSIdx]['items'][oldGIdx]['z'] ;
    var newX  = newData['series'][newSIdx]['items'][newGIdx]['x'] ;
    var newY  = newData['series'][newSIdx]['items'][newGIdx]['y'] ;
    var newZ  = newData['series'][newSIdx]['items'][newGIdx]['z'] ;

    bRet = ((newX !== oldX) || (newY !== oldY) || (newZ !== oldZ)) ;
  }

  return bRet;
};


/**
  *     Remove update animation overlay 
  */

DvtDCChartMarker.prototype._onEndAnimation = function()
{
    if (this._overlay) {
      this._peer.getChart().getPlotArea().removeChild(this._overlay);
      this._overlay = null ;
    }
};

// Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.
/*---------------------------------------------------------------------*/
/*  DvtDCChartUtils()                                                       */
/*---------------------------------------------------------------------*/

// Utilities for AMX Graph data change animations

/**
  *   @constructor
  */
var DvtDCChartUtils = new Object;

DvtObj.createSubclass(DvtDCChartUtils, DvtObj, "DvtDCChartUtils");

DvtDCChartUtils.DIR_UP       = 0;     // pointer directions
DvtDCChartUtils.DIR_DOWN     = 1;
DvtDCChartUtils.DIR_NOCHANGE = 2 ;

DvtDCChartUtils.UPDATE = 0 ;          // vertex
DvtDCChartUtils.DELETE = 1 ;          // action
DvtDCChartUtils.INSERT = 2 ;          // types


/**
 * Returns the direction of data change for use with animation indicators
 * @param {Object} oldChart
 * @param {number} oldSIdx old series index.
 * @param {number} oldGIdx old group index. 
 * @param {DvtChartImpl} new chart.
 * @param {number} newSIdx new series index
 * @param {number} newGIdx new group index
 */
DvtDCChartUtils.getDirection = function(oldChart, oldSIdx, oldGIdx, newChart, newSIdx, newGIdx)
{
   var oldValue = DvtChartDataUtils.getValue(oldChart, oldSIdx, oldGIdx);
   var newValue = DvtChartDataUtils.getValue(newChart, newSIdx, newGIdx);

   return  (newValue > oldValue)?  DvtDCChartUtils.DIR_UP :
                        ((newValue < oldValue)? DvtDCChartUtils.DIR_DOWN : DvtDCChartUtils.DIR_NOCHANGE);
};

/**
  *   Creates a DvtPath object that draws the triangle shape used for animation indicators
  *   @param  {boolean}  bDown  the direction the vertex away from the base of the triangle.
  *   @param  {number}   xPos  the x position of the middle of the base of the triangle.
  *   @param  {number}   yPos  the y position of the middle of the base of the triangle.
  *   @param  {number}   offset
  *   @param  {string}   fc    the fill color/alpha of the pointer.
  *   @returns {DvtContext} context the chart's context.
  */
DvtDCChartUtils.drawDirectionPointer = function(bDown, xPos, yPos, offset, fc, context, isHoriz)
{
  var ptrCmds;

  if(!isHoriz) { // Vertical
    if (bDown) {
      ptrCmds = DvtPathUtils.moveTo(-5, 0) +
                DvtPathUtils.lineTo(5, 0)  +
                DvtPathUtils.lineTo(0, 7)  +
                DvtPathUtils.lineTo(-5, 0);
    }
    else {
      ptrCmds = DvtPathUtils.moveTo(-5, 0) + 
                DvtPathUtils.lineTo(5, 0)  +
                DvtPathUtils.lineTo(0, -7) +
                DvtPathUtils.lineTo(-5, 0);
    }
  }
  else { // Horizontal
    var bLeft = DvtAgent.isRightToLeft(context) ? !bDown : bDown;
    if (bLeft) {
      ptrCmds = DvtPathUtils.moveTo(2, -5) +
                DvtPathUtils.lineTo(2, 5)  +
                DvtPathUtils.lineTo(-5, 0) +
                DvtPathUtils.lineTo(2, -5);
    }
    else {
      ptrCmds = DvtPathUtils.moveTo(-5, -5) +
                DvtPathUtils.lineTo(-5, 5)  +
                DvtPathUtils.lineTo(2, 0) +
                DvtPathUtils.lineTo(-5, -5);
    }
  }
 
  ptrCmds += DvtPathUtils.closePath();
    
  var ptr   = new DvtPath(context, ptrCmds);
  var fill  = new DvtSolidFill(fc);
  ptr.setFill(fill);

  var ptrOffset = offset + 12;
  yPos += (bDown? ptrOffset : (-ptrOffset)) ;

  ptr.setTranslate(xPos, yPos);
  return ptr ;
};


/**
  *  Helper function for determining which groups were inserted into the
  *  new chart, or deleted from the old chart, or exist in both charts
  *  (potential updates).
  *  @param {Array} oldList  array of groups in the old chart
  *  @param {Array} newList  array of groups in the new chart
  *  @returns {Array} an array of arrays.  array[0] is an array of updated
  *                   objects, ar[1] is an array of inserted objects, and
  *                   ar[2] is an array of deleted objects.
  */
DvtDCChartUtils.compareGroups = function(oldList, newList, isLA)
{
  var updates = [];       // )  return
  var inserts = [];       // )  values
  var deletes = [];       // )
  var oldLen  = oldList.length ; 

  newList = newList.slice(0);      // Copy the new objects list, since we will modify it

  if (oldList) {
    for (var oldIndex = 0; oldIndex < oldLen; oldIndex++) {
       var oldItem = oldList[oldIndex];
    
       // Loop through the new list looking for a match
       var bMatchFound = false;
       for (var newIndex = 0; newIndex < newList.length; newIndex++) {
          var newItem = newList[newIndex];
      
          if (oldItem === newItem) {
            // Match found, remove the item from the new list since it's handled
            newList.splice(newIndex, 1);
            if (isLA) // if Line or Area, need to keep groups in order
              inserts = inserts.concat(newList.splice(0, newIndex)); // anything before the match is an insert
            bMatchFound = true;
            updates.push(oldItem);
            break;
          }
       }
    
      // If no match found, it was a delete.
      if (! bMatchFound) {
        deletes.push(oldItem);
      }
    }
  }

  // All remaining objects in newList are inserts

  for (var i = 0; i < newList.length; i++) {
     if (newList[i])                        // must be valid object for insert
       inserts.push(newList[i]);
  }
    
  return [updates, inserts, deletes];
};

/**
 * Creates and returns a DvtPath centered at (0,0) for the animation indicator.
 * @param {DvtContext} context
 * @param {boolean} bDown True if the indicator represents a decrease in value.
 * @param {boolean} bHoriz True if the y axis is horizontal.
 * @param {string} fc The fill color of the indicator
 * @return {DvtPath}
 */
DvtDCChartUtils.drawBarPointer = function(context, bDown, bHoriz, fc)
{
  // TODO: This function will be combined with drawDirectionPointer and removed in the near future.
  var ptrCmds;
  if(bHoriz) {
    var bLeft = DvtAgent.isRightToLeft(context) ? !bDown : bDown;
    ptrCmds = bLeft ? "M3.5,-5L3.5,5L-3.5,0L3.5,-5" : "M-3.5,-5L-3.5,5L3.5,0L-3.5,-5";
  }
  else  // Vertical
    ptrCmds = bDown ? "M-5,-3.5L5,-3.5L0,3.5L-5,-3.5Z" : "M-5,3.5L5,3.5L0,-3.5L-5,3.5Z";
    
  var ret = new DvtPath(context, ptrCmds);
  ret.setSolidFill(fc);
  return ret ;
}
// Copyright (c) 2013, Oracle and/or its affiliates. All rights reserved.

/**
 *  Data change Handler for DvtFunnelSlice (implements DvtDCChartAbstract).
 *  @extends DvtDCChartAbstract
 *  @class DvtDCFunnelSlice  Data change Handler for Funnel Slices.
 *  @constructor
 *  @param {DvtChartObjPeer} peer  The chart object peer for the shape to be animated.
 *  @param {Number} duration  the animation duration is seconds.
 *  @returns {DvtDCFunnelSlice} A new DvtDCFunnelSlice object.
 */
var DvtDCFunnelSlice = function (peer, duration) {
  this.Init(peer, duration);
};

DvtObj.createSubclass(DvtDCFunnelSlice, DvtDCChartAbstract, "DvtDCFunnelSlice");

/**
 * Creates the update animation for this Funnel Slice.
 * @param {DvtDataAnimationHandler} handler The animation handler, which can
 *                                          be used to chain animations.
 * @param {DvtDCFunnelSlice} oldDC The old node state to animate from.
 */
DvtDCFunnelSlice.prototype.animateUpdate = function (handler, oldDC) {
  var obj = this._shape;
  
  var startState = oldDC._shape.getAnimationParams();
  var endState = obj.getAnimationParams();
  
  if (DvtArrayUtils.equals(startState, endState)) // if no change,
    return; // nothing to animate.
  
  // Create the animator for this slice update
  obj.setAnimationParams(startState); // initialize the start state
  var nodePlayable = new DvtCustomAnimation(obj.getCtx(), this, this._duration);
  nodePlayable.getAnimator().addProp(DvtAnimator.TYPE_NUMBER_ARRAY, obj, obj.getAnimationParams, obj.setAnimationParams, endState);
  if (this._indicator) {
    nodePlayable.setOnEnd(this._onEndAnimation, this);
  }

  handler.add(nodePlayable, 0); // create the playable
};

/**
 * Creates the insert animation for this Funnel Slice.
 * @param {DvtDataAnimationHandler} handler The animation handler, which
 * can be used to chain animations.
 * @return {DvtPlayable} The animation to perform for this insert.
 */
DvtDCFunnelSlice.prototype.animateInsert = function (handler) {
  var obj = this._shape;

  var endState = obj.getAnimationParams();
  var startState = endState.slice(0);
  startState[0] += startState[1] / 2;
  startState[1] = 0;
  startState[3] = 0; // start alpha

  obj.setAnimationParams(startState);// set the start state
  var nodePlayable = new DvtCustomAnimation(obj.getCtx(), this, this._duration);
  nodePlayable.getAnimator().addProp(DvtAnimator.TYPE_NUMBER_ARRAY, obj, obj.getAnimationParams, obj.setAnimationParams, endState);

  handler.add(nodePlayable, 0); // create the playable
};

/**
 * Creates the delete animation for this Funnel Slice.
 * @param {DvtDataAnimationHandler} handler The animation handler, which can be used to
 *                                          chain animations.
 * @param {DvtContainer} delContainer   The container to which the deleted objects should
 *                                      be moved for animation.
 * @returns {DvtPlayable} The animation to perform for this delete.
 */
DvtDCFunnelSlice.prototype.animateDelete = function (handler, delContainer) {
  var obj = this._shape;

  delContainer.addChild(obj); // move from existing container to the delete container on top of the new chart.

  var startState = obj.getAnimationParams();
  var endState = startState.slice(0);;

  endState[0] += startState[1] / 2;
  endState[1] = 0;
  endState[3] = 0; // end alpha
  
  var nodePlayable = new DvtCustomAnimation(obj.getCtx(), this, this._duration);
  nodePlayable.getAnimator().addProp(DvtAnimator.TYPE_NUMBER_ARRAY, obj, obj.getAnimationParams, obj.setAnimationParams, endState);

  handler.add(nodePlayable, 0); // create the playable
};
// Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.

/**
 * Chart component.  This chart should never be instantiated directly.  Use the
 * newInstance function instead.
 * @class
 * @constructor
 * @extends {DvtBaseComponent}
 * @export
 */
var DvtChart = function() {}

DvtObj.createSubclass(DvtChart, DvtBaseComponent, "DvtChart");

/**
 * Returns a new instance of DvtChart.
 * @param {DvtContext} context The rendering context.
 * @param {string} callback The function that should be called to dispatch component events.
 * @param {object} callbackObj The optional object instance on which the callback function is defined.
 * @return {DvtChart}
 * @export
 */
DvtChart.newInstance = function(context, callback, callbackObj) {
  return new DvtChartImpl(context, callback, callbackObj);
}

/**
 * Returns a copy of the default options for the specified skin.
 * @param {string} skin The skin whose defaults are being returned.
 * @return {object} The object containing defaults for this component.
 * @export
 */
DvtChart.getDefaults = function(skin) 
{  
  return (new DvtChartDefaults()).getDefaults(skin);
}

/**
 * @override
 */
DvtChart.prototype.Init = function(context, callback, callbackObj) {
  DvtChart.superclass.Init.call(this, context, callback, callbackObj);
  
  // Create the resource bundle
  this.Bundle = new DvtChartBundle();
  
  // Create the defaults object
  this.Defaults = new DvtChartDefaults();
  
  // Create the event handler and add event listeners
  this.EventManager = new DvtChartEventManager(this);
  this.EventManager.addListeners(this);
  
  // Set up keyboard handler on non-touch devices
  if (!DvtAgent.isTouchDevice())
    this.EventManager.setKeyboardHandler(this.CreateKeyboardHandler(this.EventManager));
  
  // Make sure the object has an id for clipRect naming
  this.setId("chart" + 1000 + Math.floor(Math.random()*1000000000));
    
  /** 
   * Reference to animation in progress.
   * @private 
   */
  this._animation = null;
}

/**
 * @override
 */
DvtChart.prototype.SetOptions = function(options) {
  if(options) {
    // Combine the user options with the defaults and store
    this.Options = this.Defaults.calcOptions(options);
    
    // Process the data to add bulletproofing
    DvtChartDataUtils.processDataObject(this);
    
    if(DvtChartEventUtils.getHoverBehavior(this) == "dim")
      this.EventManager.setSeriesRolloverHandler(new DvtChartSeriesRolloverHandler(this, this.EventManager));
    else
      this.EventManager.setSeriesRolloverHandler(null);
  
    // Disable animation for canvas and xml
    if (!DvtAgent.isEnvironmentBrowser()) {
      this.Options['animationOnDisplay']    = 'none' ;  
      this.Options['animationOnDataChange'] = 'none' ;  
    }
  }
  else if(!this.Options) // No object has ever been provided, copy the defaults
    this.Options = this.GetDefaults();
}

/**
 * @override
 * @export
 */
DvtChart.prototype.render = function(options, width, height) 
{  
  //  If datachange animation, save chart info before rendering for later use.
  var animationOnDataChange = DvtChartStyleUtils.getAnimationOnDataChange(this);
  var oldChart              = null;

  if (this.Options && animationOnDataChange !== 'none') {
    oldChart  = {'type':  this.getType(),
                 'options':  this.Options, 
                 'peers': this.getObjects().slice(0),
                 'getOptions': function() {return this.options;},
                 'pieChart': this.pieChart};

    // Also expose getOptions directly, since it will be called by internal code that is renamed.
    oldChart.getOptions = oldChart['getOptions'];
  }
                 
  // Cleanup objects from the previous render
  this.__cleanUp() ;       
  
  // Update if a new options object has been provided or initialize with defaults if needed.
  this.SetOptions(options);
  
  // Update the width and height if provided
  if(!isNaN(width) && !isNaN(height)) {
    this.Width = width;
    this.Height = height;
  }
  
  if (DvtAgent.isTouchDevice()) {
     this.EventManager.setTouchRegionBounds(new DvtRectangle(0,0,parseInt(width),parseInt(height)));
  }
  
  // Create a new container and render the component into it
  var container = new DvtContainer(this.getCtx());
  this.addChild(container);
  DvtChartRenderer.render(this, container, new DvtRectangle(0, 0, this.Width, this.Height));
  
  // Animation Support
  // Stop any animation in progress
  if(this._animation) {
    this._animationStopped = true;  // TODO Rename
    this._animation.stop();
  }
  
  // Construct the new animation playable
  var animationOnDisplay      = DvtChartStyleUtils.getAnimationOnDisplay(this);
  var animationDuration       = DvtChartStyleUtils.getAnimationDuration(this);
  var bounds                  = new DvtRectangle(0, 0, this.Width, this.Height);
  var bBlackBoxUpdate         = false; // true if this is a black box update animation

  if (! this._container) {
     if (animationOnDisplay !== "none") {
       // AnimationOnDisplay
       this._animation = DvtBlackBoxAnimationHandler.getInAnimation(this.getCtx(), animationOnDisplay, container,
                                                                  bounds, animationDuration); 
       if (! this._animation) {
         this._animation = DvtAnimOnDisplay.createAnimation(this, animationOnDisplay, animationDuration) ;
       }
     }
  }
  else if (animationOnDataChange != "none" && options) {
    // AnimationOnDataChange
    this._animation = DvtBlackBoxAnimationHandler.getCombinedAnimation(this.getCtx(), animationOnDataChange, this._container, 
                                                                       container, bounds, animationDuration);   
    if (this._animation)           // Black Box Animation
      bBlackBoxUpdate = true;
    else {
      this._delContainer = new DvtContainer(this.getCtx(), 'DelTainer') ;
      this._animation    = DvtAnimOnDC.createAnimation(oldChart, this, animationOnDataChange,
                                                       animationDuration, this._delContainer) ;
      if (this._delContainer.getNumChildren() > 0) {
        if (DvtChartTypeUtils.isFunnel(this)){ // adding it to the funnel container so it could be rotated.
          this.getFunnelContainer().addChild(this._delContainer);
        }
        else
          this.getPlotArea().addChild(this._delContainer);
      }
    }
  }
  
  // If an animation was created, play it
  if(this._animation) {  
    this._animation.play();  
    this._animation.setOnEnd(this._onAnimationEnd, this);
  }
  
  // Clean up the old container.  If doing black box animation, store a pointer and clean
  // up after animation is complete.  Otherwise, remove immediately.
  if(bBlackBoxUpdate) {
    this._oldContainer = this._container;
  }
  else if(this._container) { 
    this.removeChild(this._container);  // Not black box animation, so clean up the old contents
  }
  
  // Update the pointer to the new container
  this._container = container;
  
  // Data Cursor
  if(this.__isDataCursorEnabled()) {
    if(DvtChartTypeUtils.isHorizontal(this))
      this.DataCursor = new DvtDataCursor(this.getCtx(), true);
    else
      this.DataCursor = new DvtDataCursor(this.getCtx(), false);

    // Find the data cursor behavior to use
    var dataCursorBehavior = this.Options['dataCursorBehavior'];
    if(dataCursorBehavior == 'auto')
      dataCursorBehavior = (DvtChartTypeUtils.isLine(this) || DvtChartTypeUtils.isArea(this)) ? 'smooth' : 'snap';
    
    // Set the dataCursorBehavior on the data cursor
    if(dataCursorBehavior == 'snap')
      this.DataCursor.setBehavior(DvtDataCursor.BEHAVIOR_SNAP);
    else if(dataCursorBehavior == 'smooth')
      this.DataCursor.setBehavior(DvtDataCursor.BEHAVIOR_SMOOTH);
     
    this.addChild(this.DataCursor);
    this.EventManager.setDataCursorHandler(new DvtChartDCEH(this));
  }
  else
    this.EventManager.setDataCursorHandler(null);
}

/**
 * Performs cleanup of the previously rendered content.  Note that this doesn't cleanup anything needed for animation.
 * @protected
 */
DvtChart.prototype.__cleanUp = function() {
  // Data cursor cleanup
  if(this.DataCursor) {
    this.removeChild(this.DataCursor);
    this.DataCursor = null;
  }
  
  // Tooltip cleanup
  this.EventManager.hideHoverFeedback();
};

DvtChart.prototype.__isDataCursorEnabled = function() {

  if (DvtChartTypeUtils.isPie(this) || DvtChartTypeUtils.isFunnel(this) || DvtChartTypeUtils.isPolar(this))
    return false;

  if (this.Options['dataCursor'] === 'on') {
    return true;
  }
  else if (this.Options['dataCursor'] === 'auto') {
    if (DvtAgent.isTouchDevice() && (DvtChartTypeUtils.isLine(this) || DvtChartTypeUtils.isArea(this)))
      return true;
  }
  return false;
}

/**
 * Hook for cleaning up animation behavior at the end of the animation.
 * @private
 */
DvtChart.prototype._onAnimationEnd = function() {
  // Clean up the old container used by black box updates
  if(this._oldContainer) {
    this.removeChild(this._oldContainer);
    this._oldContainer = null;
  }

  if (this._delContainer && this._delContainer.getNumChildren() > 0) {
    if (DvtChartTypeUtils.isFunnel(this)){
      this.getFunnelContainer().removeChild(this._delContainer);
    }
    else
      this.getPlotArea().removeChild(this._delContainer) ;
  }
  this._delContainer = null ;

  // Reset the animation flag and reference
  this._animationStopped = false;
  this._animation = null;
}

/**
 * @override
 */
DvtChart.prototype.CreateKeyboardHandler = function (manager) {
  return new DvtChartKeyboardHandler(manager, this);
}
/**
 * Chart Constants
 * @class
 * @export
 */
var DvtChartConstants = {};

DvtObj.createSubclass(DvtChartConstants, DvtObj, "DvtChartConstants");

/**
 * @const
 * @export
 */
DvtChartConstants.BACKGROUND = "background";

/**
 * @const
 * @export
 */
DvtChartConstants.DATA_ITEM = "dataItem";

/**
 * @const
 * @export
 */
DvtChartConstants.DATA_ITEM_OTHER = "dataItemOther";

/**
 * @const
 * @export
 */
DvtChartConstants.FOOTNOTE = "footnote";

/**
 * @const
 * @export
 */
DvtChartConstants.LEGEND = "legend";

/**
 * @const
 * @export
 */
DvtChartConstants.LEGEND_ITEM = "legendItem";

/**
 * @const
 * @export
 */
DvtChartConstants.LEGEND_TITLE = "legendTitle";

/**
 * @const
 * @export
 */
DvtChartConstants.PLOT_AREA = "plotArea";

/**
 * @const
 * @export
 */
DvtChartConstants.SERIES = "series";

/**
 * @const
 * @export
 */
DvtChartConstants.SUBTITLE = "subtitle";

/**
 * @const
 * @export
 */
DvtChartConstants.TITLE = "title";

/**
 * @const
 * @export
 */
DvtChartConstants.X_AXIS_LABEL = "xAxisLabel";

/**
 * @const
 * @export
 */
DvtChartConstants.X_AXIS_TITLE = "xAxisTitle";

/**
 * @const
 * @export
 */
DvtChartConstants.Y_AXIS_LABEL = "yAxisLabel";

/**
 * @const
 * @export
 */
DvtChartConstants.Y_AXIS_TITLE = "yAxisTitle";

/**
 * @const
 * @export
 */
DvtChartConstants.Y2_AXIS_LABEL = "y2AxisLabel";

/**
 * @const
 * @export
 */
DvtChartConstants.Y2_AXIS_TITLE = "y2AxisTitle";
/**
 * Chart selection event.
 * @param {array} selection The array of currently selected ids for the component.
 * @param {number} [xMin] The xMin of the marquee bounds (only applies to marquee selection).
 * @param {number} [xMax] The xMax of the marquee bounds (only applies to marquee selection).
 * @param {string} [startGroup] The first group that is included in the bounds (only applies to marquee selection).
 * @param {string} [endGroup] The last group that is included in the bounds (only applies to marquee selection).
 * @param {number} [yMin] The yMin of the marquee bounds (only applies to marquee selection).
 * @param {number} [yMax] The yMax of the marquee bounds (only applies to marquee selection).
 * @param {number} [y2Min] The y2Min of the marquee bounds (only applies to marquee selection).
 * @param {number} [y2Max] The y2Max of the marquee bounds (only applies to marquee selection).
 * @class
 * @constructor
 * @export
 */
var DvtChartSelectionEvent = function(selection, xMin, xMax, startGroup, endGroup, yMin, yMax, y2Min, y2Max) {
  DvtChartSelectionEvent.superclass.Init.call(this, selection) ;
  this._xMin = xMin;
  this._xMax = xMax;
  this._startGroup = startGroup;
  this._endGroup = endGroup;
  this._yMin = yMin;
  this._yMax = yMax;
  this._y2Min = y2Min;
  this._y2Max = y2Max;
  this.addedSet = null;
  this.removedSet = null;
}

DvtObj.createSubclass(DvtChartSelectionEvent, DvtSelectionEvent, "DvtChartSelectionEvent");

/**
 * Returns the xMin of the marquee selection bounds.
 * @return {number} xMin.
 * @export
 */
DvtChartSelectionEvent.prototype.getXMin = function() {
  return this._xMin;
}

/**
 * Returns the xMax of the marquee selection bounds.
 * @return {number} xMax.
 * @export
 */
DvtChartSelectionEvent.prototype.getXMax = function() {
  return this._xMax;
}

/**
 * Returns the startGroup of the marquee selection bounds.
 * @return {string} startGroup.
 * @export
 */
DvtChartSelectionEvent.prototype.getStartGroup = function() {
  return this._startGroup;
}

/**
 * Returns the endGroup of the marquee selection bounds.
 * @return {string} endGroup.
 * @export
 */
DvtChartSelectionEvent.prototype.getEndGroup = function() {
  return this._endGroup;
}

/**
 * Returns the yMin of the marquee selection bounds.
 * @return {number} yMin.
 * @export
 */
DvtChartSelectionEvent.prototype.getYMin = function() {
  return this._yMin;
}

/**
 * Returns the yMax of the marquee selection bounds.
 * @return {number} yMax.
 * @export
 */
DvtChartSelectionEvent.prototype.getYMax = function() {
  return this._yMax;
}

/**
 * Returns the y2Min of the marquee selection bounds.
 * @return {number} y2Min.
 * @export
 */
DvtChartSelectionEvent.prototype.getY2Min = function() {
  return this._y2Min;
}

/**
 * Returns the y2Max of the marquee selection bounds.
 * @return {number} y2Max.
 * @export
 */
DvtChartSelectionEvent.prototype.getY2Max = function() {
  return this._y2Max;
}
/**
 * Chart viewport change event.
 * @param {number} [xMin] The xMin of the viewport.
 * @param {number} [xMax] The xMax of the viewport.
 * @param {string} [startGroup] The first group that is included in the viewport.
 * @param {string} [endGroup] The last group that is included in the viewport.
 * @param {number} [yMin] The yMin of the viewport.
 * @param {number} [yMax] The yMax of the viewport.
 * @class
 * @constructor
 * @export
 */
var DvtChartViewportChangeEvent = function(xMin, xMax, startGroup, endGroup, yMin, yMax) {
  DvtChartViewportChangeEvent.superclass.Init.call(this, DvtChartViewportChangeEvent.TYPE) ;
  this._xMin = xMin;
  this._xMax = xMax;
  this._startGroup = startGroup;
  this._endGroup = endGroup;
  this._yMin = yMin;
  this._yMax = yMax;
}

DvtObj.createSubclass(DvtChartViewportChangeEvent, DvtBaseComponentEvent, "DvtChartViewportChangeEvent");

/**
 * @export
 */
DvtChartViewportChangeEvent.TYPE = "viewportChange";

/**
 * Returns the xMin of the viewport.
 * @return {number} xMin.
 * @export
 */
DvtChartViewportChangeEvent.prototype.getXMin = function() {
  return this._xMin;
}

/**
 * Returns the xMax of the viewport.
 * @return {number} xMax.
 * @export
 */
DvtChartViewportChangeEvent.prototype.getXMax = function() {
  return this._xMax;
}

/**
 * Returns the startGroup of the viewport.
 * @return {string} startGroup.
 * @export
 */
DvtChartViewportChangeEvent.prototype.getStartGroup = function() {
  return this._startGroup;
}

/**
 * Returns the endGroup of the viewport.
 * @return {string} endGroup.
 * @export
 */
DvtChartViewportChangeEvent.prototype.getEndGroup = function() {
  return this._endGroup;
}

/**
 * Returns the yMin of the viewport.
 * @return {number} yMin.
 * @export
 */
DvtChartViewportChangeEvent.prototype.getYMin = function() {
  return this._yMin;
}

/**
 * Returns the yMax of the viewport.
 * @return {number} yMax.
 * @export
 */
DvtChartViewportChangeEvent.prototype.getYMax = function() {
  return this._yMax;
}
/**
 * Implementation of DvtChart.  This chart defines the internal APIs of DvtChart that are
 * needed for rendering and interactivity.
 * @param {DvtContext} context The rendering context.
 * @param {string} callback The function that should be called to dispatch component events.
 * @param {object} callbackObj The optional object instance on which the callback function is defined.
 * @class
 * @constructor
 * @extends {DvtChart}
 */
var DvtChartImpl = function(context, callback, callbackObj) {
  this.Init(context, callback, callbackObj);
}

DvtObj.createSubclass(DvtChartImpl, DvtChart, "DvtChartImpl");

/**
 * @override
 */
DvtChartImpl.prototype.Init = function(context, callback, callbackObj) {
  DvtChartImpl.superclass.Init.call(this, context, callback, callbackObj);
  
  /**
   * The legend of the chart.  This will be set during render time.
   * @type {DvtLegend}
   */
  this.legend = null;
  /**
   * The x axis of the chart.  This will be set during render time.
   * @type {DvtChartAxis}
   */
  this.xAxis = null;
  /**
   * The y axis of the chart.  This will be set during render time.
   * @type {DvtChartAxis}
   */
  this.yAxis = null;
  /**
   * The y2 axis of the chart.  This will be set during render time for dual-y graphs.
   * @type {DvtChartAxis}
   */
  this.y2Axis = null;
  /**
   * The overview scrollbar of the chart.  This will be set during render time.
   * @type {DvtChartOverview}
   */
  this.overview = null;
  /**
   * The x-axis simple scrollbar of the chart.  This will be set during render time.
   * @type {DvtSimpleScrollbar}
   */
  this.xScrollbar = null;
  /**
   * The y-axis simple scrollbar of the chart.  This will be set during render time.
   * @type {DvtSimpleScrollbar}
   */
  this.yScrollbar = null;
  /**
   * The drag mode buttons of the chart.  This will be set during render time.
   * @type {DvtContainer}
   */
  this.dragButtons = null;
  /**
   * The pie chart subcomponent.  This will be set during render time for pie graphs.
   * @type {DvtPieChart}
   */
  this.pieChart = null;
  /** 
   * The array of logical objects for this chart.
   * @private 
   */
  this._peers = [];
  
  /** @private */
  this._seriesStyleArray = [];
  
  // Support for changing z-order for selection
  this._numFrontObjs = 0;
  this._numSelectedObjsInFront = 0;
}

/**
 * @override
 */
DvtChartImpl.prototype.SetOptions = function(options) {
  DvtChartImpl.superclass.SetOptions.call(this, options);

  // Initialize the selection handler
  var selectionMode = this.Options['selection'];
  if(selectionMode == "single")
    this._selectionHandler = new DvtSelectionHandler(DvtSelectionHandler.TYPE_SINGLE);
  else if(selectionMode == "multiple")
    this._selectionHandler = new DvtSelectionHandler(DvtSelectionHandler.TYPE_MULTIPLE);
  else
    this._selectionHandler = null;
  
  // Pass to event handler
  this.EventManager.setSelectionHandler(this._selectionHandler);
  
  // Popup Support
  var popupBehaviors = this.Options['_spb'];
  if(popupBehaviors) {
    this._popupBehaviors = {};
    
    // Iterate through the popup behaviors for each parent stamp id
    for(var stampId in popupBehaviors) {
      var popupBehaviorArray = popupBehaviors[stampId];
      for(var i=0; i<popupBehaviorArray.length; i++) {
        // Create the array of behaviors for this stampId
        if(!this._popupBehaviors[stampId])
          this._popupBehaviors[stampId] = [];
        
        var popupBehavior = popupBehaviorArray[i];
        var popupId = popupBehavior['popupId'];
        var triggerType = popupBehavior['triggerType'];
        var alignId = popupBehavior['alignId'];
        var align = popupBehavior['align'];
        this._popupBehaviors[stampId].push(new DvtShowPopupBehavior(popupId, triggerType, alignId, align));
      }
    }
  }
}

/**
 * Filters or removes the filter from the specified category.
 * @param {string} category The category which has been filtered out.
 * @param {string} type "out" to filter out the specified category, or "in" to remove the filter.
 * @export
 */
DvtChart.prototype.filter = function(category, type) {
  // Update the component state
  var visibility = (type == "out" ? "hidden" : "visible");
  DvtChartEventUtils.setVisibility(this, category, visibility);

  // Rerender the component
  this.render();
}

/**
 * Highlights the specified categories.
 * @param {array} categories The array of categories whose data items will be highlighted. If null or empty, all 
 *                           highlighting will be removed.
 * @export
 */
DvtChart.prototype.highlight = function(categories) {
  DvtCategoryRolloverHandler.highlight(categories, this.getObjects());

  if(this.legend) 
    this.legend.highlight(categories);
    
  if(this.pieChart)
    this.pieChart.highlight(categories);
}

/**
 * Returns the DvtEventManager for this component.
 * @return {DvtEventManager}
 */
DvtChartImpl.prototype.getEventManager = function() {
  return this.EventManager;
}

/**
 * Processes the specified event.
 * @param {object} event
 * @param {object} source The component that is the source of the event, if available.
 */
DvtChartImpl.prototype.processEvent = function(event, source) {
  var type = event.getType();
  if (type == DvtCategoryHideShowEvent.TYPE_HIDE || type == DvtCategoryHideShowEvent.TYPE_SHOW) 
    this.filter(event.getCategory(), (type == DvtCategoryHideShowEvent.TYPE_HIDE ? "out" : "in"));
  
  else if (type == DvtCategoryRolloverEvent.TYPE_OVER || type == DvtCategoryRolloverEvent.TYPE_OUT) {
    if (DvtChartEventUtils.getHoverBehavior(this) == "dim") {
      DvtCategoryRolloverHandler.processEvent(event, this.getObjects());
      this._distributeToChildren(event, source); 
    }
  }
  
  else if (type == DvtSelectionEvent.TYPE)
    event = this._processSelectionEvent(event);
  
  else if (type == DvtPanZoomEvent.TYPE)
    event = this._processPanZoomEvent(event);
  
  else if (type == DvtMarqueeEvent.TYPE)
    event = this._processMarqueeEvent(event);
  
  else if (type == DvtOverviewEvent.TYPE)
    event = this._processOverviewEvent(event, source);

  else if (type == DvtShowPopupEvent.TYPE)	
    event = this._processShowPopupEvent(event);
  
  else if(event instanceof DvtComponentUIEvent)
    event = this._processComponentUIEvent(event, source);
    
  // For selection events, update the options object and calculate the added/removed arrays
  if(event instanceof DvtChartSelectionEvent) {
    // TODO hzhang: The calculation of added/removedSet should ideally happen in the selectionHandler, but the code there
    // was changed such that it doesn't fire the selection event directly anymore.
    var options = this.getOptions();
    var oldItems = options['selectedItems'];
    var newItems = DvtChartDataUtils.getCurrentSelection(this);
    options['selectedItems'] = newItems;
    
    // Ensure old and new items are not null
    oldItems = oldItems ? oldItems : [];
    newItems = newItems ? newItems : [];
    
    // Calculate the old and set selection id sets
    var oldIndex, newIndex;
        
    var oldSet = {};
    for(oldIndex = 0; oldIndex < oldItems.length; oldIndex++) {
      oldSet[oldItems[oldIndex]['id']] = true;
    }
    
    var newSet = {};
    for(newIndex = 0; newIndex < newItems.length; newIndex++) {
      newSet[newItems[newIndex]['id']] = true;
    }
    
    // Calculate the added and remove sets using the old and new
    var addedSet = {};
    for(newIndex = 0; newIndex < newItems.length; newIndex++) {
      var newItemId = newItems[newIndex]['id'];
      if(!oldSet[newItemId])
        addedSet[newItemId] = true;
    }
    
    var removedSet = {};
    for(oldIndex = 0; oldIndex < oldItems.length; oldIndex++) {
      var oldItemId = oldItems[oldIndex]['id'];
      if(!newSet[oldItemId])
        removedSet[oldItemId] = true;
    }
    
    // Finally add to the selection event
    event['addedSet'] = addedSet;
    event['removedSet'] = removedSet;
  }
  
  // Dispatch the event to the callback
  if (event)
    this.__dispatchEvent(event);
};

/**
 * Processes selection event.
 * @param {DvtSelectionEvent} event Selection event.
 * @return {object} Processed event.
 * @private
 */
DvtChartImpl.prototype._processSelectionEvent = function(event) {
  var selection = DvtChartEventUtils.processIds(this, event.getSelection());
  
  // Update the selection in the overview bg chart
  if (this.overview) {
    var ovChart = this.overview.getBackgroundChart();
    ovChart.getSelectionHandler().processInitialSelections(selection, ovChart.getObjects());
  }  
  
  return new DvtChartSelectionEvent(selection);
}

/**
 * Processes pan/zoom event.
 * @param {DvtPanZoomEvent} event Pan/zoom event.
 * @return {object} Processed event.
 * @private
 */
DvtChartImpl.prototype._processPanZoomEvent = function(event) {
  var subtype = event.getSubtype();
  var actionDone = subtype == DvtPanZoomEvent.SUBTYPE_PAN_END || subtype == DvtPanZoomEvent.SUBTYPE_ZOOM || subtype == DvtPanZoomEvent.SUBTYPE_PINCH_END;
  var actionStart = subtype == DvtPanZoomEvent.SUBTYPE_PAN_START || subtype == DvtPanZoomEvent.SUBTYPE_PINCH_START;
  
  // The initial touch target has to be kept so that the subsequent touch move events are fired
  if (DvtAgent.isTouchDevice() && actionStart && this._panZoomTarget != this._plotArea) {
    this._container.removeChild(this._panZoomTarget);
    this._panZoomTarget = this._plotArea;
  }
  
  // Calculate the bounds and update the viewport
  var bounds;
  if (DvtChartEventUtils.isLiveScroll(this)) { // live
    bounds = DvtChartEventUtils.getAxisBoundsByDelta(this, event.dxMin, event.dxMax, event.dyMin, event.dyMax);
    if (!actionStart) {
      this.setViewport(bounds, actionDone);
      this.setScrollbarViewport(bounds);
    }
  }
  else { // delayed
    bounds = DvtChartEventUtils.getAxisBoundsByDelta(this, event.dxMinTotal, event.dxMaxTotal, event.dyMinTotal, event.dyMaxTotal);
    this.setScrollbarViewport(bounds); // always update the scrollbars
    if (actionDone)
      this.setViewport(bounds, actionDone);
  }
  
  if (actionDone) {
    // Event handlers have to be reset because the plot area space may change
    DvtChartRenderer._setEventHandlers(this);
    
    // Clear the touch target, if there's one
    if (this._panZoomTarget != this._plotArea) {
      this._container.removeChild(this._panZoomTarget);
      this._panZoomTarget = null;
    }
    
    // Fire viewport change event  
    if (DvtChartTypeUtils.isBLAC(this))
      return new DvtChartViewportChangeEvent(bounds.xMin, bounds.xMax, bounds.startGroup, bounds.endGroup, null, null);
    else
      return new DvtChartViewportChangeEvent(bounds.xMin, bounds.xMax, null, null, bounds.yMin, bounds.yMax);
  }
  else
    return null;
}

/**
 * Processes marquee event.
 * @param {DvtMarqueeEvent} event Marquee event.
 * @return {object} Processed event.
 * @private
 */
DvtChartImpl.prototype._processMarqueeEvent = function(event) {
  var subtype = event.getSubtype();
  var em = this.EventManager;
  var bounds; // chart bounds
  DvtChartEventUtils.adjustBounds(event);
  
  // Marquee selection
  if (em.getDragMode() == DvtChartEventManager.DRAG_MODE_SELECT) {
    var selectionHandler = em.getSelectionHandler();
    
    if (subtype == DvtMarqueeEvent.SUBTYPE_START) {
      // If ctrl key is pressed at start of drag, the previous selection should be preserved.
      this._initSelection = event.ctrlKey ? selectionHandler.getSelectedIds() : [];
    } else {
      var targets = DvtChartEventUtils.getBoundedObjects(this, event);
      selectionHandler.processInitialSelections(this._initSelection, this.getObjects());
      selectionHandler.processGroupSelection(targets, true);
    }
    
    // Fire selection event only at the end of marquee
    if (subtype == DvtMarqueeEvent.SUBTYPE_END) {
      var selection = selectionHandler.getSelectedIds();
      
      // Update the selection in the overview bg chart
      if (this.overview) {
        var ovChart = this.overview.getBackgroundChart();
        ovChart.getSelectionHandler().processInitialSelections(selection, ovChart.getObjects());
      }
      
      bounds = DvtChartEventUtils.getAxisBounds(this, event, false);
      return new DvtChartSelectionEvent(selection, bounds.xMin, bounds.xMax, bounds.startGroup, bounds.endGroup, 
          bounds.yMin, bounds.yMax, bounds.y2Min, bounds.y2Max);
    }
    else
      return null;
  }
  
  // Marquee zoom
  else if (em.getDragMode() == DvtChartEventManager.DRAG_MODE_ZOOM) {
    if (subtype != DvtMarqueeEvent.SUBTYPE_END)
      return null;
    
    // Compute and limit the bounds
    bounds = DvtChartEventUtils.getAxisBounds(this, event, true);    
    this.setViewport(bounds, true);
    this.setScrollbarViewport(bounds);
    
    // Event handlers have to be reset because the plot area space may change
    DvtChartRenderer._setEventHandlers(this);
    
    if (DvtChartTypeUtils.isBLAC(this))
      return new DvtChartViewportChangeEvent(bounds.xMin, bounds.xMax, bounds.startGroup, bounds.endGroup, null, null);
    else
      return new DvtChartViewportChangeEvent(bounds.xMin, bounds.xMax, null, null, bounds.yMin, bounds.yMax);     
  }
  
  return null;
}

/**
 * Processes overview event.
 * @param {DvtOverviewEvent} event Overview event.
 * @param {object} source The component that is the source of the event, if available.
 * @return {object} Processed event.
 * @private
 */
DvtChartImpl.prototype._processOverviewEvent = function(event, source) {
  var subtype = event.getSubType();
  if (subtype == DvtOverviewEvent.SUBTYPE_PRE_RANGECHANGE)
    return;
  
  var start = event.getNewStartTime();
  var end = event.getNewEndTime();
  var actionDone = subtype == DvtOverviewEvent.SUBTYPE_SCROLL_TIME || 
                   subtype == DvtOverviewEvent.SUBTYPE_SCROLL_END  || 
                   subtype == DvtOverviewEvent.SUBTYPE_RANGECHANGE;
  
  if (DvtChartEventUtils.isLiveScroll(this) || actionDone) {
    if (source == this.yScrollbar)
      this.setViewport({yMin: start, yMax: end}, actionDone);
    else
      this.setViewport({xMin: start, xMax: end}, actionDone);
  }
 
  if (actionDone) {
    if (source == this.yScrollbar)
      return new DvtChartViewportChangeEvent(null, null, null, null, start, end, null, null);
    else {
      var startEndGroup = DvtChartEventUtils.getAxisStartEndGroup(this.xAxis, start, end);
      return new DvtChartViewportChangeEvent(start, end, startEndGroup.startGroup, startEndGroup.endGroup, null, null, null, null);
    }
  }
  else
    return null;
}

/**
 * Processes show popup event.
 * @param {DvtShowPopupEvent} event Show popup event.
 * @return {object} Processed event.
 * @private
 */
DvtChartImpl.prototype._processShowPopupEvent = function(event) {
  if(this.isSelectionSupported()) {
    var selection = DvtChartEventUtils.processIds(this, this.getSelectionHandler().getSelectedIds());
    event = new DvtShowPopupEvent(event.getShowPopupBehavior(), event.getLauncherBounds(), event.getLauncherId())
    event.addParam(DvtBaseComponentEvent.CLIENT_ROW_KEY, selection);
  }

  return event;
}

/**
 * Processes component UI event.
 * @param {DvtComponentUIEvent} event Component UI event.
 * @param {object} source The component that is the source of the event, if available.
 * @return {object} Processed event.
 * @private
 */
DvtChartImpl.prototype._processComponentUIEvent = function(event, source) {
  // Convert event based on source
  var params = event['params'];
  var chartObjType = params['type'];
  if(source === this.legend) {
    if(chartObjType == DvtLegendConstants.LEGEND_ITEM)
      chartObjType = DvtChartConstants.LEGEND_ITEM;
    else if(chartObjType == DvtLegendConstants.TITLE)
      chartObjType = DvtChartConstants.LEGEND_TITLE;
    else if(chartObjType == DvtLegendConstants.BACKGROUND)
      chartObjType = DvtChartConstants.LEGEND;
    
    return new DvtComponentUIEvent(event.getType(), DvtChartEventManager.getUIEventParams(chartObjType, null, params['id']));
  }
  else if(source === this.xAxis) {
    if(chartObjType == DvtAxisConstants.TICK_LABEL)
      chartObjType = DvtChartConstants.X_AXIS_LABEL;
    else if(chartObjType == DvtAxisConstants.TITLE)
      chartObjType = DvtChartConstants.X_AXIS_TITLE;
      
    return new DvtComponentUIEvent(event.getType(), DvtChartEventManager.getUIEventParams(chartObjType, params['id']));
  }
  else if(source === this.yAxis) {
    if(chartObjType == DvtAxisConstants.TICK_LABEL)
      chartObjType = DvtChartConstants.Y_AXIS_LABEL;
    else if(chartObjType == DvtAxisConstants.TITLE)
      chartObjType = DvtChartConstants.Y_AXIS_TITLE;
      
    return new DvtComponentUIEvent(event.getType(), DvtChartEventManager.getUIEventParams(chartObjType, params['id']));
  }
  else if(source === this.y2Axis) {
    if(chartObjType == DvtAxisConstants.TICK_LABEL)
      chartObjType = DvtChartConstants.Y2_AXIS_LABEL;
    else if(chartObjType == DvtAxisConstants.TITLE)
      chartObjType = DvtChartConstants.Y2_AXIS_TITLE;
      
    return new DvtComponentUIEvent(event.getType(), DvtChartEventManager.getUIEventParams(chartObjType, params['id']));
  }
  else // Don't need to modify the event.  Generally this means the source is the chart itself.
    return event;
}

/**
 * Distributes the specified event to this chart's children.
 * @param {object} event
 * @param {object} source The component that is the source of the event, if available.
 */
DvtChartImpl.prototype._distributeToChildren = function(event, source) {
  if(this.legend && this.legend != source) 
    this.legend.processEvent(event, source);
    
  if(this.pieChart && this.pieChart != source)
    this.pieChart.processEvent(event, source);
}

/**
 * @Override
 */
DvtChartImpl.prototype.__cleanUp = function() {
  DvtChartImpl.superclass.__cleanUp.call(this);
  
  // Clear the list of registered peers
  this._peers.length = 0;
  
  // Clear scrollbars, buttons
  this.overview = null;
  this.xScrollbar = null;
  this.yScrollbar = null;
  this.hideDragButtons();
  this.dragButtons = null;
};

/**
 * Clean up axis and plot area for rerendering (zoom/scroll).
 */
DvtChartImpl.prototype.__cleanUpAxisAndPlotArea = function() {
  // Tooltip cleanup
  this.EventManager.hideHoverFeedback();
  
  // Clear the list of registered peers
  this._peers.length = 0;
  
  // Clean up the axis and plot area
  this._container.removeChild(this.xAxis);
  this._container.removeChild(this.yAxis);
  this._container.removeChild(this.y2Axis);
  
  // Plot area which is a touch target needs to be kept so that subsequent touch events are fired.
  if (this._plotArea == this._panZoomTarget)
    this._plotArea.setVisible(false);
  else
    this._container.removeChild(this._plotArea);
}


/**
 * Registers the object peer with the chart.  The peer must be registered to participate
 * in interactivity.
 * @param {DvtChartObjPeer} peer
 */
DvtChartImpl.prototype.registerObject = function(peer) {
  this._peers.push(peer);
}

/**
 * Returns the peers for all objects within the chart.
 * @return {array}
 */
DvtChartImpl.prototype.getObjects = function() {
  return this._peers;
}

/**
 * Returns the peer specified by the seriesIndex and groupIndex.
 * @param {number} seriesIndex
 * @param {number} groupIndex
 * @return {DvtChartObjPeer}
 */
DvtChartImpl.prototype.getObject = function(seriesIndex, groupIndex) {
  for (i=0; i<this._peers.length; i++) {
    if (this._peers[i].getSeriesIndex() == seriesIndex && this._peers[i].getGroupIndex() == groupIndex)
      return this._peers[i];
  }
  return null;
}

/**
 * Returns the options object for this chart.
 * @return {object}
 */
DvtChartImpl.prototype.getOptions = function() {
  if(!this.Options)
    this.Options = this.GetDefaults();
    
  return this.Options;
}

/**
 * @return {number} chart width
 */
DvtChartImpl.prototype.getWidth = function() {
  return this.Width;
}

/**
 * @return {number} chart height
 */
DvtChartImpl.prototype.getHeight = function() {
  return this.Height;
}

/**
 * Returns the resource bundle for this chart.
 * @return {DvtChartBundle}
 */
DvtChartImpl.prototype.getBundle = function() {
  return this.Bundle;
}

/**
 * Returns the array containing unique series ids.  This array is used
 * to maintain default styles for each unique series.
 * @return {array}
 */
DvtChartImpl.prototype.getSeriesStyleArray = function() {
  return this._seriesStyleArray;
}

/**
 * Returns the plot area container.
 * @returns {DvtContainer}  the plot area container.
 */
DvtChartImpl.prototype.getPlotArea = function() {
  return this._plotArea ;
};

/**
 * Sets the plot area container.
 * @param {DvtContainer} plot  the plot area container.
 */
DvtChartImpl.prototype.setPlotArea = function(plot) {
  this._plotArea = plot
};


/**
 * Returns the funnel container.
 * @returns {DvtContainer}  the funnel container.
 */
DvtChartImpl.prototype.getFunnelContainer = function() {
  return this._funnelContainer ;
};

/**
 * Sets the funnel container.
 * @param {DvtContainer} container  the funnel container.
 */
DvtChartImpl.prototype.setFunnelContainer = function(container) {
  this._funnelContainer = container
};

/**
 * Returns the type of this chart, such as "bar" or "scatter".
 * @return {string}
 */
DvtChartImpl.prototype.getType = function() {
  return this.getOptions()['type'];
}

/**
 * Returns the scale factor for gaps on this chart.
 * @return {number}
 */
DvtChartImpl.prototype.getGapRatio = function() {
  // If defined in the options, use that instead
  var options = this.getOptions();
  if(options['layout']['gapRatio'] !== null && !isNaN(options['layout']['gapRatio']))
    return options['layout']['gapRatio'];
  else {
    var wRatio = Math.min(this.Width/400, 1);
    var hRatio = Math.min(this.Height/300, 1);
    return Math.min(wRatio, hRatio);
  }
}

/**
 * Returns the selection handler for the graph.
 * @return {DvtSelectionHandler} The selection handler for the graph
 */
DvtChartImpl.prototype.getSelectionHandler = function() {
  return this._selectionHandler;
}

/**
  *  Returns whether selecton is supported on the graph.
  *  @return {boolean} True if selection is turned on for the graph and false otherwise.
  */
DvtChartImpl.prototype.isSelectionSupported = function() {
   return (this._selectionHandler ? true : false);
}

/**
 * Returns the array of DvtShowPopupBehaviors for the given stamp id.
 * @param {string} stampId The id of the stamp containing the showPopupBehaviors.
 * @return {array} The array of showPopupBehaviors.
 */
DvtChartImpl.prototype.getShowPopupBehaviors = function(stampId) {
  return this._popupBehaviors ? this._popupBehaviors[stampId] : null;
}

//---------------------------------------------------------------------//
// Ordering Support: ZOrderManager impl                                //
//---------------------------------------------------------------------//

/**
 * @override
 */
DvtChartImpl.prototype.bringToFrontOfSelection = function(detObj)
{
  var par = detObj.getParent();
  if (par) {
    var parentChildCount = par.getNumChildren();

    if (parentChildCount - this._numFrontObjs > 1) {
      par.removeChild(detObj);
      var newIndex = parentChildCount - this._numFrontObjs - 1;
      par.addChildAt(detObj, newIndex);
    }
  }
  
  //if the object is not both selected and selecting then
  //increment the counter (otherwise the object is already
  //represented in the counter)
  if (!detObj.isSelected() || !detObj.isHoverEffectShown())
    this._numSelectedObjsInFront++;

};

/**
 * @override
 */
DvtChartImpl.prototype.pushToBackOfSelection = function(detObj)
{
  //decrement the counter
  if (this._numSelectedObjsInFront > 0)
    this._numSelectedObjsInFront--;
  
  //move the object to the first z-index before the selected objects
  var par = detObj.getParent();
  if (par) {
    var parentChildCount = par.getNumChildren();
    var newIndex = parentChildCount - this._numFrontObjs - 1 - this._numSelectedObjsInFront;
    if (newIndex >= 0) {
      par.removeChild(detObj);
      par.addChildAt(detObj, newIndex);
    }
  }
};

/**
 * @override
 */
DvtChartImpl.prototype.setNumFrontObjs = function(num)
{
  this._numFrontObjs = num;
};

DvtChartImpl.prototype.getShapesForViewSwitcher = function(bOld) {
  var shapes = {};
  
  if (this._currentMarkers && this._peers) {
    for (var i = 0; i < this._currentMarkers.length; i++) {
      var arMarkers = this._currentMarkers[i];
      if (arMarkers) {
        for (var j = 0; j < arMarkers.length; j++) {
          var marker = arMarkers[j];
          if (!marker) {
            continue; //j loop
          }
          //find the peer associated with this marker in order to get the id
          for (var k = 0; k < this._peers.length; k++) {
            var peer = this._peers[k];
            var peerDisplayables = peer.getDisplayables();
            if (peerDisplayables && peerDisplayables.length > 0) {
              if (peerDisplayables[0] == marker) {
                var chartDataItem = peer.getId();
                if (chartDataItem) {
                  var id = chartDataItem.getId();
                  if (id) {
                    shapes[id] = marker;
                    break; //out of k loop
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  else if (this.pieChart) {
    shapes = this.pieChart.getShapesForViewSwitcher(bOld);
  }
  
  return shapes;
};

/**
 * Sets the chart viewport and rerender the axis and plot area.
 * @param {DvtRectangle} bounds An object containing the xMin, xMax, yMin, yMax of the new viewport.
 * @param {boolean} actionDone Whether the animation is done, so that the chart should be fully rendered.
 */
DvtChartImpl.prototype.setViewport = function(bounds, actionDone) {
  if (DvtChartTypeUtils.isScrollSupported(this)) {
    if (bounds.xMax != null)
      this.Options['xAxis']['viewportMax'] = bounds.xMax;
    if (bounds.xMin != null)
      this.Options['xAxis']['viewportMin'] = bounds.xMin;
    
    if (DvtChartTypeUtils.isBLAC(this)) {
      this.Options['xAxis']['viewportStartGroup'] = null;
      this.Options['xAxis']['viewportEndGroup'] = null;
    } 
    else {
      if (bounds.yMax != null)
        this.Options['yAxis']['viewportMax'] = bounds.yMax;
      if (bounds.yMin != null)
        this.Options['yAxis']['viewportMin'] = bounds.yMin;
    }
    
    this.Options['_duringAnimation'] = !actionDone;
    DvtChartRenderer.rerenderAxisAndPlotArea(this, this._container);
  }
}

/**
 * Sets the scrollbar viewport.
 * @param {DvtRectangle} bounds An object containing the xMin, xMax, yMin, yMax of the new viewport.
 */
DvtChartImpl.prototype.setScrollbarViewport = function(bounds) {
  if (this.overview)
    this.overview.setViewportRange(bounds.xMin, bounds.xMax);
  if (this.xScrollbar)
    this.xScrollbar.setViewportRange(bounds.xMin, bounds.xMax);
  if (this.yScrollbar)
    this.yScrollbar.setViewportRange(bounds.yMin, bounds.yMax);
}

/**
 * Sets the space for the axis and the plot area.
 * @param {DvtRectangle} space
 */
DvtChartImpl.prototype.__setAxisSpace = function(space) {
  this._axisSpace = space;
  this._radius = Math.min(space.h * 0.9, space.w * 0.8) / 2; // TODO (panho): set based on label height
}

/**
 * Gets the space for the axis and the plot area.
 * @return {DvtRectangle} space
 */
DvtChartImpl.prototype.__getAxisSpace = function() {
  return this._axisSpace;
}

/**
 * Sets the space for the plot area.
 * @param {DvtRectangle} space
 */
DvtChartImpl.prototype.__setPlotAreaSpace = function(space) {
  this._plotAreaSpace = space;
}

/**
 * Gets the space for the plot area.
 * @return {DvtRectangle} space
 */
DvtChartImpl.prototype.__getPlotAreaSpace = function() {
  return this._plotAreaSpace;
}

/**
 * Returns the radius of a polar chart.
 * @return {number} Polar chart radius.
 */
DvtChartImpl.prototype.getRadius = function() {
  return this._radius;  
}

/**
 * Shows the drag buttons.
 */
DvtChartImpl.prototype.showDragButtons = function() {
  if (this.dragButtons)
    this.dragButtons.setVisible(true);
}

/**
 * Hides the drag buttons.
 */
DvtChartImpl.prototype.hideDragButtons = function() {
  if (this.dragButtons)
    this.dragButtons.setVisible(false);
}
/**
 * Axis component for use by DvtChart.  This class exposes additional functions needed for 
 * rendering grid lines and data items.
 * @param {DvtContext} context The rendering context.
 * @param {string} callback The function that should be called to dispatch component events.
 * @param {object} callbackObj The optional object instance on which the callback function is defined.
 * @class
 * @constructor
 * @extends {DvtAxis}
 */
var DvtChartAxis = function(context, callback, callbackObj) {
  this.Init(context, callback, callbackObj);
}

DvtObj.createSubclass(DvtChartAxis, DvtAxis, "DvtChartAxis");

/**
 * Returns the options settings for the axis.
 * @return {object} The options for the axis.
 */
DvtChartAxis.prototype.getOptions = function() {
  return this.Info.Options;
}

/**
 * Converts the axis coord to plot area coord.
 * @param {number} coord Axis coord.
 * @param {boolean} [bRoundResult] Whether the resulting coordinate is rounded to the nearest pixel.  Defaults to true.
 * @return {number} Plot area coord.
 */
DvtChartAxis.prototype.axisToPlotArea = function(coord, bRoundResult) {
  if (this.getOptions()['position'] == "tangential")
    return coord;

  if (coord == null)
    return null;
  
  var ret = coord - this.getLeftOverflow();
  return (bRoundResult === false) ? ret : Math.round(ret);
}

/**
 * Converts the plot area coord to axis coord.
 * @param {number} coord Plot area coord.
 * @param {boolean} [bRoundResult] Whether the resulting coordinate is rounded to the nearest pixel.  Defaults to true.
 * @return {number} Axis coord.
 */
DvtChartAxis.prototype.plotAreaToAxis = function(coord, bRoundResult) {
  if (this.getOptions()['position'] == "tangential")
    return coord;

  if (coord == null)
    return null;
  
  var ret = coord + this.getLeftOverflow();
  return (bRoundResult === false) ? ret : Math.round(ret);
}

/**
 * Returns the value for the specified coordinate along the axis.  Returns null
 * if the coordinate is not within the axis.
 * @param {number} coord The coordinate along the axis.
 * @return {object} The value at that coordinate.
 */
DvtChartAxis.prototype.getValueAt = function(coord) {
  return this.Info ? this.Info.getValueAt(this.plotAreaToAxis(coord)) : null;
}

/**
 * Returns the coordinate for the specified value.
 * @param {object} value The value to locate.
 * @param {boolean} [bRoundResult] Whether the resulting coordinate is rounded to the nearest pixel.  Defaults to true.
 * @return {number} The coordinate for the value.
 */
DvtChartAxis.prototype.getCoordAt = function(value, bRoundResult) {
  return this.Info ? this.axisToPlotArea(this.Info.getCoordAt(value), bRoundResult) : null;
}

/**
 * Returns the value for the specified coordinate along the axis.  If a coordinate
 * is not within the axis, returns the value of the closest coordinate within the axis.
 * @param {number} coord The coordinate along the axis.
 * @return {object} The value at that coordinate.
 */
DvtChartAxis.prototype.getBoundedValueAt = function(coord) {
  return this.Info ? this.Info.getBoundedValueAt(this.plotAreaToAxis(coord)) : null;
}

/**
 * Returns the coordinate for the specified value.  If a value is not within the axis,
 * returns the coordinate of the closest value within the axis.
 * @param {object} value The value to locate.
 * @param {boolean} [bRoundResult] Whether the resulting coordinate is rounded to the nearest pixel.  Defaults to true.
 * @return {number} The coordinate for the value.
 */
DvtChartAxis.prototype.getBoundedCoordAt = function(value, bRoundResult) {
  return this.Info ? this.axisToPlotArea(this.Info.getBoundedCoordAt(value), bRoundResult) : null;
}

/**
 * Returns the value for the specified coordinate along the axis.
 * @param {number} coord The coordinate along the axis.
 * @return {object} The value at that coordinate.
 */
DvtChartAxis.prototype.getUnboundedValueAt = function(coord) {
  return this.Info ? this.Info.getUnboundedValueAt(this.plotAreaToAxis(coord)) : null;
}

/**
 * Returns the coordinate for the specified value.
 * @param {object} value The value to locate.
 * @param {boolean} [bRoundResult] Whether the resulting coordinate is rounded to the nearest pixel.  Defaults to true.
 * @return {number} The coordinate for the value.
 */
DvtChartAxis.prototype.getUnboundedCoordAt = function(value, bRoundResult) {
  return this.Info ? this.axisToPlotArea(this.Info.getUnboundedCoordAt(value), bRoundResult) : null;
}

/**
 * Returns the group label for the specified group. Only applies to group axis.
 * @param {number} index The group index.
 * @return {string} The group label.
 */
DvtChartAxis.prototype.getGroupLabelAt = function(index) {
  if (this.isGroupAxis())
    return this.Info ? this.Info.getLabelAt(index) : null;
  else
    return null;
}

/**
 * Returns the baseline coordinate for the axis, if applicable.
 * @return {number} The baseline coordinate for the axis.
 */
DvtChartAxis.prototype.getBaselineCoord = function() {
  return this.Info ? this.axisToPlotArea(this.Info.getBaselineCoord()) : null;
}

/**
 * Returns the position of the axis relative to the chart.
 * @return {string} The position of the axis.
 */
DvtChartAxis.prototype.getPosition = function() {
  return this.__getOptions()['position'];
}

/**
 * Returns true if this is a group axis.
 * @return {boolean}
 */
DvtChartAxis.prototype.isGroupAxis = function() {
  return this.Info instanceof DvtGroupAxisInfo;
}

/**
 * Returns true if this is a time axis.
 * @return {boolean}
 */
DvtChartAxis.prototype.isTimeAxis = function() {
  return this.Info instanceof DvtTimeAxisInfo;
}

/**
 * Returns true if this is a data axis.
 * @return {boolean}
 */
DvtChartAxis.prototype.isDataAxis = function() {
  return this.Info instanceof DvtDataAxisInfo;
}

/**
 * Returns the width of a group of bars in an axis. The supported axis are time axis and group axis. 
 * @return {number} The width of a single group for an axis.  Returns
 *                  0 for unsupported axes.
 */
DvtChartAxis.prototype.getGroupWidth = function() {
  if(this.isGroupAxis()) {   
    return Math.abs(this.getUnboundedCoordAt(1) - this.getUnboundedCoordAt(0));
  } else if (this.isTimeAxis()) {
    return this.Info.getGroupWidth();
  } else { // not a supported axis
    return 0;
  }
}

/**
 * Returns the axis line for this axis.
 * @param {DvtContext} context
 * @return {DvtLine} The axis line.
 */
DvtChartAxis.prototype.getAxisLine = function(context) {
  return this.Info ? this.Info.getAxisLine(context) : null;
}

/**
 * Returns an array containing the majorTick grid lines for this axis.  Objects
 * are returned in the desired z-order.
 * @param {DvtContext} context
 * @return {Array} The Array of DvtLine objects.
 */
DvtChartAxis.prototype.getMajorGridLines = function(context) {
  return this.Info ? this.Info.getMajorGridLines(context) : [];
}

/**
 * Returns an array containing the minorTick grid lines for this axis.  Objects
 * are returned in the desired z-order.
 * @param {DvtContext} context
 * @return {Array} The Array of DvtLine objects.
 */
DvtChartAxis.prototype.getMinorGridLines = function(context) {
  return this.Info ? this.Info.getMinorGridLines(context) : [];
}

/**
 * Returns the number of major tick counts for the axis.
 * @return {number} The number of major tick counts.
 */
DvtChartAxis.prototype.getMajorTickCount = function() {
   return this.Info ? this.Info.getMajorTickCount() : null;
}

/**
 * Sets the number of major tick counts for the axis.
 * @param {number} count The number of major tick counts.
 */
DvtChartAxis.prototype.setMajorTickCount = function(count) {
   if (this.Info)
    this.Info.setMajorTickCount(count);
}

/**
 * Returns the number of minor tick counts for the axis.
 * @return {number} The number of minor tick counts.
 */
DvtChartAxis.prototype.getMinorTickCount = function() {
   return this.Info ? this.Info.getMinorTickCount() : null;
}

/**
 * Sets the number of minor tick counts for the axis.
 * @param {number} count The number of minor tick counts.
 */
DvtChartAxis.prototype.setMinorTickCount = function(count) {
   if (this.Info)
    this.Info.setMinorTickCount(count);
}

/**
 * Returns the major increment for the axis.
 * @return {number} The major increment.
 */
DvtChartAxis.prototype.getMajorIncrement = function() {
  return this.Info ? this.Info.getMajorIncrement() : null;
}

/**
 * Returns the minor increment for the axis.
 * @return {number} The minor increment.
 */
DvtChartAxis.prototype.getMinorIncrement = function() {
  return this.Info ? this.Info.getMinorIncrement() : null;
}

/**
 * Returns the global min value of the axis.
 * @return {number} The global min value.
 */
DvtChartAxis.prototype.getGlobalMin = function() {
  return this.Info ? this.Info.getGlobalMin() : null;
}

/**
 * Returns the global max value of the axis.
 * @return {number} The global max value.
 */
DvtChartAxis.prototype.getGlobalMax = function() {
  return this.Info ? this.Info.getGlobalMax() : null;
}

/**
 * Returns the viewport min value of the axis.
 * @return {number} The viewport min value.
 */
DvtChartAxis.prototype.getViewportMin = function() {
  return this.Info ? this.Info.getViewportMin() : null;
}

/**
 * Returns the viewport max value of the axis.
 * @return {number} The viewport max value.
 */
DvtChartAxis.prototype.getViewportMax = function() {
  return this.Info ? this.Info.getViewportMax() : null;
}

/**
 * Returns the data min value of the axis.
 * @return {number} The data min value.
 */
DvtChartAxis.prototype.getDataMin = function() {
  return this.Info ? this.Info.getDataMin() : null;
}

/**
 * Returns the data max value of the axis.
 * @return {number} The data max value.
 */
DvtChartAxis.prototype.getDataMax = function() {
  return this.Info ? this.Info.getDataMax() : null;
}

/**
 * Returns the minimum extent of the axis, i.e. the (minValue-maxValue) during maximum zoom.
 * @return {number} The minimum extent.
 */
DvtChartAxis.prototype.getMinimumExtent = function() {
  return this.Info ? this.Info.getMinimumExtent() : null;
}

/**
 * Returns whether the viewport is showing the full extent of the chart.
 * @return {boolean}
 */
DvtChartAxis.prototype.isFullViewport = function() {
  return this.getViewportMin() == this.getGlobalMin() && this.getViewportMax() == this.getGlobalMax();
}

/**
 * Returns how much the axis labels overflow to the left.
 * @return {number}
 */
DvtChartAxis.prototype.getLeftOverflow = function() {
  if (DvtAgent.isRightToLeft(this.getCtx()))
    return this.Info ? this.Info.getEndOverflow() : null;
  else
    return this.Info ? this.Info.getStartOverflow() : null;
}

/**
 * Returns how much the axis labels overflow to the right.
 * @return {number}
 */
DvtChartAxis.prototype.getRightOverflow = function() {
  if (DvtAgent.isRightToLeft(this.getCtx()))
    return this.Info ? this.Info.getStartOverflow() : null;
  else
    return this.Info ? this.Info.getEndOverflow() : null;
}
/**
 * Resource bundle for DvtChart.
 * @class
 * @constructor
 * @extends {DvtBundle}
 */
var DvtChartBundle = function() {}

DvtObj.createSubclass(DvtChartBundle, DvtBundle, "DvtChartBundle");

DvtChartBundle["_defaults"] = {
  'EMPTY_TEXT': 'No data to display',
  'DEFAULT_GROUP_NAME': 'Group {0}',
  'LABEL_SERIES': 'Series: {0}',
  'LABEL_GROUP': 'Group: {0}',
  'LABEL_VALUE': 'Value: {0}',
  'LABEL_TARGET_VALUE': 'Target: {0}',
  'LABEL_X': 'X: {0}',
  'LABEL_Y': 'Y: {0}',
  'LABEL_Z': 'Z: {0}',
  'LABEL_LOW': 'Low: {0}',
  'LABEL_HIGH': 'High: {0}',
  'LABEL_OTHER': 'Other',
  'PAN': 'Pan',
  'MARQUEE_SELECT': 'Marquee select',
  'MARQUEE_ZOOM': 'Marquee zoom'
}

/**
 * @override
 */
DvtChartBundle.prototype.GetDefaultStringForKey = function(key) {
  return DvtChartBundle["_defaults"][key];
}

/**
 * @override
 */
DvtChartBundle.prototype.GetBundlePrefix = function() {
  return "DvtChartBundle";
}
/**
 * Event Manager for DvtChart.
 * @param {DvtChartImpl} chart
 * @class
 * @extends DvtEventManager
 * @constructor
 */
var DvtChartEventManager = function(chart) {
  DvtChartEventManager.superclass.Init.call(this, chart.getCtx(), chart.processEvent, chart);
  this._chart = chart;
  
  this._dragMode = null;
  this._dragButtonsVisible = DvtAgent.isTouchDevice();
  
  /**
   * The marquee zoom button
   * @type {DvtButton}
   */
  this.zoomButton = null;
  /**
   * The marquee select button
   * @type {DvtButton}
   */
  this.selectButton = null;
  
  // Event handlers
  this._seriesRolloverHandler = null;
  this._dataCursorHandler = null;
  this._panZoomHandler = null;
  this._marqueeZoomHandler = null;
  this._marqueeSelectHandler = null;
  
  // Cached stage absolute position
  this._stageAbsolutePosition = null;
};

DvtObj.createSubclass(DvtChartEventManager, DvtEventManager, "DvtChartEventManager");

// Drag modes
DvtChartEventManager.DRAG_MODE_PAN     = "pan";
DvtChartEventManager.DRAG_MODE_ZOOM    = "zoom";
DvtChartEventManager.DRAG_MODE_SELECT  = "select";
DvtChartEventManager.DRAG_MODE_TOOLTIP = "tooltip";


/**
 * Returns the parameters for the DvtComponentUIEvent for an object with the specified arguments.
 * @param {string} type The type of object that was the target of the event.
 * @param {object} [id] The id of the object, if one exists.
 * @param {string} [series] The series for the object, if one exists.
 * @param {string} [group] The group for the object, if one exists.
 */
DvtChartEventManager.getUIEventParams = function(type, id, series, group) {
  return {'type': type, 'id': id, 'series': series, 'group': group};
}

/**
 * @override
 */
DvtChartEventManager.prototype.addListeners = function (displayable) {
  DvtChartEventManager.superclass.addListeners.call(this, displayable);
  if (!DvtAgent.isTouchDevice()) { 
    if (DvtAgent.isPlatformGecko()) // Firefox
      displayable.addEvtListener("wheel", this.OnMouseWheel, false, this);
    else 
      displayable.addEvtListener(DvtMouseEvent.MOUSEWHEEL, this.OnMouseWheel, false, this);
  }
}

/**
 * @override
 */
DvtChartEventManager.prototype.removeListeners = function (displayable) {
  DvtChartEventManager.superclass.removeListeners.call(this, displayable);
  if (!DvtAgent.isTouchDevice()) { 
    if (DvtAgent.isPlatformGecko()) //Firefox
      displayable.removeEvtListener("DOMMouseScroll", this.OnMouseWheel, false, this);
    else 
      displayable.removeEvtListener(DvtMouseEvent.MOUSEWHEEL, this.OnMouseWheel, false, this);
  }
}

/**
 * Creates and fires an instance of DvtComponentUIEvent for the specified object.
 * @param {string} type The type of DvtComponentUIEvent.
 * @param {object} logicalObj The logical object corresponding to the target of the event.
 * @protected
 */
DvtChartEventManager.prototype.FireUIEvent = function(type, logicalObj) {
  var params = null;
  if(logicalObj instanceof DvtSimpleObjPeer && logicalObj.getParams() != null) 
    params = logicalObj.getParams();
  else if(logicalObj instanceof DvtPieSlice) {
    var sliceId = logicalObj.getId();
    if(sliceId.getSeries() == DvtPieChartUtils.OTHER_SLICE_SERIES_ID)
      params = DvtChartEventManager.getUIEventParams(DvtChartConstants.DATA_ITEM_OTHER);
    else
      params = DvtChartEventManager.getUIEventParams(DvtChartConstants.DATA_ITEM, sliceId.getId(), sliceId.getSeries(), sliceId.getGroup());
  }
  else if(logicalObj instanceof DvtChartObjPeer) {
    var objectType;
    if(logicalObj.getSeriesIndex() >= 0 && logicalObj.getGroupIndex() >= 0)
      objectType = DvtChartConstants.DATA_ITEM;
    else if(logicalObj.getSeriesIndex() >= 0)
      objectType = DvtChartConstants.SERIES;
        
    params = DvtChartEventManager.getUIEventParams(objectType, logicalObj.getDataItemId(), logicalObj.getSeries(), logicalObj.getGroup());
  }
  
//  if(params)
//    this.FireEvent(new DvtComponentUIEvent(type, params));
}

/**
 * Returns the logical object corresponding to the specified DvtDisplayable.  All high level event handlers,
 * such as the selection and popup handlers, are designed to react to the logical objects.
 * @param {DvtDisplayable} target The displayable.
 * @return {object} The logical object corresponding to the target.
 */
DvtChartEventManager.prototype.getLogicalObject = function(target) {
  return this.GetLogicalObject(target, true);
}

/**
 * Return the relative position relative to the stage, based on the cached stage absolute position.
 * @param {number} pageX
 * @param {number} pageY
 * @return {DvtPoint} The relative position.
 * @private
 */
DvtChartEventManager.prototype._getRelativePosition = function(pageX, pageY) {
  if (!this._stageAbsolutePosition)
    this._stageAbsolutePosition = this._context.getStageAbsolutePosition();
  
  return new DvtPoint(pageX - this._stageAbsolutePosition.x, pageY - this._stageAbsolutePosition.y);
}

/**
 * Returns an event handler for the current drag mode.
 * @return {DvtMarqueeHandler or DvtPanZoomHandler} Drag handler.
 */
DvtChartEventManager.prototype._getDragHandler = function() {
  if (this._dragMode == DvtChartEventManager.DRAG_MODE_PAN)
    return this._panZoomHandler;
  else if (this._dragMode == DvtChartEventManager.DRAG_MODE_ZOOM)
    return this._marqueeZoomHandler;
  else if (this._dragMode == DvtChartEventManager.DRAG_MODE_SELECT)
    return this._marqueeSelectHandler;
  return null;
}

/**
 * @override
 */
DvtChartEventManager.prototype.OnMouseDown = function(event) {
  var relPos = this._getRelativePosition(event.pageX, event.pageY);
  var dragHandler = this._getDragHandler();
  var chartEvent;
  
  // Do not initiate drag if the target is selectable. Drag only on left click.
  var obj = this.GetLogicalObject(this.GetCurrentTargetForEvent(event));
  var selectable = obj && obj.isSelectable && obj.isSelectable();
  if (!selectable && event.button == 0 && dragHandler) {
    chartEvent = dragHandler.processDragStart(relPos, event.ctrlKey);
    if (chartEvent)
      this._callback.call(this._callbackObj, chartEvent);
    
    this._chart.setCursor(dragHandler.getCursor(relPos));
    this.setDragButtonsVisible(false); // hide drag buttons on drag
  }
  
  if (chartEvent) {
    if (this._dataCursorHandler)
      this._dataCursorHandler.processEnd();
  }
  else
    DvtChartEventManager.superclass.OnMouseDown.call(this, event); 
}

/**
 * @override
 */
DvtChartEventManager.prototype.OnMouseMove = function(event) {
  var relPos = this._getRelativePosition(event.pageX, event.pageY); 
  var dragHandler = this._getDragHandler();
  var chartEvent;
  
  if (dragHandler) {
    chartEvent = dragHandler.processDragMove(relPos, event.ctrlKey);
    if (chartEvent) {
      this._callback.call(this._callbackObj, chartEvent);
      this.setDragButtonsVisible(false); // hide drag buttons on drag
    }
    else {
      // show drag buttons when plot area or axis are hovered
      var axisSpace = this._chart.__getAxisSpace();
      if (axisSpace)
        this.setDragButtonsVisible(axisSpace.containsPoint(relPos.x, relPos.y));
    }
    
    this._chart.setCursor(dragHandler.getCursor(relPos));
  }
  
  if (!chartEvent) {
    if (this._dataCursorHandler) {
      if (this.GetCurrentTargetForEvent(event) instanceof DvtButton) // don't show DC over buttons
        this._dataCursorHandler.processEnd();
      else
        this._dataCursorHandler.processMove(event.pageX, event.pageY, event.target);
    }
    
    DvtChartEventManager.superclass.OnMouseMove.call(this, event);
  }
}

/**
 * @override
 */
DvtChartEventManager.prototype.OnMouseUp = function(event) {
  var relPos = this._getRelativePosition(event.pageX, event.pageY);
  var dragHandler = this._getDragHandler();
  var chartEvent;
  
  if (dragHandler) {
    chartEvent = dragHandler.processDragEnd(relPos, event.ctrlKey);
    if (chartEvent) {
      this._callback.call(this._callbackObj, chartEvent);
      this.autoToggleZoomButton();
    }
    
    this._chart.setCursor(dragHandler.getCursor(relPos));
  }
  
  // Clear the stage absolute position cache
  this._stageAbsolutePosition = null;
  
  if (!chartEvent)
    DvtChartEventManager.superclass.OnMouseUp.call(this, event);
}

/**
 * @override
 */
DvtChartEventManager.prototype.OnMouseOver = function(event) {
  DvtChartEventManager.superclass.OnMouseOver.call(this, event);
  
  var obj = this.GetLogicalObject(event.target);
  if(!obj)
    return;
  if(this._seriesRolloverHandler) 
    this._seriesRolloverHandler.processMouseOver(obj);
}

/**
 * @override
 */
DvtChartEventManager.prototype.OnMouseOut = function(event) {
  DvtChartEventManager.superclass.OnMouseOut.call(this, event);
  var relPos = this._getRelativePosition(event.pageX, event.pageY);
  
  // Hide the drag buttons
  var axisSpace = this._chart.__getAxisSpace();
  if (axisSpace)
    this.setDragButtonsVisible(axisSpace.containsPoint(relPos.x, relPos.y));
  
  if (this._dataCursorHandler)
    this._dataCursorHandler.processOut(relPos);
  
  // Clear the stage absolute position cache
  this._stageAbsolutePosition = null;
  
  var obj = this.GetLogicalObject(event.target);
  if(!obj)
    return;
    
  if(this._seriesRolloverHandler) 
    this._seriesRolloverHandler.processMouseOut(obj);
}

DvtChartEventManager.prototype.OnMouseWheel = function (event) {
  if (!DvtChartEventUtils.isZoomable(this._chart))
    return;
  
  var delta = event.wheelDelta != null ? event.wheelDelta : 0;
  var relPos = this._getRelativePosition(event.pageX, event.pageY);
  
  if (this._panZoomHandler) {
    var panZoomEvent = this._panZoomHandler.processMouseWheel(relPos, delta);
    if (panZoomEvent) {
      event.preventDefault();
      event.stopPropagation();
      this._callback.call(this._callbackObj, panZoomEvent);
      
      // Update the data cursor since the viewport has changed
      if(this._dataCursorHandler)
        this._dataCursorHandler.processMove(event.pageX, event.pageY, event.target);
    }
  }
}

/**
 * @override
 */
DvtChartEventManager.prototype.OnClickInternal = function(event) {
  var obj = this.GetLogicalObject(event.target);
  var pos = this._getRelativePosition(event.pageX, event.pageY);
  if (this.SeriesFocusHandler)
      this.SeriesFocusHandler.processSeriesFocus(pos, obj);
      
  if(!obj)
    return;
      
  // Action Support
  if(obj.getAction && obj.getAction()) 
    this.FireEvent(new DvtActionEvent(DvtActionEvent.SUBTYPE_ACTION, obj.getAction(), obj.getId()));
}

/**
 * @override
 */
DvtChartEventManager.prototype.HandleTouchHoverStartInternal = function(event) {
  var touch = event.touch;
  var pos = this._context.pageToStageCoords(touch.pageX, touch.pageY);
  var dlo = this.GetLogicalObject(event.target);
  this.TouchManager.setTooltipEnabled(touch.identifier, this.IsTooltipShowable(dlo, pos));                       
  return false;
}

/**
 * @override
 */
DvtChartEventManager.prototype.HandleTouchHoverMoveInternal = function(event) {
  var touch = event.touch;
  var pos = this._context.pageToStageCoords(touch.pageX, touch.pageY);
  var dlo = this.GetLogicalObject(event.target);
  this.TouchManager.setTooltipEnabled(touch.identifier, this.IsTooltipShowable(dlo, pos));                       
  return false;
}

/**
 * @override
 */
DvtChartEventManager.prototype.HandleTouchHoverEndInternal = function(event) {
  if(this._seriesRolloverHandler) {
    var dlo = this.GetLogicalObject(event.target);
    this._seriesRolloverHandler.processMouseOut(dlo)
  }
} 

/**
 * @override
 */
DvtChartEventManager.prototype.HandleTouchHoverOverInternal = function(event) {
  if(this._seriesRolloverHandler) {
    var dlo = this.GetLogicalObject(event.target);
    this._seriesRolloverHandler.processMouseOver(dlo);
  }
}

/**
 * @override
 */
DvtChartEventManager.prototype.HandleTouchHoverOutInternal = function(event) {
  if(this._seriesRolloverHandler) {
    var dlo = this.GetLogicalObject(event.target);
    this._seriesRolloverHandler.processMouseOut(dlo);
  }
}

/**
 * @override
 */
DvtChartEventManager.prototype.HandleTouchClickInternal = function(evt) {
  DvtChartEventManager.superclass.HandleTouchClickInternal.call(this, evt);
    
  // Action Support
  var obj = this.GetLogicalObject(evt.target);
  if(!obj)
    return;
  
  if(obj.getAction && obj.getAction()) 
    this.FireEvent(new DvtActionEvent(DvtActionEvent.SUBTYPE_ACTION, obj.getAction(), obj.getId()));
}

/**
 * @override
 */
DvtChartEventManager.prototype.HandleImmediateTouchStartInternal = function(event) {
  var touches = event.touches;
  var chartEvent, dataCursorOn, dragHandler;
  
  if (touches.length == 1) {
    dragHandler = this._getDragHandler();
    if (dragHandler) {
      var relPos = this._getRelativePosition(touches[0].pageX, touches[0].pageY); 
      chartEvent = dragHandler.processDragStart(relPos, true);
    }
    else if (this._dataCursorHandler) {
      this._dataCursorHandler.processMove(touches[0].pageX, touches[0].pageY, event.target, this.GetLogicalObject(event.target));
      dataCursorOn = true;
    } 
  }  
  else if (touches.length == 2 && this._panZoomHandler) {
    this.endDrag(); // clean 1-finger events before starting pinch zoom
    var relPos1 = this._getRelativePosition(touches[0].pageX, touches[0].pageY);
    var relPos2 = this._getRelativePosition(touches[1].pageX, touches[1].pageY);
    chartEvent = this._panZoomHandler.processPinchStart(relPos1, relPos2);
  }
  
  if (chartEvent || dataCursorOn) {
    event.preventDefault();
    event.stopPropagation();
    this.setDragButtonsVisible(false); // hide drag buttons on drag
  }
  
  if (chartEvent) {
    this._callback.call(this._callbackObj, chartEvent);
    this.getCtx().getTooltipManager().hideTooltip();
  } 
}

/**
 * @override
 */
DvtChartEventManager.prototype.HandleImmediateTouchMoveInternal = function(event) {
  var touches = event.touches;
  var chartEvent, dataCursorOn;
  
  if (touches.length == 1) {
    var dragHandler = this._getDragHandler();
    if (dragHandler) {
      var relPos = this._getRelativePosition(touches[0].pageX, touches[0].pageY); 
      chartEvent = dragHandler.processDragMove(relPos, true);
    }
    else if (this._dataCursorHandler) {
      this._dataCursorHandler.processMove(touches[0].pageX, touches[0].pageY, event.target, this.GetLogicalObject(event.target));
      dataCursorOn = true;
    } 
  }
  else if (touches.length == 2 && this._panZoomHandler) {
    var relPos1 = this._getRelativePosition(touches[0].pageX, touches[0].pageY);
    var relPos2 = this._getRelativePosition(touches[1].pageX, touches[1].pageY);
    chartEvent = this._panZoomHandler.processPinchMove(relPos1, relPos2);
  }
  
  if (chartEvent || dataCursorOn) {
    event.preventDefault();
    event.stopPropagation();
  }
  
  if (chartEvent) {
    this._callback.call(this._callbackObj, chartEvent);
    this.getCtx().getTooltipManager().hideTooltip();
  }
}

/**
 * @override
 */
DvtChartEventManager.prototype.HandleImmediateTouchEndInternal = function(event) {
  // End 1-finger event
  var chartEvent1 = this.endDrag();
  
  // End 2-finger event
  var chartEvent2;
  if (this._panZoomHandler) {
    chartEvent2 = this._panZoomHandler.processPinchEnd();
    if (chartEvent2)
      this._callback.call(this._callbackObj, chartEvent2);
  }
  
  if (chartEvent1 || chartEvent2) {
    event.preventDefault();
    event.stopPropagation();
    this.getCtx().getTooltipManager().hideTooltip();
  }
  
  this._stageAbsolutePosition = null; // Clear the stage absolute position cache
  this.setDragButtonsVisible(true);
}

/**
 * @override
 */
DvtChartEventManager.prototype.endDrag = function() {
  var dragHandler = this._getDragHandler();
  var chartEvent;
  
  if (dragHandler) {
    chartEvent = dragHandler.processDragEnd(null, true);
    if (chartEvent)
      this._callback.call(this._callbackObj, chartEvent);
  }
  if (this._dataCursorHandler)
    this._dataCursorHandler.processEnd();
  
  if (chartEvent)
    this._callback.call(this._callbackObj, chartEvent);
  
  return chartEvent;
}

/**
 * @override
 */
DvtChartEventManager.prototype.IsTooltipShowableInternal = function(obj, pos) {
  // Don't show tooltips if data cursor is visible, or if the target is a data item
  if (this._dataCursorHandler) {
    if(obj instanceof DvtChartObjPeer)
      return false;
    else
      return !this._dataCursorHandler.isDataCursorShown();
  } 
  return true;
}

/**
 * Helper function to hide tooltips and data cursor, generally in preparation for render or removal of the chart. This 
 * is not done in hideTooltip to avoid interactions with the superclass, which would cause problems with the data cursor.
 */
DvtChartEventManager.prototype.hideHoverFeedback = function() {
  // Hide tooltip and data cursor
  this.hideTooltip();

  // Hide the data cursor. This is necessary to hide the data cursor line when the user mouses over the tooltip div in 
  // IE9, which does not support pointer-events.
  if(this._dataCursorHandler) 
    this._dataCursorHandler.processEnd();
}

/**
 * @override
 */
DvtChartEventManager.prototype.hideTooltip = function() {
  // Don't hide the tooltip if data cursor is shown on a touch device
  if(!this._dataCursorHandler || !this._dataCursorHandler.isDataCursorShown())
    DvtChartEventManager.superclass.hideTooltip.call(this);
}


/**
 * @override
 */
DvtChartEventManager.prototype.getTooltipsEnabled = function() {
  // Don't allow tooltips to conflict with the data cursor
  if(this._dataCursorHandler && this._dataCursorHandler.isDataCursorShown())
    return false;
  else
    return DvtChartEventManager.superclass.getTooltipsEnabled.call(this);
}

/**
 * Sets the series rollover handler.
 * @param {DvtChartSeriesRolloverHandler} handler The series rollover handler.
 */
DvtChartEventManager.prototype.setSeriesRolloverHandler = function(handler) {
  this._seriesRolloverHandler = handler;
}

/**
 * Sets the data cursor handler.
 * @param {DvtDCEH} handler The data cursor handler.
 */
DvtChartEventManager.prototype.setDataCursorHandler = function(handler) {
  this._dataCursorHandler = handler;
}

/**
 * Sets the pan zoom handler.
 * @param {DvtPanZoomHandler} handler The pan zoom handler.
 */
DvtChartEventManager.prototype.setPanZoomHandler = function(handler) {
  this._panZoomHandler = handler;
}

/**
 * Sets the marquee zoom handler.
 * @param {DvtMarqueeHandler} handler The marquee zoom handler.
 */
DvtChartEventManager.prototype.setMarqueeZoomHandler = function(handler) {
  this._marqueeZoomHandler = handler;
}

/**
 * Sets the marquee select handler.
 * @param {DvtMarqueeHandler} handler The marquee select handler.
 */
DvtChartEventManager.prototype.setMarqueeSelectHandler = function(handler) {
  this._marqueeSelectHandler = handler;
}

/**
 * Cancels marquee zoom/select.
 * @param {event} The event
 * @return {boolean} Whether a marquee is canceled.
 */
DvtChartEventManager.prototype.cancelMarquee = function(event) {
  if (this._dragMode == DvtChartEventManager.DRAG_MODE_ZOOM) {
    if (this._marqueeZoomHandler.cancelMarquee())
      event.preventDefault();
  }
  else if (this._dragMode == DvtChartEventManager.DRAG_MODE_SELECT) {
    // If marquee is in progress, re-render from the options obj, which has the old selection
    if(this._marqueeSelectHandler && this._marqueeSelectHandler.cancelMarquee())
      this._chart.render();
  }
}

/**
 * Gets the current drag mode.
 * @return {string} The drag mode.
 */
DvtChartEventManager.prototype.getDragMode = function() {
  return this._dragMode;
}

/**
 * Sets the drag mode. If set to null, the drag mode will become the default one.
 * @param {string} dragMode The drag mode, or null.
 */
DvtChartEventManager.prototype.setDragMode = function(dragMode) {
  if (dragMode == null)
    this._dragMode = this._getDefaultDragMode();
  else
    this._dragMode = dragMode;
  
  // If the chart is fully zoomed out, the pan mode should fall back to the zoom mode on desktop
  if (this._chart.xAxis.isFullViewport() && (!this._chart.yAxis || this._chart.yAxis.isFullViewport()))
    this.autoToggleZoomButton();
}

/**
 * Returns the default drag mode for the chart.
 * @return {string} The default drag mode.
 * @private
 */
DvtChartEventManager.prototype._getDefaultDragMode = function() {
  if (DvtAgent.isTouchDevice())
    return DvtChartEventManager.DRAG_MODE_TOOLTIP;
  else if (DvtChartEventUtils.isScrollable(this._chart))
    return DvtChartEventManager.DRAG_MODE_PAN;
  else if (this._chart.getOptions()['selection'] == 'multiple')
    return DvtChartEventManager.DRAG_MODE_SELECT;
  else
    return null;
}

/**
 * Handles the zoom button click event.
 * @param {object} event
 */
DvtChartEventManager.prototype.onZoomButtonClick = function(event) {
  if (this.zoomButton.isToggled()) {
    if (this.selectButton)
      this.selectButton.setToggled(false);
    this.setDragMode(DvtChartEventManager.DRAG_MODE_ZOOM);
  }
  else
    this.setDragMode(null);
}

/**
 * Handles the pan button click event.
 * @param {object} event
 */
DvtChartEventManager.prototype.onPanButtonClick = function(event) {
  if (this.panButton.isToggled()) {
    if (this.selectButton)
      this.selectButton.setToggled(false);
    this.setDragMode(DvtChartEventManager.DRAG_MODE_PAN); 
  }
  else
    this.setDragMode(null);
}

/**
 * Handles the select button click event.
 * @param {object} event
 */
DvtChartEventManager.prototype.onSelectButtonClick = function(event) {
  if (this.selectButton.isToggled()) {
    if (this.zoomButton)
      this.zoomButton.setToggled(false);
    if (this.panButton)
      this.panButton.setToggled(false);
    this.setDragMode(DvtChartEventManager.DRAG_MODE_SELECT);
  }
  else
    this.setDragMode(null);
}

/**
 * Sets the visibility of the drag buttons.
 * @param {boolean} visible The visibility.
 */
DvtChartEventManager.prototype.setDragButtonsVisible = function(visible) {
  if (visible && !this._dragButtonsVisible) {
    this._chart.showDragButtons();
    this._dragButtonsVisible = true;
  } 
  else if (!visible && this._dragButtonsVisible) {
    this._chart.hideDragButtons();
    this._dragButtonsVisible = false;
  }
}

/**
 * Returns whether the drag buttons are visible.
 * @return {boolean}
 */
DvtChartEventManager.prototype.areDragButtonsVisible = function() {
  return this._dragButtonsVisible;
}

/**
 * Toggles the marquee zoom button automatically:
 * - Marquee select button is unaffected.
 * - If the chart is fully zoomed out, turn on the marquee zoom mode; otherwise, turn it off.
 * Doesn't apply to touch devices.
 */
DvtChartEventManager.prototype.autoToggleZoomButton = function() {
  if (DvtAgent.isTouchDevice() || !this.zoomButton)
    return;
  
  if (this._chart.xAxis.isFullViewport() && this._chart.yAxis.isFullViewport()) {
    if (this._dragMode == DvtChartEventManager.DRAG_MODE_PAN) {
      this.zoomButton.setToggled(true);
      this.onZoomButtonClick(null);
      this._chart.setCursor("crosshair");
    }
  } else {
    if (this._dragMode == DvtChartEventManager.DRAG_MODE_ZOOM) {
      this.zoomButton.setToggled(false);
      this.onZoomButtonClick(null);
      this._chart.setCursor(this._panZoomHandler.getCursor());
    }
  }
}
/*---------------------------------------------------------------------------------*/
/*  DvtChartKeyboardHandler     Keyboard handler for Chart                         */
/*---------------------------------------------------------------------------------*/
/**
  *  @param {DvtEventManager} manager The owning DvtEventManager 
  *  @class DvtChartKeyboardHandler
  *  @extends DvtKeyboardHandler
  *  @constructor
  */
var  DvtChartKeyboardHandler = function(manager, chart)
{
    this.Init(manager, chart);
};

DvtObj.createSubclass(DvtChartKeyboardHandler, DvtKeyboardHandler, "DvtChartKeyboardHandler");

/**
 * @override
 */
DvtChartKeyboardHandler.prototype.Init = function(manager, chart) {
  DvtChartKeyboardHandler.superclass.Init.call(this, manager);
  this._chart = chart;
}

/**
 * @override
 */
DvtChartKeyboardHandler.prototype.isSelectionEvent = function(event)
{
  return  this.isNavigationEvent(event) && !event.ctrlKey;
}

/**
 * @override
 */ 
DvtChartKeyboardHandler.prototype.isMultiSelectEvent = function(event)
{
  return  event.keyCode == DvtKeyboardEvent.SPACE && event.ctrlKey;
}

/**
 * @override
 */ 
DvtChartKeyboardHandler.prototype.processKeyDown = function(event) {
  var keyCode = event.keyCode;
  if (keyCode == DvtKeyboardEvent.TAB) {
    var currentNavigable = this._eventManager.getFocus();
    var next = null;
    event.preventDefault();
    if (!currentNavigable) {
      var navigables;
      if (DvtChartTypeUtils.isPie(this._chart)) {
        navigables = this._chart.pieChart.__getSlices();
      } else {
        navigables = this._chart.getObjects();
      }
      next = DvtChartKeyboardHandler.superclass.getDefaultNavigable.call(this, navigables);
    }
    else {
      next = currentNavigable;
    }
    if (next)     
      this._eventManager.setFocus(next);
    return next;      
  }
  else if (keyCode == DvtKeyboardEvent.ESCAPE) {
    this._eventManager.cancelMarquee(event);
  }
  return DvtChartKeyboardHandler.superclass.processKeyDown.call(this, event);
};

/**
 *  Series rollover event handler performs rollover effects on the object's
 *  behalf.
 *  @param {DvtGraphCore}  the owning chart object.
 *  @class  DvtSeriesRolloverHandler
 *  @constructor
 */
var DvtSeriesRolloverHandler = function (chart) {
  this.Init(chart)
};

DvtObj.createSubclass(DvtSeriesRolloverHandler, DvtObj, "DvtSeriesRolloverHandler");

DvtSeriesRolloverHandler.prototype.Init = function () {
};

/**
 * Processes a mouse over event on the specified object.
 * @param {object} obj The logical object.
 */
DvtSeriesRolloverHandler.prototype.processMouseOver = function(obj) {
  this.ProcessEvent(obj, true);
}

/**
 * Processes a mouse out event on the specified object.
 * @param {object} obj The logical object.
 */
DvtSeriesRolloverHandler.prototype.processMouseOut = function(obj) {
  this.ProcessEvent(obj, false);
}

/*
 * Subclasses override
 */
DvtSeriesRolloverHandler.prototype.ProcessEvent = function(obj, bOver) {
}
/**
 * @constructor
 */
var DvtChartSeriesRolloverHandler = function (chart, handler) {
  this.Init(chart, handler)
};

DvtObj.createSubclass(DvtChartSeriesRolloverHandler, DvtSeriesRolloverHandler, "DvtChartSeriesRolloverHandler");

DvtChartSeriesRolloverHandler.prototype.Init = function (chart, handler) {
  DvtChartSeriesRolloverHandler.superclass.Init.call(this);
  this._chart = chart;
  // TODO: don't need to pass in handler
  this.EventHandler = handler;
};

/**
 * @param {object} obj The logical object.
 * @param {boolean} bOver True if this is a rollOver.
 * @private
 */
DvtChartSeriesRolloverHandler.prototype.ProcessEvent = function (obj, bOver) {
  this._rolloverHandled = false;
  if (!obj)
    return;

  var rolloverContainer = this.getRolloverContainer();
  var eventType = bOver ? DvtCategoryRolloverEvent.TYPE_OVER : DvtCategoryRolloverEvent.TYPE_OUT;    
  var categories = obj.getCategories ? obj.getCategories() : null;
  if (categories && categories.length > 0) {
    this.EventHandler.FireEvent(new DvtCategoryRolloverEvent(eventType, categories), rolloverContainer);
    this._rolloverHandled = true;
  }
}

DvtChartSeriesRolloverHandler.prototype.isRolloverHandled = function () {
  return this._rolloverHandled;
}

DvtChartSeriesRolloverHandler.prototype.getRolloverContainer = function () {
  return this._chart;
}
/**
 * Overview window for chart.
 * @param {DvtContext} context The rendering context.
 * @param {string} callback The function that should be called to dispatch component events.
 * @param {object} callbackObj The object instance on which the callback function is defined.
 * @param {string} id The id of the parent chart.
 * @class
 * @constructor
 * @extends {DvtOverview}
 */
var DvtChartOverview = function(context, callback, callbackObj, id) {
  this.Init(context, callback, callbackObj);
  this._chart = null;
  this._id = id + "_overview";
}

DvtObj.createSubclass(DvtChartOverview, DvtOverview, "DvtChartOverview");

/**
 * Renders the background chart at the specified width and height.
 * @param {object} options Chart options.
 * @param {number} width Chart width.
 * @param {number} height Chart height.
 * @return {number} Chart plot area height.
 */
DvtChartOverview.prototype._renderChart = function(options, width, height) {
  this._chartContainer = new DvtContainer(this.getCtx());
  this.addChild(this._chartContainer);
  
  // Set the options override for the overview background chart
  optionsOverride = {
    'zoomAndScroll': "off",
    'legend': {'rendered': "off"},
    'xAxis': {
      'viewportMin': null, 'viewportMax': null, 'viewportStartGroup': null, 'viewportEndGroup': null, 
      'axisLine': {'rendered': "off"},
      'title': null
    },
    'yAxis': {
      'axisLine': {'rendered': "off"},
      'tickLabel': {'rendered': "off"},
      'majorTick': {'rendered': "off"},
      'minorTick': {'rendered': "off"},
      'title': null
    },
    'y2Axis': {
      'axisLine': {'rendered': "off"},
      'tickLabel': {'rendered': "off"},
      'majorTick': {'rendered': "off"},
      'minorTick': {'rendered': "off"},
      'title': null
    },
    'title': {'text': null},
    'subtitle': {'text': null},
    'footnote': {'text': null},
    'titleSeparator': {'rendered': "off"},
    'layout': {'outerGapWidth': 0, 'outerGapHeight': 0, 'tickLabelGapWidth': 0},
    '_isOverview': true
  };
  options = DvtJSONUtils.merge(optionsOverride, options);
  if (options['timeAxisType'] == 'disabled')
    options['xAxis']['tickLabel']['rendered'] = "off";
  
  // render the chart
  this._chart = DvtChart.newInstance(this.getCtx());
  this._chart.setId(this._id); // Set the id to prevent randomly generated one from breaking tests
  this._chartContainer.addChild(this._chart);
  this._chart.render(options, width, height);
  
  // cover the chart with a glass pane to prevent interaction
  var glassPane = new DvtRect(this.getCtx(), 0, 0, width, height);
  glassPane.setInvisibleFill();
  this._chartContainer.addChild(glassPane);
  
  return this._chart.__getPlotAreaSpace().h;
}

/**
 * @override
 */
DvtChartOverview.prototype.createBackground = function(width, height) {
  // pass. Handled by _renderChart().
}

/**
 * Override to change some of the styles
 * @override
 */
DvtChartOverview.prototype.render = function(options, width, height) {
  // override styles
  options['style'] = {
    'overviewBackgroundColor': "rgba(0,0,0,0)",
    'windowBackgroundColor': "rgba(0,0,0,0)",
    'windowBorderTopColor': "#333333",
    'windowBorderRightColor': "#333333",
    'windowBorderBottomColor': "#333333",
    'windowBorderLeftColor': "#333333",
    'leftFilterPanelColor': "rgba(5,65,135,0.1)",
    'rightFilterPanelColor': "rgba(5,65,135,0.1)",
    'handleBackgroundImage': options['chart']['_resources']['overviewGrippy'],
    'handleWidth': 3,
    'handleHeight': 15,
    'handleFillColor': "rgba(0,0,0,0)"
  };
  options['animationOnClick'] = "off";
  
  var windowHeight = this._renderChart(options['chart'], width, height);

  // now call super to render the scrollbar
  DvtChartOverview.superclass.render.call(this, options, width, windowHeight);
}

/**
 * Returns the overview background chart.
 * @return {DvtChart} Overview background chart.
 */
DvtChartOverview.prototype.getBackgroundChart = function() {
  return this._chart;
}

/**
 * Renders filters beside the sliding window
 * @override
 */
DvtChartOverview.prototype.isLeftAndRightFilterRendered = function() {
  return true;
}
// Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.
/**
 * Logical object for chart data object displayables.
 * @param {DvtChartImpl} chart The owning chart instance.
 * @param {array} displayables The array of associated DvtDisplayables.
 * @param {number} seriesIndex
 * @param {number} groupIndex
 * @param {DvtPoint} dataPos The coordinate of the data point relative to the plot area
 * @class
 * @constructor
 * @implements {DvtCategoricalObject}
 * @implements {DvtLogicalObject}
 * @implements {DvtPopupSource}
 * @implements {DvtSelectable}
 * @implements {DvtTooltipSource}
 */
var DvtChartObjPeer = function (chart, displayables, seriesIndex, groupIndex, dataPos) {
  this.Init(chart, displayables, seriesIndex, groupIndex, dataPos);
}

DvtObj.createSubclass(DvtChartObjPeer, DvtObj, "DvtChartObjPeer");

/**
 * @param {DvtChartImpl} chart The owning chart instance.
 * @param {array} displayables The array of associated DvtDisplayables.
 * @param {number} seriesIndex
 * @param {number} groupIndex
 * @param {DvtPoint} dataPos The coordinate of the data point relative to the plot area
 */
DvtChartObjPeer.prototype.Init = function (chart, displayables, seriesIndex, groupIndex, dataPos) {
  this._chart = chart;
  this._displayables = displayables;
  this._series = null;
  this._group = null;
  this._dataPos = dataPos

  // Set series to -1 if not specified
  if (!isNaN(seriesIndex))
    this._seriesIndex = seriesIndex;
  else 
    this._seriesIndex =  -1;

  // Cache the series id, which is used for interactivity
  if (this._seriesIndex >= 0)
    this._series = DvtChartDataUtils.getSeries(chart, this._seriesIndex);
  
  // Set group to -1 if not specified
  if (!isNaN(groupIndex))
    this._groupIndex = groupIndex;
  else 
    this._groupIndex =  -1;

  // Cache the group id, which is used for datachange animation.
  if (this._groupIndex >= 0)
    this._group = DvtChartDataUtils.getGroup(chart, this._groupIndex);
  
  var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
  if (seriesItem) {
    this._action = seriesItem['action'];
    
    // Popup Support: Store the stamp id for this series item, which is used to look up the popup behaviors
    this._stampId = seriesItem['_id'];
  }
  
  // Create the array specifying all categories that this data item belongs to
  this._categories = (this._series != null) ? [this._series] : [];
  var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);
  if (dataItem) {
    if (dataItem['categories'])
      this._categories = this._categories.concat(dataItem['categories']);

    this._dataItemId = dataItem['id'];
    this._action = dataItem['action']; // override the series action
    
    // Popup Support: Override the series stamp id
    this._stampId = dataItem['_id'];
  }
  
  // Apply the cursor for the action if specified
  if (this._action) {
    for (var i = 0;i < this._displayables.length;i++) {
      this._displayables[i].setCursor(DvtSelectionEffectUtils.getSelectingCursor());
    }
  }
  
  // Apply the aria properties if we can't defer their addition
  if(!DvtAgent.deferAriaCreation()) {
    var ariaLabel = this.getDatatip(null);
    for(var index=0; index<displayables.length; index++) {
      displayables[index].setAriaRole('img');
      displayables[index].setAriaProperty('label', ariaLabel);
    }
  }

  this._isSelected = false;
}

/**
 * Creates a data item to identify the specified displayable and registers it with the chart.
 * @param {DvtDisplayable} displayable The displayable to associate.
 * @param {DvtChartImpl} chart The owning chart instance.
 * @param {number} seriesIndex
 * @param {number} groupIndex
 * @param {DvtPoint} dataPos The coordinate of the data point relative to the plot area
 */
DvtChartObjPeer.associate = function (displayable, chart, seriesIndex, groupIndex, dataPos) {
  if (!displayable)
    return;

  // Create the logical object. 
  var identObj = new DvtChartObjPeer(chart, [displayable], seriesIndex, groupIndex, dataPos);

  // Register with the chart
  chart.registerObject(identObj);

  // Finally associate using the event manager  
  chart.getEventManager().associate(displayable, identObj);
};

/**
 * @override
 */
DvtChartObjPeer.prototype.getId = function () {
  if (this._series != null && this._group != null)
    return new DvtChartDataItem(this._dataItemId, this._series, this._group);
  else if (this._series != null)
    return this._series;
  else 
    return null;
}

/**
 * Return the peer's data item id.  This is an optional id that is provided to simplifying
 * row key support for ADF and AMX.
 * @returns {string} the peer's row key.
 */
DvtChartObjPeer.prototype.getDataItemId = function () {
  return this._dataItemId;
}

/**
 * Return the peer's series.
 * @returns {string} the peer's series.
 */
DvtChartObjPeer.prototype.getSeries = function () {
  return this._series;
}

/**
 * Return the peer's series index.
 * @returns {Number} the peer's series index.
 */
DvtChartObjPeer.prototype.getSeriesIndex = function () {
  return this._seriesIndex;
}

/**
 * Return the peer's group.
 * @returns {string} the peer's group.
 */
DvtChartObjPeer.prototype.getGroup = function () {
  return this._group;
}

/**
 * Return the peer's group index.
 * @returns {Number} the peer's group index.
 */
DvtChartObjPeer.prototype.getGroupIndex = function () {
  return this._groupIndex;
}

/**
 * Return the action string for the data item, if any exists.
 * @returns {string} the action outcome for the data item.
 */
DvtChartObjPeer.prototype.getAction = function () {
  return this._action;
}

/**
 * Convenience function to return the peer's chart.
 * @returns {DvtChart} the associated chart object.
 */
DvtChartObjPeer.prototype.getChart = function () {
  return this._chart;
}

/**
 * Return the peer's series type.
 * @returns {string} the peer's series type.
 */
DvtChartObjPeer.prototype.getSeriesType = function () {
  return DvtChartStyleUtils.getSeriesType(this._chart, this._seriesIndex);
}

/**
 * Return the peer's series item.
 * @returns {object} the peer's series item.
 */
DvtChartObjPeer.prototype.getSeriesItem = function () {
  return DvtChartDataUtils.getSeriesItem(this._chart, this._seriesIndex);
}

//---------------------------------------------------------------------//
// Tooltip Support: DvtTooltipSource impl                              //
//---------------------------------------------------------------------//

/**
 * @override
 */
DvtChartObjPeer.prototype.getDatatip = function (target) {
  return DvtChartTooltipUtils.getDatatip(target, this._chart, this._seriesIndex, this._groupIndex);
}

/**
 * @override
 */
DvtChartObjPeer.prototype.getDatatipColor = function () {
  return DvtChartTooltipUtils.getDatatipColor(this._chart, this._seriesIndex, this._groupIndex);
}

//---------------------------------------------------------------------//
// Selection Support: DvtSelectable impl                               //
//---------------------------------------------------------------------//

/**
 * @override
 */
DvtChartObjPeer.prototype.isSelectable = function () {
  return this.getChart().isSelectionSupported() && this._series != null && this._group != null;
}

/**
 * @override
 */
DvtChartObjPeer.prototype.isSelected = function () {
  return this._isSelected;
}

/**
 * @override
 */
DvtChartObjPeer.prototype.setSelected = function (bSelected) {
  this._isSelected = bSelected;
  for (var i = 0;i < this._displayables.length;i++) {
    if (this._displayables[i].setSelected)
      this._displayables[i].setSelected(bSelected);
  }
}

/**
 * @override
 */
DvtChartObjPeer.prototype.showHoverEffect = function () {
  for (var i = 0;i < this._displayables.length;i++) {
    if (this._displayables[i].showHoverEffect)
      this._displayables[i].showHoverEffect();
  }
}

/**
 * @override
 */
DvtChartObjPeer.prototype.hideHoverEffect = function () {
  for (var i = 0;i < this._displayables.length;i++) {
    if (this._displayables[i].hideHoverEffect)
      this._displayables[i].hideHoverEffect();
  }
}

//---------------------------------------------------------------------//
// Popup Support: DvtPopupSource impl                                  //
//---------------------------------------------------------------------//

/**
 * @override
 */
DvtChartObjPeer.prototype.getShowPopupBehaviors = function() {
  return this._chart.getShowPopupBehaviors(this._stampId);
}

//---------------------------------------------------------------------//
// Rollover and Hide/Show Support: DvtLogicalObject impl               //
//---------------------------------------------------------------------//

/**
 * @override
 */
DvtChartObjPeer.prototype.getDisplayables = function () {
  return this._displayables;
}

/**
 * @override
 */
DvtChartObjPeer.prototype.getAriaLabel = function () {
  return this.getDatatip(null);
}

//---------------------------------------------------------------------//
// Rollover and Hide/Show Support: DvtCategoricalObject impl           //
//---------------------------------------------------------------------//
/**
 * @override
 */
DvtChartObjPeer.prototype.getCategories = function (category) {
  return this._categories;
};


/**
 * @return {DvtPoint} The coordinate of the data point relative to the plot area 
 */
DvtChartObjPeer.prototype.getDataPosition = function () {
  return this._dataPos;
};

//---------------------------------------------------------------------//
// Keyboard Support: DvtKeyboardNavigables impl                        //
//---------------------------------------------------------------------//
/**
 * @override
 */
DvtChartObjPeer.prototype.getNextNavigable = function (event) {
  var keyCode;
  var next;

  keyCode = event.keyCode;
  if (event.type == DvtMouseEvent.CLICK) {
    return this;
  }
  else if (keyCode == DvtKeyboardEvent.SPACE && event.ctrlKey) {
    // multi-select node with current focus; so we navigate to ourself and then let the selection handler take
    // care of the selection
    return this;
  }

  var chart = this._chart;
  var chartObjs = chart.getObjects();
  
  var navigables = [];
  for (var i = 0; i < chartObjs.length; i++) {
    if (chartObjs[i].isNavigable())
      navigables.push(chartObjs[i]);
  }

  if (DvtChartTypeUtils.isScatterBubble(chart)) {
    next = DvtKeyboardHandler.getNextAdjacentNavigable(this, event, navigables);
  }
  else if (DvtChartTypeUtils.isArea(chart) || DvtChartTypeUtils.isLine(chart) || DvtChartTypeUtils.isStacked(chart)) {
    next = this._findNextNavigable(event);
  }
  else if (DvtChartTypeUtils.isFunnel(chart) && (event.keyCode == DvtKeyboardEvent.UP_ARROW || event.keyCode == DvtKeyboardEvent.DOWN_ARROW)) {
    var newEvent = event.clone();
    event.keyCode = event.keyCode - 1;
    next = DvtKeyboardHandler.getNextNavigable(this, event, navigables);
  }
  else {
    next = DvtKeyboardHandler.getNextNavigable(this, event, navigables);
  }
  return next;
}

/**
 * @override
 */
DvtChartObjPeer.prototype.getKeyboardBoundingBox = function () {
  if (this._displayables[0])
    return this._displayables[0].getDimensions();
  else 
    return new DvtRectangle(0, 0, 0, 0);
}

/**
 * @override
 */
DvtChartObjPeer.prototype.showKeyboardFocusEffect = function () {
  if (this.isNavigable()) {
    this._isShowingKeyboardFocusEffect = true;
    this.showHoverEffect();
  }
};

/**
 * @override
 */
DvtChartObjPeer.prototype.hideKeyboardFocusEffect = function () {
  if (this.isNavigable()) {
    this._isShowingKeyboardFocusEffect = false;
    this.hideHoverEffect();
  }
};

/**
 * @override
 */
DvtChartObjPeer.prototype.isShowingKeyboardFocusEffect = function () {
  return this._isShowingKeyboardFocusEffect;
}

/**
 * Returns true if the object is navigable
 */
DvtChartObjPeer.prototype.isNavigable = function () {
  return this.getGroupIndex() != -1 && this.getSeriesIndex() != -1;
}

/**
 * Returns the next navigable object in the direction of the arrow
 */
DvtChartObjPeer.prototype._findNextNavigable = function (event) {
  var keyCode = event.keyCode;
  var chart = this._chart;
  var context = chart.getCtx();
  var seriesIndex = this.getSeriesIndex();
  var groupIndex = this.getGroupIndex();
  var seriesCount = DvtChartDataUtils.getSeriesCount(chart);
  var groupCount = DvtChartDataUtils.getGroupCount(chart);
  var nextUpSeriesIndex = this._findNextUpSeries(chart, seriesIndex, groupIndex);
  var nextDownSeriesIndex = this._findNextDownSeries(chart, seriesIndex, groupIndex);
  var nextSeriesIndex;
  var nextGroupIndex;
  var isRTL = DvtAgent.isRightToLeft(context);

  if (DvtChartTypeUtils.isStacked(chart) && keyCode == DvtKeyboardEvent.DOWN_ARROW && seriesIndex > 0) {
    nextSeriesIndex = seriesIndex - 1;
    nextGroupIndex = groupIndex;
  }
  else if (DvtChartTypeUtils.isStacked(chart) && keyCode == DvtKeyboardEvent.UP_ARROW && seriesIndex < seriesCount - 1) {
    nextSeriesIndex = seriesIndex + 1;
    nextGroupIndex = groupIndex;
  }
  else if (!DvtChartTypeUtils.isStacked(chart) && keyCode == DvtKeyboardEvent.UP_ARROW && nextUpSeriesIndex != null) {
    nextSeriesIndex = nextUpSeriesIndex;
    nextGroupIndex = groupIndex;
  }
  else if (!DvtChartTypeUtils.isStacked(chart) && keyCode == DvtKeyboardEvent.DOWN_ARROW && nextDownSeriesIndex != null) {
    nextSeriesIndex = nextDownSeriesIndex;
    nextGroupIndex = groupIndex;
  }
  else if (keyCode == DvtKeyboardEvent.RIGHT_ARROW && groupIndex < groupCount - 1 && !isRTL) {
    nextSeriesIndex = seriesIndex;
    nextGroupIndex = groupIndex + 1;
  }
  else if (keyCode == DvtKeyboardEvent.LEFT_ARROW && groupIndex > 0 && !isRTL) {
    nextSeriesIndex = seriesIndex;
    nextGroupIndex = groupIndex - 1;
  }
  else if (keyCode == DvtKeyboardEvent.RIGHT_ARROW && groupIndex > 0 && isRTL) {
    nextSeriesIndex = seriesIndex;
    nextGroupIndex = groupIndex - 1;
  }
  else if (keyCode == DvtKeyboardEvent.LEFT_ARROW && groupIndex < groupCount - 1 && isRTL) {
    nextSeriesIndex = seriesIndex;
    nextGroupIndex = groupIndex + 1;
  }
  else {
    return this;
  }
  return chart.getObject(nextSeriesIndex, nextGroupIndex);
}

/**
 * Returns the index of the next up series
 */
DvtChartObjPeer.prototype._findNextUpSeries = function (chart, seriesIndex, groupIndex) {
  var seriesCount = DvtChartDataUtils.getSeriesCount(chart);
  var currentValue = DvtChartDataUtils.getValue(chart, seriesIndex, groupIndex);
  var nextValue = null;
  var nextSeriesIndex = null;
  for (var i = 0;i < seriesCount;i++) {
    var itemValue = DvtChartDataUtils.getValue(chart, i, groupIndex);
    if (itemValue > currentValue || (itemValue == currentValue && i > seriesIndex)) {
      if ((nextValue !== null && itemValue < nextValue) || (nextValue == null)) {
        nextValue = itemValue;
        nextSeriesIndex = i;
      }
    }
  }
  return nextSeriesIndex;
}

/**
 * Returns the index of the next down series
 */
DvtChartObjPeer.prototype._findNextDownSeries = function (chart, seriesIndex, groupIndex) {
  var seriesCount = DvtChartDataUtils.getSeriesCount(chart);
  var currentValue = DvtChartDataUtils.getValue(chart, seriesIndex, groupIndex);
  var nextValue = null;
  var nextSeriesIndex = null;
  for (var i = seriesCount - 1;i >= 0;i--) {
    var itemValue = DvtChartDataUtils.getValue(chart, i, groupIndex);
    if (itemValue < currentValue || (itemValue == currentValue && i < seriesIndex)) {
      if ((nextValue !== null && itemValue > nextValue) || (nextValue == null)) {
        nextValue = itemValue;
        nextSeriesIndex = i;
      }
    }
  }
  return nextSeriesIndex;
}
/**
  * Creates an object representing the ID of a chart data item.
  * @constructor  
  * @param {string} id The ID for the data item, if available.
  * @param {string} series The series ID for the chart data item.
  * @param {string} group The group ID for the chart data item.
  * @export
  */
var DvtChartDataItem = function(id, series, group) {
  this.Init(id, series, group);
}

DvtObj.createSubclass(DvtChartDataItem, DvtObj, "DvtChartDataItem");

/**
 * Initializes the component.
 * @param {string} id The ID for the data item, if available.
 * @param {string} series The series ID.
 * @param {string} group The group ID.
 * @protected
 */
DvtChartDataItem.prototype.Init = function(id, series, group) {
  this._id = id;
  this._series = series;
  this._group = group;
}

/**
 * Returns the ID for the data item, if available.
 * @return {string} The data item ID.
 * @export
 */
DvtChartDataItem.prototype.getId = function() {
  return this._id;
}

/**
 * Returns the series ID for a chart data item.
 * @return {string} The series ID.
 * @export
 */
DvtChartDataItem.prototype.getSeries = function() {
  return this._series;
}

/**
 * Returns the group ID for a chart data item.
 * @return {string} The group ID.
 * @export
 */
DvtChartDataItem.prototype.getGroup = function() {
  return this._group;
}

/**
 * Determines if two DvtChartDataItem objects are equal.
 *
 * @param {DvtChartDataItem} The data item that will be used to test for equality.
 * @return {boolean} True if the two DvtChartDataItem objects are equal
 */
DvtChartDataItem.prototype.equals = function(dataItem) {
  // Note that the id is not compared, because the series and group ids are considered the primary identifiers.
  if(dataItem instanceof DvtChartDataItem)
    return this._group === dataItem.getGroup() && this._series === dataItem.getSeries();
  else
    return false;
}
/**
 * Default values and utility functions for component versioning.
 * @class
 * @constructor
 * @extends {DvtBaseComponentDefaults}
 */
var DvtChartDefaults = function() {
  this.Init({'skyros': DvtChartDefaults.VERSION_1, 'alta': DvtChartDefaults.SKIN_ALTA});
}

DvtObj.createSubclass(DvtChartDefaults, DvtBaseComponentDefaults, "DvtChartDefaults");

/**
 * Contains overrides for the 'alta' skin.
 */ 
DvtChartDefaults.SKIN_ALTA = {
  'skin': DvtCSSStyle.SKIN_ALTA,
  'title': {'style': new DvtCSSStyle("font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 13px; color: #252525;")},
  'subtitle': {'style': new DvtCSSStyle("font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; color: #252525;")},
  'footnote': {'style': new DvtCSSStyle("font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 11px;")},
  
  'styleDefaults': {
    'seriesEffect': "color",
    'colors': DvtCSSStyle.COLORS_ALTA,
    'sliceLabelStyle': new DvtCSSStyle("font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;"),
    'dataLabelStyle': new DvtCSSStyle("font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;")
  }
}

/**
 * Defaults for version 1.
 */ 
DvtChartDefaults.VERSION_1 = {
  'skin': DvtCSSStyle.SKIN_SKYROS,
  'type': "bar", 'stack': "off", 'emptyText': null, 
  'selection': "none", 'hideAndShowBehavior': "none", 'zoomAndScroll': "off",
  'hoverBehavior': "none", 'sorting': "off",
  'otherThreshold': 0, 
  'animationOnDataChange': "none", 'animationOnDisplay': "none", 
  'timeAxisType': "disabled",
  '__sparkBarSpacing': 'subpixel', '__spark': false, 
  'dataCursor': "auto", 'dataCursorBehavior': "auto",
  
  'title': {'style': new DvtCSSStyle("font-size: 12px; color: #003d5b; font-weight: bold"), 'hAlign': "start"},
  'subtitle': {'style': new DvtCSSStyle("font-size: 12px; color: #003d5b;")},
  'footnote': {'style': new DvtCSSStyle("font-size: 10px; color: #333333;"), 'hAlign': "start"},
  'titleSeparator': { 'upperColor': "#74779A", 'lowerColor': "#FFFFFF", 'rendered': "off"},
  
  'xAxis': {
    'baselineScaling': "zero",
    'tickLabel': {'rendered': "on"},
    'majorTick': {'rendered': "auto"},
    'minorTick': {'rendered': "off"},
    'axisLine': {'rendered': "on"},
    'layout': {'gapRatio': 1.0}
  },
  'yAxis': {
    'baselineScaling': "zero",
    'tickLabel': {'rendered': "on"},
    'majorTick': {'rendered': "auto"},
    'minorTick': {'rendered': "off"},
    'axisLine': {'rendered': "on"},
    'layout': {'gapRatio': 1.0}
  },
  'y2Axis': {
    'baselineScaling': "zero",
    'tickLabel': {'rendered': "on"},
    'majorTick': {'rendered': "auto"},
    'minorTick': {'rendered': "off"},
    'axisLine': {'rendered': "on"},
    'layout': {'gapRatio': 1.0},
    'alignTickMarks': 'on'
  },
  
  'plotArea': {'backgroundColor': null},
  
  'legend': {
    'position': "auto",
    'rendered': "on",
    'layout': {'gapRatio': 1.0}
  },
  
  'overview': {
    'rendered': "off"
  },
  
  'styleDefaults': {
    'colors': DvtCSSStyle.COLORS_SKYROS,
    'patterns': ["smallDiagonalRight", "smallChecker", "smallDiagonalLeft", "smallTriangle", "smallCrosshatch", "smallDiamond", 
                 "largeDiagonalRight", "largeChecker", "largeDiagonalLeft", "largeTriangle", "largeCrosshatch", "largeDiamond"],
    'shapes': ["square", "circle", "diamond", "plus", "triangleDown", "triangleUp"],
    'seriesEffect': "gradient", 'threeDEffect': "off", 'borderColor': null, 
    'groupTooltipType': "auto", 'seriesTooltipType': "auto", 'valueTooltipType': "auto",
    'animationDuration': 1000, 'animationIndicators': "all", 
    'animationUpColor': "#0099FF", 'animationDownColor': "#FF3300",
    'lineWidth': 3, 'lineStyle': "solid",
    'markerDisplayed': 'off', 
    'markerColor': null, 'markerShape': "auto", 'markerSize': 8,
    'marqueeColor': 'rgba(255,255,255,0.5)', 'marqueeBorderColor': 'rgba(0,0,0,0.2)',
    'pieFeelerColor': "#BAC5D6", 
    'selectedInnerColor': '#ffffff', 'selectedOuterColor': '#5a5a5a',
    'sliceLabelPosition': "auto",
    'sliceLabelStyle': new DvtCSSStyle("font-size: 11px;"), 
    'sliceLabelType': "percent",
    'otherColor': "#4b4b4b",
    'dataLabelStyle': new DvtCSSStyle("font-size: 11px;"),
    'dataLabelPosition': "auto",
    'x1Format': {}, 'y1Format': {}, 'y2Format': {}, 'zFormat': {},
    '_defaultSliceLabelColor': "#333333",
    '_scrollbarHeight': 3, '_scrollbarTrackColor': "#F0F0F0", '_scrollbarHandleColor': "#9E9E9E"
  },
  
  'layout': {
    'gapRatio': null, // gapRatio is dynamic based on the component size
    // TODO, the following are internal and should be moved to a _layout object
    'outerGapWidth': 10, 'outerGapHeight': 8,
    'titleSubtitleGapWidth': 14, 'titleSubtitleGapHeight': 4,
    'titleSeparatorGap': 6, 'titlePlotAreaGap': 10, 'footnoteGap': 7, 'verticalAxisTopGap': 6,
    'legendMaxSize': 0.3, 'legendGap': 10,
    'axisMaxSize': 0.33, 'tickLabelGapHeight': 5, 'tickLabelGapWidth': 7
  },
  
  '_resources': {}
}

/**
 * Scales down gap sizes based on the size of the component.
 * @param {DvtChartImpl} chart The chart that is being rendered.
 * @param {Number} defaultSize The default gap size.
 * @return {Number} 
 */
DvtChartDefaults.getGapSize = function(chart, defaultSize) {
  return Math.ceil(defaultSize * chart.getGapRatio());
}

/**
 * Returns true if the skyros skin effects should be used.
 * @param {DvtChartImpl} chart
 * @return {boolean}
 */
DvtChartDefaults.isSkyrosSkin = function(chart) 
{
  return (chart.getOptions()['skin'] == DvtCSSStyle.SKIN_SKYROS);
}
/**
 * Axis related utility functions for DvtChartImpl.
 * @class
 */
var DvtChartAxisUtils = new Object();

DvtObj.createSubclass(DvtChartAxisUtils, DvtObj, "DvtChartAxisUtils");

/** @private */
DvtChartAxisUtils._BAR_AXIS_OFFSET = 0.5;

/**
 * Returns the position of the x axis relative to the chart.
 * @param {DvtChartImpl} chart
 * @return {string} The axis position
 */
DvtChartAxisUtils.getXAxisPosition = function(chart) {
  if(DvtChartTypeUtils.isPolar(chart))
    return "tangential";
  if(DvtChartTypeUtils.isHorizontal(chart))
    return DvtAgent.isRightToLeft(chart.getCtx()) ? "right" : "left";
  else
    return "bottom";
}

/**
 * Returns the position of the y axis relative to the chart.
 * @param {DvtChartImpl} chart
 * @return {string} The axis position
 */
DvtChartAxisUtils.getYAxisPosition = function(chart) {
  if(DvtChartTypeUtils.isPolar(chart))
    return "radial";
  if(DvtChartTypeUtils.isHorizontal(chart))
    return "bottom";
  else
    return DvtAgent.isRightToLeft(chart.getCtx()) ? "right" : "left";
}

/**
 * Returns the position of the y2 axis relative to the chart.
 * @param {DvtChartImpl} chart
 * @return {string} The axis position
 */
DvtChartAxisUtils.getY2AxisPosition = function(chart) {
  if(DvtChartTypeUtils.isHorizontal(chart))
    return "top";
  else
    return DvtAgent.isRightToLeft(chart.getCtx()) ? "left" : "right";
}

/**
 * Returns true if the chart has a time axis.
 * @param {DvtChartImpl} chart
 * @return {boolean}
 */
DvtChartAxisUtils.hasTimeAxis = function(chart) {
  if(DvtChartTypeUtils.isBLAC(chart))
    return chart.getOptions()['timeAxisType'] != "disabled";
  else
    return false;
}

/**
 * Returns true if the chart has a group axis.
 * @param {DvtChartImpl} chart
 * @return {boolean}
 */
DvtChartAxisUtils.hasGroupAxis = function(chart) {
  if(DvtChartTypeUtils.isBLAC(chart))
    return chart.getOptions()['timeAxisType'] == "disabled";
  else
    return false;
}

/**
 * Returns the offset before and after the groups for the specified chart.
 * @param {DvtChartImpl} chart
 * @return {number} The offset factor.
 */
DvtChartAxisUtils.getBarAxisOffset = function(chart) {
  // Use the offset for any graph with bars, or for single point line graph
  var bLineOrArea = (DvtChartTypeUtils.isLine(chart) || DvtChartTypeUtils.isArea(chart));
  if(DvtChartTypeUtils.hasBarSeries(chart) || (bLineOrArea && DvtChartDataUtils.getGroupCount(chart) == 1)) {
    return DvtChartAxisUtils._BAR_AXIS_OFFSET;
  }
  
  // Otherwise no offset
  return 0; 
}

/**
 * Returns the axis value on the x axis for the given parameters.  The axis value can be used 
 * to find the coordinate on the axis.
 * @param {object} dataItem 
 * @param {number} groupIndex
 * @return {number} The x value.
 */
DvtChartAxisUtils.getXAxisValue = function(dataItem, groupIndex) {
  if(dataItem == null || isNaN(dataItem.x)) // TODO pass chart in instead and be more explicit about group axis?
    return groupIndex;
  else if(dataItem)
    return dataItem.x;
}

/**
 * Returns whether the Y-axis labels are rendered.
 * @param {DvtChartImpl} chart
 * @return {boolean}
 */
DvtChartAxisUtils.areYAxisLabelsRendered = function(chart) {
  var options = chart.getOptions()['yAxis'];
  if (options['rendered'] == 'off')
    return false;
  if (options['tickLabel'] && options['tickLabel']['rendered'] && options['tickLabel']['rendered'] != 'on')
    return false;
  return true;
}
/**
 * Data related utility functions for DvtChartImpl.
 * @class
 */
var DvtChartDataUtils = new Object();

DvtObj.createSubclass(DvtChartDataUtils, DvtObj, "DvtChartDataUtils");

/** @private */
DvtChartDataUtils._TYPE_LABEL = "label";

/**
 * Returns true if the specified chart has data.
 * @param {DvtChartImpl} chart
 * @return {boolean}
 */
DvtChartDataUtils.hasData = function(chart) {
  var options = chart.getOptions();
  
  // Check that there is a data object with at least one series
  if(!options || !options['series'] || options['series'].length < 1)
    return false;  
    
  // Check that the minimum number of data points is present
  var minDataCount = 1;
  var seriesCount = DvtChartDataUtils.getSeriesCount(chart);
  for (var i = 0;i < seriesCount;i++) {
    var seriesItem = DvtChartDataUtils.getSeriesItem(chart, i);
    if(seriesItem && seriesItem['items'] && seriesItem['items'].length >= minDataCount)
      return true;
  }
  
  return false;
}

/**
 * Returns true if the specified chart series has non-null data.
 * @param {DvtChartImpl} chart
 * @param {number} seriesIndex
 * @return {boolean}
 */
DvtChartDataUtils.hasSeriesData = function(chart, seriesIndex) {
  var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
  var dataItems = seriesItem['items'];
  if(dataItems) {
    for(var i=0; i<dataItems.length; i++) {
      if(dataItems[i] != null)
        return true;
    }
  }
  
  // No data items or no non-null data items
  return false;
}


/**
 * Processes the data object.  Generates default group labels if none or
 * not enough have been specified.
 * @param {DvtChartImpl} chart
 */
DvtChartDataUtils.processDataObject = function (chart) {
  // If no data or unusable data, return
  if(!DvtChartDataUtils.hasData(chart))
    return;

  // Iterate through the series to keep track of the count and the series style indices
  var maxGroups = 0;
  var arSeriesStyle = chart.getSeriesStyleArray();
  var seriesCount = DvtChartDataUtils.getSeriesCount(chart);
  for(var i = 0;i < seriesCount;i++) {
    var series = DvtChartDataUtils.getSeries(chart, i);
    if(series != null && DvtArrayUtils.getIndex(arSeriesStyle, series) < 0) 
      arSeriesStyle.push(series);
    
    var seriesItem = DvtChartDataUtils.getSeriesItem(chart, i);
    if(seriesItem && seriesItem['items'] && seriesItem['items'].length > maxGroups)
      maxGroups = seriesItem['items'].length;
      
    if (DvtChartTypeUtils.isFunnel(chart)) // turn off legend series display for funnel
      seriesItem['displayInLegend'] = "off";
  }

  // Make sure the data object specifies enough groups
  var options = chart.getOptions();
  if (!options['groups'])
    options['groups'] = new Array();

  // Lengthen the array so that there are enough groups
  var bundle = chart.getBundle();
  while (options['groups'].length < maxGroups) {
    var group = bundle.getTranslatedString('DEFAULT_GROUP_NAME', options['groups'].length + 1);// +1 so we start at "Group 1"
    options['groups'].push(group);
  }
  
  if (DvtChartTypeUtils.isFunnel(chart)) // tooltips should not include the group for funnel charts
    options['styleDefaults']['groupTooltipType'] = "none";
}

/**
 * Returns the number of series in the specified chart.
 * @param {DvtChartImpl} chart
 * @return {number}
 */
DvtChartDataUtils.getSeriesCount = function (chart) {
  return chart.getOptions()['series'].length;
}

/**
 * Returns the id for the specified series.
 * @param {DvtChartImpl} chart
 * @param {number} seriesIndex
 * @return {string} The id of the series.
 */
DvtChartDataUtils.getSeries = function (chart, seriesIndex) {
  var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
  if (seriesItem) {
    if(seriesItem['id'])
      return seriesItem['id'];
    else if(seriesItem['name'] || seriesItem['name'] == "")
      return seriesItem['name'];
    else
      return String(seriesIndex);
  }
  else
    return null;
}

/**
 * Returns the label for the specified series.
 * @param {DvtChartImpl} chart
 * @param {number} seriesIndex
 * @return {string} The label for the series.
 */
DvtChartDataUtils.getSeriesLabel = function (chart, seriesIndex) {
  var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
  if (seriesItem && (seriesItem['name'] || seriesItem['name'] == ""))
    return seriesItem['name'];
  else 
    return null;
}

/**
 * Returns the index for the specified series.
 * @param {DvtChartImpl} chart
 * @param {string} series The id of the series
 * @return {number} The index of the series.
 */
DvtChartDataUtils.getSeriesIndex = function (chart, series) {
  var numSeries = DvtChartDataUtils.getSeriesCount(chart);
  for (var seriesIndex = 0;seriesIndex < numSeries;seriesIndex++) {
    var seriesId = DvtChartDataUtils.getSeries(chart, seriesIndex);
    if (seriesId == series) 
      return seriesIndex;
  }

  // No match found
  return  - 1;
}

/**
 * Returns the style index for the specified series.
 * @param {DvtChartImpl} chart
 * @param {string} series The id of the series
 * @return {number} The index to use when looking for style information.
 */
DvtChartDataUtils.getSeriesStyleIndex = function(chart, series) {
  if(series) {
    var arSeriesStyle = chart.getSeriesStyleArray();
    return DvtArrayUtils.getIndex(arSeriesStyle, series);
  }
  else 
    return DvtChartDataUtils.getSeriesIndex(chart, series);
}

/**
 * Returns the series item for the specified index.
 * @param {DvtChartImpl} chart
 * @param {number} seriesIndex
 * @return {object} The series data item.
 */
DvtChartDataUtils.getSeriesItem = function (chart, seriesIndex) {
  if (isNaN(seriesIndex) || seriesIndex == null)
    return null;

  var options = chart.getOptions();
  if (options['series'] && options['series'].length > seriesIndex)
    return options['series'][seriesIndex];
}

/**
 * Returns the data item for the specified index.
 * @param {DvtChartImpl} chart
 * @param {number} seriesIndex
 * @param {number} groupIndex
 * @return {object} The data item.
 */
DvtChartDataUtils.getDataItem = function (chart, seriesIndex, groupIndex) {
  if (isNaN(groupIndex) || groupIndex == null)
    return null;

  var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
  if (seriesItem && seriesItem['items'] && groupIndex >= 0 && seriesItem['items'].length > groupIndex)
    return seriesItem['items'][groupIndex];
}

/**
 * Returns the number of groups in the specified chart.
 * @param {DvtChartImpl} chart
 * @return {number}
 */
DvtChartDataUtils.getGroupCount = function (chart) {
  return chart.getOptions()['groups'].length;
}

/**
 * Returns the group id for the specified group index.
 * @param {DvtChartImpl} chart
 * @param {Number} groupIndex The group index.
 * @returns {string} The group id, null if the index is invalid.
 */
DvtChartDataUtils.getGroup = function (chart, groupIndex) {
  var groupItems = chart.getOptions()['groups'];
  if (groupIndex >= 0 && groupIndex < groupItems.length) {
    var group = groupItems[groupIndex];
    if(group) {
      if(group['id'])
        return group['id'];
      else if(group['name'] || group['name'] == "")
        return group['name'];
      else
        return group;
    }
  }
  
  return null;
}

/**
 * Returns the index of the group with the specified id.
 * @param {DvtChartImpl} chart
 * @returns {number} The index of the group
 */
DvtChartDataUtils.getGroupIndex = function (chart, group) {
  var groups = DvtChartDataUtils.getGroups(chart);
  return groups.indexOf(group);
}

/**
 * Returns the group label for the specified group index.
 * @param {DvtChartImpl} chart
 * @param {Number} groupIndex The group index.
 * @returns {string} The group label, null if the index is invalid.
 */
DvtChartDataUtils.getGroupLabel = function (chart, groupIndex) {
  var groupItems = chart.getOptions()['groups'];
  if (groupIndex >= 0 && groupIndex < groupItems.length) {
    var group = groupItems[groupIndex];
    if(group) {
      if(group['name'])
        return group['name'];
      else
        return group;
    }
  }
  
  return null;
}

/**
 * Returns a list of the group ids in the chart's data.
 * @param {DvtChartImpl} chart
 * @returns {Array} An array of the group id's.
 */
DvtChartDataUtils.getGroups = function (chart) {
  var groupCount = chart.getOptions()['groups'].length;
  var groups = [];
  for(var groupIndex = 0; groupIndex < groupCount; groupIndex++) {
    groups.push(DvtChartDataUtils.getGroup(chart, groupIndex));
  }
  return groups;
}

/**
 * Returns the value for the specified data item.
 * @param {DvtChartImpl} chart
 * @param {number} seriesIndex
 * @param {number} groupIndex
 * @return {number} The value of the specified data item.
 */
DvtChartDataUtils.getValue = function (chart, seriesIndex, groupIndex) {
  var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);
  if (dataItem == null) // null or undefined, return null
    return null;
  else if(!isNaN(dataItem)) // Number, just return
    return dataItem;
  else if (dataItem['value'] != null) // Object with value property
    return dataItem['value'];
  else if (dataItem['y'] != null) // Object with y property
    return dataItem['y'];
  return null;
}

/**
 * Returns the cumulative value for the specified data item, taking into account stacked values.
 * @param {DvtChartImpl} chart
 * @param {number} seriesIndex
 * @param {number} groupIndex
 * @param {boolean} bIncludeHiddenSeries True if hidden series should be included in the value calculation.
 * @return {number} The value of the specified data item.
 */
DvtChartDataUtils.getCumulativeValue = function (chart, seriesIndex, groupIndex, bIncludeHiddenSeries) {
  if (DvtChartTypeUtils.isStacked(chart)) {
    // Match the series type and add up the values
    var bCombo = DvtChartTypeUtils.isCombo(chart);
    var seriesType = DvtChartStyleUtils.getSeriesType(chart, seriesIndex);
    var bAssignedToY2 = DvtChartDataUtils.isAssignedToY2(chart, seriesIndex);

    var total = 0;
    for (var i = 0;i <= seriesIndex;i++) {
      // Skip series that are not rendered
      if (!bIncludeHiddenSeries && !DvtChartStyleUtils.isSeriesRendered(chart, i))
        continue;

      // Skip series that don't match the type
      if (bCombo && seriesType != DvtChartStyleUtils.getSeriesType(chart, i))
        continue;

      // Skip series who aren't assigned to the same y axis
      if (bAssignedToY2 != DvtChartDataUtils.isAssignedToY2(chart, i))
        continue;

      // Add up all the values for the group.  Null values are treated as 0.
      var groupValue = DvtChartDataUtils.getValue(chart, i, groupIndex);
      total += ((groupValue == null || isNaN(groupValue))? 0 : groupValue);
    }
    return total;
  }
  else 
    return DvtChartDataUtils.getValue(chart, seriesIndex, groupIndex);
}

/**
 * Returns the X value of a data point. For group axis, it will return the group index.
 * @param {DvtChartImpl} chart
 * @param {number} seriesIndex
 * @param {number} groupIndex
 * @return {number} The X value.
 */
DvtChartDataUtils.getXValue = function(chart, seriesIndex, groupIndex) {
  var xVal; 
  if (DvtChartAxisUtils.hasGroupAxis(chart)) {
    xVal = groupIndex;
  } else {
    var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);
    if (dataItem == null)
      return false;
    xVal = !isNaN(dataItem['x']) ? dataItem['x'] : DvtChartDataUtils.getGroupLabel(chart, groupIndex);
  }
  return xVal;
}

/**
 * Returns the target value for the specified data item in funnel charts.
 * @param {DvtChartImpl} chart
 * @param {number} seriesIndex
 * @return {number} The target value of the specified data item.
 */
DvtChartDataUtils.getTargetValue = function (chart, seriesIndex) {
  var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, 0);
  if(!isNaN(dataItem) || dataItem == null)
    return null;
  else
    return dataItem['targetValue'];
}

/**
 * Retuns whether the data point X value is inside the viewport
 * @param {DvtChartImpl} chart
 * @param {number} seriesIndex
 * @param {number} groupIndex
 * @return {boolean} 
 */
DvtChartDataUtils.isXInViewport = function(chart, seriesIndex, groupIndex) {
  var xVal = DvtChartDataUtils.getXValue(chart, seriesIndex, groupIndex);
  if (isNaN(xVal))
    return false;
  
  var options = chart.getOptions()['xAxis'];
  var min = options['viewportMin'] != null ? options['viewportMin'] : options['min'];
  var max = options['viewportMax'] != null ? options['viewportMax'] : options['max'];
  if ((min != null && xVal < min) || (max != null && xVal > max))
    return false;
  return true;
}

/**
 * Compute the Y corresponding to the X along the line from (x1,y1) to (x2,y2).
 * @param {number} x1
 * @param {number} y1
 * @param {number} x2
 * @param {number} y2
 * @param {number} X
 * @return {number} Y
 */
DvtChartDataUtils._computeYAlongLine = function(x1, y1, x2, y2, X) {
  return y1 + (y2-y1) * (X-x1) / (x2-x1);
}

/**
 * Returns the Y values at the X-axis min/max edges of the viewport.
 * @param {DvtChartImpl} chart
 * @param {number} seriesIndex
 * @return {object} An object containing the Y values at the viewport min/max edge.
 */
DvtChartDataUtils.getViewportEdgeYValues = function(chart, seriesIndex) {
  var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
  
  // Loop through the data
  var seriesData = seriesItem['items'];
  if(!seriesData) 
    return {'min': null, 'max': null};
  
  // Include hidden series if hideAndShowBehavior occurs without rescale
  var bIncludeHiddenSeries = (DvtChartEventUtils.getHideAndShowBehavior(chart) == "withoutRescale");
  
  // Find the viewport min/max
  var options = chart.getOptions()['xAxis'];
  var min = options['viewportMin'] != null ? options['viewportMin'] : options['min'];
  var max = options['viewportMax'] != null ? options['viewportMax'] : options['max'];
  
  // Find the X locations of the edges and compute the Y values
  var x, y, prevX, prevY, yMin, yMax;
  for (var groupIndex = 0; groupIndex < seriesData.length; groupIndex++) {
    if(!bIncludeHiddenSeries && !DvtChartStyleUtils.isDataItemRendered(chart, seriesIndex, groupIndex))
      continue;
      
    x = DvtChartDataUtils.getXValue(chart, seriesIndex, groupIndex);
    y = DvtChartDataUtils.getCumulativeValue(chart, seriesIndex, groupIndex, bIncludeHiddenSeries);
    
    if (prevX != null) {
      if (min != null && min > prevX && min < x)
        yMin = DvtChartDataUtils._computeYAlongLine(prevX, prevY, x, y, min);
      if (max != null && max > prevX && max < x)
        yMax = DvtChartDataUtils._computeYAlongLine(prevX, prevY, x, y, max);
    }
    
    prevX = x;
    prevY = y;
  }
  
  return {'min': yMin, 'max': yMax};
}


/**
 * Returns the min and max values from the data.
 * @param {DvtChartImpl} chart.
 * @param {string} type The type of value to find: "x", "y", "y2", "z".
 * @param {boolean} [limitToViewport] Whether the min/max are computed based on only the values that are within the viewport.
 *     Default is false. Only implemented for BLAC chart "y" and "y2" axis.
 * @return {object} An object containing the minValue and the maxValue.
 */
DvtChartDataUtils.getMinMaxValue = function(chart, type, limitToViewport) {
  // TODO date support
  // TODO support for null or NaN values

  // Y2 values pull from the y data value
  var isY2Value = (type == "y2");
  if(isY2Value)
    type = "y";
  
  // Y values may be listed directly as numbers
  var isYValue = (type == "y");
  
  // limitToViewport is not supported for x/z-axis or non-BLAC charts
  if (!isYValue || !DvtChartTypeUtils.isBLAC(chart))
    limitToViewport = false;
  
  // Include hidden series if hideAndShowBehavior occurs without rescale
  var bIncludeHiddenSeries = (DvtChartEventUtils.getHideAndShowBehavior(chart) == "withoutRescale");
  
  var isBubble = chart.getType() == "bubble";

  var maxValue = -Infinity;
  var minValue = Infinity;
  var options = chart.getOptions();
  var seriesCount = DvtChartDataUtils.getSeriesCount(chart);
  
  for(var seriesIndex=0; seriesIndex<seriesCount; seriesIndex++) {
    var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
    
    // Skip the series if it is hidden
    if(!bIncludeHiddenSeries && !DvtChartStyleUtils.isSeriesRendered(chart, seriesIndex))
      continue;
    
    // Skip the series if it's not assigned to the right y axis
    var isY2Series = DvtChartDataUtils.isAssignedToY2(chart, seriesIndex);
    if(isYValue && isY2Value != isY2Series)
      continue;
    
    // Loop through the data
    var seriesData = seriesItem['items'];
    if(!seriesData) 
      continue;
    
    for(var groupIndex=0; groupIndex<seriesData.length; groupIndex++) {
      // Skip the data item if it is hidden
      if(!bIncludeHiddenSeries && !DvtChartStyleUtils.isDataItemRendered(chart, seriesIndex, groupIndex))
        continue;
      
      if (typeof seriesData[groupIndex] != "object")
        seriesData[groupIndex] = {'y': seriesData[groupIndex]};
      var data = seriesData[groupIndex];
     
      var value; 
      if(isYValue)
        value = DvtChartDataUtils.getCumulativeValue(chart, seriesIndex, groupIndex, bIncludeHiddenSeries);
      else if(data != null) {
        if (options['timeAxisType'] && options['timeAxisType'] == "enabled" && data['x'] == null) {
          var timeAxisGroupLabel = DvtChartDataUtils.getGroupLabel(chart, groupIndex);
          if (!isNaN(timeAxisGroupLabel))
            data['x'] = timeAxisGroupLabel;
        }
        value = data[type];
      }
      
      if (limitToViewport && !DvtChartDataUtils.isXInViewport(chart, seriesIndex, groupIndex))
        continue;
        
      if(!isNaN(value)) {
        var radius = 0;
        if (isBubble && data['markerSize']) {
          if (isYValue)
            radius = data['_yAxisRadius'];
          else if (type == "x")
            radius = data['_xAxisRadius'];
        }
        maxValue = Math.max(maxValue, value + radius);
        minValue = Math.min(minValue, value - radius);
      }
    }
    
    //Loop through reference objects and include their min/max values in the calulation
    var refObjects = null;
    if(type == "x")
      refObjects = DvtChartRefObjUtils.getXAxisObjects(chart);
    else if(type == "y")
      refObjects = DvtChartRefObjUtils.getYAxisObjects(chart);
    else if(type == "y2")
      refObjects = DvtChartRefObjUtils.getY2AxisObjects(chart);
   
    if(refObjects != null){
      for(var i=0; i< refObjects.length; i++) {
        var refObj = refObjects[i];
        var items = refObj['items'];
        
        if(items != null){
          for(var j = 0; j < items.length; j++) {
  
            var min = items[j]['min'];
            var max = items[j]['max'];
            var val = items[j]['value'];
  
            if(min !=null){
              minValue = Math.min(minValue, min);
              maxValue = Math.max(maxValue, min);
            }
            if(max !=null){
              minValue = Math.min(minValue, max);
              maxValue = Math.max(maxValue, max);
            }
            if(val != null){
              minValue = Math.min(minValue, val);
              maxValue = Math.max(maxValue, val); 
            }
          }
        }
      }
    }
    
    // If the min/max is limited to viewport, included the values at the viewport edges.
    if (limitToViewport) {
      var edgeValues = DvtChartDataUtils.getViewportEdgeYValues(chart, seriesIndex);
      if (edgeValues['min'] != null) {
        minValue = Math.min(minValue, edgeValues['min']);
        maxValue = Math.max(maxValue, edgeValues['min']);
      }
      if (edgeValues['max'] != null) {
        minValue = Math.min(minValue, edgeValues['max']);
        maxValue = Math.max(maxValue, edgeValues['max']);
      }
    }
  }
  
  return {'min': minValue, 'max': maxValue};
}


/**
 * Returns true if the series is assigned to the y2 axis.
 * @param {DvtChartImpl} chart
 * @param {string} series
 * @return {boolean} True if the series is assigned to the y2 axis.
 */
DvtChartDataUtils.isAssignedToY2 = function (chart, seriesIndex) {
  var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
  if (seriesItem && seriesItem['assignedToY2'] == "on" && DvtChartTypeUtils.isDualY(chart))
    return true;
  else 
    return false;
}

/**
 * Returns information if graph contains mixed frequency data.
 * @param {DvtChartImpl} chart The chart that will be rendered.
 * @return {boolean} true if graph ha mixed data.
 */
DvtChartDataUtils.hasMixedFrequency = function (chart) {
  return chart.getOptions()["timeAxisType"] == 'mixedFrequency';
}

/**
 * Returns the array of initially selected objects for a chart.  This information is based on the data object.
 * @param {DvtChartImpl} chart The chart that will be rendered.
 * @return {array} The array of selected objects.
 */
DvtChartDataUtils.getInitialSelection = function (chart) {
  var selection = chart.getOptions()['selectedItems'];
  if(!selection)
    selection = [];
  
  // Process the data item ids and fill in series and group information
  var peers = chart.getObjects();
  for (var i = 0; i < selection.length; i++) {
    var id = selection[i]['id'];
    
    // If id is defined, but series and group are not
    if(id && !(selection[i]['series'] && selection[i]['group'])) {
      for (var j = 0; j < peers.length; j++) {
        var peer = peers[j];
        if(id == peer.getDataItemId()) {
          selection[i]['series'] = peer.getSeries();
          selection[i]['group'] = peer.getGroup();
          break;
        }
      }
    }
  } 

  return selection;
}

/**
 * Returns the current selection for the chart.  This selection is in the format of the data['selectedItems'] API.
 * @param {DvtChartImpl} chart The chart that will be rendered.
 * @return {array} The array of selected objects.
 */
DvtChartDataUtils.getCurrentSelection = function (chart) {
  var selection = [];
  var handler = chart.getSelectionHandler();
  if(handler) {
    var selectedIds = handler.getSelectedIds();
    for(var i = 0; i < selectedIds.length; i++) {
      var selectedId = selectedIds[i]; // selectedId is an instance of DvtChartDataItem
      selection.push({'series': selectedId.getSeries(), 'group': selectedId.getGroup(), 'id': selectedId.getId()});
    }
  }
  
  return selection;
}

/**
 * Returns whether the data point is currently selected.
 * @param {DvtChartImpl} chart
 * @param {number} seriesIndex
 * @param {number} groupInex
 * @return {boolean}
 */
DvtChartDataUtils.isDataSelected = function(chart, seriesIndex, groupIndex) {
  var handler = chart.getSelectionHandler();
  var series = DvtChartDataUtils.getSeries(chart, seriesIndex);
  var group = DvtChartDataUtils.getGroup(chart, groupIndex);
  
  if (handler && series != null && group != null) {
    var selectedIds = handler.getSelectedIds();
    for(var i = 0; i < selectedIds.length; i++) {
      var selectedId = selectedIds[i]; // selectedId is an instance of DvtChartDataItem
      if (selectedId.getSeries() == series && selectedId.getGroup() == group)
        return true;
    }
  }
  return false;
}

/**
 * Returns the data label for the specified data point.
 * @param {DvtChartImpl} chart
 * @param {Number} groupIndex The series index.
 * @param {Number} groupIndex The group index.
 * @returns {string} The data label, null if the index is invalid.
 */
DvtChartDataUtils.getDataLabel = function(chart, seriesIndex, groupIndex){
  var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);
  if (dataItem['label']) {
    var label = parseFloat(dataItem['label']);
    if (!isNaN(label)) {
      var options = chart.getOptions();
      
      // Find the extents of the corresponding axis
      // Note: We assume y axis here because charts with numerical x axis would not pass a single value for the label.
      var min, max;
      var bAssignedToY2 = DvtChartDataUtils.isAssignedToY2(chart, seriesIndex);
      var axis = (bAssignedToY2 && chart.y2Axis) ? chart.y2Axis : chart.yAxis;
      if(axis) {
        min = axis.getGlobalMin();
        max = axis.getGlobalMax();
        majorIncrement = axis.getMajorIncrement();
      }
      
      var valueFormats = options['valueFormats'];
      label = DvtChartTooltipUtils._formatValue(valueFormats, DvtChartDataUtils._TYPE_LABEL, label, min, max, majorIncrement); 
      return label;
    } 
    else
      return dataItem['label'];
  }
  return null;
}
/**
 * Utility functions for DvtChartImpl eventing and interactivity.
 * @class
 */
var DvtChartEventUtils = new Object();

DvtObj.createSubclass(DvtChartEventUtils, DvtObj, "DvtChartEventUtils");

/**
 * Returns the hide and show behavior for the specified chart.
 * @param {DvtChartImpl} chart
 * @return {string}
 */
DvtChartEventUtils.getHideAndShowBehavior = function(chart) {
  return chart.getOptions()['hideAndShowBehavior'];
}

/**
 * Returns the hover behavior for the specified chart.
 * @param {DvtChartImpl} chart
 * @return {string}
 */
DvtChartEventUtils.getHoverBehavior = function(chart) {
  return chart.getOptions()['hoverBehavior'];
}


/**
 * Updates the visibility of the specified category.  Returns true if the visibility is successfully
 * updated.  This function will return false if the visibility change is rejected, such as when
 * hiding the last visible series with hideAndShowBehavior withRescale.
 * @param {DvtChartImpl} chart
 * @param {string} category
 * @param {string} visibility The new visibility of the category.
 * @return {boolean} True if the visibility was successfully updated.
 */
DvtChartEventUtils.setVisibility = function(chart, category, visibility) {
  var hsb = DvtChartEventUtils.getHideAndShowBehavior(chart);

  // Note: The only supported categories are series for now.  The category is the series. 
  var seriesItem = DvtChartDataUtils.getSeriesItem(chart, DvtChartDataUtils.getSeriesIndex(chart, category));
  
  if (category == DvtPieChartUtils.OTHER_SLICE_SERIES_ID && DvtPieChartUtils.getOtherSliceVisibility(chart) !== visibility) {    
    // Update the "Other" slice visibility
    DvtPieChartUtils.setOtherSliceVisibility(chart, visibility);
    return true;
  }
  else if (seriesItem && seriesItem['visibility'] !== visibility) {    
    // Update the visibility
    seriesItem['visibility'] = visibility;
    return true;
  }
  else {
    // Data point hide/show is only supported for scatter and bubble graphs
    if(!(DvtChartTypeUtils.isScatterBubble(chart)))
      return false;
    
    // Update the categories list
    var hiddenCategories = DvtChartStyleUtils.getHiddenCategories(chart);
    if(visibility == "hidden")
      hiddenCategories.push(category);
    else {
      var index = DvtArrayUtils.getIndex(hiddenCategories, category);
      hiddenCategories.splice(index, 1);
    }
      
    // Update the legend
    var options = chart.getOptions();
    if(options && options['legend'] && options['legend']['sections']) {
      // Iterate through any sections defined
      for(var i=0; i<options['legend']['sections'].length; i++) {
        var dataSection = options['legend']['sections'][i];
        if(dataSection && dataSection['items']) {
          // Find the matching item and apply visibility 
          for(var j=0; j<dataSection['items'].length; j++) {
            if(dataSection['items'][j]['id'] == category)
              dataSection['items'][j]['categoryVisibility'] = visibility;
          }
        }
      }
    }
    
    return true;
  }
  
  return false;
}

/**
 * Returns whether scroll is enabled.
 * @param {DvtChartImpl} chart
 * @return {boolean}
 */
DvtChartEventUtils.isScrollable = function(chart) {
  return chart.getOptions()['zoomAndScroll'] != "off";
}

/**
 * Returns whether zoom is enabled.
 * @param {DvtChartImpl} chart
 * @return {boolean}
 */
DvtChartEventUtils.isZoomable = function(chart) {
  var zs = chart.getOptions()['zoomAndScroll'];
  return zs == "live" || zs == "delayed";
}

/**
 * Returns whether zoom/scroll is live.
 * @param {DvtChartImpl} chart
 * @return {boolean}
 */
DvtChartEventUtils.isLiveScroll = function(chart) {
  var zs = chart.getOptions()['zoomAndScroll'];
  return zs == "live" || zs == "liveScrollOnly";
}

/**
 * Returns whether zoom/scroll is delayed.
 * @param {DvtChartImpl} chart
 * @return {boolean}
 */
DvtChartEventUtils.isDelayedScroll = function(chart) {
  var zs = chart.getOptions()['zoomAndScroll'];
  return zs == "delayed" || zs == "delayedScrollOnly";
}

/**
 * Processes an array of DvtChartDataItems representing the current selection, making them ready to be
 * dispatched to the callback. This is primarily used for expanding the "Other" data item into its contained
 * ids.
 * @param {DvtChartImpl} chart
 * @param {array} selection The array of unprocessed ids.
 * @return {array} The array of processed ids, ready to be dispatched.
 */
DvtChartEventUtils.processIds = function(chart, selection) {
  var ret = [];
  for (var i = 0; i < selection.length; i++) {
    var item = selection[i];
    if (item.getSeries() == DvtPieChartUtils.OTHER_SLICE_SERIES_ID) {
      // Get the slice ids of the slices that are grouped into "other" slice
      var otherItems = DvtPieChartUtils.getOtherSliceIds(chart);
      ret = ret.concat(otherItems);
    } 
    else
      ret.push(item);
  }
  return ret;
}

/**
 * Enlarge marquee rectangular bounds by one pixel in all directions to cover the points at the edges.
 * @param {DvtMarqueeEvent} marqueeEvent The marquee event.
 */
DvtChartEventUtils.adjustBounds = function(event) {
  if (event.x != null) event.x -= 1;
  if (event.w != null) event.w += 2;
  if (event.y != null) event.y -= 1;
  if (event.h != null) event.h += 2;
}

/**
 * Gets the chart data items that are inside a marquee.
 * @param {DvtChartImpl} chart The chart.
 * @param {DvtMarqueeEvent} event The marquee event, which contains the rectangular bounds (relative to stage).
 * @return {array} Array of peer objects that are inside the rectangle.
 */
DvtChartEventUtils.getBoundedObjects = function(chart, event) {
  var peers = chart.getObjects();
  var boundedPeers = [];
  
  for (var i = 0; i < peers.length; i++) {
    var peer = peers[i];
    var dataPos = peer.getDataPosition();
    
    if (dataPos) {
      dataPos = chart.getPlotArea().localToStage(dataPos);
      var withinX = (event.x == null) || (dataPos.x >= event.x && dataPos.x <= event.x + event.w);
      var withinY = (event.y == null) || (dataPos.y >= event.y && dataPos.y <= event.y + event.h);
      if (withinX && withinY)
        boundedPeers.push(peer);
    }
  }
  
  return boundedPeers;
}

/**
 * Gets the chart axis bounds corresponding to the bounding rectangle.
 * @param {DvtChartImpl} chart The chart.
 * @param {DvtMarqueeEvent} event The marquee event, which contains the rectangular bounds (relative to stage).
 * @param {boolean} limitExtent Whether the result should be limited to the axis min/max extent.
 * @return {object} An object containing xMin, xMax, yMin, yMax, startGroup, endGroup corresponding to the bounds.
 */
DvtChartEventUtils.getAxisBounds = function(chart, event, limitExtent) {
  // Get the bounds in the axis coordinates
  var plotArea = chart.getPlotArea();
  var minPt = plotArea.stageToLocal(new DvtPoint(event.x, event.y));
  var maxPt = plotArea.stageToLocal(new DvtPoint(event.x + event.w, event.y + event.h));
  var coords = DvtChartEventUtils._convertToAxisCoord(chart, minPt.x, maxPt.x, minPt.y, maxPt.y);
  
  // Compute the axis bounds.
  var xMinMax = {}, yMinMax = {}, y2MinMax = {}, startEndGroup = {};
  if (chart.xAxis) {
    xMinMax = DvtChartEventUtils._getAxisMinMax(chart.xAxis, coords.xMin, coords.xMax, limitExtent);
    startEndGroup = DvtChartEventUtils.getAxisStartEndGroup(chart.xAxis, xMinMax.min, xMinMax.max);
  }
  if (chart.yAxis)
    yMinMax = DvtChartEventUtils._getAxisMinMax(chart.yAxis, coords.yMin, coords.yMax, limitExtent);
  if (chart.y2Axis)
    y2MinMax = DvtChartEventUtils._getAxisMinMax(chart.y2Axis, coords.yMin, coords.yMax, limitExtent);
  
  return {xMin: xMinMax.min, xMax: xMinMax.max, 
          yMin: yMinMax.min, yMax: yMinMax.max,
          y2Min: y2MinMax.min, y2Max: y2MinMax.max,
          startGroup: startEndGroup.startGroup, endGroup: startEndGroup.endGroup};
}

/**
 * Gets the axis min/max values corresponding to the bounding coords.
 * @param {DvtChartAxis} axis
 * @param {number} minCoord The coord of the minimum value of the axis.
 * @param {number} maxCoord The coord of the maximum value of the axis.
 * @param {boolean} limitExtent Whether the result should be limited to the axis min/max extent.
 * @return {object} An object containing the axis min/max value.
 */
DvtChartEventUtils._getAxisMinMax = function(axis, minCoord, maxCoord, limitExtent) {
  var min = axis.getUnboundedValueAt(minCoord);
  var max = axis.getUnboundedValueAt(maxCoord);
  
  if (limitExtent) {
    // Limit to min extent
    var minExtent = axis.getMinimumExtent();
    if (max - min < minExtent) {
      var center = (max + min)/2;
      max = center + minExtent/2;
      min = center - minExtent/2;
    }
    return DvtChartEventUtils._limitToGlobal(axis, min, max);
  }
  else
    return {min: min, max: max};
}


/**
 * Gets the chart axis bounds corresponding to the deltas in coords. The results are bounded by axis global min/max and
 * minimum axis extent.
 * @param {DvtChartImpl} chart The chart.
 * @param {number} xMinDelta The delta coord of the left end of the horizontal axis.
 * @param {number} xMaxDelta The delta coord of the right end of the horizontal axis.
 * @param {number} yMinDelta The delta coord of the top end of the vertical axis.
 * @param {number} yMaxDelta The delta coord of the bottom end of the vertical axis.
 * @return {object} An object containing xMin, xMax, yMin, yMax, startGroup, endGroup corresponding to the bounds.
 */
DvtChartEventUtils.getAxisBoundsByDelta = function(chart, xMinDelta, xMaxDelta, yMinDelta, yMaxDelta) {
  // Convert the deltas to the axis coordinates
  var deltas = DvtChartEventUtils._convertToAxisCoord(chart, xMinDelta, xMaxDelta, yMinDelta, yMaxDelta);
  
  // Compute the axis bounds.
  var xMinMax = {}, yMinMax = {}, y2MinMax = {}, startEndGroup = {};
  if (chart.xAxis) {
    xMinMax = DvtChartEventUtils._getAxisMinMaxByDelta(chart.xAxis, deltas.xMin, deltas.xMax);
    startEndGroup = DvtChartEventUtils.getAxisStartEndGroup(chart.xAxis, xMinMax.min, xMinMax.max);
  }
  if (chart.yAxis)
    yMinMax = DvtChartEventUtils._getAxisMinMaxByDelta(chart.yAxis, deltas.yMin, deltas.yMax);
  if (chart.y2Axis)
    y2MinMax = DvtChartEventUtils._getAxisMinMaxByDelta(chart.y2Axis, deltas.yMin, deltas.yMax);
  
  return {xMin: xMinMax.min, xMax: xMinMax.max, 
          yMin: yMinMax.min, yMax: yMinMax.max,
          y2Min: y2MinMax.min, y2Max: y2MinMax.max,
          startGroup: startEndGroup.startGroup, endGroup: startEndGroup.endGroup};
}

/**
 * Gets the axis min/max values corresponding to the delta coords. The results are bounded by axis global min/max and
 * minimum axis extent.
 * @param {DvtChartAxis} axis
 * @param {number} minDelta The delta coord of the minimum value of the axis.
 * @param {number} maxDelta The delta coord of the maximum value of the axis.
 * @return {object} An object containing the axis min/max value.
 */
DvtChartEventUtils._getAxisMinMaxByDelta = function(axis, minDelta, maxDelta) {
  var min = axis.getViewportMin();
  var max = axis.getViewportMax();
  
  // Don't do the computation if the min/max won't change. This is to prevent rounding errors.
  if (maxDelta == minDelta && axis.isFullViewport())
    return {min: min, max: max};
  
  var minDeltaVal = axis.getUnboundedValueAt(minDelta) - axis.getUnboundedValueAt(0);
  var maxDeltaVal = axis.getUnboundedValueAt(maxDelta) - axis.getUnboundedValueAt(0);
  
  // Make sure that the min/max is not less than the minimum axis extent
  var weight = 1;
  var newExtent = (max + maxDeltaVal) - (min + minDeltaVal);
  if (minDelta != maxDelta && newExtent < axis.getMinimumExtent())
    weight = (max - min - axis.getMinimumExtent()) / (minDeltaVal - maxDeltaVal);
  
  min += minDeltaVal * weight;
  max += maxDeltaVal * weight;
  
  return DvtChartEventUtils._limitToGlobal(axis, min, max);
}

/**
 * Convert from real coord to axis coord.
 * @param {DvtChartImpl} chart
 * @param {number} xMin The minimum x in real coord.
 * @param {number} xMax The maximum x in real coord.
 * @param {number} yMin The minimum y in real coord.
 * @param {number} yMax The maximum y in real coord.
 * @return {object} An object containing the axis xMin/Max and yMin/Max.
 */
DvtChartEventUtils._convertToAxisCoord = function(chart, xMin, xMax, yMin, yMax) {
  var axisCoord = {};
  var isRTL = DvtAgent.isRightToLeft(chart.getCtx());
  if (DvtChartTypeUtils.isHorizontal(chart)) {
    axisCoord.xMin = yMin;
    axisCoord.xMax = yMax;
    axisCoord.yMin = isRTL ? xMax : xMin;
    axisCoord.yMin = isRTL ? xMin : xMax;
  } else {
    axisCoord.xMin = isRTL ? xMax : xMin;
    axisCoord.xMax = isRTL ? xMin : xMax;
    axisCoord.yMin = yMax;
    axisCoord.yMax = yMin;
  }
  return axisCoord;
}

/**
 * Limits the min/max values to the global extents of the axis.
 * @param {DvtChartAxis} axis
 * @param {number} min The minimum value of the axis.
 * @param {number} max The maximum value of the axis.
 * @return {object} An object containing the axis min/max value after limiting.
 */
DvtChartEventUtils._limitToGlobal = function(axis, min, max) {
  var globalMin = axis.getGlobalMin();
  var globalMax = axis.getGlobalMax();
  
  // Limit to global min/max  
  if ((max-min) >= (globalMax-globalMin)) {
    min = globalMin;
    max = globalMax;
  } else if (min < globalMin) {
    max += globalMin - min;
    min = globalMin;
  } else if (max > globalMax) {
    min -= max - globalMax;
    max = globalMax;
  }
  return {min: min, max: max};
}

/**
 * Returns the start/endGroup of the axis.
 * @param {DvtChartAxis} axis
 * @param {number} min The minimum value of the axis.
 * @param {number} max The maximum value of the axis.
 * @return {object} An object containing the axis start/endGroup.
 */
DvtChartEventUtils.getAxisStartEndGroup = function(axis, min, max) {
  if (axis.isGroupAxis()) {
    var startIdx = Math.ceil(min);
    var endIdx = Math.floor(max);
    if (endIdx >= startIdx) {
      var startGroup = axis.getGroupLabelAt(startIdx);
      var endGroup = axis.getGroupLabelAt(endIdx);
      return {startGroup: startGroup, endGroup: endGroup};
    }
  }
  return {startGroup: null, endGroup: null};
}

/**
 * Sets initial selection for the graph.
 * @param {DvtChartImpl} chart The chart being rendered.
 * @param {array} selected The array of initially selected objects.
 */
DvtChartEventUtils.setInitialSelection = function(chart, selected) {
  var handler = chart.getSelectionHandler();
  if(!handler)
    return;

  var peers = chart.getObjects();
  var selectedIds = [];
  for (var i = 0; i < selected.length; i++) {
    for (var j = 0; j < peers.length; j++) {
      var peer = peers[j];
      if(peer.getSeries() === selected[i]['series'] && peer.getGroup() === selected[i]['group']) {
        selectedIds.push(peer.getId());
        continue;
      }
    }
  }
  
  handler.processInitialSelections(selectedIds, peers);
}
/**
 * Reference object related utility functions for DvtChartImpl.
 * @class
 */
var DvtChartRefObjUtils = new Object();

DvtObj.createSubclass(DvtChartRefObjUtils, DvtObj, "DvtChartRefObjUtils");

/**
 * Returns all reference objects for the current chart.
 * @param {DvtChartImpl} chart
 * @return {array} The array of reference object definitions.
 */
DvtChartRefObjUtils.getObjects = function(chart) {
  var x = DvtChartRefObjUtils.getXAxisObjects(chart);
  var y = DvtChartRefObjUtils.getYAxisObjects(chart);
  var y2 = DvtChartRefObjUtils.getY2AxisObjects(chart);
  return x.concat(y, y2);
}

/**
 * Returns all reference objects for the x-axis of the current chart.
 * @param {DvtChartImpl} chart
 * @return {array} The array of reference object definitions.
 */
DvtChartRefObjUtils.getXAxisObjects = function(chart) {
  var options = chart.getOptions();
  if(options && options['xAxis'] && options['xAxis']['referenceObjects'])
    return options['xAxis']['referenceObjects'];
  else
    return [];
}

/**
 * Returns all reference objects for the y-axis of the current chart.
 * @param {DvtChartImpl} chart
 * @return {array} The array of reference object definitions.
 */
DvtChartRefObjUtils.getYAxisObjects = function(chart) {
  var options = chart.getOptions();
  if(options && options['yAxis'] && options['yAxis']['referenceObjects'])
    return options['yAxis']['referenceObjects'];
  else
    return [];
}

/**
 * Returns all reference objects for the y2-axis of the current chart.
 * @param {DvtChartImpl} chart
 * @return {array} The array of reference object definitions.
 */
DvtChartRefObjUtils.getY2AxisObjects = function(chart) {
  var options = chart.getOptions();
  if(options && options['y2Axis'] && options['y2Axis']['referenceObjects'])
    return options['y2Axis']['referenceObjects'];
  else
    return [];
}

/**
 * Returns the type of the reference object.
 * @param {object} refObj The reference object definition.
 * @return {string} The type of the reference object.
 */
DvtChartRefObjUtils.getType = function(refObj) {
  if(refObj['type'] == "area")
    return "area";
  else // default to "line"
    return "line";
}

/**
 * Returns the location of the reference object.
 * @param {object} refObj The reference object definition.
 * @return {string} The location of the reference object.
 */
DvtChartRefObjUtils.getLocation = function(refObj) {
  if(refObj['location'] == "front")
    return "front";
  else // default to "back"
    return "back";
}

/**
 * Returns the color of the reference object.
 * @param {object} refObj The reference object definition.
 * @return {string} The color.
 */
DvtChartRefObjUtils.getColor = function(refObj) {
  if(refObj['color'])
    return refObj['color'];
  else
    return "#333333";
}

/**
 * Returns the line width of the reference line.
 * @param {object} refObj The reference object definition.
 * @return {number} The line width.
 */
DvtChartRefObjUtils.getLineWidth = function(refObj) {
  if(refObj['lineWidth'])
    return refObj['lineWidth'];
  else // default to 1 pixel
    return 1;
}
/**
 * Series effect utility functions for DvtChartImpl.
 * @class
 */
var DvtChartSeriesEffectUtils = new Object();

DvtObj.createSubclass(DvtChartSeriesEffectUtils, DvtObj, "DvtChartSeriesEffectUtils");

/**
 * Returns the color of the hover border for a data item with the specified base color.
 * @param {DvtChartImpl} chart
 * @param {string} dataColor
 * @return {string}
 */
DvtChartSeriesEffectUtils.getHoverColor = function(chart, dataColor) {
  return DvtColorUtils.adjustHSL(dataColor, 0, 0, 0.15);
}

/**
 * Returns the fill for a bar with the given series and group.
 * @param {DvtChartImpl} chart
 * @param {number} seriesIndex
 * @param {number} groupIndex
 * @param {boolean} bHoriz True if the bar is horizontal
 * @param {number} barWidth The width of the bar
 * @return {DvtFill}
 */
DvtChartSeriesEffectUtils.getBarFill = function(chart, seriesIndex, groupIndex, bHoriz, barWidth) {
  // All series effects are based off of the color
  var color = DvtChartStyleUtils.getColor(chart, seriesIndex, groupIndex);
  var pattern = DvtChartStyleUtils.getPattern(chart, seriesIndex, groupIndex);
  var seriesEffect = DvtChartStyleUtils.getSeriesEffect(chart);
  
  if(pattern) 
    return new DvtPatternFill(pattern, color);
  else if(seriesEffect == "gradient" && barWidth > 3) { // to improve performance, don't use gradient if bar is too thin
    var colors;
    var stops;
    var angle = bHoriz ? 270: 0;
    if(DvtChartSeriesEffectUtils._useAltaGradients(chart)) 
    {
      colors = [DvtColorUtils.adjustHSL(color, 0, -0.09, 0.04), 
                DvtColorUtils.adjustHSL(color, 0, -0.04, -0.05)];
      stops = [0, 1.0];
    }
    else {
      colors = [DvtColorUtils.getPastel(color, 0.15), 
                DvtColorUtils.getPastel(color, 0.45), 
                DvtColorUtils.getPastel(color, 0.25),
                color,
                DvtColorUtils.getPastel(color, 0.15),
                DvtColorUtils.getDarker(color, 0.9)];
      stops = [0, 0.15, 0.30, 0.65, 0.85, 1.0];
    }
    
    return new DvtLinearGradientFill(angle, colors, null, stops);
  }
  else // seriesEffect="color"
    return new DvtSolidFill(color);
}

/**
 * Returns the fill for an area with the given series and group.
 * @param {DvtChartImpl} chart
 * @param {number} seriesIndex
 * @return {DvtFill}
 */
DvtChartSeriesEffectUtils.getAreaFill = function(chart, seriesIndex) {
  // All series effects are based off of the color
  var color = DvtChartStyleUtils.getColor(chart, seriesIndex);
  var pattern = DvtChartStyleUtils.getPattern(chart, seriesIndex);
  var seriesEffect = DvtChartStyleUtils.getSeriesEffect(chart);
  
  if(pattern) 
    return new DvtPatternFill(pattern, color);
  else if(seriesEffect == "gradient") {
    var colors, stops;
    if(DvtChartSeriesEffectUtils._useAltaGradients(chart)) 
    {
      colors = [DvtColorUtils.adjustHSL(color, 0, -0.09, 0.04), 
                DvtColorUtils.adjustHSL(color, 0, -0.04, -0.05)];
      stops = [0, 1.0];
    }
    else {
      if(DvtChartTypeUtils.isSpark(chart)) {      
        colors = [DvtColorUtils.getDarker(color, 0.5), color, DvtColorUtils.getPastel(color, 0.50)];
        stops = [0, 0.5, 1.0];
      }
      else {
        colors = [DvtColorUtils.getPastel(color, 0.5), color, DvtColorUtils.getDarker(color, 0.70)];
        stops = [0, 0.5, 1.0];
      }
    }
    return new DvtLinearGradientFill(270, colors, null, stops);
  }
  else // seriesEffect="color"
    return new DvtSolidFill(color);
}

/**
 * Returns the fill for a marker with the given series and group.
 * @param {DvtChartImpl} chart
 * @param {number} seriesIndex
 * @param {number} groupIndex
 * @return {DvtFill}
 */
DvtChartSeriesEffectUtils.getMarkerFill = function(chart, seriesIndex, groupIndex) {
  // All series effects are based off of the color
  var color = DvtChartStyleUtils.getMarkerColor(chart, seriesIndex, groupIndex);
  var pattern = DvtChartStyleUtils.getPattern(chart, seriesIndex, groupIndex);
  
  // Only bubble markers use complex fills
  if(chart.getType() == "bubble") {
    var seriesEffect = DvtChartStyleUtils.getSeriesEffect(chart);
    
    if(pattern) 
      return new DvtPatternFill(pattern, color);
    else if(seriesEffect == "gradient") {
      if(DvtChartSeriesEffectUtils._useAltaGradients(chart)) 
      {
        colors = [DvtColorUtils.adjustHSL(color, 0, -0.09, 0.04), 
                  DvtColorUtils.adjustHSL(color, 0, -0.04, -0.05)];
        stops = [0, 1.0];
        return new DvtLinearGradientFill(270, colors, null, stops);
      }
      else {
        // Gradient varies by shape
        var shape = DvtChartStyleUtils.getMarkerShape(chart, seriesIndex, groupIndex);
        if(shape == "human") {
          var linearColors = [DvtColorUtils.getPastel(color, 0.2), 
                              DvtColorUtils.getPastel(color, 0.1), 
                              color,
                              DvtColorUtils.getDarker(color, 0.8)];
          var linearStops = [0, 0.3, 0.7, 1.0];
          return new DvtLinearGradientFill(315, linearColors, null, linearStops);
        }
        else {    
          var radialColors = [DvtColorUtils.getPastel(color, 0.15), 
                              color,
                              DvtColorUtils.getDarker(color, 0.9), 
                              DvtColorUtils.getDarker(color, 0.8)];
          var radialStops = [0, 0.5, 0.75, 1.0];
          return new DvtRadialGradientFill(radialColors, null, radialStops)
        }
      }
    }
  }
  
  // seriesEffect="color" or line/scatter marker
  return new DvtSolidFill(color);
}

/**
 * Returns the fill for a funnel slice with the given series and group.
 * @param {DvtChartImpl} chart
 * @param {number} seriesIndex
 * @param {string} color  The color that is associated with the funnel slice, to apply the effect onto it. 
 * @param {DvtRectangle} dimensions  The dimensions of this funnel slice, to pass as limits for the gradient effect.
 * @return {DvtFill}
 */
DvtChartSeriesEffectUtils.getFunnelSliceFill = function(chart, seriesIndex, color, dimensions, bBackground) {
  var pattern = DvtChartStyleUtils.getPattern(chart, seriesIndex, 0);
  var seriesEffect = DvtChartStyleUtils.getSeriesEffect(chart);
  
  if (pattern && !bBackground)
    return new DvtPatternFill(pattern, color);
  else if (seriesEffect == "gradient") {
    var angle = 90;
    var colors, stops;
    if (chart.getOptions()['styleDefaults']['threeDEffect'] == "on") {
      colors = [DvtColorUtils.adjustHSL(color, 0, 0,  - 0.1), DvtColorUtils.adjustHSL(color, 0, 0, 0.12), color];
      stops = [0, 0.65, 1.0];
    }
    else {
      colors = [DvtColorUtils.adjustHSL(color, 0,  - 0.09, 0.04), DvtColorUtils.adjustHSL(color, 0,  - 0.04,  - 0.05)];
      stops = [0, 1.0];
    }
    return new DvtLinearGradientFill(angle, colors, null, stops, [dimensions.x, dimensions.y, dimensions.w, dimensions.h]);
  }
  else // seriesEffect="color"
    return new DvtSolidFill(color);
}

/**
 * Returns true if the alta gradients should be used.
 */
DvtChartSeriesEffectUtils._useAltaGradients = function(chart) 
{
  return !DvtChartDefaults.isSkyrosSkin(chart);
}
/**
 * Style related utility functions for DvtChartImpl.
 * @class
 */
var DvtChartStyleUtils = new Object();

DvtObj.createSubclass(DvtChartStyleUtils, DvtObj, "DvtChartStyleUtils");

/** @private */
DvtChartStyleUtils._SERIES_TYPE_RAMP = ["bar", "line", "area"];

/**
 * Returns the series type for the specified data item.  Returns "auto" for chart types
 * that do not support multiple series types.
 * @param {DvtChartImpl} chart
 * @param {number} seriesIndex
 * @return {string} The series type.
 */
DvtChartStyleUtils.getSeriesType = function(chart, seriesIndex) {
  if(DvtChartTypeUtils.isBar(chart)) {
    return "bar";
  }
  else if(DvtChartTypeUtils.isLine(chart)) {
    return "line";
  }
  else if(DvtChartTypeUtils.isArea(chart)) {
    return "area";
  }
  else if(DvtChartTypeUtils.isCombo(chart)) {
    var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
    var seriesType = seriesItem ? seriesItem['type'] : null;
    if(!seriesType || seriesType == "auto") {
      // Series type not specified, get default
      var series = DvtChartDataUtils.getSeries(chart, seriesIndex);
      var styleIndex = DvtChartDataUtils.getSeriesStyleIndex(chart, series);
      var typeIndex = styleIndex % DvtChartStyleUtils._SERIES_TYPE_RAMP.length;
      return DvtChartStyleUtils._SERIES_TYPE_RAMP[typeIndex]; 
    }
    else
      return seriesType;
  }
  else
    return "auto";
};

/**
 * Returns the series effect for the specified chart.
 * @param {DvtChartImpl} chart
 * @return {string} The series effect.
 */
DvtChartStyleUtils.getSeriesEffect = function(chart) {
  // Style Defaults
  var options = chart.getOptions();
  return options['styleDefaults']['seriesEffect'];
};

/**
 * Returns the color for the specified data item.
 * @param {DvtChartImpl} chart
 * @param {number} seriesIndex
 * @param {number} groupIndex
 * @return {string} The color string.
 */
DvtChartStyleUtils.getColor = function(chart, seriesIndex, groupIndex) {
  // Data Override
  var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);
  if(dataItem && dataItem['color'])
    return dataItem['color'];

  // Series Override
  var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
  if(seriesItem && seriesItem['color'])
    return seriesItem['color'];
  
  // Style Defaults
  var options = chart.getOptions();
  var defaultColors = options['styleDefaults']['colors'];
  var series = DvtChartDataUtils.getSeries(chart, seriesIndex);
  var styleIndex = DvtChartDataUtils.getSeriesStyleIndex(chart, series);
  var colorIndex = styleIndex % defaultColors.length;
  return options['styleDefaults']['colors'][colorIndex];
};

/**
 * Returns the pattern for the specified data item.
 * @param {DvtChartImpl} chart
 * @param {number} seriesIndex
 * @param {number} groupIndex
 * @return {string} The pattern string.
 */
DvtChartStyleUtils.getPattern = function(chart, seriesIndex, groupIndex) {
  // Patterns not supported for line charts, scatter charts, or line series
  if(DvtChartTypeUtils.isLine(chart) || DvtChartTypeUtils.isScatter(chart) ||
     DvtChartStyleUtils.getSeriesType(chart, seriesIndex) == "line")
    return null;

  // Data Override
  var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);
  if(dataItem && dataItem['pattern'] && dataItem['pattern'] != "auto")
    return dataItem['pattern'];

  // Series Override
  var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
  if(seriesItem && seriesItem['pattern'] && seriesItem['pattern'] != "auto")
    return seriesItem['pattern'];
  
  // Style Defaults
  if(DvtChartStyleUtils.getSeriesEffect(chart) == "pattern") {
    var options = chart.getOptions();
    var defaultPatterns = options['styleDefaults']['patterns'];
    var series = DvtChartDataUtils.getSeries(chart, seriesIndex);
    var styleIndex = DvtChartDataUtils.getSeriesStyleIndex(chart, series);
    var patternIndex = styleIndex % defaultPatterns.length;
    return options['styleDefaults']['patterns'][patternIndex];
  }
  else
    return null;
};

/**
 * Returns the border color for the specified data item.
 * @param {DvtChartImpl} chart
 * @param {number} seriesIndex
 * @param {number} groupIndex
 * @return {string} The border color string.
 */
DvtChartStyleUtils.getBorderColor = function(chart, seriesIndex, groupIndex) {
  // Data Override
  var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);
  if(dataItem && dataItem['borderColor'])
    return dataItem['borderColor'];

  // Series Override
  var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
  if(seriesItem && seriesItem['borderColor'])
    return seriesItem['borderColor'];
  
  // Style Defaults
  var options = chart.getOptions();
  return options['styleDefaults']['borderColor'];
};

/**
 * Returns the marker color for the specified data item.
 * @param {DvtChartImpl} chart
 * @param {number} seriesIndex
 * @param {number} groupIndex
 * @return {string} The marker color string.
 */
DvtChartStyleUtils.getMarkerColor = function(chart, seriesIndex, groupIndex) {
  // Data Override: Note that the data object defines a single 'color' attribute
  var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);
  if(dataItem && dataItem['color'])
    return dataItem['color'];

  // Series Override
  var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
  if(seriesItem && seriesItem['markerColor'])
    return seriesItem['markerColor'];
  
  // Style Defaults
  var options = chart.getOptions();
  var defaultMarkerColor = options['styleDefaults']['markerColor'];
  if(defaultMarkerColor) // Return the default if set
    return defaultMarkerColor;
  else {
    // Otherwise return the series color
    return DvtChartStyleUtils.getColor(chart, seriesIndex, groupIndex);
  }
};

/**
 * Returns the marker shape for the specified data item.  Returns the actual shape
 * if the marker shape is set to "auto".
 * @param {DvtChartImpl} chart
 * @param {number} seriesIndex
 * @param {number} groupIndex
 * @return {string} The marker shape.
 */
DvtChartStyleUtils.getMarkerShape = function(chart, seriesIndex, groupIndex) {
  // Style Defaults
  var options = chart.getOptions();
  var shape = options['styleDefaults']['markerShape'];
  
  // Series Override
  var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
  if(seriesItem && seriesItem['markerShape'])
    shape = seriesItem['markerShape'];
    
  // Data Override
  var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);
  if(dataItem && dataItem['markerShape'])
    shape = dataItem['markerShape'];
  
  // Convert automatic shape to actual shape
  if(shape == "auto") {
    if(chart.getType() == "bubble") 
      shape = "circle";
    else {
      var series = DvtChartDataUtils.getSeries(chart, seriesIndex);
      var styleIndex = DvtChartDataUtils.getSeriesStyleIndex(chart, series);
      
      // Iterate through the shape ramp to find the right shape
      var shapeRamp = options['styleDefaults']['shapes'];
      var shapeIndex = styleIndex % shapeRamp.length;
      shape = shapeRamp[shapeIndex];
    }
  }
  
  return shape;
};

/**
 * Returns the marker size for the specified data item.
 * @param {DvtChartImpl} chart
 * @param {number} seriesIndex
 * @param {number} groupIndex
 * @return {number} The marker size.
 */
DvtChartStyleUtils.getMarkerSize = function(chart, seriesIndex, groupIndex) {
  var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);
  var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
  var options = chart.getOptions();
  var markerSize;
  
  if(dataItem && dataItem['markerSize'])
    // Data Override
    markerSize = dataItem['markerSize'];
  else if(seriesItem && seriesItem['markerSize'])
    // Series Override
    markerSize = seriesItem['markerSize'];
  else
    // Style Defaults
    markerSize = options['styleDefaults']['markerSize'];
  
  // Scale down for chart overview
  if (options['_isOverview'])
    markerSize = Math.ceil(markerSize * 0.6);
    
  return markerSize;
};

/**
 * Returns the whether markers are displayed for the specified line or area series.
 * @param {DvtChartImpl} chart
 * @param {number} seriesIndex
 * @param {number} groupIndex
 * @return {String} on if markers should be displayed, false otherwise
 */
DvtChartStyleUtils.getMarkerDisplayed = function(chart, seriesIndex, groupIndex) {
  // Always show markers for bubble and scatter graphs
  var chartType = chart.getType();
  if(chartType == "scatter" || chartType == "bubble")
    return "on";
    
  // Data Override
  var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);
  if(dataItem && (dataItem['markerDisplayed'] === "on" || dataItem['markerDisplayed'] === "off"))
    return dataItem['markerDisplayed'];

  // Series Override
  var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
  if(seriesItem && (seriesItem['markerDisplayed'] === "on" || seriesItem['markerDisplayed'] === "off"))
    return seriesItem['markerDisplayed'];
  
  // Style Defaults
  var options = chart.getOptions();
  return options['styleDefaults']['markerDisplayed'];
};

/**
 * Returns the line width for the specified series.
 * @param {DvtChartImpl} chart
 * @param {number} seriesIndex
 * @return {number} The line width.
 */
DvtChartStyleUtils.getLineWidth = function(chart, seriesIndex) {
  var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
  var options = chart.getOptions();
  var lineWidth;
  
  if(seriesItem && seriesItem['lineWidth'])
    // Series Override
    lineWidth = seriesItem['lineWidth'];
  else
    // Style Defaults
    lineWidth = options['styleDefaults']['lineWidth'];
  
  // Scale down for chart overview
  if (options['_isOverview'])
    lineWidth = Math.ceil(lineWidth * 0.6);
  
  return lineWidth;
};

/**
 * Returns the line style for the specified series.
 * @param {DvtChartImpl} chart
 * @param {number} seriesIndex
 * @return {string} The line style.
 */
DvtChartStyleUtils.getLineStyle = function(chart, seriesIndex) {
  // Series Override
  var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
  if(seriesItem && seriesItem['lineStyle'])
    return seriesItem['lineStyle'];
  
  // Style Defaults
  var options = chart.getOptions();
  return options['styleDefaults']['lineStyle'];
};

/**
 * Returns the bar spacing behavior.  Only applies for spark charts.
 * @param {DvtChartImpl} chart
 * @return {string} The bar spacing behavior
 */
DvtChartStyleUtils.getBarSpacing = function(chart) {
  var options = chart.getOptions();
  return options['__sparkBarSpacing'];
};

/**
 * Returns the width for bars in the specified chart.
 * @param {DvtChartImpl} chart
 * @param {number} barSeriesCount The number of bar series in the chart.
 * @param {DvtChartAxis} axis The x-axis.
 * @return {number} The width of the bars.
 */
DvtChartStyleUtils.getBarWidth = function(chart, barSeriesCount, axis) {
  var options = chart.getOptions();
  var isPolar = DvtChartTypeUtils.isPolar(chart);
  
  var barCount; // the number of independent bars
  if(DvtChartTypeUtils.isStacked(chart))
    barCount = DvtChartTypeUtils.hasY2BarData(chart) ? 2 : 1;
  else
    barCount = barSeriesCount;
  
  var barGapRatio = options['styleDefaults']['barGapRatio'];
  if (typeof(barGapRatio) == 'string' && barGapRatio.slice(-1) == "%") // parse percent input
    barGapRatio = Number(barGapRatio.slice(0, -1)) / 100;
  if (barGapRatio == null) { // fall back to default
    if (isPolar)
      barGapRatio = (barCount == 1 || DvtChartTypeUtils.isStacked(chart)) ? 0 : 0.25;
    else
      barGapRatio = (barCount == 1) ? 0.625 : 0.25;
  }
  
  var barWidth = axis.getGroupWidth() * (1 - barGapRatio) / barCount;
  
  // Cap the barWidth to the max if specified
  var maxBarWidth = options['styleDefaults']['maxBarWidth'];
  if (maxBarWidth != null && !isPolar)
    barWidth = Math.min(barWidth, maxBarWidth);
  
  // Spark Chart Pixel Spacing Support
  if(DvtChartStyleUtils.getBarSpacing(chart) == "pixel")
    barWidth = Math.max(Math.floor(barWidth), 1);
  
  return barWidth;
};

/**
 * Returns the offset for bars in the specified chart.
 * @param {DvtChartImpl} chart
 * @param {number} barWidth The width of each bar in the chart.
 * @param {number} barSeriesCount The number of bar series in the chart.
 * @return {number} The offset for the bars.
 */
DvtChartStyleUtils.getBarOffset = function(chart, barWidth, barSeriesCount) {
  var offset = -(barWidth * barSeriesCount/2); 
  if(DvtChartTypeUtils.isStacked(chart) || DvtChartDataUtils.hasMixedFrequency(chart)) {
    if(DvtChartTypeUtils.hasY2BarData(chart))
      offset = DvtAgent.isRightToLeft(chart.getCtx()) ? 0 : -barWidth;
    else
      offset = -barWidth/2;
  }
  
  return offset;
};

/**
 * Returns the additional offset for y2 bars in the specified charts.
 * @param {DvtChartImpl} chart
 * @param {number} barWidth The width of each bar in the chart.
 * @return {number} The addition offset for the y2 bars.
 */
DvtChartStyleUtils.getY2BarOffset = function(chart, barWidth) {
  if(DvtChartTypeUtils.isStacked(chart))
    return DvtAgent.isRightToLeft(chart.getCtx()) ? -barWidth : barWidth;
  else
    return 0;
};

/**
 * Returns the visibility for the specified series.
 * @param {DvtChartImpl} chart
 * @param {number} seriesIndex
 * @return {string} The visibility.
 */
DvtChartStyleUtils.getVisibility = function(chart, seriesIndex) {
  // Series Override
  var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
  if(seriesItem && seriesItem['visibility'])
    return seriesItem['visibility'];
  else // Return the default
    return "visible";
};

/**
 * Returns true if the specified series should be rendered.
 * @param {DvtChartImpl} chart
 * @param {number} seriesIndex
 * @return {boolean} True if the series should be rendered.
 */
DvtChartStyleUtils.isSeriesRendered = function(chart, seriesIndex) {
  if(DvtChartStyleUtils.getVisibility(chart, seriesIndex) == "hidden")
    return false;
  else
    return true;
};

/**
 * Returns true if the specified data item should be rendered.
 * @param {DvtChartImpl} chart
 * @param {number} seriesIndex
 * @param {number} groupIndex
 * @return {boolean} True if the series should be rendered.
 */
DvtChartStyleUtils.isDataItemRendered = function(chart, seriesIndex, groupIndex) {
  if(DvtChartStyleUtils.getVisibility(chart, seriesIndex) == "hidden")
    return false;
  else {
    // Check if any category is hidden
    var hiddenCategories = DvtChartStyleUtils.getHiddenCategories(chart);
    var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);
    if(hiddenCategories.length > 0 && dataItem && dataItem['categories']) {
      for(var i=0; i<dataItem['categories'].length; i++) {
        var category = dataItem['categories'][i];
        if(DvtArrayUtils.getIndex(hiddenCategories, category) >= 0)
          return false;
      }
    }
  
    return true;
  }
};

/**
 * Returns the display animation for the specified chart.
 * @param {DvtChartImpl} chart
 * @return {string} 
 */
DvtChartStyleUtils.getAnimationOnDisplay = function(chart) {
  return chart.getOptions()['animationOnDisplay'];
};

/**
 * Returns the data change animation for the specified chart.
 * @param {DvtChartImpl} chart
 * @return {string} 
 */
DvtChartStyleUtils.getAnimationOnDataChange = function(chart) {
  return chart.getOptions()['animationOnDataChange'];
};

/**
 * Returns the animation duration in seconds for the specified chart.  This duration is
 * intended to be passed to the animatino handler, and is not in the same units
 * as the API.
 * @param {DvtChartImpl} chart
 * @return {number} The animation duration in seconds.
 */
DvtChartStyleUtils.getAnimationDuration = function(chart) {
  return chart.getOptions()['styleDefaults']['animationDuration']/1000;
};


/**
 * Returns the animation indicators property for the specified chart.
 * @param {DvtChartImpl} chart
 * @return {string}  The animation indicators value.
 */
DvtChartStyleUtils.getAnimationIndicators = function(chart) {
  return chart.getOptions()['styleDefaults']['animationIndicators'];
};


/**
 * Returns the animation indicators up color.
 * @param {DvtChartImpl} chart
 * @return {string}  The animation indicator up color.
 */
DvtChartStyleUtils.getAnimationUpColor = function(chart) {
  return chart.getOptions()['styleDefaults']['animationUpColor'];
};

/**
 * Returns the animation indicators down color.
 * @param {DvtChartImpl} chart
 * @return {string}  The animation indicator down color.
 */
DvtChartStyleUtils.getAnimationDownColor = function(chart) {
  return chart.getOptions()['styleDefaults']['animationDownColor'];
};

/**
 * Returns the array containing the hidden categories for the chart.
 * @return {array}
 */
DvtChartStyleUtils.getHiddenCategories = function(chart) {
  var options = chart.getOptions();
  if(!options['_hiddenCategories'])
    options['_hiddenCategories'] = [];
  
  return options['_hiddenCategories']; 
}

/**
 * Returns the inner color of the selection feedback.
 * @return {string}
 */
DvtChartStyleUtils.getSelectedInnerColor = function(chart) {
  return chart.getOptions()['styleDefaults']['selectedInnerColor'];
}

/**
 * Returns the outer color of the selection feedback.
 * @return {string}
 */
DvtChartStyleUtils.getSelectedOuterColor = function(chart) {
  return chart.getOptions()['styleDefaults']['selectedOuterColor'];
}

/**
 * Returns the data label style for the specified data point.
 * @param {DvtChartImpl} chart
 * @param {Number} seriesIndex The series index.
 * @param {Number} groupIndex The group index.
 * @param {Color} dataColor The color of the marker this is associated with.
 * @param {string} position The position returned by the getDataLabelPosition function, not the API values.
 * @returns {string} The data label, null if the index is invalid.
 */
DvtChartStyleUtils.getDataLabelStyle = function(chart, seriesIndex, groupIndex, dataColor, position){
  var labelStyleArray = [];
  if (dataColor && (DvtChartStyleUtils.getSeriesType(chart, seriesIndex) == "bar" || DvtChartTypeUtils.isBubble(chart))
       && (position == "center" || position == "inBottom" || position == "inTop" || position == "inRight" || position == "inLeft")){
    var labelColor = (DvtChartStyleUtils.getPattern(chart, seriesIndex, groupIndex) != null)? "#000000" : DvtColorUtils.getContrastingTextColor(dataColor);
    labelStyleArray.push(new DvtCSSStyle("color: " + labelColor + ";"));
  }
  else
    labelStyleArray.push(new DvtCSSStyle("color: #333333;"));
  
  labelStyleArray.push(chart.getOptions()['styleDefaults']['dataLabelStyle']);
  labelStyleArray.push(new DvtCSSStyle(DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex)['labelStyle']));
  return DvtCSSStyle.mergeStyles(labelStyleArray);
}

/**
 * Returns the data label position for the specified data point.
 * @param {DvtChartImpl} chart
 * @param {Number} seriesIndex The series index.
 * @param {Number} groupIndex The group index.
 * @returns {string} The data label position. Uses an internal list different from the API values. 
 * Possible values are: center, inRight, inLeft, inTop, inBottom, right, left, above, below
 */
DvtChartStyleUtils.getDataLabelPosition = function(chart, seriesIndex, groupIndex){
  // Read the position value
  var data = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);
  var position = data['labelPosition'];
  if (!position)
    position = chart.getOptions()['styleDefaults']['dataLabelPosition'];
      
  var bBidi = DvtAgent.isRightToLeft(chart.getCtx());
  
  // Bar has a separate treatment
  if (DvtChartStyleUtils.getSeriesType(chart, seriesIndex) == "bar"){
    // Only center is supported for polar bar
    if (DvtChartTypeUtils.isPolar(chart))
      return "center"; 
      
    // Only insideBarEdge, outsideBarEdge, and center are supported for cartesian bar.  Use default otherwise.
    if (position != "insideBarEdge" && position != "outsideBarEdge" && position != "center"){
      if (DvtChartTypeUtils.isStacked(chart))
        return "center";
      else
        position = "insideBarEdge";
    }
    
    var bNegative = DvtChartDataUtils.getValue(chart, seriesIndex, groupIndex) < 0;  
    if (position == "outsideBarEdge"){
      if (DvtChartTypeUtils.isHorizontal(chart))
        return ((!bNegative && !bBidi) || (bNegative && bBidi)) ? "right" : "left";
      else 
        return bNegative ? "below" : "above";
    }
    else if (position == "insideBarEdge"){
      if (DvtChartTypeUtils.isHorizontal(chart))
        return ((!bNegative && !bBidi) || (bNegative && bBidi)) ? "inRight" : "inLeft";
      else 
        return bNegative ? "inBottom" : "inTop";
    }
    return "center";
  }
  else if (position == "belowMarker")
    return "below";
  else if (position == "aboveMarker")
    return "above";
  else if(position != "afterMarker" && position != "beforeMarker" && position != "center"){
    if (DvtChartTypeUtils.isBubble(chart))
      return "center";
    else
      position = "afterMarker";
  }
  // For before/after Marker, bidi matters.
  if ((!bBidi && position == "afterMarker") || (bBidi && position == "beforeMarker"))
    return "right";
  else if ((!bBidi && position == "beforeMarker") || (bBidi && position == "afterMarker"))
    return "left";
  else // At this point, only remaining option is "center"
    return "center";
}

/**
 * Returns whether the overview is rendered.
 * @return {boolean}
 */
DvtChartStyleUtils.isOverviewRendered = function(chart) {
  var options = chart.getOptions();
  return DvtChartTypeUtils.isOverviewSupported(chart) && options['overview']['rendered'] != 'off';
}

/**
 * Returns the height of the overview scrollbar.
 * @return {number} The height.
 */
DvtChartStyleUtils.getOverviewHeight = function(chart) {
  var options = chart.getOptions();
  var height = options['overview']['height'];
  if (height != null) {
    if (typeof(height) == 'string') {
      if (height.slice(-1) == "%")
        height = chart.getHeight() * Number(height.slice(0, -1)) / 100;
      else if (height.slice(-2) == "px")
        height = Number(height.slice(0, -2));
      else
        height = Number(height);
    } 
    if (!isNaN(height) && height > 0)
      return height;
  } 
  
  // If nothing works, use the default
  var defaultRatio = options['timeAxisType'] == 'disabled' ? 0.2 : 0.25;
  return chart.getHeight() * defaultRatio;
}
/**
 * Text related utility functions.
 * @class
 */
var DvtChartTextUtils = new Object();

DvtObj.createSubclass(DvtChartTextUtils, DvtObj, "DvtChartTextUtils");

/**
 * Creates and adds a DvtText object to a container. Will truncate and add tooltip as necessary.
 * @param {DvtEventManager} eventManager
 * @param {DvtContainer} container The container to add the text object to.
 * @param {String} textString The text string of the text object.
 * @param {DvtCSSStyle} cssStyle The css style to apply to the text object.
 * @param {number} x The x coordinate of the text object.
 * @param {number} y The y coordinate of the text object.
 * @param {number} width The width of available text space.
 * @param {number} height The height of the available text space.
 * @param {object} params Additional parameters that will be passed to the logical object.
 * @return {DvtText} The created text object. Can be null if no text object could be created in the given space.
 */
DvtChartTextUtils.createText = function(eventManager, container, textString, cssStyle, x, y, width, height, params) {
  var text = new DvtOutputText(container.getCtx(), textString, x, y);
  text.setCSSStyle(cssStyle);
  
  if(DvtTextUtils.fitText(text, width, height, container)) {
    // Associate with logical object to support DvtComponentUIEvent and truncation
    eventManager.associate(text, new DvtSimpleObjPeer(text.getUntruncatedTextString(), null, null, params));
    return text;
  }
  else
    return null;
}
/**
 * Utility functions for DvtChartImpl.
 * @class
 */
var DvtChartTooltipUtils = new Object();

DvtObj.createSubclass(DvtChartTooltipUtils, DvtObj, "DvtChartTooltipUtils");

/** @private */
DvtChartTooltipUtils._TYPE_X = "x";
DvtChartTooltipUtils._TYPE_Y = "y";
DvtChartTooltipUtils._TYPE_Y2 = "y2";
DvtChartTooltipUtils._TYPE_Z = "z";
DvtChartTooltipUtils._TYPE_VALUE = "value";
DvtChartTooltipUtils._TYPE_TARGET_VALUE = "targetValue";

/**
 * Returns true if the specified chart displays datatips.
 * @param {DvtChartImpl} chart
 * @return {boolean}
 */
DvtChartTooltipUtils.hasDatatips = function(chart) {
  var options = chart.getOptions();
  if(options['styleDefaults']['seriesTooltipType'] == "none" && 
     options['styleDefaults']['groupTooltipType'] == "none" &&
     options['styleDefaults']['valueTooltipType'] == "none")
    return false;
  else
    return true;
}

/**
 * Returns the datatip color for the tooltip of a data item with the given series 
 * and group indices.
 * @param {DvtChartImpl} chart 
 * @param {number} seriesIndex
 * @param {number} groupIndex
 * @return {string} The datatip color.
 */
DvtChartTooltipUtils.getDatatipColor = function(chart, seriesIndex, groupIndex) {
  return DvtChartStyleUtils.getColor(chart, seriesIndex, groupIndex);
}

/**
 * Returns the datatip text for a data item with the given series and group indices.
 * @param {DvtDisplayable} target The target of the event.
 * @param {DvtChartImpl} chart 
 * @param {number} seriesIndex
 * @param {number} groupIndex
 * @return {string} The tooltip text.
 */
DvtChartTooltipUtils.getDatatip = function(target, chart, seriesIndex, groupIndex) {
  // Only data items have tooltips
  if(seriesIndex < 0 || groupIndex < 0)
    return null;
    
  // Custom Tooltip Support
  var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);
  if(dataItem && dataItem['shortDesc'])
    return dataItem['shortDesc'];

  // Default Tooltip Support
  var arTooltip = [];
  
  // Series Tooltip
  DvtChartTooltipUtils._addSeriesStrings(arTooltip, chart, seriesIndex, groupIndex);
  
  // Group Tooltip
  DvtChartTooltipUtils._addGroupStrings(arTooltip, chart, seriesIndex, groupIndex);
    
  // Value Tooltip
  DvtChartTooltipUtils._addValueStrings(arTooltip, chart, seriesIndex, groupIndex);
  
  // Combine the lines and return the tooltip string
  return DvtChartTooltipUtils._convertLinesToString(arTooltip);
}

/**
 * Returns the datatip text for an "Other" slice.
 * @param {DvtChartImpl} chart 
 * @param {number} otherValue The value of the "Other" slice
 * @param {number} groupIndex
 * @return {string} The tooltip text.
 */
DvtChartTooltipUtils.getOtherSliceDatatip = function(chart, otherValue, groupIndex) {
  // Only data items have tooltips
  if(groupIndex < 0)
    return null;

  // Default Tooltip Support
  var arTooltip = [];
  var options = chart.getOptions();
  var bundle = chart.getBundle();
  
  // Series Tooltip
  if(options['styleDefaults']['seriesTooltipType'] != "none") {
    var otherStr = bundle.getTranslatedString('LABEL_OTHER', null);
    arTooltip.push(otherStr); 
  }
  
  // Group Tooltip
  DvtChartTooltipUtils._addGroupStrings(arTooltip, chart, 0, groupIndex);
    
  // Value Tooltip
  if(options['styleDefaults']['valueTooltipType'] != "none") {
    var val = otherValue;
    var valueFormats = options['valueFormats'];
    val = DvtChartTooltipUtils._formatValue(valueFormats, DvtChartTooltipUtils._TYPE_VALUE, val); 
    var labelValue = bundle.getTranslatedString('LABEL_VALUE', val);
    arTooltip.push(labelValue);
  }
  
  // Combine the lines and return the tooltip string
  return DvtChartTooltipUtils._convertLinesToString(arTooltip);
}

/**
 * Returns the tooltip for the reference object.
 * @param {DvtChartImpl} chart
 * @param {object} refObj The reference object definition.
 * @return {string} The tooltip for the reference object.
 */
DvtChartTooltipUtils.getRefObjTooltip = function(chart, refObj) {
  // Custom Tooltip Support
  if(refObj['shortDesc'])
    return refObj['shortDesc'];
}

/**
 * Adds the series strings to the tooltip array.
 * @param {array} arTooltip The tooltip array.
 * @param {DvtChartImpl} chart The owning chart instance.
 * @param {number} seriesIndex
 * @param {number} groupIndex
 */
DvtChartTooltipUtils._addSeriesStrings = function(arTooltip, chart, seriesIndex, groupIndex) {
  var options = chart.getOptions();
  if(options['styleDefaults']['seriesTooltipType'] == "none")
    return;
  else {
    var bundle = chart.getBundle();
    
    // Find the series and the data item using the indices
    var seriesLabel = DvtChartDataUtils.getSeriesLabel(chart, seriesIndex);
    if(seriesLabel) {
      if(chart.getType() == "funnel") {
        arTooltip.push(seriesLabel);
      }
      else {
        var labelSeries = bundle.getTranslatedString('LABEL_SERIES', seriesLabel);
        arTooltip.push(labelSeries); 
      }
    }
  }
}

/**
 * Adds the group strings to the tooltip array.
 * @param {array} arTooltip The tooltip array.
 * @param {DvtChartImpl} chart The owning chart instance.
 * @param {number} seriesIndex
 * @param {number} groupIndex
 */
DvtChartTooltipUtils._addGroupStrings = function(arTooltip, chart, seriesIndex, groupIndex) {
  var options = chart.getOptions();
  var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);
  
  if(options['styleDefaults']['groupTooltipType'] == "none" ||
     DvtChartTypeUtils.isPie(chart))
    return;
  else {
    var bundle = chart.getBundle();
    var groupLabel;
    
    if (options['timeAxisType'] && options['timeAxisType'] != "disabled") {
      var xAxis = chart.xAxis;
      groupLabel = xAxis.__getInfo().formatLabel(dataItem['x']);
    } else {
      groupLabel = DvtChartDataUtils.getGroupLabel(chart, groupIndex);
    }
    if(groupLabel) {
      var labelGroup = bundle.getTranslatedString('LABEL_GROUP', groupLabel);
      arTooltip.push(labelGroup);
    }
  }
}

/**
 * Adds the value strings to the tooltip array.
 * @param {array} arTooltip The tooltip array.
 * @param {DvtChartImpl} chart The owning chart instance.
 * @param {number} seriesIndex
 * @param {number} groupIndex
 */
DvtChartTooltipUtils._addValueStrings = function(arTooltip, chart, seriesIndex, groupIndex) {
  var options = chart.getOptions();
  if(options['styleDefaults']['valueTooltipType'] == "none")
    return;
  else {
    var bundle = chart.getBundle();
    var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);
  
    // Number Formatting for Tooltips
    var valueFormats = options['valueFormats'];
    
    if(chart.getType() == "scatter" || chart.getType() == "bubble") {
      // Add the x and y values
      var xValue = dataItem['x'];
      var y1Value = dataItem['y'];
      xValue = DvtChartTooltipUtils._formatValue(valueFormats, DvtChartTooltipUtils._TYPE_X, xValue);
      y1Value = DvtChartTooltipUtils._formatValue(valueFormats, DvtChartTooltipUtils._TYPE_Y, y1Value);
      var labelX = bundle.getTranslatedString('LABEL_X', xValue);
      var labelY = bundle.getTranslatedString('LABEL_Y', y1Value);
      arTooltip.push(labelX); 
      arTooltip.push(labelY);
      
      // Also add the z value for a bubble chart
      if(chart.getType() == "bubble") {
        var zValue = dataItem['z'];
        zValue = DvtChartTooltipUtils._formatValue(valueFormats, DvtChartTooltipUtils._TYPE_Z, zValue);
        var labelZ = bundle.getTranslatedString('LABEL_Z', zValue);
        arTooltip.push(labelZ);
      }
    }
    else if(chart.getType() == "pie") {
      var val = DvtChartDataUtils.getValue(chart, seriesIndex, groupIndex);
      val = DvtChartTooltipUtils._formatValue(valueFormats, DvtChartTooltipUtils._TYPE_VALUE, val);  
      var labelValue = bundle.getTranslatedString('LABEL_VALUE', val);
      arTooltip.push(labelValue);
    }
    else if(chart.getType() == "funnel") {
      var val = DvtChartDataUtils.getValue(chart, seriesIndex, groupIndex);
      val = DvtChartTooltipUtils._formatValue(valueFormats, DvtChartTooltipUtils._TYPE_VALUE, val);  
      var labelValue = bundle.getTranslatedString('LABEL_VALUE', val);
      arTooltip.push(labelValue);
      var target = DvtChartDataUtils.getTargetValue(chart, seriesIndex);
      if (target) {
        target = DvtChartTooltipUtils._formatValue(valueFormats, DvtChartTooltipUtils._TYPE_TARGET_VALUE, target);  
        var labelValue2 = bundle.getTranslatedString('LABEL_TARGET_VALUE', target);
        arTooltip.push(labelValue2);
      }
    }
    else { // bar, line, area, combo
      // Add the y value string
      var yValue = DvtChartDataUtils.getValue(chart, seriesIndex, groupIndex);
      var type = DvtChartDataUtils.isAssignedToY2(chart, seriesIndex) ? DvtChartTooltipUtils._TYPE_Y2 : DvtChartTooltipUtils._TYPE_Y;
      yValue = DvtChartTooltipUtils._formatValue(valueFormats, type, yValue);
      var labelValue2 = bundle.getTranslatedString('LABEL_VALUE', yValue);
      arTooltip.push(labelValue2);
    }
  }
}

/**
 * Converts the lines of the tooltip into a single string.
 * @param {array} arTooltip The array of strings containing the lines of the tooltip.
 * @return {string} The resulting tooltip string.
 */
DvtChartTooltipUtils._convertLinesToString = function(arTooltip) {
  var ret = "";
  for(var i=0; i<arTooltip.length; i++) {
    if(ret.length > 0)
      ret += "\n";
  
    ret += arTooltip[i];
  }
  return ret;
}

/**
 * Format value with the converter from the valueFormats
 * @param {array} valueFormats the array of the value formats
 * @param {string} type the type 
 * @param {number} value the value to format
 * @param {number} [min] Optional min value of the axis corresponding to the value.  This should be provided only if the
 *                       label should be formatted in the context of the axis extents.
 * @param {number} [max] Optional max value of the axis corresponding to the value.  This should be provided only if the
 *                       label should be formatted in the context of the axis extents.
 * @param {number} [majorIncrement] Optional major increment of the axis corresponding to the value.  This should be 
 *                                  provided only if the label should be formatted in the context of the axis extents.
 * @return {string} the formatted value string
 */
DvtChartTooltipUtils._formatValue = function (valueFormats, type, value, min, max, majorIncrement) {
  var scaling = "auto";
  var autoPrecision = "on";
  var converter;
  // override from valueFormat
  if (valueFormats) {
    for (var i = 0; i < valueFormats.length; i++) {
      if (valueFormats[i]['type'] == type) {
        if (valueFormats[i]['scaling'])
          scaling = valueFormats[i]['scaling'];
        if (valueFormats[i]['autoPrecision'])
          autoPrecision = valueFormats[i]['autoPrecision'];
        if (valueFormats[i]['converter'])
          converter = valueFormats[i]['converter'];
        break;
      }
    }
  }
  
  // Retrieve the extent information
  min = (min != null) ? min : value;
  max = (max != null) ? max : value;
  majorIncrement = (majorIncrement != null) ? majorIncrement : 0;
  
  // Create the formatter
  var formatter = new DvtLinearScaleAxisValueFormatter(min, max, majorIncrement, scaling, autoPrecision);
  if (converter && converter.getAsString)
    return formatter.format(value, converter);
    
  else if (converter && converter['format'])
    return converter['format'](value);
    
  else 
    return formatter.format(value);
}
/**
 * Utility functions for DvtChartImpl.
 * @class
 */
var DvtChartTypeUtils = new Object();

DvtObj.createSubclass(DvtChartTypeUtils, DvtObj, "DvtChartTypeUtils");

/**
 * Returns true if the chart is a spark.
 * @param {DvtChartImpl} chart
 * @return {boolean}
 */
DvtChartTypeUtils.isSpark = function(chart) {
  return chart.getOptions()['__spark'];
}

/**
 * Returns true if the chart is a combo type.
 * @param {DvtChartImpl} chart
 * @return {boolean}
 */
DvtChartTypeUtils.isCombo = function(chart) {
  return chart.getType() == "combo";
}

/**
 * Returns true if the chart is a vertical type.
 * @param {DvtChartImpl} chart
 * @return {boolean}
 */
DvtChartTypeUtils.isVertical = function(chart) {
  return !DvtChartTypeUtils.isHorizontal(chart) && !DvtChartTypeUtils.isPolar(chart);
}

/**
 * Returns true if the chart is a horizontal type.
 * @param {DvtChartImpl} chart
 * @return {boolean}
 */
DvtChartTypeUtils.isHorizontal = function(chart) {
  if (chart.getType() == "horizontalBar")
    return true;
  
  return chart.getOptions()['orientation'] == "horizontal" && !DvtChartTypeUtils.isPolar(chart) 
      && (DvtChartTypeUtils.isBLAC(chart) || DvtChartTypeUtils.isFunnel(chart));
}

/**
 * Returns true if the chart is polar.
 * @param {DvtChartImpl} chart
 * @return {boolean}
 */
DvtChartTypeUtils.isPolar = function(chart) {
  return chart.getOptions()['coordinateSystem'] == "polar";
}

/**
 * Returns true if the chart series should be stacked.
 * @param {DvtChartImpl} chart
 * @return {boolean}
 */
DvtChartTypeUtils.isStacked = function(chart) {
  // To be stacked, the attribute must be set and the chart must be a supporting type.
  var options = chart.getOptions();
  if(options['stack'] != "on" || DvtChartDataUtils.hasMixedFrequency(chart))
    return false;

  var type = chart.getType();
  return type == "bar" || type == "line" || type == "area" || 
         type == "combo" || type == "horizontalBar";
}

/**
 * Returns true if the chart is a bar graph.
 * @param {DvtChartImpl} chart
 * @return {boolean}
 */
DvtChartTypeUtils.isBar = function(chart) {
  var type = chart.getType();
  return type == "bar" || type == "horizontalBar";
}

/**
 * Returns true if the chart is a line graph.
 * @param {DvtChartImpl} chart
 * @return {boolean}
 */
DvtChartTypeUtils.isLine = function(chart) {
  return chart.getType() == "line";
}

/**
 * Returns true if the chart is an area graph.
 * @param {DvtChartImpl} chart
 * @return {boolean}
 */
DvtChartTypeUtils.isArea = function(chart) {
  return chart.getType() == "area";
}

/**
 * Returns true if the chart is a scatter graph.
 * @param {DvtChartImpl} chart
 * @return {boolean}
 */
DvtChartTypeUtils.isScatter = function(chart) {
  return chart.getType() == "scatter";
}

/**
 * Returns true if the chart is a bubble graph.
 * @param {DvtChartImpl} chart
 * @return {boolean}
 */
DvtChartTypeUtils.isBubble = function(chart) {
  return chart.getType() == "bubble";
}

/**
 * Returns true if the chart is a pie graph.
 * @param {DvtChartImpl} chart
 * @return {boolean}
 */
DvtChartTypeUtils.isPie = function(chart) {
  return chart.getType() == "pie";
}

/**
 * Returns true if the chart is a funnel graph.
 * @param {DvtChartImpl} chart
 * @return {boolean}
 */
DvtChartTypeUtils.isFunnel = function(chart) {
  return chart.getType() == "funnel";
}

/**
 * Returns true if the chart supports dual-y.
 * @param {DvtChartImpl} chart
 * @return {boolean}
 */
DvtChartTypeUtils.isDualY = function(chart) {
  // Verify the chart type
  if(!DvtChartTypeUtils.hasAxes(chart) || DvtChartTypeUtils.isScatterBubble(chart))
    return false;
    
  // Dual-Y
  return true;
}

/**
 * Returns true if the chart is type bar, line, area or combo.
 * @param {DvtChartImpl} chart
 * @return {boolean}
 */
DvtChartTypeUtils.isBLAC = function(chart) {
  var type = chart.getType();
  return (type == "bar" || type == "horizontalBar" || type == "line" || type == "area" || type == "combo");
}

/**
 * Returns true if the chart is type scatter or bubble.
 * @param {DvtChartImpl} chart
 * @return {boolean}
 */
DvtChartTypeUtils.isScatterBubble = function(chart) {
  var type = chart.getType();
  return (type == "scatter" || type == "bubble");
}

/**
 * Returns whether zoom and scroll is supported for the chart type
 * @param {DvtChartImpl} chart
 * @return {boolean}
 */
DvtChartTypeUtils.isScrollSupported = function(chart) {
  return !DvtChartTypeUtils.isPie(chart) && !DvtChartTypeUtils.isFunnel(chart) && !DvtChartTypeUtils.isPolar(chart);
}

/**
 * Returns whether overview scrollbar is supported for the chart type
 * @param {DvtChartImpl} chart
 * @return {boolean}
 */
DvtChartTypeUtils.isOverviewSupported = function(chart) {
  return DvtChartTypeUtils.isBLAC(chart) && DvtChartTypeUtils.isVertical(chart);
}

/**
 * Returns whether horizontal scrollbar is supported for the chart type
 * @param {DvtChartImpl} chart
 * @return {boolean}
 */
DvtChartTypeUtils.isHorizScrollbarSupported = function(chart) {
  if (DvtChartTypeUtils.isPolar(chart))
    return false;
  return (DvtChartTypeUtils.isBLAC(chart) && DvtChartTypeUtils.isVertical(chart)) || DvtChartTypeUtils.isScatterBubble(chart);
}

/**
 * Returns whether vertical scrollbar is supported for the chart type
 * @param {DvtChartImpl} chart
 * @return {boolean}
 */
DvtChartTypeUtils.isVertScrollbarSupported = function(chart) {
  if (DvtChartTypeUtils.isPolar(chart))
    return false;
  return (DvtChartTypeUtils.isBLAC(chart) && DvtChartTypeUtils.isHorizontal(chart)) || DvtChartTypeUtils.isScatterBubble(chart);
}

/**
 * Returns true if the chart has axes.
 * @param {DvtChartImpl} chart
 * @return {boolean}
 */
DvtChartTypeUtils.hasAxes = function(chart) {
  return !(chart.getType() == "pie" || chart.getType() == "funnel");
}

/**
 * Returns true if the chart has y2 data items only.
 * @param {DvtChartImpl} chart
 * @return {boolean}
 */
DvtChartTypeUtils.hasY2DataOnly = function(chart) { 
  if(!DvtChartTypeUtils.isDualY(chart))
    return false;
    
  // Verify the chart has a y2 series
  var options = chart.getOptions();
  var seriesCount = DvtChartDataUtils.getSeriesCount(chart);
  if(seriesCount == 0)
    return false; // treat no data as a y1 case
  
  for(var i=0; i<seriesCount; i++) {
    if(!DvtChartDataUtils.isAssignedToY2(chart, i))
      return false;
  }
  
  // No y1 value found
  return true;
}

/**
 * Returns true if the chart has y2 data items.
 * @param {DvtChartImpl} chart
 * @param {string} type Optional series type to look for.
 * @return {boolean}
 */
DvtChartTypeUtils.hasY2Data = function(chart, type) { 
  if(!DvtChartTypeUtils.isDualY(chart))
    return false;
    
  // Verify the chart has a y2 series
  var options = chart.getOptions();
  var seriesCount = DvtChartDataUtils.getSeriesCount(chart);
  for(var i=0; i<seriesCount; i++) {
    if(type && DvtChartStyleUtils.getSeriesType(chart, i) != type)
      continue;
  
    if(DvtChartDataUtils.isAssignedToY2(chart, i))
      return true;
  }
  
  // No y2 value found
  return false;
}

/**
 * Returns true if the chart has y2 data items.
 * @param {DvtChartImpl} chart
 * @return {boolean}
 */
DvtChartTypeUtils.hasY2BarData = function(chart) { 
  return DvtChartTypeUtils.hasY2Data(chart, "bar");
}

/**
 * @param {DvtChartImpl} chart
 * @return {boolean} true if on of the series type is bar graph.
 */
DvtChartTypeUtils.hasBarSeries = function(chart) {
     
     if(DvtChartTypeUtils.isBar(chart)){
        return true;
     } else if(DvtChartTypeUtils.isCombo(chart)){     
         var seriesCount = DvtChartDataUtils.getSeriesCount(chart); 
        
         for(var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
            // Ignore the series if it isn't rendered
            if(!DvtChartStyleUtils.isSeriesRendered(chart, seriesIndex)){
              continue;
            } else if(DvtChartStyleUtils.getSeriesType(chart, seriesIndex) == "bar") {
              return true;
            }
          } 
    }
    return false;
}
/**
 * Bubble chart utility functions for DvtChartImpl.
 * @class
 */
var DvtChartMarkerUtils = new Object();

DvtObj.createSubclass(DvtChartMarkerUtils, DvtObj, "DvtChartMarkerUtils");

/** @private */
DvtChartMarkerUtils._MIN_RADIUS = 5;
/** @private */
DvtChartMarkerUtils._MAX_RADIUS_PERCENT = 0.125;
/** @private */
DvtChartMarkerUtils._DEFAULT_MARKER_SIZE_PERCENT = .20;

/**
 * Calculates the bubble sizes for the chart.
 * @param {DvtChartImpl} chart
 * @param {number} width The width of the plot area.
 * @param {number} height The height of the plot area.
 */
DvtChartMarkerUtils.calcBubbleSizes = function (chart, width, height) {
  // Calculate the min and max z values
  var minMax = DvtChartDataUtils.getMinMaxValue(chart, "z");
  var minValue = minMax['min'];
  var maxValue = minMax['max'];
  
  // To approximate bubble radius in axis coordinate space instead of pixel used for auto axis extent calculation,
  // assume x and y axis includes 0. 
  var xMinMax = DvtChartDataUtils.getMinMaxValue(chart, "x");
  var xAxisValueRange = Math.max(0, xMinMax['max']) - Math.min(0, xMinMax['min']); // Assume we start from 0 for axis extents when auto calculating
  var yMinMax = DvtChartDataUtils.getMinMaxValue(chart, "y");
  var yAxisValueRange = Math.max(0, yMinMax['max']) - Math.min(0, yMinMax['min']);
  var options = chart.getOptions();

  var axisWidth, axisHeight;
  if (DvtChartTypeUtils.isPolar(chart)) {
    axisWidth = Infinity;
    axisHeight = chart.getRadius();
  }
  else {
    axisWidth = (1 - options['layout']['axisMaxSize']) * width; 
    axisHeight = (1 - options['layout']['axisMaxSize']) * height;
  }

  // Calculate the max allowed bubble sizes
  var minArea = Math.PI * Math.pow(DvtChartMarkerUtils._MIN_RADIUS, 2);
  var maxRadius = DvtChartMarkerUtils._MAX_RADIUS_PERCENT * Math.min(width, height);
  var maxArea = Math.PI * Math.pow(maxRadius, 2);
  
  // Adjust the min and max bubble sizes based on data distribution and count
  var minMaxArea = DvtChartMarkerUtils._adjustBubbleSizeRangeForCount(chart, minArea, maxArea, minValue, maxValue);
  minArea = minMaxArea['minArea'];
  maxArea = minMaxArea['maxArea'];

  // Adjust the min and max bubble sizes based on data range
  minMaxArea = DvtChartMarkerUtils._adjustBubbleSizeRangeForDataRange(chart, minArea, maxArea, minValue, maxValue);
  minArea = minMaxArea['minArea'];
  maxArea = minMaxArea['maxArea'];
  
  // Calculate bubble sizes based on min and max area
  var valueRange = maxValue - minValue;
  var areaRange = maxArea - minArea;
  
  // Loop through the data and update the sizes
  var seriesCount = DvtChartDataUtils.getSeriesCount(chart);
  for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
    var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
    var numGroups = seriesItem['items'] ? seriesItem['items'].length : 0;
    for (var j = 0;j < numGroups;j++) {
      var dataItem = seriesItem['items'][j];

      // If a z value exists, calculate and set the marker size
      if (dataItem && dataItem['z']) {
        // Marker size is calculated using the relative size fraction of the range.
        if (seriesCount === 1 && numGroups === 1) {
          dataItem['markerSize'] = DvtChartMarkerUtils._DEFAULT_MARKER_SIZE_PERCENT * Math.min(axisWidth, axisHeight);
          xAxisValueRange = xAxisValueRange === 0 ? 100 : xAxisValueRange;
          yAxisValueRange = yAxisValueRange === 0 ? 100 : yAxisValueRange;
        } else {
          var relSize = (dataItem['z'] - minValue) / valueRange;
          var area = minArea + (relSize * areaRange);
          dataItem['markerSize'] = 2 * Math.sqrt(area / Math.PI);
        }
        dataItem['_xAxisRadius'] = (dataItem['markerSize']/axisWidth) * 0.5 * xAxisValueRange;
        dataItem['_yAxisRadius'] = (dataItem['markerSize']/axisHeight) * 0.5 * yAxisValueRange;
      }
    }
  }
}

/**
 * Sorts the markers in order of descending marker size.
 * @param {array} markers The array of DvtMarkers.
 */
DvtChartMarkerUtils.sortMarkers = function (markers) {
  markers.sort(DvtChartMarkerUtils._compareSize);
}

/**
 * Compare function to sort markers in order of descending size.
 * @private
 */
DvtChartMarkerUtils._compareSize = function (a, b) {
  // We want to sort the markers from biggest to smallest
  var aSize = a.getSize();
  var bSize = b.getSize();
  if (aSize > bSize)
    return  - 1;
  else if (aSize < bSize)
    return 1;
  else 
    return 0;
}

/**
 * Adjust the min and max possible bubble sizes based on the number of bubbles
 * and the distribution of the data.
 * @param {DvtChartImpl} chart
 * @param {number} minArea The min bubble area
 * @param {number} maxArea The max bubble area
 * @param {number} minValue The bubble with the min z value.
 * @param {number} maxValue The bubble with the max z value.
 * @return {object} An object containing the minArea and the maxArea.
 * @private
 */
DvtChartMarkerUtils._adjustBubbleSizeRangeForCount = function (chart, minArea, maxArea, minValue, maxValue) {
  // Algorithm from JChart_2D_Scat.java
  // Calculate the bubble count and average relative size (area - minArea)/(areaRange)
  var bubbleCount = 0;
  var sizeTotal = 0;
  var seriesCount = DvtChartDataUtils.getSeriesCount(chart);
  for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
    var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
    var numDataItems = seriesItem['items'].length;
    for (var j = 0;j < numDataItems;j++) {
      var dataItem = seriesItem['items'][seriesIndex];
      if (dataItem && dataItem['z']) {
        bubbleCount++;
        sizeTotal += dataItem['z'];
      }
    }
  }

  var avgRelSize = ((sizeTotal / bubbleCount) - minValue) / (maxValue - minValue);

  ///////////////////////////////////////////////////////////////////
  // Reduce the max bubble size
  ///////////////////////////////////////////////////////////////////
  //The algorithm to reduce the max bubble size based on the number of bubbles looks
  //like the graph below.  If the number of bubbles is less than t1, the
  //first threshold, then no reduction occurs.  If the number of bubbles
  //is greater than t2, the second threshold, then the range of bubble sizes
  //is reduced to the floor percentage of the original range.  If the number of
  //bubbles is between t1 and t2, then the bubble size range is reduced by
  //a percentage of the original range.  
  //The data distribution affects the values of t1 and t2.  Each threshold has
  //a min and max associated with it.  The average relative value of the data, 
  //between 0 and 1, is used to determine the exact value of the thresholds
  //within their ranges.  The percentage reduction that occurs for each bubble 
  //between t1 and t2, p12, is equal to (1 - floor) / (t2 - t1).  
  // % original bubble size range
  //
  //           ^
  //           |
  //     100% -|------
  //           |      \ -p12
  //           |       \  |
  //           |        \
  //    floor -|         -------
  //           |                
  //          -|-----|---|------>   # of bubbles
  //           |     t1  t2
  //initialize the threshold ranges
  var t1Min = 15;
  var t1Max = 45;
  var t2Min = 30;
  var t2Max = 180;

  //initialize the floor value
  var floor = .15;

  //calculate the exact thresholds based on the ranges
  var t1 = t1Min + Math.floor((1.0 - avgRelSize) * (t1Max - t1Min));
  var t2 = t2Min + Math.floor((1.0 - avgRelSize) * (t2Max - t2Min));

  //determine the percentage reduction per bubble between t1 and t2
  var p12 = (1.0 - floor) / (t2 - t1);

  //if there are more than t2 bubbles, the range is reduced to the floor;
  //if there are more than t1 bubbles, the range is reduced by the
  //calculated percentage;
  //if there are fewer than t1 bubbles, no reduction occurs
  if (bubbleCount >= t2)
    maxArea = minArea + (floor * (maxArea - minArea));
  else if (bubbleCount >= t1)
    maxArea -= (p12 * (bubbleCount - t1) * (maxArea - minArea));

  ///////////////////////////////////////////////////////////////////
  // Increase the min bubble size
  ///////////////////////////////////////////////////////////////////
  //The algorithm to increase the min bubble size based on the number of bubbles looks
  //like the graph below.  If the number of bubbles is less than s1, the
  //first threshold, then the ceiling percentage of the range is used as the minimum
  //bubble size.  If the number of bubbles is greater than s2, the second threshold, 
  //then the min size is reduced to the absolute min of the original range.  
  //If the number of bubbles is between s1 and s2, then the min is increased by
  //a percentage of the original range.  
  //The data distribution affects the values of s1 and s2.  Each threshold has
  //a min and max associated with it.  The average relative value of the data, 
  //between 0 and 1, is used to determine the exact value of the thresholds
  //within their ranges.  The percentage reduction that occurs for each bubble 
  //between s1 and s2, q12, is equal to (ceil) / (s2 - s1).  
  // % original bubble size range
  //
  //           ^
  //           |
  //     ceil -|------
  //           |      \ -q12
  //           |       \  |
  //           |        \
  //       0% -|-----|---|------>   # of bubbles
  //           |     s1  s2
  //initialize the threshold ranges
  var s1Min = 5;
  var s1Max = 20;
  var s2Min = 30;
  var s2Max = 100;

  //initialize the ceiling value
  var ceil = .005;

  //calculate the exact thresholds based on the ranges
  var s1 = s1Min + Math.floor((1.0 - avgRelSize) * (s1Max - s1Min));
  var s2 = s2Min + Math.floor((1.0 - avgRelSize) * (s2Max - s2Min));

  //determine the percentage reduction per bubble between s1 and s2
  var q12 = (ceil) / (s2 - s1);

  //if there are more than s2 bubbles, the min is the original min;
  //if there are less than s1 bubbles, the min is increased by ceil% of the
  //original range;
  //if there are between s1 and s2 bubbles, the min is increased by the calculated
  //percentage between 0 and the ceiling
  if (bubbleCount < s1)
    minArea = minArea + (ceil * (maxArea - minArea));
  else if (bubbleCount < s2)
    minArea += ((ceil - (q12 * (bubbleCount - s1))) * (maxArea - minArea));

  return {'minArea' : minArea, 'maxArea' : maxArea};
}

/**
 * Adjust the min and max possible bubble sizes based on the number of bubbles
 * and the distribution of the data.
 * @param {DvtChartImpl} chart
 * @param {number} minArea The min bubble area
 * @param {number} maxArea The max bubble area
 * @param {number} minValue The bubble with the min z value.
 * @param {number} maxValue The bubble with the max z value.
 * @return {object} An object containing the minArea and the maxArea.
 * @private
 */
DvtChartMarkerUtils._adjustBubbleSizeRangeForDataRange = function (chart, minArea, maxArea, minValue, maxValue) {
  // Algorithm from JChart_2D_Scat.java
  //NOTE: bubble sizes should not be affected by the particular units of 
  //measurement used for the data; for instance, if the data is 1 - 100
  //or 10,000 - 1,000,000, then the ratio of max to min is 100:1 in 
  //both cases, so given similar data distributions the bubble sizes should
  //be similar
  // adjust the bubble size range based on the data range
  var dataRange = maxValue - minValue;

  //if there is only one bubble size, then there is no data range, and
  //therefore no reduction of bubble sizes
  if (dataRange != 0.0) {
    //the ratio of max / min bubble sizes
    var bubbleRatio = maxArea / minArea;

    //don't know how to handle the case where one value is 0, or where one value is
    //negative and the other is positive, so do not reduce bubble sizes in
    //that case
    var dataRatio = bubbleRatio;
    if (maxValue > 0 && minValue > 0)
      dataRatio = maxValue / minValue;
    else if (minValue < 0 && maxValue < 0)
      dataRatio = minValue / maxValue;

    if (dataRatio < bubbleRatio) {
      var desiredBubbleRatio = dataRatio;

      //NOTE: the reduction in bubble size range to produce the desired ratio
      //can be done either linearly or proportionally.  It is being done linearly 
      //because the bubble sizes end up being larger.
      //                //equiproportional reduction
      //                //The equation used to reduce the bubble size range to match the data range, if 
      //                //necessary, is as follows:
      //                // maxBubbleSize / buffer    
      //                //------------------------ = ratio
      //                // minBubbleSize * buffer    
      //                //
      //                //Solving for buffer:
      //                //
      //                //                     maxBubbleSize / minBubbleSize
      //                //buffer = Math.sqrt( -------------------------------) = Math.sqrt(bubbleRatio / ratio);
      //                //                                ratio
      //                double proportion = Math.sqrt(bubbleRatio / desiredBubbleRatio);
      //                minArea *= proportion;
      //                maxArea /= proportion;
      //equidistant reduction
      //The equation used to reduce the bubble size range to match the data range, if 
      //necessary, is as follows:
      //      maxBubbleSize
      //------------------------ = ratio
      // minBubbleSize + buffer    
      //
      //Solving for buffer:
      //
      //          maxBubbleSize
      //buffer = --------------- - minBubbleSize
      //              ratio
      var buffer = (maxArea / desiredBubbleRatio) - minArea;
      if (buffer > 0) {
        minArea += buffer;
      }
    }
  }
  else {
    //if dataRange is 0, meaning there is only one value (although there may be
    //multiple bubbles), then use the maximum bubble size
    minArea = maxArea;
  }

  return {'minArea' : minArea, 'maxArea' : maxArea};
}
/**
 * Utility functions for pie chart.
 * @class
 */
var DvtPieChartUtils = new Object();

DvtObj.createSubclass(DvtPieChartUtils, DvtObj, "DvtPieChartUtils");

DvtPieChartUtils.OTHER_SLICE_SERIES_ID = "_dvtOther";

/**
 * Generates the slice ID of a pie series
 * @param {DvtChartImpl} chart The pie chart
 * @param {Number} seriesIndex The series index
 * @return {DvtChartDataItem} The slice ID
 */
DvtPieChartUtils.getSliceId = function(chart, seriesIndex) {
  var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, 0);
  var id = dataItem ? dataItem['id'] : null;
  var series = DvtChartDataUtils.getSeries(chart, seriesIndex);
  var group = DvtChartDataUtils.getGroup(chart, 0);
  return new DvtChartDataItem(id, series, group);
}

/**
 * Generates the slice ID of a pie "Other" series
 * @param {DvtChartImpl} chart The pie chart
 * @return {DvtChartDataItem} The slice ID
 */
DvtPieChartUtils.getOtherSliceId = function(chart) {
  var group = DvtChartDataUtils.getGroup(chart, 0);
  return new DvtChartDataItem(null, DvtPieChartUtils.OTHER_SLICE_SERIES_ID, group);
}

/**
 * Returns an array of series indices that will be rendered on the pie chart.
 * The array is sorted if sorting is enabled, and does not include the series that will be grouped under "Other" slice.
 * The array includes hidden series and series with non-positive values.
 * @param {DvtChartImpl} chart The pie chart
 * @return {Array} The array containing series indices
 */
DvtPieChartUtils.getRenderedSeriesIndices = function(chart) {
  return DvtPieChartUtils._getSeriesIndicesArrays(chart).rendered;
}

/**
 * Returns whether the pie has at least one series (visible or hidden) that is grouped under "Other".
 * @param {DvtChartImpl} chart The pie chart
 * @return {Boolean}
 */
DvtPieChartUtils.hasOtherSeries = function(chart) {
  return DvtPieChartUtils._getSeriesIndicesArrays(chart).other.length > 0;
}

/**
 * Computes the total value of the "Other" slice. Only includes visible series with positive values.
 * @param {DvtChartImpl} chart The pie chart
 * @return {Number} The total value
 */
DvtPieChartUtils.getOtherValue = function(chart) {
  var otherSeries = DvtPieChartUtils._getSeriesIndicesArrays(chart).other;
  var otherValue = 0;
  for (var i = 0; i < otherSeries.length; i++) {
    var seriesIndex = otherSeries[i];
    // Only add the values of visible series
    if(DvtChartStyleUtils.isSeriesRendered(chart, seriesIndex)) {
      var value = DvtChartDataUtils.getValue(chart, seriesIndex, 0);
      if (value > 0)
        otherValue += value;
    }
  }
  return otherValue;
}

/**
 * Generates the slice IDs of the series that are grouped under "Other".
 * @param {DvtChartImpl} chart The pie chart
 * @return {Array} The array containing slice IDs
 */
DvtPieChartUtils.getOtherSliceIds = function(chart) {
  var otherSeries = DvtPieChartUtils._getSeriesIndicesArrays(chart).other;
  var seriesIds = [];
  for (var i = 0; i < otherSeries.length; i++) {
    var seriesIndex = otherSeries[i];
    seriesIds.push(DvtPieChartUtils.getSliceId(chart, seriesIndex));
  }
  return seriesIds;
}

/**
 * Returns the visibility of the "Other" slice. The "Other" slice is visible if at least one of the series in it is 
 * visible.
 * @param {DvtChartImpl} chart The pie chart
 * @return {String} The visibility of the "Other" slice
 */
DvtPieChartUtils.getOtherSliceVisibility = function(chart) {
  var otherSeries = DvtPieChartUtils._getSeriesIndicesArrays(chart).other;
  
  for (var i = 0; i < otherSeries.length; i++) {
    var seriesIndex = otherSeries[i];
    if (DvtChartStyleUtils.isSeriesRendered(chart, seriesIndex))
      return "visible";
  }
  
  return "hidden";
}

/**
 * Sets the visibility of the "Other" slice. The visibility of all the series in "Other" will be set to the visibility
 * of the "Other" slice.
 * @param {DvtChartImpl} chart The pie chart
 * @param {String} visibility The visibility of the "Other" slice
 */
DvtPieChartUtils.setOtherSliceVisibility = function(chart, visibility) {
  var otherSeries = DvtPieChartUtils._getSeriesIndicesArrays(chart).other;
  
  for (var i = 0; i < otherSeries.length; i++) {
    var seriesIndex = otherSeries[i];
    var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
    seriesItem['visibility'] = visibility;
  }
}

/**
 * Returns whether the "Other" slice is selected. It is selected if all the series in it are selected.
 * @param {DvtChartImpl} chart The pie chart
 * @param {Array} selected An array containing the ID objects of the selected slices.
 * @return {Boolean} Whether the "Other" slice is selected
 */
DvtPieChartUtils.isOtherSliceSelected = function(chart, selected) {
  var otherIds = DvtPieChartUtils.getOtherSliceIds(chart);
  
  for (var j = 0; j < otherIds.length; j++) {
    var sliceId = otherIds[j];
    var sliceSelected = false;
    
    // Check if this slice is in the selected list
    for (var i = 0; i < selected.length; i++) {
      if ((selected[i]['id'] && sliceId.getId() === selected[i]['id']) ||
          (sliceId.getSeries() === selected[i]['series'] && sliceId.getGroup() === selected[i]['group'])) {
        sliceSelected = true;
        break;
      }
    }
    
    if (!sliceSelected)
      return false;
  }
  
  return true;
}

/**
 * Divides the series indices into two arrays. The first array contains the series that are not grouped under "Other",
 * sorted by value if sorting is enabled. The second array contains the series that belongs to "Other". The arrays
 * include hidden series and series with non-positive values.
 * @param {DvtChartImpl} chart The pie chart
 * @return {Object} An object in the form {rendered: firstArray, other: secondArray}. firstArray and secondArray are
 *     as described above.
 * @private
 */
DvtPieChartUtils._getSeriesIndicesArrays = function(chart) {
  var renderedSeries = [];
  var otherSeries = [];
  
  var seriesCount = DvtChartDataUtils.getSeriesCount(chart);
  var options = chart.getOptions();
  var otherThreshold = options['otherThreshold'] * DvtPieChartUtils.getTotalValue(chart);
  
  for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
    // Skip the series if its value is 0 or negative  
    var value = DvtChartDataUtils.getValue(chart, seriesIndex, 0);
    
    // Do not use "Other" if the threshold is zero
    if (otherThreshold > 0 && value < otherThreshold)
      otherSeries.push(seriesIndex);
    else
      renderedSeries.push(seriesIndex);
  }
  
  // Sort the slices if enabled
  if (options['sorting'] == "on") {
    renderedSeries.sort(function(a,b){
      return DvtChartDataUtils.getValue(chart, b, 0) - DvtChartDataUtils.getValue(chart, a, 0);
    });
  }
  
  return {rendered: renderedSeries, other: otherSeries};
}

/**
 * Computes the total value of a pie chart, including hidden series.
 * @param {DvtChartImpl} chart The pie chart.
 */
DvtPieChartUtils.getTotalValue = function(chart) {
  var seriesCount = DvtChartDataUtils.getSeriesCount(chart);
  var totalValue = 0;
  
  for (var seriesIndex = 0;seriesIndex < seriesCount;seriesIndex++) {
    // Skip the series if its value is 0 or negative
    var value = DvtChartDataUtils.getValue(chart, seriesIndex, 0);
    if(value > 0) { 
      totalValue += value;
    } 
  }
  
  return totalValue; 
}

/**
 * Returns the pie slice explode for the specified series.
 * @param {DvtChartImpl} chart
 * @param {number} seriesIndex
 * @return {number} The pie slice explode from 0 to 100.
 */
DvtPieChartUtils.getSliceExplode = function(chart, seriesIndex) {
  // Series Override
  var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
  if(seriesItem && seriesItem['pieSliceExplode'])
    return seriesItem['pieSliceExplode'];
  else
    return 0;
};

/**
 * Returns the show popup behaviors of "Other" slice.
 * @param {DvtChartImpl} chart
 * @return {array}
 */
DvtPieChartUtils.getOtherSliceShowPopupBehaviors = function(chart) {
  // Use the info from the first contained slice
  var otherSliceIds = DvtPieChartUtils.getOtherSliceIds(chart);
  if(otherSliceIds && otherSliceIds.length >= 1) {
    var firstDataItem = otherSliceIds[0];
    var firstDataItemSeriesIndex = DvtChartDataUtils.getSeriesIndex(chart, firstDataItem.getSeries());
    var stampId = DvtChartDataUtils.getDataItem(chart, firstDataItemSeriesIndex, 0)['_id'];
    return chart.getShowPopupBehaviors(stampId);
  }
}
// Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
/**
 * @class DvtPieRenderUtils
 */
var DvtPieRenderUtils = function () {
};

DvtObj.createSubclass(DvtPieRenderUtils, DvtObj, "DvtPieRenderUtils");

/** @final  @type String  */
DvtPieRenderUtils.TWOD = "2D";
/** @final  @type String  */
DvtPieRenderUtils.THREED = "3D";
/** @final  @type String  */
DvtPieRenderUtils.CRUST = "CRUST";
/** @final  @type String  */
DvtPieRenderUtils.SIDE = "SIDE";
/** @final  @type String  */
DvtPieRenderUtils.BORDER = "BORDER";

// surface types
DvtPieRenderUtils.SURFACE_CRUST = 0;
DvtPieRenderUtils.SURFACE_LEFT = 1;
DvtPieRenderUtils.SURFACE_RIGHT = 2;
DvtPieRenderUtils.SURFACE_TOP = 3;

/**
 * Returns a <code>Point</code> object representing a point at a given
 * angle at a distance specified by the rx and ry radius from the center cx, cy.
 *
 * Function reflects input angle over the y-axis.  It then scales the
 * cosine and sine of this angle by rx and ry, and then translates
 * the cosine and sine values by cx and cy.  The reflected, scaled, and
 * translated angle's cosine and sine values are then returned
 *
 * @param {number} angle A <code>Number</code> representing the desired angle in degrees.
 * @param {number} cx    A <code>Number</code> indicating the center horizontal position.
 * @param {number} cy    A <code>Number</code> indicating the center vertical position.
 * @param {number} rx    A <code>Number</code> indicating the horizontal radius.
 * @param {number} ry    A <code>Number</code> indicating the vertical radius.
 *
 * @return A point object with the calculated x and y fields.
 */

// original code taken from com.oracle.dvt.shape.draw.utils.RenderUtils
// function originally called rotatePoint -- but that was a serious misnomer
DvtPieRenderUtils.reflectAngleOverYAxis = function (angle, cx, cy, rx, ry) {
  var radian = DvtMath.degreesToRads(360 - angle);
  var cosine = Math.cos(radian);
  var sine = Math.sin(radian);

  return {x: cx+(cosine*rx), y: cy+(sine*ry)};
}

/**
 * Returns an array of colors (with no alphas) for use in creating a gradient, based on a base color and where the gradient
 * will be applied
 *
 * @param {String} baseColor
 * @param {String} style Either DvtPieRenderUtils.TWOD, DvtPieRenderUtils.THREED, DvtPieRenderUtils.CRUST,
 *                          DvtPieRenderUtils.SIDE, or DvtPieRenderUtils.BORDER
 * @param {string} skin
 * @return {Array}
 */
DvtPieRenderUtils.getGradientColors = function (baseColor, style, skin) {
  if (skin && skin != DvtCSSStyle.SKIN_SKYROS) {
    if (style == DvtPieRenderUtils.TWOD || style == DvtPieRenderUtils.THREED)
      return [DvtColorUtils.adjustHSL(baseColor, 0,  - 0.04,  - 0.05), DvtColorUtils.adjustHSL(baseColor, 0,  - 0.09, 0.04)];
    else if (style == DvtPieRenderUtils.CRUST)
      return [DvtColorUtils.adjustHSL(baseColor, 0,  - 0.04,  - 0.05), DvtColorUtils.adjustHSL(baseColor, 0, 0,  - 0.14)];
    else if (style == DvtPieRenderUtils.SIDE)
      return [DvtColorUtils.adjustHSL(baseColor, 0,  - 0.10, 0.06), DvtColorUtils.adjustHSL(baseColor, 0,  - 0.04,  - 0.05)];
  }
  else if (style == DvtPieRenderUtils.TWOD) {
    var arColors = [];
    arColors[0] = DvtColorUtils.getRGB(DvtColorUtils.getPastel(baseColor, 0.1));
    arColors[1] = arColors[0];
    arColors[2] = DvtColorUtils.getRGB(DvtColorUtils.getDarker(baseColor, 0.9));
    return arColors;
  }
  else if (style == DvtPieRenderUtils.BORDER)
    return ["#FFFFFF", "#000000", "#000000"];
  else {
    var c = DvtColorUtils.getRGB(DvtColorUtils.getDarker(baseColor, 0.88));
    var c1 = DvtColorUtils.getRGB(DvtColorUtils.getPastel(baseColor, .05));
    var c2 = DvtColorUtils.getRGB(DvtColorUtils.getPastel(baseColor, .15));
    var c3 = DvtColorUtils.getRGB(DvtColorUtils.getPastel(baseColor, .35));

    if (style == DvtPieRenderUtils.CRUST)
      return [c, c2, c3, c];
    else if (style == "SIDE")
      return [c, c3];
    else if (style == "3D")
      return [c3, c2, c, c1, c3];
  }
}

/**
 * Returns an array of alphas for use in creating a gradient, based on an initial alpha value and where the gradient
 * will be applied
 *
 * @param {number} baseAlpha
 * @param {String} style Either DvtPieRenderUtils.TWOD, DvtPieRenderUtils.THREED, DvtPieRenderUtils.CRUST,
 *                          DvtPieRenderUtils.SIDE, or DvtPieRenderUtils.BORDER
 *
 * @return {Array}
 */
DvtPieRenderUtils.getGradientAlphas = function (baseAlpha, style) {
  var alpha = (baseAlpha == null || isNaN(baseAlpha) || baseAlpha == 0) ? 1.0 : baseAlpha;
  if (style == DvtPieRenderUtils.TWOD)
    return [alpha, alpha, alpha]
  else if (style == DvtPieRenderUtils.BORDER)
    return [(alpha / (0xFF / 0xA0)), (alpha / (0xFF / 0x30)), (alpha / (0xFF / 0x60))];
  else if (style == DvtPieRenderUtils.THREED)
    return [alpha, alpha, alpha, alpha, alpha];
  else if (style == DvtPieRenderUtils.CRUST)
    return [alpha, alpha, alpha, alpha];
  else if (style == DvtPieRenderUtils.SIDE)
    return [alpha, alpha];
}

// ported over from PieUtils
/**
 * Returns an array of stops for use in creating a gradient, based on where the gradient will be applied
 * 
 * @param {String} style Either DvtPieRenderUtils.TWOD, DvtPieRenderUtils.THREED, DvtPieRenderUtils.CRUST, 
 *                          DvtPieRenderUtils.SIDE, or DvtPieRenderUtils.BORDER  
 * @param {string} skin
 * @return {Array}
 */
DvtPieRenderUtils.getGradientRatios = function (style, skin) {
  if (skin && skin != DvtCSSStyle.SKIN_SKYROS)
    return [0, 1.0];
  else if (style == DvtPieRenderUtils.TWOD)
    return [0.2, 0.5, 1.0];
  else if (style == DvtPieRenderUtils.BORDER)
    return [0, 0.5, 1.0];
  else if (style == DvtPieRenderUtils.THREED)
    return [0.0, 0.29, 0.55, 0.84, 1.0];
  else if (style == DvtPieRenderUtils.CRUST)
    return [0, 0.43, 0.91, 1.0];
  else if (style == DvtPieRenderUtils.SIDE)
    return [0, 1];
}


/*
 * Static methods for generating the physical shapes that make up the different pieces of a DvtPieSlice
 */

/**
 * @this {DvtPieSlice}
 * Returns an array of DvtShape objects representing the top of a pie slice
 *
 * @param {DvtFill} fill The fill for the top
 * @param {DvtPieSlice} slice The slice to generate the top for
 * @return {Array} An array of DvtShape objects representing the top of this pie slice
 */
DvtPieRenderUtils.createTopSurface = function (slice, fill) {
  var pieChart = slice.getPieChart();
  var context = pieChart.getCtx();
  var pieCenter = pieChart.getCenter();

  // Bug fix 12419047
  var sliceClosureType = DvtArc.PIE;

  if (slice.getAngleExtent() == 360) {
    sliceClosureType = DvtArc.OPEN;
  }

  var wedge = new DvtGraphSelectableArc(context, pieCenter.x, pieCenter.y, slice._radiusX, slice._radiusY, slice.getAngleStart(), slice.getAngleExtent(), sliceClosureType);
  wedge.setDataColor(slice.getFillColor(), DvtChartStyleUtils.getSelectedInnerColor(pieChart.chart), DvtChartStyleUtils.getSelectedOuterColor(pieChart.chart));
  wedge.setZOrderManager(this._Chart);

  wedge.setTranslate(slice.__getExplodeOffsetX(), slice.__getExplodeOffsetY());
  wedge.setFill(fill);
  if (slice.getStrokeColor()) {
    wedge.setSolidStroke(slice.getStrokeColor());
  }

  // WAI-ARIA
  wedge.setAriaRole('img');
  var ariaLabel = slice.getTooltip();
  wedge.setAriaProperty('label', ariaLabel);

  var shapes = [wedge];

  if (!slice.getStrokeColor() && pieChart.getSkin() == DvtCSSStyle.SKIN_SKYROS && pieChart.is3D() && pieChart.getDepth() > 0 && DvtChartStyleUtils.getSeriesEffect(pieChart.chart) == "gradient" && 
      (slice.getAngleStart() >= 180 || (slice.getAngleStart() + slice.getAngleExtent()) >= 180 || slice.getAngleExtent() == 360))// Bug fix 12419047; slice.getAngleExtent() == 360 means we only have one slice
  {
    // create arc for the pie border with border gradient and add arc to shapes array
    var edge = DvtPieRenderUtils._createGradientPieBorder(slice, fill);
    edge.setTranslate(slice.__getExplodeOffsetX(), slice.__getExplodeOffsetY());
    shapes.push(edge);
  }

  // Associate the shapes with the slice for use during event handling
  DvtPieRenderUtils.associate(slice, shapes);

  return shapes;
}

/**
 * Associates the specified displayables with the specified slice.
 * @param {DvtPieSlice} slice The owning slice.
 * @param {array} displayables The displayables to associate.
 */
DvtPieRenderUtils.associate = function (slice, displayables) {
  if (!displayables)
    return;

  for (var i = 0;i < displayables.length;i++)
    slice.getPieChart().chart.getEventManager().associate(displayables[i], slice);
}

/**
 * Private helper method to generate the gradient border for a pie slice
 * @param {DvtPieSlice} slice
 * @param {DvtGradientFill} topFill
 * @return {DvtArc} The gradient border to apply on top of the pie slice at the edge
 * @private
 */
DvtPieRenderUtils._createGradientPieBorder = function (slice, topFill) {
  // first create the gradient to apply
  var style = DvtPieRenderUtils.BORDER;
  var arColors = DvtPieRenderUtils.getGradientColors(null, style);// base color ignored for border gradient
  var arAlphas = DvtPieRenderUtils.getGradientAlphas(null, style);
  var arRatios = DvtPieRenderUtils.getGradientRatios(style);

  var arBounds = topFill.getBounds();

  grAngle = 120;// constant used in Flash impl originally 120
  //  grAngle = 360 - grAngle ;        // Html5 toolkit rotates from 0 clockwise so
  // convert to anticlockwise convention
  var gradBorder = new DvtLinearGradientStroke(grAngle, arColors, arAlphas, arRatios, arBounds);
  gradBorder.setWidth(1);

  // now create the arc for the border
  // only show border on the front-top-edge (180-360 degrees)
  var sliceAngleStart = slice.getAngleStart();
  var sliceAngleExtent = slice.getAngleExtent();

  var diff = (sliceAngleStart < 180) ? 180 - sliceAngleStart : 0;
  var angStart = (diff > 0) ? 180 : sliceAngleStart;
  var angExtent = sliceAngleExtent - diff;

  if (angStart + angExtent > 360)
    angExtent = 360 - angStart;

  var pieChart = slice.getPieChart();
  var pieCenter = pieChart.getCenter();

  var edge = new DvtArc(pieChart.getCtx(), pieCenter.x, pieCenter.y, pieChart.getRadiusX(), pieChart.getRadiusY(), angStart, angExtent, DvtArc.OPEN);

  edge.setStroke(gradBorder);

  return edge;
}

/**
 * Generates any lateral (non-top) pie surface
 *
 * @param {DvtFill} fill The fill for the lateral surface
 * @param {DvtPieSlice} slice
 * @param {number} pathType One of DvtPieRenderUtils.SURFACE_CRUST,
 *                          DvtPieRenderUtils.SURFACE_LEFT, or DvtPieRenderUtils.SURFACE_RIGHT
 *
 * @return {Array} An array of DvtShape objects representing this lateral surface
 */
// replaces PieSlice._draw 
DvtPieRenderUtils.createLateralSurface = function (slice, pathType, fill) {
  // handle the case where we are animating a slice insert
  // initially, this slice will have 0 extent. in this case
  // don't generate any surface
  if (slice.getAngleExtent() == 0) {
    return [];
  }

  var talpha = DvtColorUtils.getAlpha(slice.getFillColor());
  var shapes = [];

  if (talpha > 0) {

    if (pathType == DvtPieRenderUtils.SURFACE_LEFT || pathType == DvtPieRenderUtils.SURFACE_RIGHT) {
      shapes.push(DvtPieRenderUtils._generateLateralShape(slice, pathType, null, fill));
    }
    else if (pathType == DvtPieRenderUtils.SURFACE_CRUST) {
      var pathCommands = DvtPieRenderUtils._createCrustPathCommands(slice);

      var len = pathCommands.length;
      for (var i = 0;i < len;i++) {
        shapes.push(DvtPieRenderUtils._generateLateralShape(slice, pathType, pathCommands[i], fill));
      }

    }
  }

  // Associate the shapes with the slice for use during event handling
  DvtPieRenderUtils.associate(slice, shapes);

  return shapes;
}

/**
 * Create the gradient fill used for lateral surfaces.
 * @param {DvtPieSlice} slice
 * @param {String} objType One of DvtPieRenderUtils.CRUST or DvtPieRenderUtils.SIDE
 * @return {DvtLinearGradientFill}
 */
DvtPieRenderUtils.generateLateralGradientFill = function (slice, objType) {
  var pieChart = slice.getPieChart();
  var skin = pieChart.getSkin();
  var yOffset = (objType == DvtPieRenderUtils.CRUST) ? pieChart.getDepth() : 0;

  var angle = (skin == DvtCSSStyle.SKIN_SKYROS) ? 0 : 270;
  var arColors = DvtPieRenderUtils.getGradientColors(DvtColorUtils.getRGB(slice.getFillColor()), objType, skin);
  var arAlphas = DvtPieRenderUtils.getGradientAlphas(DvtColorUtils.getAlpha(slice.getFillColor()), objType);
  var arRatios = DvtPieRenderUtils.getGradientRatios(objType, skin);
  var arBounds = null;
  if (skin == DvtCSSStyle.SKIN_SKYROS) {
    arBounds = [Math.floor(pieChart.getCenter().x - pieChart.getRadiusX()), 
                Math.floor(pieChart.getCenter().y - pieChart.getRadiusY()) + yOffset, 
                Math.ceil(2 * pieChart.getRadiusX()), 
                Math.ceil(2 * pieChart.getRadiusY())];
  }

  return new DvtLinearGradientFill(angle, arColors, arAlphas, arRatios, arBounds);
}

/**
 * Private method that generates an array of DvtShape objects for different lateral pie surfaces
 *
 * @param {DvtPieSlice} slice
 * @param {number} pathType One of DvtPieRenderUtils.SURFACE_CRUST,
 *                          DvtPieRenderUtils.SURFACE_LEFT, or DvtPieRenderUtils.SURFACE_RIGHT
 * @param {String} pathCommand  A string of SVG commands in SVG "d" attribute format. Used when pathType is
 *                              DvtPieRenderUtils.SURFACE_CRUST. Can be set to null otherwise
 * @param {DvtFill} fill The fill to apply to the shapes
 *
 * @return {DvtShape} A right or left pie surface, or a piece of a crust, as described in pathCommands
 *
 * @private
 */
DvtPieRenderUtils._generateLateralShape = function (slice, pathType, pathCommand, fill) {
  var pie = slice.getPieChart();
  var context = pie.getCtx();

  // left side points and right side points
  if (pathType == DvtPieRenderUtils.SURFACE_LEFT || pathType == DvtPieRenderUtils.SURFACE_RIGHT) {
    var angle = slice.getAngleStart();
    var arc = slice.getAngleExtent();
    var xCenter = pie.getCenter().x;
    var yCenter = pie.getCenter().y;
    var xRadius = slice._radiusX;
    var yRadius = slice._radiusY;
    var depth = pie.getDepth();

    var pt = (pathType == DvtPieRenderUtils.SURFACE_LEFT) ? DvtPieRenderUtils.reflectAngleOverYAxis(angle + arc, xCenter, yCenter, xRadius, yRadius) : 
                                                      DvtPieRenderUtils.reflectAngleOverYAxis(angle, xCenter, yCenter, xRadius, yRadius);
    var pointArray = DvtPieRenderUtils._generateInnerPoints(xCenter, yCenter, pt.x, pt.y, depth);
    
    var points = [];
    for (var i=0; i<pointArray.length; i++) {
      points.push(pointArray[i].x, pointArray[i].y);
    }

    var polygon = new DvtGraphSelectablePolygon(context, points);
    polygon.setDataColor(slice.getFillColor(), DvtChartStyleUtils.getSelectedInnerColor(pie.chart), DvtChartStyleUtils.getSelectedOuterColor(pie.chart));
    polygon.setZOrderManager(pie);
    polygon.setTranslate(slice.__getExplodeOffsetX(), slice.__getExplodeOffsetY());

    polygon.setFill(fill);
    if(slice.getStrokeColor())
      polygon.setSolidStroke(slice.getStrokeColor());

    return polygon;
  }
  else // draw piece of pie crust
  {
    if (pathCommand) {
      var path = new DvtGraphSelectablePath(context, null);
      path.setDataColor(slice.getFillColor(), DvtChartStyleUtils.getSelectedInnerColor(pie.chart), DvtChartStyleUtils.getSelectedOuterColor(pie.chart));
      path.setZOrderManager(pie);
      path.setCmds(pathCommand);
      path.setTranslate(slice.__getExplodeOffsetX(), slice.__getExplodeOffsetY());

      path.setFill(fill);
      if (slice.getStrokeColor()) {
        path.setSolidStroke(slice.getStrokeColor());
      }

      return path;
    }
  }

  return null;
}

/**
 * Returns an array of path commands describing how to draw a pie crust
 *
 * @param {DvtPieSlice} slice
 *
 * @return {Array} An array of strings of SVG commands in SVG "d" attribute format.
 *                 e.g., [ [command1 x1, y1, ..., commandi xn, yn, ...], [commandj xs, ys, ...] ]
 *
 * @private
 */
DvtPieRenderUtils._createCrustPathCommands = function (slice) {
  var angle = slice.getAngleStart();
  var arc = slice.getAngleExtent();
  var angleEnd = angle + arc;
  var pie = slice.getPieChart();
  var xCenter = pie.getCenter().x;
  var yCenter = pie.getCenter().y;
  var xRadius = slice._radiusX;
  var yRadius = slice._radiusY;
  var depth = pie.getDepth();

  // If slice crosses 0 degrees (right horizontal x-axis), we need to break crust into 2 pieces joined at the crossing 
  // point so that the right side of the slice appears to be a solid 3D wall. If slice crosses 180 degrees (left 
  // horizontal x-axis), we need to break crust into 2 pieces joined at the crossing point so that the left side of the 
  // slice appears to be a solid 3D wall.
  var arOuterPath = [];
  if (angle < 180.0 && angleEnd > 360.0) {
    arOuterPath.push(DvtPieRenderUtils._makeOuterPath(xCenter, yCenter, xRadius, yRadius, depth, angle, 180.0 - angle)); // left
    arOuterPath.push(DvtPieRenderUtils._makeOuterPath(xCenter, yCenter, xRadius, yRadius, depth, 360.0, angleEnd - 360.0)); // right
    arOuterPath.push(DvtPieRenderUtils._makeOuterPath(xCenter, yCenter, xRadius, yRadius, depth, 180.0, 180.0)); // center
  }
  else if (angleEnd > 360.0) {
    arOuterPath.push(DvtPieRenderUtils._makeOuterPath(xCenter, yCenter, xRadius, yRadius, depth, angle, 360.0 - angle));
    arOuterPath.push(DvtPieRenderUtils._makeOuterPath(xCenter, yCenter, xRadius, yRadius, depth, 360.0, angleEnd - 360.0));
  }
  else if (angle < 180.0 && angleEnd > 180.0) {
    arOuterPath.push(DvtPieRenderUtils._makeOuterPath(xCenter, yCenter, xRadius, yRadius, depth, angle, 180.0 - angle));
    arOuterPath.push(DvtPieRenderUtils._makeOuterPath(xCenter, yCenter, xRadius, yRadius, depth, 180.0, angleEnd - 180.0));
  }
  else 
    arOuterPath.push(DvtPieRenderUtils._makeOuterPath(xCenter, yCenter, xRadius, yRadius, depth, angle, arc));

  return arOuterPath;
}

/**
 * Returns the path string for a segment of the outer crust of a pie slice.
 * @param {number} cx The x coordinate of the center of the pie.
 * @param {number} cy The y coordinate of the center of the pie.
 * @param {number} rx The radius of the pie.
 * @param {number} ry The radius of the pie.
 * @param {number} depth The depth of the pie.
 * @param {number} startAngle The start angle in degrees.
 * @param {number} angleExtent The angular extent in degrees.  Always less than 180 degrees (half the pie).
 * @returns {String} An SVG string that represents part of the crust.
 * @private
 */
DvtPieRenderUtils._makeOuterPath = function (cx, cy, rx, ry, depth, startAngle, angleExtent) {
  var angleExtentRads = DvtMath.degreesToRads(angleExtent);
  var endAngleRads = -(DvtMath.degreesToRads(startAngle)+angleExtentRads);
  
  // Adjust the cy to reduce rendering artifacts between the top and crust
  cy -= 1;
  
  // Calculate the start and end points on the top curve
  var startPointTop = DvtPieRenderUtils.reflectAngleOverYAxis(startAngle, cx, cy, rx, ry);
  var endPointTopX = cx + Math.cos(endAngleRads) * rx;
  var endPointTopY = cy + Math.sin(endAngleRads) * ry;
  
  // Top Curve
  var pathCommands = DvtPathUtils.moveTo(startPointTop.x, startPointTop.y);
  pathCommands += DvtPathUtils.arcTo(rx, ry, angleExtentRads, 0, endPointTopX, endPointTopY);

  // Line to Bottom Curve
  pathCommands += DvtPathUtils.lineTo(endPointTopX, endPointTopY + depth);
  
  // Bottom Curve
  pathCommands += DvtPathUtils.arcTo(rx, ry, angleExtentRads, 1, startPointTop.x, startPointTop.y + depth);
  
  // Line to Top Curve
  pathCommands += DvtPathUtils.lineTo(startPointTop.x, startPointTop.y);
  
  return pathCommands;
}

/**
 * Private function to generate the points for the left or right pie surface
 *
 * @param {number} cx The x-coordinate of the center of the pie slice
 * @param {number} cy The y-coordinate of the center of the pie slice
 * @param {number} x The x-coordinate of the top, outside (left or right) edge of the pie slice
 * @param {number} y The y-coordinate of the top, outside (left or right) edge of the pie slice
 * @param {number} tilt Pie tilt
 * @param {number} side Either DvtPieRenderUtils.SURFACE_LEFT or DvtPieRenderUtils.SURFACE_RIGHT
 *
 * @return {Array} An array of points that are the coordinates for the left or right surface of a pie slice
 *
 * @private
 */
DvtPieRenderUtils._generateInnerPoints = function (cx, cy, xpos, ypos, tilt) {
  var pointArray = [];
  pointArray.push({x: cx, y: cy});
  pointArray.push({x: xpos, y: ypos});
  pointArray.push({x: xpos, y: ypos + tilt});
  pointArray.push({x: cx, y: cy + tilt});
  return pointArray;
}
// Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.
/*---------------------------------------------------------------------*/
/* Class DvtPieLabelInfo       Slice label information               */
/*---------------------------------------------------------------------*/

/** A property bag used to pass around information used for label placement
 *
 * @constructor
 */
var DvtPieLabelInfo = function () {
  this._init();
};

DvtObj.createSubclass(DvtPieLabelInfo, DvtObj, "DvtPieLabelInfo");

/**
 * Private initializer
 * @private
 */
DvtPieLabelInfo.prototype._init = function () {
  this._sliceLabel = null;// instance of DvtTextArea
  this._slice = null;// DvtSlice we will associate _sliceLabel with, if we can fit the label
  this._angle =  - 1;

  // this._position is the normalized midpoint angle, where 0 degrees is at 12 o'clock
  //    and angular measures are degrees away from 12 o'clock (so 90 degrees
  //    can be either at 3 o'clock or 9 o'clock on the unit circle)
  this._position =  - 1;
  this._width =  - 1;
  this._height =  - 1;
  this._x =  - 1;
  this._y =  - 1;

  this._initialNumLines =  - 1;

  this._hasFeeler = false;

  this._maxY =  - 1;
  this._minY =  - 1;
};

/**
 * @return {number} Angle of the text in this slice label
 */
DvtPieLabelInfo.prototype.getAngle = function () {
  return this._angle;
}

/**
 * @param {number} angle Sets the angle of the text in this slice label
 */
DvtPieLabelInfo.prototype.setAngle = function (angle) {
  this._angle = angle;
}

/**
 * @return {number} The height of this slice label
 */
DvtPieLabelInfo.prototype.getHeight = function () {
  return this._height;
}

/**
 * @param {number} height The height of this slice label
 */
DvtPieLabelInfo.prototype.setHeight = function (height) {
  this._height = height;
}

/**
 * @return {number}
 */
DvtPieLabelInfo.prototype.getInitialNumLines = function () {
  return this._initialNumLines;
}

/**
 * @param {number} numLines
 */
DvtPieLabelInfo.prototype.setInitialNumLines = function (numLines) {
  this._initialNumLines = numLines;
}

/**
 * @return {number} The maximum Y position of this slice label
 */
DvtPieLabelInfo.prototype.getMaxY = function () {
  return this._maxY;
}

/**
 * @param {number} The maximum Y position of this slice label
 */
DvtPieLabelInfo.prototype.setMaxY = function (maxY) {
  this._maxY = maxY;
}

/**
 * @return {number} The minimum Y position of this slice label
 */
DvtPieLabelInfo.prototype.getMinY = function () {
  return this._minY;
}

/**
 * @param {number} The minimum Y position of this slice label
 */
DvtPieLabelInfo.prototype.setMinY = function (minY) {
  this._minY = minY;
}

/**
 * bound the value of y within minY and maxY
 * assumes that maxY > minY
 * @param {number} a y value
 */
DvtPieLabelInfo.prototype.boundY = function (y) {
  y = Math.max(y, this._minY);
  y = Math.min(y, this._maxY);
  return y;
}

/**
 * @return {boolean}
 */
DvtPieLabelInfo.prototype.hasFeeler = function () {
  return this._hasFeeler;
}

/**
 * @param {boolean}
 */
DvtPieLabelInfo.prototype.setHasFeeler = function (hasFeeler) {
  this._hasFeeler = hasFeeler;
}

/**
 * Returns the normalized midpoint angle, where 0 degrees is at 12 o'clock
 * and angular measures are degrees away from 12 o'clock (so 90 degrees
 * can be either at 3 o'clock or 9 o'clock on the unit circle)
 *
 * @return {number}
 */
DvtPieLabelInfo.prototype.getPosition = function () {
  return this._position;
}

/**
 * Sets the normalized midpoint angle, where 0 degrees is at 12 o'clock
 * and angular measures are degrees away from 12 o'clock (so 90 degrees
 * can be either at 3 o'clock or 9 o'clock on the unit circle)
 *
 * @param {number} position
 */
DvtPieLabelInfo.prototype.setPosition = function (position) {
  this._position = position;
}

/**
 * The slice that we want to associate the label with
 *
 * @return {DvtPieSlice}
 */
DvtPieLabelInfo.prototype.getSlice = function () {
  return this._slice;
}

/**
 * @param {DvtPieSlice} slice
 */
DvtPieLabelInfo.prototype.setSlice = function (slice) {
  this._slice = slice;
}

/**
 * The DvtTextArea associated with this SliceLabelInfo
 *
 * @return {DvtTextArea}
 */
DvtPieLabelInfo.prototype.getSliceLabel = function () {
  return this._sliceLabel;
}

/**
 * Sets the DvtTextArea this label info will layout
 *
 * @param {DvtTextArea} label
 */
DvtPieLabelInfo.prototype.setSliceLabel = function (label) {
  this._sliceLabel = label;
}

/**
 * @return {number} The width of this label
 */
DvtPieLabelInfo.prototype.getWidth = function () {
  return this._width;
}

/**
 * @param {number} width
 */
DvtPieLabelInfo.prototype.setWidth = function (width) {
  this._width = width;
}

/**
 * @return {number} The x-coordinate of the reference point for this label
 */
DvtPieLabelInfo.prototype.getX = function () {
  return this._x;
}

/**
 * @param {number} x
 */
DvtPieLabelInfo.prototype.setX = function (x) {
  this._x = x;
}

/**
 * @return {number} The y-coordinate of hte reference point for this label
 */
DvtPieLabelInfo.prototype.getY = function () {
  return this._y;
}

/**
 * @param {number} y
 */
DvtPieLabelInfo.prototype.setY = function (y) {
  this._y = y;
}
// Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.
/*---------------------------------------------------------------------*/
/*   DvtPieLabelUtils                                                  */
/*---------------------------------------------------------------------*/

/**
 * @class DvtPieLabelUtils
 */
var DvtPieLabelUtils = function () {
};

DvtObj.createSubclass(DvtPieLabelUtils, DvtObj, "DvtPieLabelUtils");

DvtPieLabelUtils._MAX_LINES_PER_LABEL = 3;

DvtPieLabelUtils._COLLISION_MARGIN = 1;

DvtPieLabelUtils._LEFT_SIDE_LABELS = 1;
DvtPieLabelUtils._RIGHT_SIDE_LABELS = 2;

DvtPieLabelUtils._OUTSIDE_LABEL_DISTANCE = 0.04;// distance from the slice, as a ratio of the radius 

//constants for column layout
DvtPieLabelUtils._FEELER_RAD_MINSIZE = 0.1;// ratio to the pie diameter
DvtPieLabelUtils._FEELER_HORIZ_MINSIZE = 0.1;// ratio to the pie diameter
DvtPieLabelUtils._LABEL_TO_FEELER_OFFSET = 0.5;// ratio to the label height
DvtPieLabelUtils._LABEL_TO_FEELER_DISTANCE = 3;// in pixels
DvtPieLabelUtils._NO_COLLISION = 0;
DvtPieLabelUtils._HALF_COLLISION = 1;
DvtPieLabelUtils._ALL_COLLISION = 2;

/**
 * Public entry point called by DvtPieChart to layout the pie chart's labels and feelers.
 * @param {DvtPieChart}
 */
DvtPieLabelUtils.layoutLabelsAndFeelers = function (pie) {
  var labelPosition = pie.getLabelPosition();
  if (labelPosition == "none")
    return;
  else if (labelPosition == "inside")
    DvtPieLabelUtils._layoutInsideLabels(pie);
  else
    DvtPieLabelUtils._layoutOutsideLabelsAndFeelers(pie);
}

/**
 *
 * Lays out labels that appear within the pie slices.
 * @param {DvtPieChart}
 * @private
 */
DvtPieLabelUtils._layoutInsideLabels = function (pie) {
  if (pie == null)
    return;

  var slices = pie.__getSlices();
  var n = slices.length;

  if (n > 0) {
    for (i = 0;i < n;i++) {
      var slice = slices[i];
      var midPt;
      var midAngle = slice.getAngleStart() + (slice.getAngleExtent() / 2);
      var center = pie.getCenter();
      var posX = 0;
      var posY = 0;

      var sliceLabel = DvtPieLabelUtils._createLabel(slice, true);
      
      if (n==1) {
        // Center the label
        posX = center.x;
        posY = center.y;
      }
      else {
        // The flash Graph tries to center the label manually.
        // With the toolkit, we can just set the alignment on the label
        // to center, middle
        var offset = 0.66;// Constant originally used in flash impl
        midPt = DvtPieRenderUtils.reflectAngleOverYAxis(midAngle, center.x, center.y, pie.getRadiusX() * offset, pie.getRadiusY() * offset);
  
        posX = midPt.x;
        posY = midPt.y;
      }

      sliceLabel.setX(posX);
      sliceLabel.setY(posY);
      sliceLabel.alignMiddle();
      sliceLabel.alignCenter();
      
      // Find the estimated dimensions of the label
      var estimatedDims = DvtTextUtils.guessTextDimensions(sliceLabel);
      
      // Find the largest rectangle that will fit.  The height is accurate, so we only need to check the width.
      var x1 = posX;
      var x2 = posX;
      var y1 = posY - estimatedDims.h/2;
      var y2 = posY + estimatedDims.h/2;
      
      // Calculate the left-most x1 that will fit
      while(slice.contains(x1, y1) && slice.contains(x1, y2)) {
        x1--;
      }
      
      // Calculate the right-most x2 that will fit
      while(slice.contains(x2, y1) && slice.contains(x2, y2)) {
        x2++;
      }
      
      // Add a 3-pixel buffer on each side (accounts for the potential extra pixel in the while loop on failed check)
      x1 += 3;
      x2 -= 3;
      
      // Adjust the anchor point to the midpoint of available space if truncation would occur centered at current anchor
      var usableSpace = 2 * Math.min(posX-x1, x2-posX);
      if(usableSpace < estimatedDims.w) {
        sliceLabel.setX((x1 + x2)/2);
        usableSpace = x2 - x1; 
      }
      
      // Truncate the text.  It will be added to the chart later, so remove if it is added.
      var stage = slice.getPieChart().getCtx().getStage()
      if(DvtTextUtils.fitText(sliceLabel, usableSpace, estimatedDims.h, stage)) {
        stage.removeChild(sliceLabel);
        slice.setSliceLabel(sliceLabel);
      }
    }
  }
}


/**
 *
 * Lays out labels (and feelers if necessary) that appear outside the pie slices
 * @param {DvtPieChart}
 * @private
 */
DvtPieLabelUtils._layoutOutsideLabelsAndFeelers = function (pie) {
  if (pie == null)
    return;

  var leftLabels = [];
  var rightLabels = [];

  // -----------------------------------------------------------
  // Build arrays of Left side and Right side Labels
  //
  // When computing the positioning of the labels, we consider 
  // angles to be measured from the 12 o'clock position, 
  // i.e., 12 o'clock is 0 degrees.
  // Angular measurements then range from 0 to 180.  
  // A value of 90 degrees can then be either at the
  // 3 o'clock position or at the 9 o'clock position
  // -----------------------------------------------------------
  var alabels = DvtPieLabelUtils._generateInitialLayout(pie);

  leftLabels = alabels[0];
  rightLabels = alabels[1];

  // -----------------------------------------------------------
  // Evaluate initial label layout from generateInitialLayout
  // -----------------------------------------------------------
  var leftColl = DvtPieLabelUtils._refineInitialLayout(pie, leftLabels, DvtPieLabelUtils._LEFT_SIDE_LABELS);
  var rightColl = DvtPieLabelUtils._refineInitialLayout(pie, rightLabels, DvtPieLabelUtils._RIGHT_SIDE_LABELS);
  
  if (leftColl == DvtPieLabelUtils._HALF_COLLISION && rightColl != DvtPieLabelUtils._NO_COLLISION)
    DvtPieLabelUtils._columnLabels(pie, leftLabels, true, true, true);
  if (leftColl != DvtPieLabelUtils._NO_COLLISION && rightColl == DvtPieLabelUtils._HALF_COLLISION)
    DvtPieLabelUtils._columnLabels(pie, rightLabels, false, true, true);

  DvtPieLabelUtils._setLabelsAndFeelers(pie, leftLabels, DvtPieLabelUtils._LEFT_SIDE_LABELS);       
  DvtPieLabelUtils._setLabelsAndFeelers(pie, rightLabels, DvtPieLabelUtils._RIGHT_SIDE_LABELS);
}

/**
 * Create a label for the given pie slice. Label positioning is done elsewhere
 * @param {DvtPieSlice} slice
 * @param {boolean} noWrap true if text wrapping is not needed
 * @return {DvtTextArea}
 * @private
 */
DvtPieLabelUtils._createLabel = function (slice, noWrap) {
  var pieChart = slice.getPieChart();

  if (pieChart.getLabelPosition() == "none") {
    return null;
  }

  var context = pieChart.getCtx();

  var sliceLabel = noWrap ? new DvtOutputText(context) : new DvtMultilineText(context);

  // If color is not defined, apply a default color
  var sd = pieChart.getOptions()['styleDefaults'];
  var style = sd['sliceLabelStyle'];
  if(style) {
    var styleStr = style.toString();
    if(styleStr.indexOf('color') == -1) {
      var defaultColor = sd['_defaultSliceLabelColor'];
      
      // Default color for interior label is based on slice color
      if(pieChart.getLabelPosition() == "inside") {
        var backgroundColor = slice.getFillColor();
        defaultColor = DvtColorUtils.getContrastingTextColor(backgroundColor);
      }
      
      // If a default color is found, apply it
      styleStr += "color: " + defaultColor + ";";
      style = new DvtCSSStyle(styleStr);
    }
  }
  
  DvtPieLabelUtils._setFontPropsOnLabel(style, sliceLabel);

  var labelStr = DvtPieLabelUtils._generateSliceLabelString(slice);
  sliceLabel.setTextString(labelStr);
  slice.setSliceLabelString(labelStr);

  return sliceLabel;
}

/**
 * Returns the untruncated label text for a given pie slice
 *
 * @param {DvtPieSlice} slice
 * @return {String} The full, untruncated label string, or null if the slice's pie chart
 is configured to not display labels
 */
DvtPieLabelUtils._generateSliceLabelString = function (slice) {
  var pieChart = slice.getPieChart();

  if (pieChart.getLabelPosition() == "none")
    return null;
  
  var customLabel = slice.getCustomLabel();
  if (customLabel != null)
    return customLabel;
  
  var spercent = "";
  var svalue = "";
  var stext = "";
  var s = "";
  
  var value = slice.getValue();
  var valueFormats = slice._chart.getOptions()['valueFormats'];

  // BUG fix 7349510 - PSLVF attribute
  //
  var percentage = 0;
  var dataTotal = pieChart.getTotalValue();

  percentage = (dataTotal == 0) ? 0 : ((Math.abs(value) / dataTotal) * 100);

  if (valueFormats) {
    // if converter is set, we delegate the formatting to the converter
    spercent = DvtChartTooltipUtils._formatValue(valueFormats, DvtChartDataUtils._TYPE_LABEL, slice.getValue()/100); 
  }
  else {
    // warning: US decimal point only
    s = percentage.toString();

    if (s.length > 5) {
      s = s.slice(0, 5);
    }
    else {
      if (s.indexOf(".", 0) < 0 && s.length < 4)
        s += ".";

      while (s.length < 5)
        s += "0";
    }
    s += "%";
    spercent = s;
  }

  // get data value
  if (!isNaN(value)) {
    if (valueFormats) {
      // if converter is set, we delegate the formatting to the converter
      svalue = DvtChartTooltipUtils._formatValue(valueFormats, DvtChartDataUtils._TYPE_LABEL, slice.getValue());
    }
    else {
      // warning: US decimal point only
      svalue = value.toString();       
    }
  }

  // Set default text to series name
  stext = slice.getSeriesLabel();
  
  var labelType = pieChart.getOptions()['styleDefaults']['sliceLabelType'];
  if (labelType == "percent")
    return spercent;
  else if (labelType == "number")
    return svalue;
  else if (labelType == "text")
    return stext;
  else if (labelType == "textAndPercent")
    return stext + ", " + spercent;
  else
    return null;
}

/**
 * Helper function to set DvtCSSStyle on slice label
 *
 * @param {DvtCSSStyle} style The CSS style to set the slice label text
 * @param {DvtTextArea} sliceLabel The slice label to set font properties on
 * @private
 */
DvtPieLabelUtils._setFontPropsOnLabel = function (style, sliceLabel) {
  if (sliceLabel == null || style == null)
    return;

  sliceLabel.setCSSStyle(style);
}

/**
 *
 * Called after initial naive layout is generated to resolve label collisions
 *
 * @param {DvtPieChart} pie
 * @param {Array} labelInfoArray An array of DvtPieLabelInfo objects
 * @param {number} side Either DvtPieLabelUtils._LEFT_SIDE_LABELS or DvtPieLabelUtils._RIGHT_SIDE_LABELS
 * @private
 */
DvtPieLabelUtils._refineInitialLayout = function (pie, labelInfoArray, side) {

  if (labelInfoArray && labelInfoArray.length > 0) {
    var lastY = pie.__getFrame().y;//think again!!
    var collisionTop = false;
    var collisionCentral = false;
    var collisionBottom = false;
    var labelBottom = 0;

    var labelInfo;

    var bottomQuarter = false;
    var prevBottomQuarter = bottomQuarter;
    var collide = false;
    var isLeftSideLabels = (side == DvtPieLabelUtils._LEFT_SIDE_LABELS);

    for (var i = 0;i < labelInfoArray.length;i++) {
      labelInfo = labelInfoArray[i];

      prevBottomQuarter = bottomQuarter;
      if (labelInfo.getPosition() > 90) {
        bottomQuarter = true;
      }

      labelBottom = labelInfo.getY() + labelInfo.getHeight();

      collide = (lastY - labelInfo.getY()) > DvtPieLabelUtils._COLLISION_MARGIN;

      if (collide) {
        if (!bottomQuarter) {
          collisionTop = true;
        }
        else if (bottomQuarter && !prevBottomQuarter) {
          collisionCentral = true;
        }
        else {
          collisionBottom = true;
        }
      }

      if (labelBottom > lastY) {
        lastY = labelBottom;
      }
    }

    if ((collisionTop && collisionBottom) || collisionCentral) {
      DvtPieLabelUtils._columnLabels(pie, labelInfoArray, isLeftSideLabels, true, true);
      return DvtPieLabelUtils._ALL_COLLISION;
    }
    else if (collisionTop) {
      DvtPieLabelUtils._columnLabels(pie, labelInfoArray, isLeftSideLabels, true, false);//top only
      return DvtPieLabelUtils._HALF_COLLISION;
    }
    else if (collisionBottom) {
      DvtPieLabelUtils._columnLabels(pie, labelInfoArray, isLeftSideLabels, false, true);//bottom only
      return DvtPieLabelUtils._HALF_COLLISION;
    }
    else {
      return DvtPieLabelUtils._NO_COLLISION;
    }
  }
}

// ported over from PieChart.as, renderLabelsAndFeelers
/**
 * 
 * Sets the location of the DvtTextArea objects as specified in the DvtPieLabelInfo objects in alabels.
 * When this method returns, the DvtPieChart labels corresponding to the DvtPieLabelInfo objects in alabels 
 * will have their layout positions set, and will be ready to render
 * 
 * @param {DvtPieChart} pie
 * @param {Array} alabels An array of DvtPieLabelInfo objects. 
 * @private 
 */
DvtPieLabelUtils._setLabelsAndFeelers = function (pie, alabels, side) {
  if (alabels == null || alabels.length <= 0)
    return;

  var i;
  var slice;// instance of DvtPieSlice
  var sliceLabel;// instance of DvtTextArea
  var labelInfo;// instance of DvtPieLabelInfo 
  var isLeftSide = (side == DvtPieLabelUtils._LEFT_SIDE_LABELS);
  
  var excessWidth = Infinity;
  var excessLength;
  
  // Determine how much the horizontal feelers can be shortened
  for (i = 0; i < alabels.length; i++) {
    labelInfo = alabels[i];
    slice = labelInfo.getSlice();
    if (labelInfo.hasFeeler()) {
      excessLength = DvtPieLabelUtils._calculateFeeler(labelInfo, slice, isLeftSide);
      excessWidth = Math.min(excessWidth, excessLength);
    }
    else
      slice.setNoOutsideFeeler();
  }
  
  for (i = 0; i < alabels.length; i++) {
    labelInfo = alabels[i];
    slice = labelInfo.getSlice();
    sliceLabel = labelInfo.getSliceLabel();
                                
    if (labelInfo.hasFeeler()) {      
      // shorten the horizontal feelers
      if (isLeftSide) {
        labelInfo.setX(labelInfo.getX() + excessWidth);
      } else {
        labelInfo.setX(labelInfo.getX() - excessWidth);
      }
      // setup the feeler line (let it clip if needed)
      DvtPieLabelUtils._calculateFeeler(labelInfo, slice, isLeftSide);
      // do not wrap text if column layout is used
      sliceLabel.setMaxLines(1);
    }

    sliceLabel.setY(labelInfo.getY());
    sliceLabel.setX(labelInfo.getX());
    
    // perform 'logical' clipping ourselves
    var frame = pie.__getFrame();
    if ((labelInfo.getY() < frame.y) || (labelInfo.getY() + labelInfo.getHeight()) > frame.y + frame.h) {
      slice.setSliceLabel(null);
      slice.setNoOutsideFeeler(); // Bug fix 8358713 - don't show feelers if the label is 'clipped' (invisible)
    }
    else {
      DvtPieLabelUtils._truncateSliceLabel(pie, slice, labelInfo, isLeftSide);
      slice.setSliceLabel(sliceLabel);
    }
  }
}

// replaces PieChart.drawFeeler
/**
 * 
 * Sets the feeler line that extends from the pie to the targetPt on the given slice. This method computes where
 * on the pie the feeler line should start, and then the start point and targetPt are set on the input slice.
 * 
 * @param {object} targetPt An object with x and y fields describing where the feeler point should extend to.
 * @param {DvtPieSlice} slice A DvtPieSlice object
 * @return The excess length of the horizontal feeler, i.e. the length of the horizontal feeler minus the minimum length
 * @private
 */
DvtPieLabelUtils._calculateFeeler = function (labelInfo, slice, isLeft) {
  var pieChart = slice.getPieChart();

  var targetX = labelInfo.getX();
  var targetY = labelInfo.getY() + labelInfo.getHeight() * DvtPieLabelUtils._LABEL_TO_FEELER_OFFSET;
  var minHorizLength = DvtPieLabelUtils._FEELER_HORIZ_MINSIZE * pieChart.getRadiusX();

  var midX;
  if (isLeft) {
    targetX += DvtPieLabelUtils._LABEL_TO_FEELER_DISTANCE;
    midX = targetX + minHorizLength;
  }
  else {
    targetX -= DvtPieLabelUtils._LABEL_TO_FEELER_DISTANCE;
    midX = targetX - minHorizLength;
  }
  
  if (pieChart.getLabelPosition() == "outside") {
    var startPt = {
      x : 0, y : 0
    };
    var midPt = {
      x : midX, y : targetY
    };
    var endPt = {
      x : targetX, y : targetY
    };

    var ma = labelInfo.getAngle();
    var tilt = DvtPieLabelUtils._adjustForDepth(ma, pieChart.getDepth());

    startPt = DvtPieRenderUtils.reflectAngleOverYAxis(ma, pieChart.getCenter().x, pieChart.getCenter().y + tilt, pieChart.getRadiusX(), pieChart.getRadiusY());

    // make set the first section of the feeler radial if possible 
    var pa = DvtMath.degreesToRads(labelInfo.getPosition());
    var radFeelerAngle = Math.abs(Math.atan2(midPt.x - startPt.x, startPt.y - midPt.y));
    var horizOffset = (startPt.y - midPt.y) * Math.tan(pa);// * pieChart.getRadiusX() / pieChart.getRadiusY();
    if ((pa > Math.PI / 2 && radFeelerAngle > Math.PI / 2 && radFeelerAngle < pa) || (pa < Math.PI / 2 && radFeelerAngle < Math.PI / 2 && radFeelerAngle > pa)) {
      if (isLeft) {
        midPt.x = startPt.x - horizOffset;
      }
      else {
        midPt.x = startPt.x + horizOffset;
      }
    }

    //bglazer: store outside feeler points on slice
    //and let slice draw the feeler so that we can 
    //easily redraw it when selecting
    slice.setOutsideFeelerPoints(startPt, midPt, endPt);
    return Math.abs(endPt.x - midPt.x) - minHorizLength;
  }
  
  return 0;
}

/**
 
 * Generates the offset of a label feeler to account for the depth of a 3d pie.
 *
 * @param {number} ma The angle on the unit circle from which the leaderline should originate from
 * @param {number} depth The pie chart's depth
 *
 * @return {number} The offset for the feeler line
 * @private
 */
DvtPieLabelUtils._adjustForDepth = function (ma, pieDepth) {
  var depth = 0;
  var leftMidHi = 189;
  var rightMidHi = 351;

  if (ma > leftMidHi && ma < rightMidHi) {
    depth = pieDepth;
  }

  return depth;
}

/**
 *  Finds the label corresponding to the most horizontal slice
 *
 *  @param {Array} alabels An array of DvtPieLabelInfo objects
 *  @private
 */
DvtPieLabelUtils._getMiddleLabel = function (alabels) {
  var bestAngle = 91;
  var bestIndex =  -1;
  for (var i = 0;i < alabels.length;i++) {
    pa = alabels[i].getPosition();
    if (Math.abs(pa - 90) < bestAngle) {
      bestAngle = Math.abs(pa - 90);
      bestIndex = i;
    }
  }
  return bestIndex;
}

/**
 * Sets the label at its optimal position, assuming all other labels do not exist.
 * @param {DvtPieChart} pie
 * @param {DvtPieLabelInfo} labelInfo
 * @param {number} vertX The x-position where the labels are aligned.
 * @param {boolean} isLeft Whether the label is on the left side of the pie.
 * @private
 */
DvtPieLabelUtils._setOptimalLabelPosition = function (pie, labelInfo, vertX, isLeft) {
  //set optimal X
  labelInfo.setX(vertX);

  //set optimal Y
  //  var a = pie.getRadiusX() * (1 + DvtPieLabelUtils._FEELER_RAD_MINSIZE);
  var b = pie.getRadiusY() * (1 + DvtPieLabelUtils._FEELER_RAD_MINSIZE);
  var angleInRad = DvtMath.degreesToRads(labelInfo.getPosition());
  //  var heightFromCenter = a*b*Math.cos(angleInRad) / 
  //      Math.sqrt(Math.pow(a*Math.cos(angleInRad), 2) + Math.pow(b*Math.sin(angleInRad), 2)); //ellipse equation 
  var heightFromCenter = b * Math.cos(angleInRad);
  var tilt = DvtPieLabelUtils._adjustForDepth(labelInfo.getAngle(), pie.getDepth());
  var optimalY = pie.getCenter().y - heightFromCenter - labelInfo.getHeight() * DvtPieLabelUtils._LABEL_TO_FEELER_OFFSET + tilt;
  labelInfo.setY(labelInfo.boundY(optimalY));
}

/**
 *  Adjusts the label locations by positioning the labels vertically in a column
 *  @param {DvtPieChart} pie
 *  @param {Array} alabels An array of DvtPieLabelInfo objects
 *  @param {boolean} isLeft Boolean indicating if these labels are on the left side of the pie
 *  @private
 */
DvtPieLabelUtils._columnLabels = function (pie, alabels, isLeft, isTop, isBottom) {
  var frame = pie.__getFrame();
  var minY = frame.y;
  var maxY = frame.y + frame.h;
  var i;
  var labelInfo;

  //determine the position where the column will be aligned
  var vertX = pie.getCenter().x;
  var minFeelerDist = pie.getRadiusX() * (1 + DvtPieLabelUtils._FEELER_RAD_MINSIZE + DvtPieLabelUtils._FEELER_HORIZ_MINSIZE);
  
  if (isLeft) {
    vertX -= minFeelerDist;
  }
  else {
    vertX += minFeelerDist;
  }

  //set the minimum heights that ensures as many labels as possible are displayed
  for (i = 0;i < alabels.length;i++) {
    alabels[i].setMinY(minY);
    minY += alabels[i].getHeight();
  }

  //set the maximum heights that ensures as many labels as possible are displayed
  for (i = alabels.length - 1;i >= 0;i--) {
    maxY -= alabels[i].getHeight();
    alabels[i].setMaxY(maxY);
  }

  if (alabels[0].getMinY() >= alabels[0].getMaxY()) {
    // not all labels will fit on the screen
    for (i = 0;i < alabels.length;i++) {
      // fit as many as possible
      labelInfo = alabels[i];
      labelInfo.setX(vertX);
      labelInfo.setY((labelInfo.getMinY() + labelInfo.getMaxY()) / 2);
      labelInfo.setHasFeeler(true);
    }
    return;
  }

  var startIndex = DvtPieLabelUtils._getMiddleLabel(alabels);
  var startLabel = alabels[startIndex];
  var isStartAtTop = startLabel.getPosition() <= 90;

  //if the column is only partial but there are too many labels, then set the whole side as column
  if (isTop && !isBottom) {
    if (startLabel.getMinY() + startLabel.getHeight() > pie.getCenter().y) {
      isBottom = true;
    }
  }
  if (isBottom && !isTop) {
    if (startLabel.getMaxY() < pie.getCenter().y) {
      isTop = true;
    }
  }

  //position the start label at the column if the angle is suitable
  if ((isTop && isStartAtTop) || (isBottom && !isStartAtTop)) {
    DvtPieLabelUtils._setOptimalLabelPosition(pie, startLabel, vertX, isLeft);
    startLabel.setHasFeeler(true);
  }

  var highestY = startLabel.getY();
  var lowestY = startLabel.getY() + startLabel.getHeight();

  var optimalY;
  var labelHeight;

  if (isTop) {
    //labels above the start label
    for (i = startIndex - 1;i >= 0;i--) {
      labelInfo = alabels[i];
      labelHeight = labelInfo.getHeight();
      DvtPieLabelUtils._setOptimalLabelPosition(pie, labelInfo, vertX, isLeft);
      labelInfo.setHasFeeler(true);

      //avoid collision with the label below
      optimalY = labelInfo.getY();
      if (optimalY + labelHeight < highestY) {
        highestY = optimalY;
      }
      else {
        highestY -= labelHeight;
      }
      labelInfo.setY(highestY);
    }
  }

  if (isBottom) {
    //labels below the start label
    for (i = startIndex + 1;i < alabels.length;i++) {
      labelInfo = alabels[i];
      labelHeight = labelInfo.getHeight();
      DvtPieLabelUtils._setOptimalLabelPosition(pie, labelInfo, vertX, isLeft);
      labelInfo.setHasFeeler(true);

      //avoid collision with the label above
      optimalY = labelInfo.getY();
      if (optimalY > lowestY) {
        lowestY = optimalY + labelHeight;
      }
      else {
        lowestY += labelHeight;
      }
      labelInfo.setY(lowestY - labelHeight);
    }
  }
}

/**
 *
 * Truncates the label for the last time after the final X position is calculated
 *
 * @param {DvtPieChart} pie
 * @param {DvtPieSlice} slice
 * @param {DvtPieLabelInfo} labelInfo
 * @param {boolean} isLeft Boolean indicating whether or not this slice is on the left side of the pie
 *
 * @return {boolean} True if the height is modified after truncation, false otherwise
 * @private
 */

DvtPieLabelUtils._truncateSliceLabel = function (pie, slice, labelInfo, isLeft) {
  var sliceLabel = labelInfo.getSliceLabel();
  var style = sliceLabel.getCSSStyle();
  var maxLabelWidth = 0;
  var tmDimPt;

  // before setting the DvtTextArea, make sure it is added to the DOM
  // necessary because the DvtTextArea will try to wrap, and to do that, 
  // it needs to get the elements dimensions, which it can only do if it's
  // added to the DOM
  var numChildren = pie.getNumChildren();
  var removeTextArea = false;
  if (!pie.contains(sliceLabel)) {
    pie.addChild(sliceLabel);
    removeTextArea = true;
  }

  sliceLabel.setCSSStyle(style);
  var labelStr = slice.getSliceLabelString();
  sliceLabel.setTextString(labelStr);

  if (removeTextArea) {
    pie.removeChildAt(numChildren);
  }
  
  var frame = pie.__getFrame();
  if (isLeft) {
    maxLabelWidth = labelInfo.getX() - frame.x;
  }
  else {
    maxLabelWidth = frame.x + frame.w - labelInfo.getX();
  }

  // truncates with larger space
  tmDimPt = DvtPieLabelUtils._getTextDimension(pie, sliceLabel, maxLabelWidth, labelInfo.getInitialNumLines());

  // Update labelinfo
  labelInfo.setWidth(tmDimPt.x);

  if (labelInfo.getHeight() != tmDimPt.y) {
    labelInfo.setHeight(tmDimPt.y);// new height
    return true;
  }
  else {
    return false;
  }

}

/**
 *
 * Create initial layout, placing each label in its ideal location. Locations will be subsequently updated
 * to account for collisions
 * @param {DvtPieChart} pie
 * @return {Array}  An array with two elements. The first element is an array of DvtPieLabelInfo objects for the
 *                  labels on the left side of the pie.  The second element is an array of DvtPieLabelInfo objects
 *                  for the labels on the right side of the pie.
 *
 * @private
 */
DvtPieLabelUtils._generateInitialLayout = function (pie) {
  var arArrays = new Array(2);
  var leftLabels = [];
  var rightLabels = [];
  
  var labelPt;// generic objects with x and y fields
  var tmDimPt;

  var ma = 0;;
  var pa = 0;
  var i;

  var s_label;// an instance of DvtTextArea ;           // for bug 7593102
  var maxLabelWidth;

  var slices = pie.__getSlices();
  var n = slices.length;
  var frame = pie.__getFrame();

  if (n > 0) {
    for (i = 0;i < n;i++) {
      slice = slices[i];
      s_label = DvtPieLabelUtils._createLabel(slice);

      ma = slice.getAngleStart() + (slice.getAngleExtent() / 2);

      if (ma > 360)
        ma -= 360;
      if (ma < 0)
        ma += 360;
        
      var dist = 1 + DvtPieLabelUtils._OUTSIDE_LABEL_DISTANCE;
      labelPt = DvtPieRenderUtils.reflectAngleOverYAxis(ma, pie.getCenter().x, pie.getCenter().y, pie.getRadiusX() * dist, pie.getRadiusY() * dist);

      if (ma >= 90 && ma < 270) {
        maxLabelWidth = labelPt.x - frame.x;
      }
      // right side
      else {
        maxLabelWidth = frame.x + frame.w - labelPt.x;
      }

      tmDimPt = DvtPieLabelUtils._getTextDimension(pie, s_label, maxLabelWidth, DvtPieLabelUtils._MAX_LINES_PER_LABEL);// set up for word wrap
      
      var midArea = 15;

      if (ma < 180-midArea && ma > midArea) {
        //upper half
        labelPt.y -= tmDimPt.y * 1;
      }
      else if (ma < midArea || ma > 360-midArea) {
        //right side, near horizontal
        labelPt.y -= tmDimPt.y * 0.5;
        labelPt.x += tmDimPt.y * 0.2;
      }
      else if (ma > 180-midArea && ma < 180+midArea) {
        //left side, near horizontal
        labelPt.y -= tmDimPt.y * 0.5;
        labelPt.x -= tmDimPt.y * 0.2;
      }

      var tilt = DvtPieLabelUtils._adjustForDepth(ma, pie.getDepth());
      labelPt.y += tilt;

      if (n == 1) {
        //only 1 label
        labelPt.x -= tmDimPt.x / 2;//position the label at the center
      }

      if (labelPt.y < frame.y) { // bound to top of pie frame
        labelPt.y = frame.y;
      }

      if ((labelPt.y + tmDimPt.y) > frame.y + frame.h) { // bound to bottom of pie frame
        labelPt.y = frame.y + frame.h - tmDimPt.y;
      }

      if (ma >= 90.0 && ma < 270.0)// left side
      {
        // right align
        s_label.alignRight();
        //        s_label.alignTop();  // alignTop impl buggy - too much interline space in FF
        // normalize from 0 to 180
        pa = ma - 90.0;

        DvtPieLabelUtils._createLabelInfo(slice, s_label, ma, pa, tmDimPt, labelPt, leftLabels);
      }

      else // right side
      {
        // normalize from 0 to 180
        pa = (ma <= 90.0) ? Math.abs(90 - ma) : (180 - (ma - 270));

        DvtPieLabelUtils._createLabelInfo(slice, s_label, ma, pa, tmDimPt, labelPt, rightLabels);
      }
    }

  }

  arArrays[0] = leftLabels;
  arArrays[1] = rightLabels;

  return arArrays;

}

/**
 * Create the DvtPieLabelInfo property bag object for a given slice and inserts it into labelInfoArray,
 * it its properly sorted position (where top-most labels are at the start of the array)
 *
 * @param {DvtPieSlice} slice
 * @param {DvtTextArea} sliceLabel  The physical label we will associate with thie DvtPieLabelInfo. This
 label will be the one eventually associated with the input slice, if this
 label gets rendered
 * @param {number} ma The angle for the feeler line, with 0 degrees being the standard
 *                    0 degrees in the trigonometric sense (3 o'clock position)
 * @param {number} pa The normalized midpoint angle, where 0 degrees is at 12 o'clock
 *                    and angular measures are degrees away from 12 o'clock (so 90 degrees
 *                    can be either at 3 o'clock or 9 o'clock on the unit circle. Used to order slice
 *                    labels from top to bottom
 * @param {object} tmDimPt Object representing the width and height of the slice label
 * @param {object} labelPit The outside endpoint of the feeler line
 * @param {Array} labelInfoArray Where we store the newly created DvtPieLabelInfo
 *
 */

// method carefully refactored from the end of PieChart.prepareLabels
DvtPieLabelUtils._createLabelInfo = function (slice, sliceLabel, ma, pa, tmDimPt, labelPt, labelInfoArray) {
  var insertPos =  - 1;
  var labelInfo;
  var s_label = sliceLabel;

  // insertion "sort"
  for (var j = 0;j < labelInfoArray.length;j++) {
    labelInfo = labelInfoArray[j];
    if (labelInfo.getPosition() > pa) {
      insertPos = j;
      break;
    }
  }

  if (insertPos ==  - 1)
    insertPos = labelInfoArray.length;

  labelInfo = new DvtPieLabelInfo();

  labelInfo.setPosition(pa);
  labelInfo.setAngle(ma);
  labelInfo.setSliceLabel(s_label);
  labelInfo.setSlice(slice);
  labelInfo.setWidth(tmDimPt.x);
  labelInfo.setHeight(tmDimPt.y);
  labelInfo.setX(labelPt.x);
  labelInfo.setY(labelPt.y);

  labelInfoArray.splice(insertPos, 0, labelInfo);
}

/**
 *
 * Wraps and truncates the text in the pieLabel, and returns a pt describing the new dimensions
 * @param {DvtPieChart} pieChart
 * @param {DvtMultilineText} sliceLabel the text instance to wrap and truncate
 * @param {Number} maxWidth the maxWidth of a line
 * @param {Number} maxLines the maximum number of lines to wrap, after which the rest of the text is truncated
 * @private
 */

DvtPieLabelUtils._getTextDimension = function (pieChart, sliceLabel, maxWidth, maxLines) {
  // Truncate and wrap the text to fit in the available space
  sliceLabel.setMaxLines(maxLines);
  DvtTextUtils.fitText(sliceLabel, maxWidth, Infinity, pieChart);

  // Add the label to the DOM to get dimensions
  pieChart.addChild(sliceLabel);
  var dimensions = sliceLabel.getDimensions();
  pieChart.removeChild(sliceLabel);
  return {x: dimensions.w, y: dimensions.h};
}
/**
 * Renderer for DvtChartImpl.
 * @class
 */
var DvtChartRenderer = new Object();

DvtObj.createSubclass(DvtChartRenderer, DvtObj, "DvtChartRenderer");

/** @private */
DvtChartRenderer._EMPTY_TEXT_GAP_WIDTH = 2;
DvtChartRenderer._EMPTY_TEXT_GAP_HEIGHT = 1;

DvtChartRenderer._BUTTON_SIZE = 16;
DvtChartRenderer._BUTTON_PADDING = 5;
DvtChartRenderer._BUTTON_CORNER_DIST = 4;
DvtChartRenderer._BUTTON_OPACITY = 0.8;

DvtChartRenderer._MOUSE_WHEEL_ZOOM_RATE_SLOW = 0.05;
DvtChartRenderer._MOUSE_WHEEL_ZOOM_RATE_FAST = 0.2;

/**
 * Renders the chart contents into the available space.
 * @param {DvtChartImpl} chart The chart being rendered.
 * @param {DvtContainer} container The container to render into.
 * @param {DvtRectangle} availSpace The available space.
 */
DvtChartRenderer.render = function(chart, container, availSpace) {
  DvtChartRenderer._renderBackground(chart, container, availSpace); 
  
  if(DvtChartDataUtils.hasData(chart)) {
    // Layout and draw the contents.  Each render call will update availSpace.
    // 1. Fixed space items: Titles and title separator
    // 2. Variable size: Legend and Axes
    // 3. Remaining space: Plot Area
    DvtChartRenderer._renderTitles(chart, container, availSpace); 
    DvtChartRenderer._adjustAvailSpace(availSpace);
    
    DvtChartLegendRenderer.render(chart, container, availSpace);
    DvtChartRenderer._adjustAvailSpace(availSpace);
    
    var horizSbDim = DvtChartRenderer._prerenderHorizScrollbar(chart, container, availSpace);
    var vertSbDim = DvtChartRenderer._prerenderVertScrollbar(chart, container, availSpace);
    DvtChartRenderer._adjustAvailSpace(availSpace);
    chart.__setAxisSpace(availSpace.clone());
    
    DvtChartAxisRenderer.render(chart, container, availSpace);
    DvtChartRenderer._adjustAvailSpace(availSpace);
    chart.__setPlotAreaSpace(availSpace.clone());
    
    DvtChartRenderer._setEventHandlers(chart);
    
    DvtChartRenderer._renderScrollbars(chart, horizSbDim, vertSbDim);
    
    DvtChartRenderer._renderPlotArea(chart, container, availSpace);
    if (DvtChartTypeUtils.isPolar(chart))
      container.addChild(chart.yAxis); // move radial labels above the plot area objects
    
    DvtChartRenderer._renderDragButtons(chart, container);
  }
  else // Render the empty text
    DvtChartRenderer.renderEmptyText(chart, container, availSpace);
}

/**
 * Sets the marquee and pan/zoom event handlers.
 * @param {DvtChartImpl} chart
 */
DvtChartRenderer._setEventHandlers = function(chart) {
  var options = chart.getOptions();
  var em = chart.getEventManager();
  
  if (!DvtChartTypeUtils.hasAxes(chart) || options['_isOverview'])
    return;
  
  var chartBounds = new DvtRectangle(0, 0, chart.getWidth(), chart.getHeight());
  var plotAreaBounds = chart.__getPlotAreaSpace();
  var axisBounds = chart.__getAxisSpace();
  var horizAxisBounds = new DvtRectangle(plotAreaBounds.x, axisBounds.y, plotAreaBounds.w, axisBounds.h);
  var vertAxisBounds = new DvtRectangle(axisBounds.x, plotAreaBounds.y, axisBounds.w, plotAreaBounds.h);
  
  var marqueeFill = new DvtSolidFill(options['styleDefaults']['marqueeColor']);
  var marqueeStroke = new DvtSolidStroke(options['styleDefaults']['marqueeBorderColor']);
  
  var marqueeHandler, panZoomHandler;
  
  if (DvtChartTypeUtils.isScrollSupported(chart) && DvtChartEventUtils.isScrollable(chart)) {
    // Pan/Zoom
    var zoomRate = DvtChartEventUtils.isDelayedScroll(chart) ? DvtChartRenderer._MOUSE_WHEEL_ZOOM_RATE_FAST : DvtChartRenderer._MOUSE_WHEEL_ZOOM_RATE_SLOW;
    panZoomHandler = new DvtPanZoomHandler(chart, plotAreaBounds, chartBounds, zoomRate);
    panZoomHandler.setPanCursor(options['_resources']['panCursorUp'], options['_resources']['panCursorDown']);
    em.setPanZoomHandler(panZoomHandler);
    
    if (DvtChartEventUtils.isZoomable(chart)) {
      // Marquee Zoom
      if (DvtChartTypeUtils.isHorizontal(chart))
        marqueeHandler = new DvtMarqueeHandler(chart, plotAreaBounds, chartBounds, marqueeFill, marqueeStroke, false, true, null, vertAxisBounds);
      else if (DvtChartTypeUtils.isBLAC(chart))
        marqueeHandler = new DvtMarqueeHandler(chart, plotAreaBounds, chartBounds, marqueeFill, marqueeStroke, true, false, horizAxisBounds, null);
      else
        marqueeHandler = new DvtMarqueeHandler(chart, plotAreaBounds, chartBounds, marqueeFill, marqueeStroke, true, true, horizAxisBounds, vertAxisBounds);
      em.setMarqueeZoomHandler(marqueeHandler);
    }
  }
  
  if (options['selection'] == "multiple") {
    // Marquee Select
    marqueeHandler = new DvtMarqueeHandler(chart, plotAreaBounds, chartBounds, marqueeFill, marqueeStroke, true, true, horizAxisBounds, vertAxisBounds);
    em.setMarqueeSelectHandler(marqueeHandler);
  }
}

/**
 * Cleans up and rerenders the axis and the plot area.
 * @param {DvtChartImpl} chart
 * @param {DvtContainer} container The container to render into.
 */
DvtChartRenderer.rerenderAxisAndPlotArea = function(chart, container) {
  if(!DvtChartDataUtils.hasData(chart))
    return;
    
  var availSpace = chart.__getAxisSpace().clone();
  
  // Save selection and clean up
  var selectionHandler = chart.getSelectionHandler();
  if (selectionHandler)
    var selectedIds = selectionHandler.getSelectedIds();
  chart.__cleanUpAxisAndPlotArea();
  
  DvtChartAxisRenderer.render(chart, container, availSpace);
  DvtChartRenderer._adjustAvailSpace(availSpace);
  
  chart.__setPlotAreaSpace(availSpace.clone());
  DvtChartRenderer._renderPlotArea(chart, container, availSpace);
  
  // Reapply selection
  if (selectionHandler)
    selectionHandler.processInitialSelections(selectedIds, chart.getObjects());
  
  chart.getEventManager().autoToggleZoomButton();
  DvtChartRenderer.positionDragButtons(chart); //reposition because the plot area dims may have changed
}

/**
 * Renders the chart background.
 * @param {DvtChartImpl} chart The chart being rendered.
 * @param {DvtContainer} container The container to render into.
 * @param {DvtRectangle} availSpace The available space.
 */
DvtChartRenderer._renderBackground = function(chart, container, availSpace) {
  var options = chart.getOptions();
  
  // Chart background: Apply invisible background for interaction support
  var rect = new DvtRect(chart.getCtx(), availSpace.x, availSpace.y, availSpace.w, availSpace.h);
  rect.setInvisibleFill();
  container.addChild(rect);
  
  // Associate with logical object to support DvtComponentUIEvent
  var params = DvtChartEventManager.getUIEventParams(DvtChartConstants.BACKGROUND);
  chart.getEventManager().associate(rect, new DvtSimpleObjPeer(null, null, null, params));
    
  // WAI-ARIA
  rect.setAriaRole('img');
  rect.setAriaProperty('label', options['shortDesc']);
}

/**
 * Renders the chart titles and updates the available space.
 * @param {DvtChartImpl} chart The chart being rendered.
 * @param {DvtContainer} container The container to render into.
 * @param {DvtRectangle} availSpace The available space.
 */
DvtChartRenderer._renderTitles = function(chart, container, availSpace) {
  var options = chart.getOptions();
  
  // Allocate outer gaps
  var gapWidth = DvtChartDefaults.getGapSize(chart, options['layout']['outerGapWidth']);
  var gapHeight = DvtChartDefaults.getGapSize(chart, options['layout']['outerGapHeight']);
  availSpace.x += gapWidth;
  availSpace.w -= 2*gapWidth;
  availSpace.y += gapHeight;
  availSpace.h -= 2*gapHeight;
  
  // Title
  if(options['title']['text']) {
    var titleObj = DvtChartTextUtils.createText(chart.getEventManager(), container, options['title']['text'], options['title']['style'], 
                                                availSpace.x, availSpace.y, availSpace.w, availSpace.h, 
                                                DvtChartEventManager.getUIEventParams(DvtChartConstants.TITLE));
    
    var titleHeight;
    var titleDims;
    if (titleObj) {
      // Calc the dimensions to figure out remaining space
      titleDims = titleObj.getDimensions();
      titleHeight = titleDims.h;
    } else {
      titleHeight = 0;
      titleDims = new DvtRectangle(0, 0, 0, 0);
    }
    
    // Subtitle
    if(options['subtitle']['text']) {
      var subtitleObj = new DvtOutputText(chart.getCtx(), options['subtitle']['text'], availSpace.x, availSpace.y);
      subtitleObj.setCSSStyle(options['subtitle']['style']);
      container.addChild(subtitleObj);
      var subtitleDims = subtitleObj.measureDimensions();
      
      // Check to see if subtitle and title fit on the same line. If not, put subtitle on next line
      var titleSubtitleGap = DvtChartDefaults.getGapSize(chart, options['layout']['titleSubtitleGapWidth']);
      var titleSpace = titleDims.w + titleSubtitleGap + subtitleDims.w;
      if (titleSpace > availSpace.w) {
        titleSubtitleGap = DvtChartDefaults.getGapSize(chart, options['layout']['titleSubtitleGapHeight']);
        subtitleObj.setY(availSpace.y + titleHeight + titleSubtitleGap);
        container.removeChild(subtitleObj);
        
        if(DvtTextUtils.fitText(subtitleObj, availSpace.w, availSpace.h, chart)) {          
          subtitleDims = subtitleObj.measureDimensions();
          titleHeight += subtitleDims.h + titleSubtitleGap;
          if(DvtAgent.isRightToLeft(chart.getCtx())) {
            if (subtitleObj)
              subtitleObj.setX(availSpace.w - subtitleDims.w);
            if (titleObj)
              titleObj.setX(availSpace.w - titleDims.w);
          }
        }
      } 
      else {
        var alignTextBottomsDiff = titleDims.h - subtitleDims.h;
        subtitleObj.setY(alignTextBottomsDiff + availSpace.y);
        DvtLayoutUtils.align(availSpace, options['title']['hAlign'], titleObj, titleSpace);
        // Adjust the positions based on locale
        if(DvtAgent.isRightToLeft(chart.getCtx())) {
          subtitleObj.setX(titleObj.getX());
          if (titleObj)
            titleObj.setX(titleObj.getX() + subtitleDims.w + titleSubtitleGap);
        }
        else {
          subtitleObj.setX(titleObj.getX() + titleSpace - subtitleDims.w);
        }
      }
      
      // WAI-ARIA
      subtitleObj.setAriaProperty('hidden', null);
      
      // Associate with logical object to support DvtComponentUIEvent and truncation
      chart.getEventManager().associate(subtitleObj, new DvtSimpleObjPeer(subtitleObj.getUntruncatedTextString(), null, null, DvtChartEventManager.getUIEventParams(DvtChartConstants.SUBTITLE)));
    }
    else {
      DvtLayoutUtils.align(availSpace, options['title']['hAlign'], titleObj, titleDims.w)
    }
    
    // WAI-ARIA
    titleObj.setAriaProperty('hidden', null);
    
    // Update available space
    var titleGapBelow = options['titleSeparator']['rendered'] == "on" ? options['layout']['titleSeparatorGap'] : options['layout']['titlePlotAreaGap'];
    availSpace.y += titleHeight + DvtChartDefaults.getGapSize(chart, titleGapBelow);
    availSpace.h -= titleHeight + DvtChartDefaults.getGapSize(chart, titleGapBelow);
    
    // Title Separator
    if(options['titleSeparator']['rendered'] == "on") {
      var upperSepObj = new DvtLine(chart.getCtx(), availSpace.x, availSpace.y, availSpace.x + availSpace.w, availSpace.y)
      var lowerSepObj = new DvtLine(chart.getCtx(), availSpace.x, availSpace.y+1, availSpace.x + availSpace.w, availSpace.y+1)
      upperSepObj.setSolidStroke(options['titleSeparator']['upperColor']);
      lowerSepObj.setSolidStroke(options['titleSeparator']['lowerColor']);
      container.addChild(upperSepObj);
      container.addChild(lowerSepObj);
      
      // Remove the title separator and gap height from available space
      var titleSepHeight = 2 + DvtChartDefaults.getGapSize(chart, options['layout']['titlePlotAreaGap']);
      availSpace.y += titleSepHeight;
      availSpace.h -= titleSepHeight;
    }
  }
  
  // Footnote
  if(options['footnote']['text']) {
    var footnoteObj = DvtChartTextUtils.createText(chart.getEventManager(), container, options['footnote']['text'], options['footnote']['style'], 
                                                   availSpace.x, 0, availSpace.w, availSpace.h, 
                                                   DvtChartEventManager.getUIEventParams(DvtChartConstants.FOOTNOTE)) 
    if (footnoteObj) {
      // Get height and reposition at correct location
      var footnoteDims = footnoteObj.getDimensions();
      footnoteObj.setY(availSpace.y + availSpace.h - footnoteDims.h);
      availSpace.h -= (footnoteDims.h + DvtChartDefaults.getGapSize(chart, options['layout']['footnoteGap']));
      DvtLayoutUtils.align(availSpace, options['footnote']['hAlign'], footnoteObj, footnoteDims.w);
    }
    
    // WAI-ARIA
    footnoteObj.setAriaProperty('hidden', null);
  }
}

/**
 * Renders plot area. 
 * @param {DvtChartImpl} chart The chart being rendered.
 * @param {DvtContainer} container The container to render into.
 * @param {DvtRectangle} availSpace The available space.
 */
DvtChartRenderer._renderPlotArea = function(chart, container, availSpace) {
  if (DvtChartTypeUtils.hasAxes(chart)) {
    // Create a container for the plot area contents
    var plotArea = new DvtContainer(chart.getCtx());
    plotArea.setTranslate(availSpace.x, availSpace.y);
    container.addChild(plotArea);
    chart.setPlotArea(plotArea);

    // Render the plot area contents
    var plotAreaBounds = new DvtRectangle(0, 0, availSpace.w, availSpace.h);
    DvtPlotAreaRenderer.render(chart, plotArea, plotAreaBounds);
  }
  else if (DvtChartTypeUtils.isPie(chart)) {
    var pieChart = new DvtPieChart(chart, availSpace);
    if (pieChart.__getSlices().length > 0) {
      container.addChild(pieChart);
      pieChart.render();
    }
    else
      DvtChartRenderer.renderEmptyText(chart, container, availSpace);
  }
  else if (DvtChartTypeUtils.isFunnel(chart)) {
    DvtFunnelRenderer.render(chart, container, availSpace);
  }

  // All space is now used
  availSpace.w = 0;
  availSpace.h = 0;
}

/**
 * Renders the empty text for the component. 
 * @param {DvtChartImpl} chart The chart being rendered.
 * @param {DvtContainer} container The container to render into.
 * @param {DvtRectangle} availSpace The available space.
 */
DvtChartRenderer.renderEmptyText = function(chart, container, availSpace) {
  // Get the empty text string
  var options = chart.getOptions();
  var emptyTextStr = options['emptyText'];
  if(!emptyTextStr) {
    emptyTextStr = chart.getBundle().getTranslatedString('EMPTY_TEXT', null);
  }
  // Calculate the alignment point and available space
  var x = availSpace.x + availSpace.w/2;
  var y = availSpace.y + availSpace.h/2;

  // Create and position the text
  var text = new DvtOutputText(chart.getCtx(), emptyTextStr, x, y);
  text.setCSSStyle(options['title']['style']);
  text.alignCenter();
  text.alignMiddle();
  
  // Truncate the text to fit horizontally.  Note, we do not account for vertical size, because displaying a
  // cut off "No Data" message is better than displaying none at all.
  var maxWidth = availSpace.w - 2*DvtChartRenderer._EMPTY_TEXT_GAP_WIDTH;
  if(DvtTextUtils.fitText(text, maxWidth, Infinity, container, 0)) {
    // Add tooltip if truncated
    if(text.isTruncated())
      chart.getEventManager().associate(text, new DvtSimpleObjPeer(text.getUntruncatedTextString()));
    
    // WAI-ARIA
    text.setAriaProperty('hidden', null);
  }
}

/**
 * Prepares the horizontal scrollbar for rendering. 
 * @param {DvtChartImpl} chart The chart being rendered.
 * @param {DvtContainer} container The container to render into.
 * @param {DvtRectangle} availSpace The available space.
 * @return {DvtDimension} The dimension of the scrollbar.
 * @private
 */
DvtChartRenderer._prerenderHorizScrollbar = function(chart, container, availSpace) {
  var width = availSpace.w;
  var height = 0;
  if (DvtChartEventUtils.isScrollable(chart) && DvtChartTypeUtils.isHorizScrollbarSupported(chart)) {
    // Overview scrollbar
    if (DvtChartStyleUtils.isOverviewRendered(chart)) {
      height = DvtChartStyleUtils.getOverviewHeight(chart);
      chart.overview = new DvtChartOverview(chart.getCtx(), chart.processEvent, chart, chart.getId());    
      container.addChild(chart.overview);
      DvtLayoutUtils.position(availSpace, "bottom", chart.overview, width, height, 10); // TODO (panho): store as default      
    } 
    
    // Simple scrollbar
    else { 
      height = chart.getOptions()['styleDefaults']['_scrollbarHeight'];
      chart.xScrollbar = new DvtSimpleScrollbar(chart.getCtx(), chart.processEvent, chart);
      container.addChild(chart.xScrollbar);
      DvtLayoutUtils.position(availSpace, "bottom", chart.xScrollbar, width, height, 8);
    }
  }
  
  return new DvtDimension(width, height);
}

/**
 * Prepares the vertical scrollbar for rendering. 
 * @param {DvtChartImpl} chart The chart being rendered.
 * @param {DvtContainer} container The container to render into.
 * @param {DvtRectangle} availSpace The available space.
 * @return {DvtDimension} The dimension of the scrollbar.
 * @private
 */
DvtChartRenderer._prerenderVertScrollbar = function(chart, container, availSpace) {
  var width = 0;
  var height = availSpace.h;
  if (DvtChartEventUtils.isScrollable(chart) && DvtChartTypeUtils.isVertScrollbarSupported(chart)) {
    width = chart.getOptions()['styleDefaults']['_scrollbarHeight'];
    var scrollbar = new DvtSimpleScrollbar(chart.getCtx(), chart.processEvent, chart);
    container.addChild(scrollbar);
    DvtLayoutUtils.position(availSpace, DvtAgent.isRightToLeft(chart.getCtx()) ? "right" : "left", scrollbar, width, height, 8);
    
    // Assign scrollbar to x- or y-axis depending on chart type
    if (DvtChartTypeUtils.isHorizontal(chart))
      chart.xScrollbar = scrollbar;
    else
      chart.yScrollbar = scrollbar;
  }
  
  return new DvtDimension(width, height);
}

/**
 * Renders the scrollbars. 
 * @param {DvtChartImpl} chart The chart being rendered.
 * @param {DvtDimension} horizScrollbarDim The dimension of the horizontal scrollbar.
 * @param {DvtDimension} vertScrollbarDim The dimension of the vertical scrollbar.
 * @private
 */
DvtChartRenderer._renderScrollbars = function(chart, horizScrollbarDim, vertScrollbarDim) {
  var options = chart.getOptions();
  var sbOptions = {'color': options['styleDefaults']['_scrollbarHandleColor'], 'backgroundColor': options['styleDefaults']['_scrollbarTrackColor']};
  var plotAreaDim = chart.__getPlotAreaSpace();
  var hitAreaSize = DvtAgent.isTouchDevice() ? 8 : 4;
  
  // Render x-axis simple scrollbar
  if (chart.xScrollbar) {
    sbOptions['min'] = chart.xAxis.getGlobalMin();
    sbOptions['max'] = chart.xAxis.getGlobalMax();
    // Vertical x-axis scrollbar
    if (DvtChartTypeUtils.isHorizontal(chart)) {
      sbOptions['isHorizontal'] = false;
      sbOptions['isReversed'] = false;
      chart.xScrollbar.setTranslateY(plotAreaDim.y);
      chart.xScrollbar.render(sbOptions, vertScrollbarDim.w, plotAreaDim.h);
    } 
    // Horizontal x-axis scrollbar
    else {
      sbOptions['isHorizontal'] = true;
      sbOptions['isReversed'] = DvtAgent.isRightToLeft(chart.getCtx());
      chart.xScrollbar.setTranslateX(plotAreaDim.x);
      chart.xScrollbar.render(sbOptions, plotAreaDim.w, horizScrollbarDim.h);
      
      // Add hit area to make interaction easier
      var hitArea = new DvtRect(chart.getCtx(), 0, -hitAreaSize, plotAreaDim.w, horizScrollbarDim.h + 2*hitAreaSize);
      hitArea.setInvisibleFill();
      chart.xScrollbar.addChild(hitArea);
    }
    chart.xScrollbar.setViewportRange(chart.xAxis.getViewportMin(), chart.xAxis.getViewportMax());
  }
  
  // Render y-axis simple scrollbar
  if (chart.yScrollbar) {
    sbOptions['min'] = chart.yAxis.getGlobalMin();
    sbOptions['max'] = chart.yAxis.getGlobalMax();
    sbOptions['isHorizontal'] = false;
    sbOptions['isReversed'] = true;
    chart.yScrollbar.setTranslateY(plotAreaDim.y);
    chart.yScrollbar.render(sbOptions, vertScrollbarDim.w, plotAreaDim.h);
    chart.yScrollbar.setViewportRange(chart.yAxis.getViewportMin(), chart.yAxis.getViewportMax());
    
    // Add hit area to make interaction easier
    var hitArea = new DvtRect(chart.getCtx(), -hitAreaSize, 0, vertScrollbarDim.w + 2*hitAreaSize, plotAreaDim.h);
    hitArea.setInvisibleFill();
    chart.yScrollbar.addChild(hitArea);
  }
  
  // Render x-axis overview scrollbar
  if (chart.overview) {
    var ovOptions = {
      'startTime': chart.xAxis.getGlobalMin(),
      'endTime': chart.xAxis.getGlobalMax(),
      'viewportStartTime': chart.xAxis.getViewportMin(),
      'viewportEndTime': chart.xAxis.getViewportMax(),
      'minimumWindowSize': chart.xAxis.getMinimumExtent(),
      'chart': DvtJSONUtils.clone(options)
    };
    
    if (!DvtChartEventUtils.isZoomable(chart))
      ovOptions['featuresOff'] = 'zoom';
    
    chart.overview.setTranslateX(plotAreaDim.x);
    chart.overview.render(ovOptions, plotAreaDim.w, horizScrollbarDim.h);
    
    // Set the initial viewport
    chart.overview.setViewportRange(chart.xAxis.getViewportMin(), chart.xAxis.getViewportMax());
  }
}



/**
 * Renders the drag buttons.
 * @param {DvtChartImpl} chart.
 * @param {DvtContainer} container The container to render into.
 * @private
 */
DvtChartRenderer._renderDragButtons = function(chart, container) {
  var options = chart.getOptions();
  if (!DvtChartTypeUtils.hasAxes(chart) || options['_isOverview'])
    return;
  
  var isTouch = DvtAgent.isTouchDevice();
  var isScrollable = DvtChartTypeUtils.isScrollSupported(chart) && DvtChartEventUtils.isScrollable(chart);
  
  var em = chart.getEventManager();
  chart.dragButtons = new DvtContainer(chart.getCtx());
  var resources = options['_resources']; 
  
  var tooltip, position;
  
  if (options['selection'] == "multiple" && (isTouch || isScrollable)) {
    position = isScrollable && (isTouch || DvtChartEventUtils.isZoomable(chart)) ? 'end' : 'solo';
    em.selectButton = DvtChartRenderer._createDragButton(chart, chart.dragButtons, 
        resources['selectUp'], resources['selectDown'], em.onSelectButtonClick, em, position);  
    tooltip = chart.getBundle().getTranslatedString('MARQUEE_SELECT');
    em.associate(em.selectButton, new DvtSimpleObjPeer(tooltip));
  }
  
  if (isScrollable) {
    position = em.selectButton == null ? 'solo' : 'start';
    if (isTouch) {
      em.panButton = DvtChartRenderer._createDragButton(chart, chart.dragButtons, 
          resources['panUp'], resources['panDown'], em.onPanButtonClick, em, position); 
      tooltip = chart.getBundle().getTranslatedString('PAN');
      em.associate(em.panButton, new DvtSimpleObjPeer(tooltip));
    }
    else if (DvtChartEventUtils.isZoomable(chart)) {
      em.zoomButton = DvtChartRenderer._createDragButton(chart, chart.dragButtons, 
          resources['zoomUp'], resources['zoomDown'], em.onZoomButtonClick, em, position);
      tooltip = chart.getBundle().getTranslatedString('MARQUEE_ZOOM');
      em.associate(em.zoomButton, new DvtSimpleObjPeer(tooltip));
    }
  }
  
  DvtChartRenderer.positionDragButtons(chart);
  em.setDragMode(null); // set the default drag mode
  
  if (chart.dragButtons.getNumChildren() > 0) {
    chart.addChild(chart.dragButtons);
    
    if (isTouch) {
      if (isScrollable) {
        // Set initial mode to pan
        em.panButton.setToggled(true);
        em.onPanButtonClick(null);
      }
    }
    else {
      // Buttons are not shown initially on desktop.
      chart.hideDragButtons();
    }
    
    // Override the chart cursor.
    chart.dragButtons.setCursor("default");
  }
}

/**
 * Positions the drag button
 * @param {DvtChartImpl} chart
 * @param {DvtButton} button
 * @param {DvtRectangle} availSpace
 * @private
 */
DvtChartRenderer._positionDragButton = function(chart, button, availSpace) { 
  var transX;
  if (DvtAgent.isRightToLeft(chart.getCtx())) {
    transX = availSpace.x + DvtChartRenderer._BUTTON_PADDING;
    availSpace.x += DvtChartRenderer._BUTTON_SIZE + 2*DvtChartRenderer._BUTTON_PADDING;;
  } 
  else
    transX = availSpace.x + availSpace.w - DvtChartRenderer._BUTTON_SIZE - DvtChartRenderer._BUTTON_PADDING;
  
  availSpace.w -= DvtChartRenderer._BUTTON_SIZE + 2*DvtChartRenderer._BUTTON_PADDING;
  button.setTranslate(transX, availSpace.y + DvtChartRenderer._BUTTON_PADDING);
}

/**
 * Positions the drag buttons at the top left/right corner of the plot area.
 * @param {DvtChartImpl} chart
 */
DvtChartRenderer.positionDragButtons = function(chart) {
  var availSpace = chart.__getPlotAreaSpace().clone();
  availSpace.x += DvtChartRenderer._BUTTON_CORNER_DIST;
  availSpace.w -= 2*DvtChartRenderer._BUTTON_CORNER_DIST;
  availSpace.y += DvtChartRenderer._BUTTON_CORNER_DIST;
  
  var em = chart.getEventManager();
  if (em.selectButton)
    DvtChartRenderer._positionDragButton(chart, em.selectButton, availSpace);
  if (em.panButton)
    DvtChartRenderer._positionDragButton(chart, em.panButton, availSpace); 
  if (em.zoomButton)
    DvtChartRenderer._positionDragButton(chart, em.zoomButton, availSpace);
}

/**
 * Creates the rounded square background for the drag button.
 * @param {DvtContext} context
 * @param {string} position The position of the button: start, end, or solo.
 * @return {DvtRect} The button background.
 * @private
 */
DvtChartRenderer._createDragButtonBackground = function(context, position) {
  var blcr = 2;
  var trcr = 2;
  var isR2L = DvtAgent.isRightToLeft(context);
  if (position=="start")
    isR2L ? blcr = 0 : trcr = 0;
  else if (position=="end")
    isR2L ? trcr = 0 : blcr = 0;
  
  var tlcr = blcr;
  var brcr = trcr;
  
//// Do not adjust corner radii for now because browser behavior is inconsistent, esp. when page is zoomed in.
//  if (DvtAgent.getDevicePixelRatio() == 1) {
//    if (DvtAgent.isPlatformWebkit()) {
//      // On Chrome, the top left corner is too small and the bottom right corner is too big due to pixel hinting.
//      tlcr *= 2;
//      brcr /= 2;
//    } else if (DvtAgent.isPlatformGecko()) {
//      // On Firefox, the opposite happens.
//      tlcr /= 2;
//      brcr *= 2;
//    }
//  }
  
  var pos = -DvtChartRenderer._BUTTON_PADDING;
  var size = DvtChartRenderer._BUTTON_SIZE + DvtChartRenderer._BUTTON_PADDING*2;
  var cmd = DvtPathUtils.roundedRectangle(pos, pos, size, size, tlcr, trcr, brcr, blcr);
  
  var background = new DvtPath(context, cmd);
  background.setSolidStroke("#D8DEE3", 1, 1);
  background.setPixelHinting(true);
  return background;
}

/**
 * Creates and a drag button.
 * @param {DvtChart} chart
 * @param {DvtContainer} container The container for the button.
 * @param {string} upSrc The image URL for the up state.
 * @param {string} downSrc The image URL for the down state.
 * @param {object} callback The callback method of the button.
 * @param {object} callbackObj The object of the callback method.
 * @param {string} position The position of the button: start, end, or solo.
 * @return {DvtButton}
 * @private
 */
DvtChartRenderer._createDragButton = function(chart, container, upSrc, downSrc, callback, callbackObj, position) {
  // Create the button and add to the container
  var context = chart.getCtx();
  
  // Initialize the button states
  var upState = DvtChartRenderer._createDragButtonBackground(context, position);
  upState.setSolidFill("#FFFFFF", DvtChartRenderer._BUTTON_OPACITY);
  upState.addChild(new DvtImage(context, upSrc, 0, 0, DvtChartRenderer._BUTTON_SIZE, DvtChartRenderer._BUTTON_SIZE));
  
  var overState = DvtChartRenderer._createDragButtonBackground(context, position);
  overState.setSolidFill("#E2E3E4", DvtChartRenderer._BUTTON_OPACITY);
  overState.addChild(new DvtImage(context, upSrc, 0, 0, DvtChartRenderer._BUTTON_SIZE, DvtChartRenderer._BUTTON_SIZE));
  
  var downState = DvtChartRenderer._createDragButtonBackground(context, position);
  downState.setFill(new DvtLinearGradientFill(90, ["#0527CE", "#0586F0"], [DvtChartRenderer._BUTTON_OPACITY, DvtChartRenderer._BUTTON_OPACITY]));
  downState.addChild(new DvtImage(context, downSrc, 0, 0, DvtChartRenderer._BUTTON_SIZE, DvtChartRenderer._BUTTON_SIZE));
  
  var overDownState = DvtChartRenderer._createDragButtonBackground(context, position);
  overDownState.setSolidFill("#0586F0", DvtChartRenderer._BUTTON_OPACITY);
  overDownState.addChild(new DvtImage(context, downSrc, 0, 0, DvtChartRenderer._BUTTON_SIZE, DvtChartRenderer._BUTTON_SIZE));
  
  var button = new DvtButton(context, upState, overState, downState, null, null, callback, callbackObj);
  button.setOverDownState(overDownState);
  button.setToggleEnabled(true);
  container.addChild(button);
  
  // Button should consume mousedown event so that drag is not initiated
  button.addEvtListener(DvtMouseEvent.MOUSEDOWN, function(event) {event.stopPropagation();}, false, this);
  
  // Add hit area to the button for touch devices
  if (DvtAgent.isTouchDevice()) {
    var isR2L = DvtAgent.isRightToLeft(context);
    var hitPadding = DvtChartRenderer._BUTTON_PADDING*2;
    
    var hitArea;
    if (position == "solo")
      hitArea = new DvtRect(context, -hitPadding, -hitPadding, DvtChartRenderer._BUTTON_SIZE + 2*hitPadding, DvtChartRenderer._BUTTON_SIZE + 2*hitPadding);
    else if ((position == "start" && !isR2L) || (position == "end" && isR2L)) // left button
      hitArea = new DvtRect(context, -hitPadding, -hitPadding, DvtChartRenderer._BUTTON_SIZE + 1.5*hitPadding, DvtChartRenderer._BUTTON_SIZE + 2*hitPadding);
    else // right button
      hitArea = new DvtRect(context, -0.5*hitPadding, -hitPadding, DvtChartRenderer._BUTTON_SIZE + 1.5*hitPadding, DvtChartRenderer._BUTTON_SIZE + 2*hitPadding);
    
    hitArea.setInvisibleFill();
    button.addChild(hitArea);
  }
    
  return button;
}

/**
 * Helper function that adjusts the input rectangle to the closest pixel.
 * @param {DvtRectangle} availSpace The available space.
 */
DvtChartRenderer._adjustAvailSpace = function(availSpace) {
  // Fix for 16446255: Adjust the bounds to the closest pixel to prevent antialiasing issues.
  availSpace.x = Math.round(availSpace.x);
  availSpace.y = Math.round(availSpace.y);
  availSpace.w = Math.round(availSpace.w);
  availSpace.h = Math.round(availSpace.h);
}
/**
 * Performs layout and positioning for the chart axes.
 * @class
 */
var DvtChartAxisRenderer = new Object();

DvtObj.createSubclass(DvtChartAxisRenderer, DvtObj, "DvtChartAxisRenderer");

/**
 * @this {DvtChartAxisRenderer}
 * Renders axes and updates the available space.
 * @param {DvtChartImpl} chart The chart being rendered.
 * @param {DvtContainer} container The container to render into.
 * @param {DvtRectangle} availSpace The available space.
 */
DvtChartAxisRenderer.render = function(chart, container, availSpace) {
  if(!DvtChartTypeUtils.hasAxes(chart))
    return;
  
  var options = chart.getOptions();
  var isHorizGraph = DvtChartTypeUtils.isHorizontal(chart);
  var isPolarGraph = DvtChartTypeUtils.isPolar(chart);
  var isR2L = DvtAgent.isRightToLeft(chart.getCtx());
  var numGroups = DvtChartDataUtils.getGroupCount(chart);
  var totalAvailSpace = availSpace.clone();
  
  // Add a gap to accommodate the vertical axis labels (bug 16347893)
  var topGap = options['layout']['verticalAxisTopGap'];
  if (DvtChartTypeUtils.isVertical(chart) && DvtChartAxisUtils.areYAxisLabelsRendered(chart)) {
    availSpace.y += topGap;
    availSpace.h -= topGap;
  }
  
  // TODO BUBBLE GRAPH MOVE THIS!
  if(chart.getType() == "bubble")
    DvtChartMarkerUtils.calcBubbleSizes(chart, availSpace.w, availSpace.h);
  
  // Layout Algorithm
  // 1. Get preferred size of y axes and allocate space.
  // 2. Get preferred size of x axis and allocate space.
  // 3. Update y axes with reduced size (due to x axis)
  // This is done because x axis labels tend to be more important for identifying data,
  // such as with a categorical axis.
  
  // Calculate the gaps, which need to be added in addition to axis size
  var gapWidth = DvtChartDefaults.getGapSize(chart, options['layout']['tickLabelGapWidth']);
  var gapHeight = DvtChartDefaults.getGapSize(chart, options['layout']['tickLabelGapHeight']);
  var xGap = isHorizGraph ? gapWidth : gapHeight;
  var yGap = isHorizGraph ? gapHeight : gapWidth;
  
  // Get preferred sizing for the y axes
  var yAxisInfo = DvtChartAxisRenderer._createYAxis(chart, container, availSpace, totalAvailSpace);
  var y2AxisInfo = DvtChartAxisRenderer._createY2Axis(chart, container, availSpace, totalAvailSpace);
  
  // Position the axes to reserve space
  if(yAxisInfo)
    DvtLayoutUtils.position(availSpace, yAxisInfo.position, yAxisInfo.axis, yAxisInfo.width, yAxisInfo.height, yGap);
  
  if(y2AxisInfo)
    DvtLayoutUtils.position(availSpace, y2AxisInfo.position, y2AxisInfo.axis, y2AxisInfo.width, y2AxisInfo.height, yGap);
  
  // After positioning the y axis, the available space can change so we need to recalculate bubble sizes
  if(chart.getType() == "bubble")
    DvtChartMarkerUtils.calcBubbleSizes(chart, availSpace.w, availSpace.h);
    
  // Spark Bar Spacing Support
  if(DvtChartStyleUtils.getBarSpacing(chart) == "pixel" && DvtChartTypeUtils.isBar(chart)) {
    // Adjust the width so that it's an even multiple of the number of groups
    if(availSpace.w > numGroups) {
      var newWidth = Math.floor(availSpace.w/numGroups)*numGroups;
      availSpace.x += (availSpace.w - newWidth)/2;
      availSpace.w = newWidth;
    }
  }
  
  // Get preferred sizing for the x axes, render, and position.
  var xAxisInfo = DvtChartAxisRenderer._createXAxis(chart, container, availSpace, totalAvailSpace);
  if (isPolarGraph) {
    xAxisInfo.axis.setTranslateX(availSpace.x);
    xAxisInfo.axis.setTranslateY(availSpace.y);
    xAxisInfo.axis.render(xAxisInfo.options, availSpace.w, availSpace.h);
  }
  else {
    xAxisInfo.axis.render(xAxisInfo.options, xAxisInfo.width, xAxisInfo.height);
    DvtLayoutUtils.position(availSpace, xAxisInfo.position, xAxisInfo.axis, xAxisInfo.width, xAxisInfo.height, xGap);
  }

  // Adjust the y-axis sizes to account for the x-axis and render them
  var leftOverflow, rightOverflow;
  if(isPolarGraph && yAxisInfo) {
    yAxisInfo.axis.setTranslateX(availSpace.x);
    yAxisInfo.axis.setTranslateY(availSpace.y);
    yAxisInfo.options['_numGroups'] = numGroups; // for drawing polar polygonal gridlines
    yAxisInfo.axis.render(yAxisInfo.options, availSpace.w, availSpace.h);
  }
  else if(isHorizGraph) {
    if(yAxisInfo) {
      yAxisInfo.axis.setTranslateX(availSpace.x);
      yAxisInfo.axis.render(yAxisInfo.options, availSpace.w, yAxisInfo.height);
    }
    
    if(y2AxisInfo) {
      if (yAxisInfo)
        this._alignYAxes(yAxisInfo.axis, y2AxisInfo.axis, options, y2AxisInfo.options);
      y2AxisInfo.axis.setTranslateX(availSpace.x);
      y2AxisInfo.axis.render(y2AxisInfo.options, availSpace.w, y2AxisInfo.height);
    }
    
    // Adjust the plot area width depending on y-axis overflow 
    leftOverflow = yAxisInfo.axis.getLeftOverflow();
    rightOverflow = yAxisInfo.axis.getRightOverflow();
    availSpace.x += leftOverflow;
    availSpace.w -= leftOverflow + rightOverflow;
  } 
  else {
    // Adjust the y-axis position and plot area width depending on x-axis overflow
    leftOverflow = xAxisInfo.axis.getLeftOverflow();
    rightOverflow = xAxisInfo.axis.getRightOverflow();
    availSpace.x += leftOverflow;
    availSpace.w -= leftOverflow + rightOverflow;
    
    if(yAxisInfo) {
      yAxisInfo.axis.setTranslateX(yAxisInfo.axis.getTranslateX() + (isR2L ? -rightOverflow : leftOverflow));
      yAxisInfo.axis.render(yAxisInfo.options, yAxisInfo.width, availSpace.h);
    }
    
    if(y2AxisInfo) {
      if (yAxisInfo)
        this._alignYAxes(yAxisInfo.axis, y2AxisInfo.axis, options, y2AxisInfo.options);
      y2AxisInfo.axis.setTranslateX(y2AxisInfo.axis.getTranslateX() + (isR2L ? leftOverflow : -rightOverflow));
      y2AxisInfo.axis.render(y2AxisInfo.options, y2AxisInfo.width, availSpace.h);
    }
  }
  
  // Store the axis objects on the chart
  chart.xAxis = xAxisInfo.axis;
  chart.yAxis = yAxisInfo ? yAxisInfo.axis : null;
  chart.y2Axis = y2AxisInfo ? y2AxisInfo.axis : null;
}

/**
 * Returns an object containing the x-axis with its position and preferred size.
 * @param {DvtChartImpl} chart The chart being rendered.
 * @param {DvtContainer} container The container to render into.
 * @param {DvtRectangle} availSpace The available space for the axis.
 * @param {DvtRectangle} totalAvailSpace The total available space allocated for all axes and plot area.
 * @return {object}
 * @private
 */
DvtChartAxisRenderer._createXAxis = function(chart, container, availSpace, totalAvailSpace) {
  var options = chart.getOptions();  
  var position = DvtChartAxisUtils.getXAxisPosition(chart);
  
  // Clone the axis options and fill with data info
  var axisOptions = DvtJSONUtils.clone(options['xAxis']);
  axisOptions['skin'] = options['skin'];
  axisOptions['layout']['gapRatio'] = chart.getGapRatio();
  axisOptions['position'] = position;
  axisOptions['baselineScaling'] = options['xAxis']['baselineScaling'];
  
  // Calc the data attributes and pass in the min and max data values for that axis
  axisOptions['title'] = options['xAxis'] ? options['xAxis']['title'] : null;
  axisOptions['groups'] = options['groups'];
  axisOptions['timeAxisType'] = options['timeAxisType'] ? options['timeAxisType'] : "disabled";
  axisOptions['zoomAndScroll'] = options['zoomAndScroll'];
  axisOptions['_radius'] = chart.getRadius();
  axisOptions['_isOverview'] = options['_isOverview'];
  
  // Data Axis Support
  if(!DvtChartAxisUtils.hasGroupAxis(chart)) {
    var dataValues = DvtChartDataUtils.getMinMaxValue(chart, "x");
    axisOptions['dataMin'] = (axisOptions['dataMin'] != null) ? axisOptions['dataMin'] : dataValues['min'];
    axisOptions['dataMax'] = (axisOptions['dataMax'] != null) ? axisOptions['dataMax'] : dataValues['max'];
  }
    
  // Add a time/group axis bar offset if needed
  if (position == "tangential" && DvtChartAxisUtils.hasGroupAxis(chart)) {
    if (DvtChartTypeUtils.isBar(chart)) {
      axisOptions['startGroupOffset'] = 0.5;
      axisOptions['endGroupOffset'] = 0.5;
    }
    else
      axisOptions['endGroupOffset'] = 1;
  }
  else {
    var axisOffset = DvtChartAxisUtils.getBarAxisOffset(chart);  
    axisOptions['startGroupOffset'] = axisOffset;
    axisOptions['endGroupOffset'] = axisOffset;
  }

  // Specify the buffers (how much the labels can overflow)
  var isHoriz = (position == "top" || position == "bottom");
  axisOptions['leftBuffer'] = isHoriz ? availSpace.x - totalAvailSpace.x : 0;
  axisOptions['rightBuffer'] = isHoriz ? (totalAvailSpace.w + totalAvailSpace.x) - (availSpace.w + availSpace.x) : 0;
  
  // Variable to be used for features that may be rendered at the label or in between labels
  axisOptions['_renderGridAtLabels'] = !DvtChartTypeUtils.isBar(chart) || DvtChartDataUtils.hasMixedFrequency(chart); 
  
  // Create the x-axis
  var axis = new DvtChartAxis(chart.getCtx(), chart.processEvent, chart);
  container.addChild(axis);
  
  // Layout the axis and find the size
  var maxWidth = isHoriz ? availSpace.w : options['layout']['axisMaxSize'] * availSpace.w;
  var maxHeight = isHoriz ? options['layout']['axisMaxSize'] * availSpace.h : availSpace.h;
  var actualSize;
  if (position == "tangential")
    actualSize = new DvtDimension(0, 0); // placeholder. don't need getPreferredSize for polar chart.
  else if (options['_duringAnimation']) {
    // During animation, reuse the previous axis size
    if (isHoriz) {
      actualSize = new DvtDimension(maxWidth, chart.xAxis.getHeight());
      
      // The axis overflow amount has to be maintained to prevent jumpy animation
      var isR2L = DvtAgent.isRightToLeft(chart.getCtx());
      axisOptions['_startOverflow'] = isR2L ? chart.xAxis.getRightOverflow() : chart.xAxis.getLeftOverflow();
      axisOptions['_endOverflow'] = isR2L ? chart.xAxis.getLeftOverflow() : chart.xAxis.getRightOverflow();
    }
    else
      actualSize = new DvtDimension(chart.xAxis.getWidth(), maxHeight);
  } 
  else
    actualSize = axis.getPreferredSize(axisOptions, maxWidth, maxHeight);
  
  return {'axis': axis, 'options': axisOptions, 'position': position, 'width': actualSize.w, 'height': actualSize.h};
}

/**
 * Returns an object containing the y-axis with its position and preferred size.
 * @param {DvtChartImpl} chart The chart being rendered.
 * @param {DvtContainer} container The container to render into.
 * @param {DvtRectangle} availSpace The available space for the axis.
 * @param {DvtRectangle} totalAvailSpace The total available space allocated for all axes and plot area.
 * @return {object}
 * @private
 */
DvtChartAxisRenderer._createYAxis = function(chart, container, availSpace, totalAvailSpace) {
  var options = chart.getOptions();  
  
  // Check that the graph needs a y1 axis
  if(DvtChartTypeUtils.hasY2DataOnly(chart))
    return null;
  
  var position = DvtChartAxisUtils.getYAxisPosition(chart);
  var isHoriz = (position == "top" || position == "bottom");
  
  // Clone the axis options and fill with data info
  var axisOptions = DvtJSONUtils.clone(options['yAxis']);
  axisOptions['skin'] = options['skin'];
  axisOptions['layout']['gapRatio'] = chart.getGapRatio();
  axisOptions['position'] = position;
  axisOptions['baselineScaling'] = options['yAxis']['baselineScaling'];
  
  // Calc the data attributes and pass in the min and max data values for that axis
  var dataValues = DvtChartDataUtils.getMinMaxValue(chart, "y", DvtChartTypeUtils.isBLAC(chart));
  axisOptions['dataMin'] = (axisOptions['dataMin'] != null) ? axisOptions['dataMin'] : dataValues['min'];
  axisOptions['dataMax'] = (axisOptions['dataMax'] != null) ? axisOptions['dataMax'] : dataValues['max'];
  
  axisOptions['title'] = options['yAxis'] ? options['yAxis']['title'] : null;
  axisOptions['timeAxisType'] = "disabled";
  axisOptions['zoomAndScroll'] = options['zoomAndScroll'];
  axisOptions['_radius'] = chart.getRadius(); // for polar charts
  
  // Use the prominent baseline display for BLAC charts
  axisOptions['_useBaselineColor'] = DvtChartTypeUtils.isBLAC(chart);
  
  // Enable continuous extent for smooth y-axis rescaling animation
  if (DvtChartEventUtils.isLiveScroll(chart) && DvtChartTypeUtils.isBLAC(chart) && !DvtChartTypeUtils.isPolar(chart))
    axisOptions['_continuousExtent'] = "on";
  
  // Specify the buffers (how much the labels can overflow)
  var isR2L = DvtAgent.isRightToLeft(chart.getCtx());
  axisOptions['leftBuffer'] = isR2L ? 0 : DvtAxis.MINIMUM_AXIS_BUFFER;
  axisOptions['rightBuffer'] = isR2L ? DvtAxis.MINIMUM_AXIS_BUFFER : 0;
  
  // Create the axis and add to the display list for calc and rendering
  var axis = new DvtChartAxis(chart.getCtx(), chart.processEvent, chart);
  container.addChild(axis);
  
  // Layout the axis and find the size
  var maxWidth = isHoriz ? availSpace.w : options['layout']['axisMaxSize'] * availSpace.w;
  var maxHeight = isHoriz ? options['layout']['axisMaxSize'] * availSpace.h : availSpace.h;
  var actualSize;
  if (position == "radial")
    actualSize = new DvtDimension(0, 0); // placeholder. don't need getPreferredSize for polar chart.
  else if (options['_duringAnimation']) {
    // During animation, reuse the previous axis size
    if (isHoriz)
      actualSize = new DvtDimension(maxWidth, chart.yAxis.getHeight());
    else
      actualSize = new DvtDimension(chart.yAxis.getWidth(), maxHeight);
  } 
  else
    actualSize = axis.getPreferredSize(axisOptions, maxWidth, maxHeight);
  
  // Store the axis min/max for zoom & scroll
  options['yAxis']['min'] = axisOptions['min'];
  options['yAxis']['max'] = axisOptions['max'];
  
  return {'axis': axis, 'options': axisOptions, 'position': position, 'width': actualSize.w, 'height': actualSize.h};
}

/**
 * Returns an object containing the y2-axis with its position and preferred size.
 * @param {DvtChartImpl} chart The chart being rendered.
 * @param {DvtContainer} container The container to render into.
 * @param {DvtRectangle} availSpace The available space for the axis.
 * @param {DvtRectangle} totalAvailSpace The total available space allocated for all axes and plot area.
 * @return {object}
 * @private
 */
DvtChartAxisRenderer._createY2Axis = function(chart, container, availSpace, totalAvailSpace) {
  var options = chart.getOptions();
  
  // Check that the graph has y2-axis data
  if(!DvtChartTypeUtils.hasY2Data(chart))
    return;
    
  var position = DvtChartAxisUtils.getY2AxisPosition(chart);
  
  // Clone the axis options and fill with data info
  var axisOptions = DvtJSONUtils.clone(options['y2Axis']);
  axisOptions['skin'] = options['skin'];
  axisOptions['layout']['gapRatio'] = chart.getGapRatio();
  axisOptions['position'] = position;
  axisOptions['baselineScaling'] = options['y2Axis']['baselineScaling'];
  
  // Calc the data attributes and pass in the min and max data values for that axis
  var dataValues = DvtChartDataUtils.getMinMaxValue(chart, "y2", DvtChartTypeUtils.isBLAC(chart));
  axisOptions['dataMin'] = (axisOptions['dataMin'] != null) ? axisOptions['dataMin'] : dataValues['min'];
  axisOptions['dataMax'] = (axisOptions['dataMax'] != null) ? axisOptions['dataMax'] : dataValues['max'];
  
  axisOptions['title'] = options['y2Axis'] ? options['y2Axis']['title'] : null;
  axisOptions['timeAxisType'] = "disabled";
  axisOptions['zoomAndScroll'] = options['zoomAndScroll'];
  
  // Enable continuous extent for smooth y-axis rescaling animation
  if (DvtChartEventUtils.isLiveScroll(chart) && DvtChartTypeUtils.isBLAC(chart) && !DvtChartTypeUtils.isPolar(chart))
    axisOptions['_continuousExtent'] = "on";
  
  // Specify the buffers (how much the labels can overflow)
  var isR2L = DvtAgent.isRightToLeft(chart.getCtx());
  axisOptions['leftBuffer'] = isR2L ? 0 : DvtAxis.MINIMUM_AXIS_BUFFER;
  axisOptions['rightBuffer'] = isR2L ? DvtAxis.MINIMUM_AXIS_BUFFER : 0;
  
  // Create the axis and add to the display list for calc and rendering
  var axis = new DvtChartAxis(chart.getCtx(), chart.processEvent, chart);
  container.addChild(axis);
  
  // Layout the axis and find the size
  var isHoriz = (position == "top" || position == "bottom");
  var maxWidth = isHoriz ? availSpace.w : options['layout']['axisMaxSize'] * availSpace.w;
  var maxHeight = isHoriz ? options['layout']['axisMaxSize'] * availSpace.h : availSpace.h;
  var actualSize;
  if (options['_duringAnimation']) {
    // During animation, reuse the previous axis size
    if (isHoriz)
      actualSize = new DvtDimension(maxWidth, chart.y2Axis.getHeight());
    else
      actualSize = new DvtDimension(chart.y2Axis.getWidth(), maxHeight);
  } 
  else
    actualSize = axis.getPreferredSize(axisOptions, maxWidth, maxHeight);
  
  // Store the axis min/max for zoom & scroll
  options['y2Axis']['min'] = axisOptions['min'];
  options['y2Axis']['max'] = axisOptions['max'];
  
  return {'axis': axis, 'options': axisOptions, 'position': position, 'width': actualSize.w, 'height': actualSize.h};
}

/**
 * Algins Y1 and Y2 axes gridlines if needed.
 * @param {DvtAxis} yAxis The Y1 axis object.
 * @param {DvtAxis} y2Axis The Y2 axis object.
 * @param {object} options The options object for the chart.
 * @param {object} y2AxisOptions The options object for the Y2 axis.
 * @private
 */
DvtChartAxisRenderer._alignYAxes = function(yAxis, y2Axis, options, y2AxisOptions) {
  var majorTickCount = yAxis.getMajorTickCount();
  var minorTickCount = yAxis.getMinorTickCount();
  if (options['y2Axis']['alignTickMarks'] == 'on' && options['y2Axis']['step'] == null) {
    y2Axis.setMajorTickCount(majorTickCount);
    y2Axis.setMinorTickCount(minorTickCount);
    y2AxisOptions['step'] = y2Axis.getMajorIncrement();
    y2AxisOptions['minorStep'] = y2Axis.getMinorIncrement();
  }
}
/**
 * Performs layout and positioning for the chart legend.
 * @class
 */
var DvtChartLegendRenderer = new Object();

DvtObj.createSubclass(DvtChartLegendRenderer, DvtObj, "DvtChartLegendRenderer");

/**
 * Renders legend and updates the available space.
 * @param {DvtChartImpl} chart The chart being rendered.
 * @param {DvtContainer} container The container to render into.
 * @param {DvtRectangle} availSpace The available space.
 */
DvtChartLegendRenderer.render = function(chart, container, availSpace) {
  var options = chart.getOptions();
  
  // Find the position of the legend
  var position = options['legend']['position'];
  var scrolling = options['legend']['scrolling'];
	
  // Done if not rendering
  if(options['legend']['rendered'] != "on") 
    return;
  
  // Create the options object for the legend
  var legendOptions = DvtJSONUtils.clone(options['legend']);
  delete legendOptions["position"];
  legendOptions['skin'] = options['skin'];
  legendOptions['layout']['gapRatio'] = chart.getGapRatio();
  legendOptions['hideAndShowBehavior'] = DvtChartEventUtils.getHideAndShowBehavior(chart);
  legendOptions['hoverBehavior'] = DvtChartEventUtils.getHoverBehavior(chart);
	
  // Add data for the legend
  DvtChartLegendRenderer._addLegendData(chart, legendOptions);
  
  // If no legend sections were added, then nothing should be rendered
  if(legendOptions['sections'].length == 0)
    return;
  
  // Create and add the legend to the display list for calc and rendering
  var legend = DvtLegend.newInstance(chart.getCtx(), chart.processEvent, chart);
  if(chart.getId() != null){
    //create and set legend id based on parent id
    legend.setId(chart.getId()+"legend");
  }
  container.addChild(legend);
  
  // Evaluate the automatic position
  // Position the legend to occupy the larger dimension so that the plot area is more square
  if(position == "auto" && scrolling !== "asNeeded") {
    if (availSpace.w >= availSpace.h) {
      position = "end";
    } else {
      position = "bottom";
    }
  }
  // If scrolling is on, auto will always render vertical legend
  else if(position == "auto" && scrolling == "asNeeded") {
    position = "end";
  }
  
  // Convert "start" and "end" to absolute position
  var isRTL = DvtAgent.isRightToLeft(chart.getCtx());
  if(position == "start")
    position = isRTL ? "right" : "left";
  else if(position == "end")
    position = isRTL ? "left" : "right";
	
  // Add legend orientation
  legendOptions['orientation'] = (position == "left" || position == "right" ? "vertical" : "horizontal");
	
  // Evaluate non-auto position
  var isHoriz = (position == "top" || position == "bottom");
  var maxWidth = isHoriz ? availSpace.w : options['layout']['legendMaxSize'] * availSpace.w;
  var maxHeight = isHoriz ? options['layout']['legendMaxSize'] * availSpace.h : availSpace.h;
  var actualSize = legend.getPreferredSize(legendOptions, maxWidth, maxHeight);
  
  legend.render(legendOptions, actualSize.w, actualSize.h);
  var gap = DvtChartDefaults.getGapSize(chart, options['layout']['legendGap']);
  DvtLayoutUtils.position(availSpace, position, legend, actualSize.w, actualSize.h, gap);

  // Cache the legend for interactivity
  chart['legend'] = legend;
}

/**
 * Adds data into the options object for the legend.
 * @param {DvtChartImpl} chart The chart whose data will be passed to the legend.
 * @param {object} legendOptions The legend options object into which data will be added.
 * @return {object} The data object for the chart's legend.
 */
DvtChartLegendRenderer._addLegendData = function(chart, legendOptions) {
  var chartOptions = chart.getOptions();
  
  // Populate top level items
  legendOptions['title'] = chartOptions['legend'] ? chartOptions['legend']['title'] : null;
  legendOptions['sections'] = [];
  
  // Series
  var seriesItems = DvtChartLegendRenderer._getSeriesItems(chart);
  if(seriesItems.length > 0)
    legendOptions['sections'].push({'items': seriesItems});
  
  // Attribute Groups Sections
  DvtChartLegendRenderer._addLegendSections(chart, legendOptions['sections']);
  
  // Reference Objects
  var refObjItems = DvtChartLegendRenderer._getRefObjItems(chart);
  if(refObjItems.length > 0) {
    var refObjTitle = chartOptions['legend'] ? chartOptions['legend']['referenceObjectTitle'] : null;
    legendOptions['sections'].push({'items': refObjItems, 'title': refObjTitle});
  }
    
  return legendOptions;
}

/**
 * Returns the array of series items to pass to the legend.
 * @param {DvtChartImpl} chart The chart whose data will be passed to the legend.
 * @return {Array} The series items.
 * @private
 */
DvtChartLegendRenderer._getSeriesItems = function(chart) {
  var ret = [];
  var legendItem;
  
  if (chart.getType() == "pie") {
    var seriesIndices = DvtPieChartUtils.getRenderedSeriesIndices(chart);
    var seriesIndex;
    // Add the series in the same order as the pie
    for (var i = 0; i < seriesIndices.length; i++) {
      seriesIndex = seriesIndices[i];
      legendItem = DvtChartLegendRenderer._createLegendItem(chart, seriesIndex);
      if (legendItem)
        ret.push(legendItem);
    }
    if (DvtPieChartUtils.hasOtherSeries(chart)) {
      // Create legend item for "other" slice
      legendItem = {'id': DvtPieChartUtils.OTHER_SLICE_SERIES_ID,
                    'text': chart.getBundle().getTranslatedString('LABEL_OTHER', null), 
                    'categoryVisibility': DvtPieChartUtils.getOtherSliceVisibility(chart),
                    'type': 'marker',
                    'color': chart.getOptions()['styleDefaults']['otherColor'],
                    'borderColor': chart.getOptions()['styleDefaults']['borderColor']};
      ret.push(legendItem);
    }
  } else {
    // Loop through and find the series
    var seriesCount = DvtChartDataUtils.getSeriesCount(chart);
    for(var seriesIndex=0; seriesIndex < seriesCount; seriesIndex++) {
      legendItem = DvtChartLegendRenderer._createLegendItem(chart, seriesIndex);
      if (legendItem)
        ret.push(legendItem);
    }
  }
  
  // Legend items are reversed in stacked charts
  if(DvtChartTypeUtils.isStacked(chart) && DvtChartTypeUtils.isVertical(chart)) 
    ret.reverse();
  
  return ret;
}


/**
 * Creates a legend item for a series
 * @param {DvtChartImpl} chart The chart whose data will be passed to the legend
 * @param {Number} seriesIndex The series index
 * @return {Object} The legend item
 * @private
 */
DvtChartLegendRenderer._createLegendItem = function(chart, seriesIndex) {
  var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
  
  // Skip if the series item isn't defined or if not displayInLegend
  if(!seriesItem || seriesItem['displayInLegend'] == "off")
    return null;
    
  // Skip if displayInLegend is auto and series has no non-null data
  if(seriesItem['displayInLegend'] != "on" && !DvtChartDataUtils.hasSeriesData(chart, seriesIndex))
    return null;
    
  // Skip if the series label is an empty string
  var seriesLabel = DvtChartDataUtils.getSeriesLabel(chart, seriesIndex);
  if(!seriesLabel || seriesLabel.trim().length <= 0)
    return null;
  
  // Create the legend item and add the properties for this series
  var series = DvtChartDataUtils.getSeries(chart, seriesIndex);
  var legendItem = {'id': series,
                    'text': seriesLabel, 
                    'categoryVisibility': seriesItem['visibility']};
  
  // Shape varies by chart type
  if(chart.getType() == "line") {
    legendItem['lineStyle'] = DvtChartStyleUtils.getLineStyle(chart, seriesIndex);
    legendItem['lineWidth'] = DvtChartStyleUtils.getLineWidth(chart, seriesIndex);
  
    if(DvtChartStyleUtils.getMarkerDisplayed(chart, seriesIndex) == "on") {
      legendItem['type'] = "lineWithMarker";
      legendItem['markerShape'] = DvtChartStyleUtils.getMarkerShape(chart, seriesIndex);
      legendItem['markerColor'] = DvtChartStyleUtils.getMarkerColor(chart, seriesIndex);
    }
    else
      legendItem['type'] = "line";
  }
  else if(chart.getType() == "scatter" || chart.getType() == "bubble") {
    legendItem['type'] = "marker";
    legendItem['markerShape'] = DvtChartStyleUtils.getMarkerShape(chart, seriesIndex); 
  }
  else
    legendItem['type'] = "marker";
  
  // Also add the color and pattern
  legendItem['color'] = DvtChartStyleUtils.getColor(chart, seriesIndex);
  legendItem['borderColor'] = DvtChartStyleUtils.getBorderColor(chart, seriesIndex);
  legendItem['pattern'] = DvtChartStyleUtils.getPattern(chart, seriesIndex);
  
  // Action and popup support
  legendItem['action'] = seriesItem['action'];
  legendItem['_spb'] = chart.getShowPopupBehaviors(seriesItem['_id']);
  
  return legendItem;
}


/**
 * Processes and adds the explicitly defined legend sections.
 * @param {DvtChartImpl} chart
 * @param {array} sections
 */
DvtChartLegendRenderer._addLegendSections = function(chart, sections) {
  var options = chart.getOptions();
  if(options && options['legend'] && options['legend']['sections']) {
    // Iterate through any sections defined with attribute groups
    for(var i=0; i<options['legend']['sections'].length; i++) {
      var dataSection = options['legend']['sections'][i];
      if(dataSection && dataSection['items']) 
        sections.push({'title': dataSection['title'], 'items': dataSection['items']});
    }
  }
}

/**
 * Returns the array of reference object items to pass to the legend.
 * @param {DvtChartImpl} chart The chart whose data will be passed to the legend.
 * @return {array} The reference object items.
 */
DvtChartLegendRenderer._getRefObjItems = function(chart) {
  var refObjs = DvtChartRefObjUtils.getObjects(chart);
  if(refObjs.length <= 0)
    return [];
  
  var items = [];
  for(var i=0; i<refObjs.length; i++) {
    var refObj = refObjs[i];
    
    // Reference Object must be defined with color and text to appear in legend
    if(!refObj || refObj['displayInLegend'] != "on" || !refObj['text'])
      continue;
    
    var type = DvtChartRefObjUtils.getType(refObj);
    items.push({
      'type': (type == "area") ? "square" : "line",
      'text': refObj['text'],
      'color': DvtChartRefObjUtils.getColor(refObj),
      'lineStyle': refObj['lineStyle'],
      'lineWidth': DvtChartRefObjUtils.getLineWidth(refObj)
    });
  }

  return items;
}
/**
 * Renderer for the plot area of a DvtChart.
 * @class
 */
var DvtPlotAreaRenderer = new Object();

DvtObj.createSubclass(DvtPlotAreaRenderer, DvtObj, "DvtPlotAreaRenderer");

DvtPlotAreaRenderer._MIN_TOUCH_MARKER_SIZE = 16; // minimum marker size for touch devices
DvtPlotAreaRenderer._MARKER_DATA_LABEL_GAP = 4; // space separating the data label from the marker
DvtPlotAreaRenderer._MIN_CHARS_DATA_LABEL = 3; // minimum number of chars to be displayed of a data label when truncating

/**
 * Renders the plot area into the available space.
 * @param {DvtChartImpl} chart The chart being rendered.
 * @param {DvtContainer} container The container to render to.
 * @param {DvtRectangle} availSpace The available space.
 */
DvtPlotAreaRenderer.render = function (chart, container, availSpace) {
  // TODO: change to formal location for displayed data
  chart._currentMarkers = new Array();
  chart._currentAreas = new Array();
  
  DvtPlotAreaRenderer._renderBackgroundObjects(chart, container, availSpace);
  DvtPlotAreaRenderer._renderGridLines(chart, container, availSpace);
  DvtPlotAreaRenderer._renderForegroundObjects(chart, container, availSpace);
}

/**
 * Renders objects in the background of the plot area.
 * @param {DvtChartImpl} chart The chart being rendered.
 * @param {DvtContainer} container The container to render to.
 * @param {DvtRectangle} availSpace The available space.
 */
DvtPlotAreaRenderer._renderBackgroundObjects = function (chart, container, availSpace) {
  // Chart background
  var options = chart.getOptions();
  
  var background;
  var context = chart.getCtx();
  if (DvtChartTypeUtils.isPolar(chart)) {
    var cx = availSpace.x + availSpace.w/2;
    var cy = availSpace.y + availSpace.h/2;
    if (options['yAxis']['majorTick']['gridType'] == "straight") {
      var points = DvtAxisInfo.getPolygonPoints(DvtChartDataUtils.getGroupCount(chart), chart.getRadius());
      background = new DvtPolygon(context, points);
      background.setTranslateX(cx);
      background.setTranslateY(cy);
    }
    else
      background = new DvtCircle(context, cx, cy, chart.getRadius());
  }
  else
    background = new DvtRect(context, availSpace.x, availSpace.y, availSpace.w, availSpace.h);
  
  if (options['plotArea']['backgroundColor'])
    background.setSolidFill(options['plotArea']['backgroundColor']);
  else
    background.setInvisibleFill(); // Always render a background plot area rectangle and save for interactivity
  
  container.addChild(background);
  
  // Associate with logical object to support DvtComponentUIEvent
  var params = DvtChartEventManager.getUIEventParams(DvtChartConstants.PLOT_AREA);
  chart.getEventManager().associate(background, new DvtSimpleObjPeer(null, null, null, params));
  
  // TODO: change to formal storage location for plot rectangle reference
  chart._plotRect = background;
  
  // Reference Objects
  if(options['xAxis']['referenceObjects'] || options['yAxis']['referenceObjects'] || options['y2Axis']['referenceObjects']){
    clipGroup = DvtPlotAreaRenderer._createClippedGroup(chart, container, availSpace);
    DvtRefObjRenderer.renderBackgroundObjects(chart, clipGroup, availSpace);
  }
  
  // Draw area series behind the gridlines (because they would obscure the grids)
  if(DvtChartTypeUtils.isArea(chart) || DvtChartTypeUtils.isCombo(chart))
    DvtPlotAreaRenderer._renderAreas(chart, container, availSpace);
}

/**
 * Renders grid lines for the plot area.
 * @param {DvtChartImpl} chart The chart being rendered.
 * @param {DvtContainer} container The container to render to.
 * @param {DvtRectangle} availSpace The available space.
 */
DvtPlotAreaRenderer._renderGridLines = function (chart, container, availSpace) {
  var context = container.getCtx();
  
  var options = chart.getOptions();
  var renderXAxis = (chart.xAxis && options['xAxis']['rendered'] != "off");
  var renderYAxis = (chart.yAxis && options['yAxis']['rendered'] != "off");
  var renderY2Axis = (chart.y2Axis && options['y2Axis']['rendered'] != "off");
  
  if(renderXAxis)
    DvtPlotAreaRenderer._positionGridLines(container, availSpace, chart.xAxis, chart.xAxis.getMinorGridLines(context));
  
  if(renderYAxis)
    DvtPlotAreaRenderer._positionGridLines(container, availSpace, chart.yAxis, chart.yAxis.getMinorGridLines(context));
  
  if(renderY2Axis)
    DvtPlotAreaRenderer._positionGridLines(container, availSpace, chart.y2Axis, chart.y2Axis.getMinorGridLines(context));
    
  if(renderXAxis)
    DvtPlotAreaRenderer._positionGridLines(container, availSpace, chart.xAxis, chart.xAxis.getMajorGridLines(context));
  
  if(renderYAxis)
    DvtPlotAreaRenderer._positionGridLines(container, availSpace, chart.yAxis, chart.yAxis.getMajorGridLines(context));
  
  if(renderY2Axis)
    DvtPlotAreaRenderer._positionGridLines(container, availSpace, chart.y2Axis, chart.y2Axis.getMajorGridLines(context));
    
  //************ Axis Lines ************************************************/
  if(renderXAxis) 
    DvtPlotAreaRenderer._positionAxisLine(container, availSpace, chart.xAxis);
  
  if(renderYAxis) 
    DvtPlotAreaRenderer._positionAxisLine(container, availSpace, chart.yAxis);
 
  if(renderY2Axis) 
    DvtPlotAreaRenderer._positionAxisLine(container, availSpace, chart.y2Axis);
}

/**
 * Positions the specified grid lines in the plotArea.
 * @param {DvtContainer} container The container to render to.
 * @param {DvtRectangle} availSpace The available space.
 * @param {array} gridlines The Array of DvtLine objects.
 * @param {boolean} isHoriz True if the axis is horizontal.
 */
DvtPlotAreaRenderer._positionGridLines = function (container, availSpace, axis, gridlines) {
  var position = axis.getPosition();
  
  for (var i = 0; i < gridlines.length; i++) {
    var gridline = gridlines[i];
    container.addChild(gridline);

    // Position the gridline based on axis orientation
    if (position == "radial" || position == "tangential") {
      gridline.setTranslateX(availSpace.x + availSpace.w/2);
      gridline.setTranslateY(availSpace.y + availSpace.h/2);
    }
    else if (position == "top" || position == "bottom") {
      gridline.setY1(availSpace.y);
      gridline.setY2(availSpace.y + availSpace.h);
      gridline.setX1(axis.axisToPlotArea(gridline.getX1()));
      gridline.setX2(axis.axisToPlotArea(gridline.getX2()));
    }
    else {
      gridline.setX1(availSpace.x);
      gridline.setX2(availSpace.x + availSpace.w);
      gridline.setY1(axis.axisToPlotArea(gridline.getY1()));
      gridline.setY2(axis.axisToPlotArea(gridline.getY2()));
    }
  }
}

/**
 * Positions the specified axis line in the plotArea.
 * @param {DvtContainer} container The container to render to.
 * @param {DvtRectangle} availSpace The available space.
 * @param {DvtLine} axisLine The DvtLine object.
 * @param {string} position The position of the axis.
 */
DvtPlotAreaRenderer._positionAxisLine = function (container, availSpace, axis) {
  var axisLine = axis.getAxisLine(container.getCtx());
  if(!axisLine)
    return;
  
  // Add the line to the container and position
  container.addChild(axisLine);
  var position = axis.getPosition();
  if (position == "radial" || position == "tangential") {
    axisLine.setTranslateX(availSpace.x + availSpace.w/2);
    axisLine.setTranslateY(availSpace.y + availSpace.h/2);
  }
  else if(position == "top") {
    axisLine.setX1(availSpace.x);
    axisLine.setX2(availSpace.x + availSpace.w);
    axisLine.setY1(availSpace.y);
    axisLine.setY2(availSpace.y);
  }
  else if(position == "bottom") {
    axisLine.setX1(availSpace.x);
    axisLine.setX2(availSpace.x + availSpace.w);
    axisLine.setY1(availSpace.y + availSpace.h);
    axisLine.setY2(availSpace.y + availSpace.h);
  }
  else if(position == "left") {
    axisLine.setX1(availSpace.x);
    axisLine.setX2(availSpace.x);
    axisLine.setY1(availSpace.y);
    axisLine.setY2(availSpace.y + availSpace.h);
  }
  else if(position == "right") {
    axisLine.setX1(availSpace.x + availSpace.w);
    axisLine.setX2(availSpace.x + availSpace.w);
    axisLine.setY1(availSpace.y);
    axisLine.setY2(availSpace.y + availSpace.h);
  }
}

/**
 * Renders objects in the foreground of the plot area.
 * @param {DvtChartImpl} chart The chart being rendered.
 * @param {DvtContainer} container The container to render to.
 * @param {DvtRectangle} availSpace The available space.
 */
DvtPlotAreaRenderer._renderForegroundObjects = function (chart, container, availSpace) {
  // Get container for clipping
  clipGroup = DvtPlotAreaRenderer._createClippedGroup(chart, container, availSpace);
  
  // Data Objects
  if(DvtChartTypeUtils.isBar(chart)) {
    DvtPlotAreaRenderer._renderBars(chart, clipGroup, availSpace);
  }
  else if(DvtChartTypeUtils.isLine(chart)) {
    DvtPlotAreaRenderer._renderLines(chart, container, clipGroup, availSpace);
  }
  else if(DvtChartTypeUtils.isCombo(chart)) {
    // Areas were drawn in the background, draw bars and lines
    DvtPlotAreaRenderer._renderBars(chart, clipGroup, availSpace);
    DvtPlotAreaRenderer._renderLines(chart, container, clipGroup, availSpace);
  }
  else if(DvtChartTypeUtils.isScatter(chart)) {
    DvtPlotAreaRenderer._renderDataMarkers(chart, container, true, availSpace);
  }
  else if(DvtChartTypeUtils.isBubble(chart)) { 
    DvtPlotAreaRenderer._renderDataMarkers(chart, clipGroup, true, availSpace);
  }
  
  // Reference Objects 
  var options = chart.getOptions();
  if(options['xAxis']['referenceObjects'] || options['yAxis']['referenceObjects'] || options['y2Axis']['referenceObjects']){
    clipGroup = DvtPlotAreaRenderer._createClippedGroup(chart, container, availSpace);
    DvtRefObjRenderer.renderForegroundObjects(chart, clipGroup, availSpace);
  }
 
  // Initial Selection
  var selected = DvtChartDataUtils.getInitialSelection(chart);
  DvtChartEventUtils.setInitialSelection(chart, selected);
}

/**
 * Renders a single data label associated with a data item.
 * @param {DvtChartImpl} chart The chart being rendered.
 * @param {DvtContainer} container The container to render to.
 * @param {DvtRectangle} dataItemBounds The space occupied by the data item this is associated with.
 * @param {number} seriesIndex The series of this data label.
 * @param {number} groupIndex The group of this data label.
 * @param {Color} dataColor The color of the data item this label is associated with.
 * @private
 */
DvtPlotAreaRenderer._renderDataLabel = function(chart, container, dataItemBounds, seriesIndex, groupIndex, dataColor){
  if (chart.getOptions()['_isOverview']) // no data label in overview
    return;
  
  // Get and create the label string
  var labelString = DvtChartDataUtils.getDataLabel(chart, seriesIndex, groupIndex);
  if (!labelString)
    return;

  var label = new DvtOutputText(chart.getCtx(), labelString, 0, 0);
  label.setMouseEnabled(false);
  
  //get label position
  var position = DvtChartStyleUtils.getDataLabelPosition(chart, seriesIndex, groupIndex);
    
  var style = DvtChartStyleUtils.getDataLabelStyle(chart, seriesIndex, groupIndex, dataColor, position);
  label.setCSSStyle(style);
    
  label.setY(dataItemBounds.y + dataItemBounds.h/2);
  label.setX(dataItemBounds.x + dataItemBounds.w/2);
  label.alignCenter();
  label.alignMiddle();
  var textDim = label.measureDimensions();

  if (position == "center" || position == "inBottom" || position == "inTop" || position == "inRight" || position == "inLeft"){
    dataItemBounds.x += DvtPlotAreaRenderer._MARKER_DATA_LABEL_GAP/2;
    dataItemBounds.y += DvtPlotAreaRenderer._MARKER_DATA_LABEL_GAP/2;
    dataItemBounds.h -= DvtPlotAreaRenderer._MARKER_DATA_LABEL_GAP;
    dataItemBounds.w -= DvtPlotAreaRenderer._MARKER_DATA_LABEL_GAP;
    
    if (DvtChartStyleUtils.getSeriesType(chart, seriesIndex) == "bar"){
      if (textDim.w > dataItemBounds.w || textDim.h > dataItemBounds.h)
        return; //dropping text if doesn't fit.
        
      if (position == "inRight"){
        label.setX(dataItemBounds.x + dataItemBounds.w - textDim.w/2.0 - DvtPlotAreaRenderer._MARKER_DATA_LABEL_GAP);
      }
      else if (position == "inLeft"){
        label.setX(dataItemBounds.x + textDim.w/2.0 + DvtPlotAreaRenderer._MARKER_DATA_LABEL_GAP);
      }
      else if (position == "inTop"){
        label.setY(dataItemBounds.y + textDim.h/2.0 + DvtPlotAreaRenderer._MARKER_DATA_LABEL_GAP);
      }
      else if (position == "inBottom"){
        label.setY(dataItemBounds.y + dataItemBounds.h - textDim.h/2.0 - DvtPlotAreaRenderer._MARKER_DATA_LABEL_GAP/2);
      }
    }
    else if (DvtChartTypeUtils.isBubble(chart)){
      var size = label.getOptimalFontSize(dataItemBounds);
      label.setFontSize(size)
      if (! DvtTextUtils.fitText(label, dataItemBounds.w, dataItemBounds.h, container, DvtPlotAreaRenderer._MIN_CHARS_DATA_LABEL))
        return; //dropping text if doesn't fit.
    }
  }
  else if (position == "right"){
    label.setX(dataItemBounds.x + dataItemBounds.w + textDim.w/2.0 + DvtPlotAreaRenderer._MARKER_DATA_LABEL_GAP);
  }
  else if (position == "left"){
    label.setX(dataItemBounds.x - textDim.w/2.0 - DvtPlotAreaRenderer._MARKER_DATA_LABEL_GAP);
  }
  else if (position == "above"){
    label.setY(dataItemBounds.y - textDim.h/2.0);
  }
  else if (position == "below"){
    label.setY(dataItemBounds.y + dataItemBounds.h + textDim.h/2.0 + DvtPlotAreaRenderer._MARKER_DATA_LABEL_GAP/2);
  }
    
  container.addChild(label);
}

/**
 * Helper function. Calculates and passes the marker bounds to the data label rendering code.
 * @param {DvtChartImpl} chart The chart being rendered.
 * @param {DvtContainer} container The container to render to.
 * @param {DvtMarker} marker
 * @private
 */
DvtPlotAreaRenderer._renderLabelForDataMarker = function(chart, container, marker) {
    var logicalObject = chart.getEventManager().getLogicalObject(marker);
    var markerBounds = new DvtRectangle(marker.getX(), marker.getY(), marker.getWidth(), marker.getHeight());
    DvtPlotAreaRenderer._renderDataLabel(chart, container, markerBounds, logicalObject.getSeriesIndex(), logicalObject.getGroupIndex(), marker.getDataColor());
}

/**
 * Renders the data markers.
 * @param {DvtChartImpl} chart The chart being rendered.
 * @param {DvtContainer} container The container to render to.
 * @param {boolean} bSortBySize True if markers should be sorted by size to reduce overlaps.
 * @param {DvtRectangle} availSpace The available space.
 */
DvtPlotAreaRenderer._renderDataMarkers = function(chart, container, bSortBySize, availSpace) {
  // Keep track of the markers so that they can be sorted and added
  var markers = [];
  
  // Loop through the series
  var seriesCount = DvtChartDataUtils.getSeriesCount(chart);
  for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
    var seriesMarkers = DvtPlotAreaRenderer._getMarkersForSeries(chart, seriesIndex, availSpace);
    markers = markers.concat(seriesMarkers);
  }
  
  // Sort the markers from smallest to largest
  if(bSortBySize)
    DvtChartMarkerUtils.sortMarkers(markers);
    
  // Add the markers to the plotArea
  var numMarkers = markers.length;
  for (var i = 0; i < numMarkers; i++) {
    container.addChild(markers[i]);
    this._renderLabelForDataMarker(chart, container, markers[i]);
  }

  // TODO: change to formal location for displayed data
  chart._currentMarkers.push(markers);

}

/**
 * Renders the data markers for the specified series.
 * @param {DvtChartImpl} chart The chart being rendered.
 * @param {DvtContainer} container The container to render to.
 * @param {number} seriesIndex The series to render.
 * @param {DvtRectangle} availSpace The available space.
 */
DvtPlotAreaRenderer._renderDataMarkersForSeries = function(chart, container, seriesIndex, availSpace) {
  // Get the markers for the specified series
  var markers = DvtPlotAreaRenderer._getMarkersForSeries(chart, seriesIndex, availSpace);
    
  // Add the markers to the plotArea
  var numMarkers = markers.length;
  for (var i = 0; i < numMarkers; i++) {
    container.addChild(markers[i]);
    this._renderLabelForDataMarker(chart, container, markers[i]);
  }


  // TODO: change to formal location for displayed data
  chart._currentMarkers.push(markers);

}

/**
 * Creates and returns the array of DvtMarker for the specified series.
 * @param {DvtChartImpl} chart The chart being rendered.
 * @param {number} seriesIndex
 * @return {array} The array of DvtMarkers for the specified series.
 * @param {DvtRectangle} availSpace The available space.
 */
DvtPlotAreaRenderer._getMarkersForSeries = function(chart, seriesIndex, availSpace) {
  // Skip the series if it shouldn't be rendered
  if(!DvtChartStyleUtils.isSeriesRendered(chart, seriesIndex))
    return [];
  
  var isTouchDevice = DvtAgent.isTouchDevice();
  var context = chart.getCtx();
  var xAxis = chart.xAxis;
  var yAxis = chart.yAxis; 
  if(DvtChartDataUtils.isAssignedToY2(chart, seriesIndex))
    yAxis = chart.y2Axis;
  var options = chart.getOptions();
  var bHasDatatips = DvtChartTooltipUtils.hasDatatips(chart);
  var bBubbleChart = DvtChartTypeUtils.isBubble(chart);
  
  // Keep track of the markers so that they can be sorted and added
  var markers = [];
  
  // Loop through the groups in the series
  var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
  var seriesItemCount = seriesItem['items'].length;
  for (var groupIndex=0; groupIndex<seriesItemCount; groupIndex++) {
    var dataItem = seriesItem['items'][groupIndex];
    
    // Skip for null or undefined values
    var dataValue = DvtChartDataUtils.getValue(chart, seriesIndex, groupIndex);
    if(dataValue == null || isNaN(dataValue))
      continue;
      
    // Filter markers only if we don't have marquee selection
    if (options['selection'] != "multiple" && dataItem['_filtered'])
      continue;
    
    // Skip if not visible
    if(!DvtChartStyleUtils.isDataItemRendered(chart, seriesIndex, groupIndex))
      continue;

    // Get the axis values
    var xValue = DvtChartAxisUtils.getXAxisValue(dataItem, groupIndex);
    var yValue = DvtChartDataUtils.getCumulativeValue(chart, seriesIndex, groupIndex);

    // Get the position of the marker
    var xCoord, yCoord;
    if (bBubbleChart) {
    // Markers for most graph types must be within the plot area to be rendered.  Bubble markers
    // do not, as they are available clipped to the plot area bounds.
      xCoord = xAxis.getUnboundedCoordAt(xValue);
      yCoord = yAxis.getUnboundedCoordAt(yValue);
    } else {
      xCoord = xAxis.getCoordAt(xValue);
      yCoord = yAxis.getCoordAt(yValue);
    }
    if (xCoord == null || yCoord == null)
      continue;
    
    if (DvtChartTypeUtils.isPolar(chart)) {
      var cartesian = DvtPlotAreaRenderer._polarToCartesian(yCoord, xCoord, availSpace);
      xCoord = cartesian.x;
      yCoord = cartesian.y;
    }
    else if (DvtChartTypeUtils.isHorizontal(chart)) { // swap xCoord and yCoord
      var temp = xCoord;
      xCoord = yCoord;
      yCoord = temp;
    }

    // Determine whether a visible marker is to be displayed
    var bMarkerDisplayed = DvtChartStyleUtils.getMarkerDisplayed(chart, seriesIndex, groupIndex) == "on";
    if(!bMarkerDisplayed) {
      // If both previous and next values are null, then always display a marker
      var prevValue = DvtChartDataUtils.getValue(chart, seriesIndex, groupIndex-1);
      var nextValue = DvtChartDataUtils.getValue(chart, seriesIndex, groupIndex+1);
      if((prevValue == null || isNaN(prevValue)) && (nextValue == null || isNaN(nextValue)) && !DvtChartDataUtils.hasMixedFrequency(chart))
        bMarkerDisplayed = true;
    }
    
    // If the chart is in the middle of animation, don't render invisible markers unless the marker is selected.
    if (options['_duringAnimation'] && !bMarkerDisplayed && !DvtChartDataUtils.isDataSelected(chart, seriesIndex, groupIndex))
      continue;
    
    // Store the center of the data point relative to the plot area (for marquee selection)
    var dataPos = new DvtPoint(xCoord, yCoord);
    
    // Get the style information for this marker
    var shape = DvtChartStyleUtils.getMarkerShape(chart, seriesIndex, groupIndex);
    var borderColor = DvtChartStyleUtils.getBorderColor(chart, seriesIndex, groupIndex);
    var markerSize = DvtChartStyleUtils.getMarkerSize(chart, seriesIndex, groupIndex);
    
    // Adjust by the marker size
    var halfMarkerSize = markerSize/2;
    xCoordMinHalf = xCoord - (DvtPlotAreaRenderer._MIN_TOUCH_MARKER_SIZE/2);
    yCoordMinHalf = yCoord - (DvtPlotAreaRenderer._MIN_TOUCH_MARKER_SIZE/2);
    xCoord -= halfMarkerSize;
    yCoord -= halfMarkerSize;    
    
    // Create the marker
    var marker = null;
    var dataColor = bMarkerDisplayed ? DvtChartStyleUtils.getMarkerColor(chart, seriesIndex, groupIndex) :
                                      DvtChartStyleUtils.getColor(chart, seriesIndex, groupIndex);
    var hoverColor = DvtChartSeriesEffectUtils.getHoverColor(chart, dataColor);
    var innerColor = DvtChartStyleUtils.getSelectedInnerColor(chart);
    var outerColor = DvtChartStyleUtils.getSelectedOuterColor(chart) ? DvtChartStyleUtils.getSelectedOuterColor(chart) : dataColor;
    
    if(bMarkerDisplayed) {
      // Support for visible markers
      marker = new DvtMarker(context, shape, DvtCSSStyle.SKIN_ALTA, xCoord, yCoord, markerSize, markerSize);
      if (chart.isSelectionSupported()) {
        marker.setCursor(DvtSelectionEffectUtils.getSelectingCursor());        
      }
      
      // Apply the marker style
      marker.setFill(DvtChartSeriesEffectUtils.getMarkerFill(chart, seriesIndex, groupIndex));
      if (borderColor)
        marker.setSolidStroke(borderColor);
	
      // Set the data color, used for data label generation
      marker.setDataColor(dataColor);
	
      // Apply the selection effects, which are also used for keyboard focus.
      marker.setHoverStroke(new DvtSolidStroke(hoverColor, 1, 2));
      marker.setSelectedStroke(new DvtSolidStroke(innerColor, 1, 1.5), new DvtSolidStroke(outerColor, 1, 4.5));
      marker.setSelectedHoverStroke(new DvtSolidStroke(innerColor, 1, 1.5), new DvtSolidStroke(hoverColor, 1, 4.5));
      
      // Make sure that the marker hit area is large enough for touch devices (bug 14757156)
      // Also make sure there is only 1 invisible marker (bug 16915350)      
      if (isTouchDevice && (markerSize < DvtPlotAreaRenderer._MIN_TOUCH_MARKER_SIZE)) {        
        var hitArea = new DvtRect(context, xCoord, yCoord, 
            DvtPlotAreaRenderer._MIN_TOUCH_MARKER_SIZE, DvtPlotAreaRenderer._MIN_TOUCH_MARKER_SIZE);
        hitArea.setInvisibleFill();
        marker.addChild(hitArea);
      }
    }
    else {
      // Support for invisible markers for tooltips/interactivity      
      if (chart.isSelectionSupported()) {
        marker = new DvtChartLineMarker(context, shape, xCoord, yCoord, markerSize);
        marker.setCursor(DvtSelectionEffectUtils.getSelectingCursor());
        if (isTouchDevice) {
          var hitArea = new DvtRect(context, xCoordMinHalf, yCoordMinHalf, 
            DvtPlotAreaRenderer._MIN_TOUCH_MARKER_SIZE, DvtPlotAreaRenderer._MIN_TOUCH_MARKER_SIZE);
          hitArea.setInvisibleFill();
          marker.addChild(hitArea);
        }
      }
      else {
        if (isTouchDevice) {
          xCoord = xCoordMinHalf;
          yCoord = yCoordMinHalf;
          markerSize = DvtPlotAreaRenderer._MIN_TOUCH_MARKER_SIZE;
        }
        if(bHasDatatips) {
          marker = new DvtMarker(context, DvtMarker.SQUARE, null, xCoord, yCoord, markerSize, markerSize);
        }
      }
      
      if(marker != null) {
        marker.setInvisibleFill();
        marker.setDataColor(dataColor, innerColor, outerColor);
      }
    }
      
    if(marker != null) {      
      // Add it to the markers array for sorting and addition to the display list later  
      markers.push(marker);
    
      // Associate the marker for interactivity
      DvtChartObjPeer.associate(marker, chart, seriesIndex, groupIndex, dataPos);
    }
  }
  
  return markers;
}

/**
 * Renders all bar series for the given chart.
 * @param {DvtChartImpl} chart
 * @param {DvtContainer} container The container to render to.
 * @param {DvtRectangle} availSpace
 */
DvtPlotAreaRenderer._renderBars = function(chart, container, availSpace) {
  var context = chart.getCtx();
  var options = chart.getOptions();
  var xAxis = chart.xAxis;
  var bHoriz = DvtChartTypeUtils.isHorizontal(chart);
  var bPolar = DvtChartTypeUtils.isPolar(chart);
  var bStacked = DvtChartTypeUtils.isStacked(chart);
  var bPixelSpacing = (DvtChartStyleUtils.getBarSpacing(chart) == "pixel");
  
  // Find all series that are bars
  var barSeries = [];
  var seriesCount = DvtChartDataUtils.getSeriesCount(chart);
  for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
    // Skip the series if it shouldn't be rendered or if the series type is not bar.
    if(!DvtChartStyleUtils.isSeriesRendered(chart, seriesIndex) || 
       DvtChartStyleUtils.getSeriesType(chart, seriesIndex) != "bar")
      continue;
    else
      barSeries.push(seriesIndex);
  }
  
  // Some BIDI charts display the bars in reverse order
  if(DvtAgent.isRightToLeft(context) && !bStacked && !bHoriz)
    barSeries.reverse();
  
  // Get the common parameters that don't vary between bars
  var groupCount = options['groups'] ? options['groups'].length : 0;
  var barSeriesCount = barSeries.length;
  var barWidth = DvtChartStyleUtils.getBarWidth(chart, barSeriesCount, xAxis);
  var offset = DvtChartStyleUtils.getBarOffset(chart, barWidth, barSeriesCount);
  var y2Offset = DvtChartStyleUtils.getY2BarOffset(chart, barWidth);

  // Iterate through the data
  for (var barSeriesIndex = 0; barSeriesIndex < barSeriesCount; barSeriesIndex++) {
    seriesIndex = barSeries[barSeriesIndex];
    
    // Find the corresponding y axis
    var bY2Series = DvtChartDataUtils.isAssignedToY2(chart, seriesIndex);
    var yAxis = bY2Series ? chart.y2Axis : chart.yAxis; 
    
    for(var groupIndex = 0; groupIndex < groupCount; groupIndex++) {
      var dataItem = DvtChartDataUtils.getDataItem(chart, seriesIndex, groupIndex);

      // Get the axis values
      var xValue = DvtChartAxisUtils.getXAxisValue(dataItem, groupIndex);
      var yValue = DvtChartDataUtils.getValue(chart, seriesIndex, groupIndex);
      var totalYValue = DvtChartDataUtils.getCumulativeValue(chart, seriesIndex, groupIndex);
      
      // Don't render bars whose value is null
      if(yValue == null || isNaN(yValue))
        continue;
  
      // Get the position on the axis
      var xCoord = xAxis.getUnboundedCoordAt(xValue, false); // false: don't round x coord, or ugly bar gaps can appear
      var yCoord = yAxis.getBoundedCoordAt(totalYValue);
      var baseCoord = bStacked ? yAxis.getBoundedCoordAt(totalYValue - yValue) : yAxis.getBaselineCoord();
      
      // Don't render bars whose start and end points are both out of bounds
      if(yCoord == baseCoord && yAxis.getCoordAt(totalYValue) === null)
        continue;
      
      // Support for 0 value bars.  Render bars smaller than a pixel as an invisible 3 pixel bar.
      var bInvisible = false;
      if(Math.abs(yCoord - baseCoord) < 1) {
        bInvisible = true;
        if(yCoord > baseCoord)
          yCoord = baseCoord + 3;
        else if(yCoord <= baseCoord)
          yCoord = baseCoord - 3;
      }
    
      // Calculate the actual x coords for the bar.  
      var x1 = bY2Series ? xCoord + offset + y2Offset : xCoord + offset;
      var x2 = x1 + barWidth;
      
      // Store the center of the data point relative to the plot area (for marquee selection)
      var dataPos;
      if (bPolar)
        dataPos = DvtPlotAreaRenderer._polarToCartesian(yCoord, (x1+x2)/2, availSpace);
      else if (bHoriz)
        dataPos = new DvtPoint(yCoord, (x1+x2)/2);
      else
        dataPos = new DvtPoint((x1+x2)/2, yCoord);
    
      // Create and apply the style
      var polygon, inner1, inner2, outer1, outer2;
      if (bPolar) {
        inner1 = DvtPlotAreaRenderer._polarToCartesian(baseCoord, x1, availSpace);
        inner2 = DvtPlotAreaRenderer._polarToCartesian(baseCoord, x2, availSpace);
        outer1 = DvtPlotAreaRenderer._polarToCartesian(yCoord, x1, availSpace);
        outer2 = DvtPlotAreaRenderer._polarToCartesian(yCoord, x2, availSpace);
        var cmd = DvtPathUtils.moveTo(inner1.x, inner1.y) +
                  DvtPathUtils.arcTo(baseCoord, baseCoord, x2-x1, 1, inner2.x, inner2.y) +
                  DvtPathUtils.lineTo(outer2.x, outer2.y) +
                  DvtPathUtils.arcTo(yCoord, yCoord, x2-x1, 0, outer1.x, outer1.y) +
                  DvtPathUtils.lineTo(inner1.x, inner1.y) +
                  DvtPathUtils.closePath();
        polygon = new DvtGraphSelectablePath(context, cmd);
      }
      else
        polygon = new DvtChartBar(context, bHoriz, bStacked, baseCoord, yCoord, x1, x2);
      container.addChild(polygon);
      
      if (chart.isSelectionSupported())
        polygon.setCursor(DvtSelectionEffectUtils.getSelectingCursor());
      
      var fill, stroke;
      if(bInvisible) // Apply an invisible fill for small bars
        fill = DvtSolidFill.invisibleFill(); 
      else {
        // Apply the specified style
        fill = DvtChartSeriesEffectUtils.getBarFill(chart, seriesIndex, groupIndex, bHoriz, barWidth);
        var borderColor = DvtChartStyleUtils.getBorderColor(chart, seriesIndex, groupIndex);
        if(borderColor)
          stroke = new DvtSolidStroke(borderColor);
      }
      
      var dataColor = DvtChartStyleUtils.getColor(chart, seriesIndex, groupIndex);
      var hoverColor = DvtChartSeriesEffectUtils.getHoverColor(chart, dataColor);
      var innerColor = DvtChartStyleUtils.getSelectedInnerColor(chart);
      var outerColor = DvtChartStyleUtils.getSelectedOuterColor(chart);
      
      // Apply the fill, stroke, and selection colors
      if (bPolar) {
        polygon.setFill(fill);
        polygon.setStroke(stroke);
        polygon.setDataColor(dataColor, innerColor, outerColor);
      }
      else
        polygon.setStyleProperties(fill, stroke, hoverColor, innerColor, outerColor)
      
      // Use pixel hinting for pixel bar spacing
      if(bPixelSpacing)
        polygon.setPixelHinting(true);
        
      // Rendering data labels for this bar
      var barDims;
      if (bPolar) {
        var minX = Math.min(inner1.x, inner2.x, outer1.x, outer2.x);
        var maxX = Math.max(inner1.x, inner2.x, outer1.x, outer2.x);
        var minY = Math.min(inner1.y, inner2.y, outer1.y, outer2.y);
        var maxY = Math.max(inner1.y, inner2.y, outer1.y, outer2.y);
        barDims = new DvtRectangle(minX, minY, maxX-minX, maxY-minY);
      }
      else if (bHoriz)
        barDims = new DvtRectangle(Math.min(yCoord,baseCoord), Math.min(x2,x1), Math.abs(yCoord-baseCoord), Math.abs(x2-x1));
      else
        barDims = new DvtRectangle(Math.min(x2,x1), Math.min(yCoord,baseCoord), Math.abs(x2-x1), Math.abs(yCoord-baseCoord));

      // Only add the text to the bar if it's on top of it. If outside, add to the bar's container. This is because the selection filter was causing the text to pick up the color.
      var position = dataItem['labelPosition'] ? dataItem['labelPosition'] : options['styleDefaults']['dataLabelPosition'];
      var parentContainer = (position  == "outsideBarEdge") ? container : polygon;
      DvtPlotAreaRenderer._renderDataLabel(chart, parentContainer, barDims, seriesIndex, groupIndex, DvtChartStyleUtils.getColor(chart, seriesIndex, groupIndex));
        
      // Associate for interactivity
      DvtChartObjPeer.associate(polygon, chart, seriesIndex, groupIndex, dataPos);
      
      var markers = new Array();
      markers.push(polygon);

      // TODO: change to formal location for displayed data      
      chart._currentMarkers.push(markers);
    }
    
    if(!bStacked && !DvtChartDataUtils.hasMixedFrequency(chart))
      offset += barWidth;
  }
}

/**
 * Renders all line series for the given chart.
 * @param {DvtChartImpl} chart
 * @param {DvtContainer} container The container to render to.
 * @param {DvtContainer} clipGroup The group for clipping the line and the area.
 * @param {DvtRectangle} availSpace
 */
DvtPlotAreaRenderer._renderLines = function(chart, container, clipGroup, availSpace) {
  var context = chart.getCtx();

  // Find all series that are lines
  var lineSeries = [];
  var seriesCount = DvtChartDataUtils.getSeriesCount(chart);
  for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
    // Skip the series if it shouldn't be rendered or if the series type is not line.
    if(!DvtChartStyleUtils.isSeriesRendered(chart, seriesIndex) || 
       DvtChartStyleUtils.getSeriesType(chart, seriesIndex) != "line")
      continue;
    else
      lineSeries.push(seriesIndex);
  }
  
  // Render the lines
  for (var lineIndex = 0; lineIndex < lineSeries.length; lineIndex++) {
    seriesIndex = lineSeries[lineIndex];
    
    // Get the style info
    var color = DvtChartStyleUtils.getColor(chart, seriesIndex);
    var lineWidth = DvtChartStyleUtils.getLineWidth(chart, seriesIndex);
    var lineStyle = DvtStroke.convertTypeString(DvtChartStyleUtils.getLineStyle(chart, seriesIndex));
    var stroke = new DvtSolidStroke(color, 1, lineWidth);
    stroke.setStyle(lineStyle);
    
    // Filter points to reduce render time
    if (!DvtChartTypeUtils.isPolar(chart))
      DvtPlotAreaRenderer._filterPointsForSeries(chart, seriesIndex);
    
    // Get the arrays of points
    var pointsArrays = DvtPlotAreaRenderer._getPointsForSeries(chart, seriesIndex, availSpace);
    
    // Create a line for each set of points
    for(var i = 0; i < pointsArrays.length; i++) {
      var points = pointsArrays[i];
      if(points && points.length > 1) {
        var line;
        if (DvtChartTypeUtils.isPolar(chart)) {
          line = new DvtPolygon(context, points);
          line.setInvisibleFill();
        }
        else
          line = new DvtPolyline(context, points);
        line.setStroke(stroke);
        clipGroup.addChild(line);
          
        // Associate for interactivity
        DvtChartObjPeer.associate(line, chart, seriesIndex);
      }
    }
  }
  
  // Render the markers
  for(lineIndex = 0; lineIndex < lineSeries.length; lineIndex++) 
    DvtPlotAreaRenderer._renderDataMarkersForSeries(chart, container, lineSeries[lineIndex], availSpace);
}

/**
 * Renders all area series for the given chart.
 * @param {DvtChartImpl} chart
 * @param {DvtContainer} container The container to render to.
 * @param {DvtRectangle} availSpace
 */
DvtPlotAreaRenderer._renderAreas = function(chart, container, availSpace) {
  var context = chart.getCtx();
  var bStacked = DvtChartTypeUtils.isStacked(chart);

  // Find all series that are areas
  var areaSeries = [];
  var seriesCount = DvtChartDataUtils.getSeriesCount(chart);
  for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
    // Skip the series if it shouldn't be rendered or if the series type is not area.
    if(!DvtChartStyleUtils.isSeriesRendered(chart, seriesIndex) || 
       DvtChartStyleUtils.getSeriesType(chart, seriesIndex) != "area")
      continue;
    else
      areaSeries.push(seriesIndex);
  }
  
  // Stacked areas are rendered in reverse order.
  if(bStacked)
    areaSeries.reverse();
  
  // Create group to clip the areas
  var group = DvtPlotAreaRenderer._createClippedGroup(chart, container, availSpace);
  
  // Loop through the series
  for (var areaIndex = 0; areaIndex < areaSeries.length; areaIndex++) {
    seriesIndex = areaSeries[areaIndex];
    
    // Filter points to reduce render time
    DvtPlotAreaRenderer._filterPointsForSeries(chart, seriesIndex);
    
    // Get the arrays of points
    var pointsArrays = DvtPlotAreaRenderer._getPointsForSeries(chart, seriesIndex, availSpace);
    
    // Get the baseline coordinate, which will be added to each area
    var baselineCoord = chart.yAxis ? chart.yAxis.getBaselineCoord() : chart.y2Axis.getBaselineCoord();
    
    // Create a shape for each set of points
    for(var i = 0; i < pointsArrays.length; i++) {
      var points = pointsArrays[i];
      if(points && points.length > 2) {
        if (!DvtChartTypeUtils.isPolar(chart)) {
          // Add the two bottom points
          if (DvtChartTypeUtils.isHorizontal(chart)) {
            points.push(baselineCoord, points[points.length-1]);
            points.push(baselineCoord, points[1]);
          }
          else {
            points.push(points[points.length-2], baselineCoord);
            points.push(points[0], baselineCoord);
          }
        }

        // Create and apply the style
        var polygon = new DvtPolygon(context, points);
        group.addChild(polygon);
        
        polygon.setFill(DvtChartSeriesEffectUtils.getAreaFill(chart, seriesIndex));
        var borderColor = DvtChartStyleUtils.getBorderColor(chart, seriesIndex);
        if(borderColor)
          polygon.setSolidStroke(borderColor);

        // TODO: change to formal API for storage
        chart._currentAreas.push(polygon);
          
        // Associate for interactivity
        DvtChartObjPeer.associate(polygon, chart, seriesIndex);
      }
    }
    
    // If not stacked, draw with each series so that markers don't bleed through
    if(!bStacked)
      DvtPlotAreaRenderer._renderDataMarkersForSeries(chart, container, seriesIndex, availSpace);
  }
  
  // If stacked, draw markers at the end so that the stacked areas don't overlap them
  if(bStacked) {
    for(areaIndex = 0; areaIndex < areaSeries.length; areaIndex++) 
      DvtPlotAreaRenderer._renderDataMarkersForSeries(chart, container, areaSeries[areaIndex], availSpace);
  }
}

/**
 * Filters the data points for line/area so that no more than one point is drawn per pixel.
 * @param {DvtChartImpl} chart
 * @param {number} seriesIndex
 */
DvtPlotAreaRenderer._filterPointsForSeries = function(chart, seriesIndex) {
  var maxNumPts = chart.__getPlotAreaSpace().w; // one point per pixel
  var seriesItems = DvtChartDataUtils.getSeriesItem(chart, seriesIndex)['items'];
  var zoomFactor = (chart.xAxis.getDataMax() - chart.xAxis.getDataMin()) / (chart.xAxis.getViewportMax() - chart.xAxis.getViewportMin());
  var setSize = Math.round(2 * (seriesItems.length/zoomFactor) / maxNumPts); // pick two points (max and min) from each set
  
  if (setSize <= 2) {
    // Nothing should be filtered. Clear _filtered flags from previous rendering.
    for (var i = 0; i < seriesItems.length; i++) {
      dataItem = seriesItems[i];
      if (dataItem)
        dataItem['_filtered'] = false;
    }
    return;  
  }
  
  var maxIndex, maxValue, minIndex, minValue, dataItem, dataValue;
  for (var i = 0; i < seriesItems.length; i += setSize) {
    maxIndex = -1;
    maxValue = -Infinity;
    minIndex = -1;
    minValue = Infinity;
    
    // Find the extreme points (min/max) of the set
    for (var j = i; j < Math.min(i+setSize, seriesItems.length); j++) {
      dataValue = DvtChartDataUtils.getValue(chart, seriesIndex, j);
      dataItem = seriesItems[j];
      if (dataValue == null || dataItem == null)
        continue;
      if (dataValue > maxValue) {
        maxIndex = j;
        maxValue = dataValue;
      }
      if (dataValue < minValue) {
        minIndex = j;
        minValue = dataValue;
      }
      dataItem['_filtered'] = true; // Filter every point in the meanwhile
    }
    
    // Unfilter the extreme points of the set
    for (var j = i; j < Math.min(i+setSize, seriesItems.length); j++) {
      dataItem = seriesItems[j];
      if (dataItem == null)
        continue;
      if (j == maxIndex || j == minIndex)
        dataItem['_filtered'] = false;
    }
  }
}

/**
 * Creates and returns the coordinates for the specified series.  An array of arrays is returned,
 * with each array being a set of contiguous points.
 * @param {DvtChartImpl} chart The chart being rendered.
 * @param {number} seriesIndex The series being rendered.
 * @param {DvtRectangle} availSpace The available space.
 * @return {array} The arrays of contiguous points for the series.
 */
DvtPlotAreaRenderer._getPointsForSeries = function(chart, seriesIndex, availSpace) {
  var xAxis = chart.xAxis;
  var yAxis = chart.yAxis; 
  if(DvtChartDataUtils.isAssignedToY2(chart, seriesIndex))
    yAxis = chart.y2Axis;

  // Create the line and add the stroke info
  var pointsArrays = [];
  var points = [];
  
  // Loop through the groups
  var seriesItem = DvtChartDataUtils.getSeriesItem(chart, seriesIndex);
  for (var groupIndex = 0; groupIndex < seriesItem['items'].length; groupIndex++) {
    var dataValue = DvtChartDataUtils.getValue(chart, seriesIndex, groupIndex);
    var dataItem = seriesItem['items'][groupIndex];
    
    // A null or undefined value begins another line or area and skips this data item
    if(dataValue == null || isNaN(dataValue)) {
      // Push the current list of points and start a new one
      if(points.length > 0 && !DvtChartDataUtils.hasMixedFrequency(chart)) {
        pointsArrays.push(points);
        points = []; 
      }
      // Skip this value since it's invalid
      continue; 
    }
    
    if (dataItem['_filtered'])
      continue;

    // Get the axis values
    var xValue = DvtChartAxisUtils.getXAxisValue(dataItem, groupIndex);
    var yValue = DvtChartDataUtils.getCumulativeValue(chart, seriesIndex, groupIndex);

    // Get the position on the axis
    var xCoord = xAxis.getUnboundedCoordAt(xValue);
    var yCoord = yAxis.getUnboundedCoordAt(yValue);
    
    // Add the points to the line
    if (DvtChartTypeUtils.isPolar(chart)) {
      var cartesian = DvtPlotAreaRenderer._polarToCartesian(yCoord, xCoord, availSpace);
      points.push(cartesian.x, cartesian.y);
    }
    else if (DvtChartTypeUtils.isHorizontal(chart))
      points.push(yCoord, xCoord);
    else
      points.push(xCoord, yCoord);
  }

  // Add any remaining points to the array
  if(points.length > 0)
    pointsArrays.push(points);
    
  return pointsArrays;
}

/**
 * Creates a container for plot area foreground objects with clipping.
 * @param {DvtChartImpl} chart The chart being rendered.
 * @param {DvtContainer} container The container to render to.
 * @param {DvtRectangle} availSpace The available space.
 * @return {DvtContainer} The clipped container for plot area foreground objects.
 * @private
 */
DvtPlotAreaRenderer._createClippedGroup = function(chart, container, availSpace) {
  var clipGroup = new DvtContainer(container.getCtx());
  container.addChild(clipGroup);
  var clip = new DvtClipPath(chart.getId());
  clip.addRect(availSpace.x, availSpace.y, availSpace.w, availSpace.h);
  clipGroup.setClipPath(clip);
  return clipGroup;
}

/**
 * Converts polar coord to cartesian coord.
 * @param {number} r The radius.
 * @param {number} theta The angle.
 * @param {DvtRectangle} availSpace The availSpace, to compute the center.
 * @return {DvtPoint} The cartesian coord.
 */
DvtPlotAreaRenderer._polarToCartesian = function(r, theta, availSpace) {
  x = availSpace.x + availSpace.w/2 + r * Math.sin(theta);
  y = availSpace.y + availSpace.h/2 - r * Math.cos(theta);
  return new DvtPoint(x, y);
}
/**
 * Renderer for funnel chart.
 * @class
 */
var DvtFunnelRenderer = new Object();

DvtObj.createSubclass(DvtFunnelRenderer, DvtObj, "DvtFunnelRenderer");

  DvtFunnelRenderer._DEFAULT_3D_GAP_RATIO = 1/36;
  DvtFunnelRenderer._DEFAULT_2D_GAP_RATIO = 1/60;
  DvtFunnelRenderer._DEFAULT_NO_GAP_RATIO = 1/360;
  DvtFunnelRenderer._MAX_WIDTH_FOR_GAPS = 0.25;
  DvtFunnelRenderer._GROUP_INDEX = 0;
  
/**
 * Renders the funnel into the available space.
 * @param {DvtChartImpl} chart The chart being rendered.
 * @param {DvtContainer} container The container to render to.
 * @param {DvtRectangle} availSpace The available space.
 */
DvtFunnelRenderer.render = function (chart, container, availSpace) {
  // Creating a container for the funnel so that it can be rotated if vertical, also for animation.
  var funnelContainer = new DvtContainer(chart.getCtx());
  funnelContainer.setTranslate(availSpace.x, availSpace.y);
  container.addChild(funnelContainer);
  chart.setFunnelContainer(funnelContainer);
    
  var bbox;
  
  if (chart.getOptions()['orientation'] == "horizontal")
    bbox = new DvtRectangle(0, 0, availSpace.w, availSpace.h);
  else{ //rotate the container and the bounding rect
    var rotationMatrix = new DvtMatrix();
    if (DvtAgent.isRightToLeft(chart.getCtx())){
      rotationMatrix.translate(availSpace.y- availSpace.h/2, availSpace.y - availSpace.w/2);
      rotationMatrix.rotate(-Math.PI / 2);
      rotationMatrix.translate(availSpace.x + availSpace.w/2, availSpace.x + availSpace.h/2);
    }
    else{
      rotationMatrix.translate( - availSpace.h/2,  - availSpace.w/2);
      rotationMatrix.rotate(Math.PI / 2);
      rotationMatrix.translate(availSpace.w/2, availSpace.y +  availSpace.h/2);
    }
    bbox = new DvtRectangle(0, 0, availSpace.h, availSpace.w);
    funnelContainer.setMatrix(rotationMatrix);
  } 
  
  if (! DvtFunnelRenderer._renderFunnelSlices(chart, funnelContainer, bbox))  
    DvtChartRenderer.renderEmptyText(chart, container, availSpace);

  // Initial Selection
  var selected = DvtChartDataUtils.getInitialSelection(chart);
  DvtChartEventUtils.setInitialSelection(chart, selected);
}

/**
 * Renders all funnel slices for the given chart.
 * @param {DvtChartImpl} chart
 * @param {DvtContainer} container The container to render to.
 * @param {DvtRectangle} availSpace
 * @return {boolean} true if funnel slices have been rendered, false otherwise
 * @private
 */
DvtFunnelRenderer._renderFunnelSlices = function (chart, container, availSpace) {
  var options = chart.getOptions();
  var seriesCount = DvtChartDataUtils.getSeriesCount(chart);
  var gapSize = options['styleDefaults']['threeDEffect'] == "on" ? DvtFunnelRenderer._DEFAULT_3D_GAP_RATIO * availSpace.w : DvtFunnelRenderer._DEFAULT_2D_GAP_RATIO * availSpace.w;
  gapSize = options['styleDefaults']['funnelSliceGaps'] == "on" ? Math.min(DvtFunnelRenderer._MAX_WIDTH_FOR_GAPS * availSpace.w / (seriesCount-1), gapSize) : DvtFunnelRenderer._DEFAULT_NO_GAP_RATIO * availSpace.w;
  var totalValue = 0; // the total value represented by the funnel
  var numDrawnSeries = 0; // to keep track of how many series are drawn, so we don't add too many gaps if there are zero values
  var cumulativeValue = 0; // keeping track of the total up to this series

  // Iterate through the data to calculate the total value
  for (var seriesIndex = 0;seriesIndex < seriesCount;seriesIndex++) {
    // Skip the series if it shouldn't be rendered
    if (!DvtChartStyleUtils.isSeriesRendered(chart, seriesIndex))
      continue;

    // Do not render if the value is not positive
    var value = DvtChartDataUtils.getTargetValue(chart, seriesIndex);
    if (value == null)
      value = DvtChartDataUtils.getValue(chart, seriesIndex, DvtFunnelRenderer._GROUP_INDEX);
    if (value <= 0)
      continue;
    totalValue += value;
  }
  
  if (totalValue == 0)
    return false;

  // Iterate through the data
  for (var seriesIndex = seriesCount - 1;seriesIndex >= 0;seriesIndex--) {
    // Skip the series if it shouldn't be rendered
    if (!DvtChartStyleUtils.isSeriesRendered(chart, seriesIndex))
      continue;

    // Do not render if the value is not positive
    var value = DvtChartDataUtils.getValue(chart, seriesIndex, DvtFunnelRenderer._GROUP_INDEX);
    var targetValue = DvtChartDataUtils.getTargetValue(chart, seriesIndex);
    if ((value <= 0 && targetValue == null) || (targetValue != null && targetValue <= 0))
      continue;

    var slice;

    if (targetValue != null) {
      cumulativeValue += targetValue / totalValue;
      slice = new DvtFunnelSlice(chart, seriesIndex, numDrawnSeries, availSpace.w, availSpace.h, 1 - cumulativeValue, targetValue / totalValue, value / targetValue, gapSize);
    }
    else {
      cumulativeValue += value / totalValue;
      slice = new DvtFunnelSlice(chart, seriesIndex, numDrawnSeries, availSpace.w, availSpace.h, 1 - cumulativeValue, value / totalValue, null, gapSize);
    }
    
    numDrawnSeries ++; // keeping track of how many series have been drawn to create the gap.    
    container.addChild(slice);    
    DvtChartObjPeer.associate(slice, chart, seriesIndex, DvtFunnelRenderer._GROUP_INDEX);
  }
  return true;
}
/**
 * Renderer for the reference objects of a DvtChart.
 * @class
 */
var DvtRefObjRenderer = new Object();

DvtObj.createSubclass(DvtRefObjRenderer, DvtObj, "DvtRefObjRenderer");

/**
 * Renders the background reference objects.
 * @param {DvtChartImpl} chart The chart being rendered.
 * @param {DvtContainer} container The container to render to.
 * @param {DvtRectangle} plotAreaBounds The bounds of the plot area.
 */
DvtRefObjRenderer.renderBackgroundObjects = function(chart, container, plotAreaBounds) {
  DvtRefObjRenderer._renderObjects(chart, container, plotAreaBounds, "back");
}

/**
 * Renders the foreground reference objects.
 * @param {DvtChartImpl} chart The chart being rendered.
 * @param {DvtContainer} container The container to render to.
 * @param {DvtRectangle} plotAreaBounds The bounds of the plot area.
 */
DvtRefObjRenderer.renderForegroundObjects = function(chart, container, plotAreaBounds) {
  DvtRefObjRenderer._renderObjects(chart, container, plotAreaBounds, "front");
}

/**
 * Renders the reference objects for the given location.
 * @param {DvtChartImpl} chart The chart being rendered.
 * @param {DvtContainer} container The container to render to.
 * @param {DvtRectangle} plotAreaBounds The bounds of the plot area.
 * @param {string} location The location of the reference objects.
 * @private
 */
DvtRefObjRenderer._renderObjects = function(chart, container, plotAreaBounds, location) {
  DvtRefObjRenderer._renderObjectsForAxis(chart, container, plotAreaBounds, location, chart.xAxis, DvtChartRefObjUtils.getXAxisObjects(chart));
  DvtRefObjRenderer._renderObjectsForAxis(chart, container, plotAreaBounds, location, chart.yAxis, DvtChartRefObjUtils.getYAxisObjects(chart));
  DvtRefObjRenderer._renderObjectsForAxis(chart, container, plotAreaBounds, location, chart.y2Axis, DvtChartRefObjUtils.getY2AxisObjects(chart));
}

/**
 * Renders the reference objects for the given location.
 * @param {DvtChartImpl} chart The chart being rendered.
 * @param {DvtContainer} container The container to render to.
 * @param {DvtRectangle} plotAreaBounds The bounds of the plot area.
 * @param {string} location The location of the reference objects.
 * @param {DvtAxis} axis The axis corresponding to the reference objects.
 * @param {array} objects The array of reference objects.
 * @private
 */
DvtRefObjRenderer._renderObjectsForAxis = function(chart, container, plotAreaBounds, location, axis, objects) {
  if(!objects || !axis)
    return;
    
  // Loop through and render each reference object
  for(var i=0; i<objects.length; i++) {
    var refObj = objects[i];
    
    if(!refObj)
      continue;
      
    if(DvtChartRefObjUtils.getLocation(refObj) != location)
      continue;
    
    var shape;
    var type = DvtChartRefObjUtils.getType(refObj);
    if(type == "area")
      shape = DvtRefObjRenderer._createReferenceArea(refObj, chart, plotAreaBounds, axis);
    else if(type == "line")
      shape = DvtRefObjRenderer._createReferenceLine(refObj, chart, plotAreaBounds, axis);
    
    if (shape == null)
      continue;
    
    // Tooltip Support
    var tooltip = DvtChartTooltipUtils.getRefObjTooltip(chart, refObj);
    chart.getEventManager().associate(shape, new DvtSimpleObjPeer(tooltip));
    
    // Add the shape to the container
    container.addChild(shape);
    
    // WAI-ARIA
    shape.setAriaRole("img");
    shape.setAriaProperty("label", tooltip);
  }
}

/**
 * Creates a reference area.
 * @param {object} refObj The options object for the reference area.
 * @param {DvtChartImpl} chart The chart being rendered.
 * @param {DvtRectangle} plotAreaBounds The bounds of the plot area.
 * @param {DvtAxis} axis The axis corresponding to the reference area.
 * @return {DvtShape} The reference area.
 * @private
 */
DvtRefObjRenderer._createReferenceArea = function(refObj, chart, plotAreaBounds, axis) {
  var position = axis.getPosition();  
  var bHoriz = (position == "top" || position == "bottom");
  var color = DvtChartRefObjUtils.getColor(refObj);
  var shape;
  
  if(refObj['items'] != null && axis == chart.yAxis) {
    var items = refObj['items'];
    var pointsArrays = [];
    var points = [];

    // Loop through the groups- along the low values
    for (var pointIndex = 0; pointIndex < items.length; pointIndex++) {
      var dataItem = items[pointIndex];
      if(dataItem['min'] == null && dataItem['max'] == null) {
        if(points.length > 0) {
          pointsArrays.push(points);
          points = []; 
        }  
        continue; 
      }
      // x is always the xCoord, and min and max along the yAxis
      var lCoord = axis.getUnboundedCoordAt(dataItem['min']);
      var hCoord = axis.getUnboundedCoordAt(dataItem['max']); 
      var xCoord = chart.xAxis.getCoordAt(DvtChartAxisUtils.getXAxisValue(dataItem, pointIndex));
        
      // Add the points to the line
      points.unshift(xCoord, hCoord);
      points.push(xCoord, lCoord);
    }
    pointsArrays.push(points);
    
    shape = new DvtContainer(chart.getCtx());
    var shapeI;
    for (var j = 0; j< pointsArrays.length; j++){
      var points = pointsArrays[j];
      if (points && points.length > 2){
        
        if(bHoriz)
          shapeI = new DvtPolygon(chart.getCtx(), points.reverse());
        else
          shapeI = new DvtPolygon(chart.getCtx(), points);
        
        // Set style attributes
        shapeI.setSolidFill(color);
        shape.addChild(shapeI);
      }
    }
  }
  else {
    // Populate the default value if either min or max is missing or infinite
    if(refObj['min'] == null || refObj['min'] == -Infinity)
      refObj['min'] = axis.getGlobalMin();
    if(refObj['max'] == null || refObj['max'] == Infinity)
      refObj['max'] = axis.getGlobalMax();
      
    // Find the coordinates
    var lowCoord =  DvtRefObjRenderer._getAxisCoord(chart, axis, refObj['min']);
    var highCoord =  DvtRefObjRenderer._getAxisCoord(chart, axis, refObj['max']);
    
    // Use the bounded coords if necessary
    if(lowCoord === null && highCoord === null) {
      // Both points outside, only render if the bounded coords don't match (above max and below min)
      lowCoord = axis.getUnboundedCoordAt(refObj['min']);
      highCoord = axis.getUnboundedCoordAt(refObj['max']);
      if(lowCoord == highCoord)
        return null;
    }
    else if(lowCoord === null)
      lowCoord = axis.getUnboundedCoordAt(refObj['min']);
    else if(highCoord === null)
      highCoord = axis.getUnboundedCoordAt(refObj['max']);
    
    var points;
    if(bHoriz)
      points = [lowCoord, 0, highCoord, 0, highCoord, plotAreaBounds.h, lowCoord, plotAreaBounds.h];
    else
      points = [0, lowCoord, 0, highCoord, plotAreaBounds.w, highCoord, plotAreaBounds.w, lowCoord];
    
    shape = new DvtPolygon(chart.getCtx(), points);
    
    // Set style attributes
    shape.setSolidFill(color);
  }
  
  return shape;
}

/**
 * Creates a reference line.
 * @param {object} refObj The options object for the reference line.
 * @param {DvtChartImpl} chart The chart being rendered.
 * @param {DvtRectangle} plotAreaBounds The bounds of the plot area.
 * @param {DvtAxis} axis The axis corresponding to the reference line.
 * @return {DvtShape} The reference line.
 * @private
 */
DvtRefObjRenderer._createReferenceLine = function(refObj, chart, plotAreaBounds, axis) {
  var position = axis.getPosition();  
  var bHoriz = (position == "top" || position == "bottom");
  var lineWidth = DvtChartRefObjUtils.getLineWidth(refObj);
  var color = DvtChartRefObjUtils.getColor(refObj);
  var shape;
  
  if(refObj['items'] != null && axis == chart.yAxis) {
    var items = refObj['items'];
    var pointsArrays = [];
    var points = [];

    for (var pointIndex = 0; pointIndex < items.length; pointIndex++) {
      var dataItem = items[pointIndex];
      if(dataItem['value'] === null) {
        if(points.length > 0) {
          pointsArrays.push(points);
          points = []; 
        }  
        continue; 
      }
      // x is always along the xAxis, and value for yAxis
      var vCoord = axis.getUnboundedCoordAt(dataItem['value']);
      var xCoord = chart.xAxis.getCoordAt(DvtChartAxisUtils.getXAxisValue(dataItem, pointIndex));
        
      // Add the points to the line
      points.push(xCoord, vCoord);
    }
    pointsArrays.push(points);

    // Set style attributes
    
    var stroke = new DvtSolidStroke(color, 1, lineWidth);
    if(refObj['lineStyle'])
      stroke.setStyle(DvtStroke.convertTypeString(refObj['lineStyle']));
    
    shape = new DvtContainer(chart.getCtx());
    var shapeI;
    for (var j = 0; j< pointsArrays.length; j++){
      var points = pointsArrays[j];
      if (points && points.length > 2){
        
        if(bHoriz)
          shapeI = new DvtPolyline(chart.getCtx(), points.reverse());
        else
          shapeI = new DvtPolyline(chart.getCtx(), points);
        // Set style attributes
        shapeI.setStroke(stroke);
        
        shape.addChild(shapeI);
      }
    }
  }
  else if(!isNaN(refObj['value'])) {
    var lineCoord = DvtRefObjRenderer._getAxisCoord(chart, axis, refObj['value']);
    
    // Don't continue if the line is outside of the axis
    if(lineCoord === null)
      return null;
    
    if(bHoriz)
      shape = new DvtLine(chart.getCtx(), lineCoord, 0, lineCoord, plotAreaBounds.h);
    else
      shape = new DvtLine(chart.getCtx(), 0, lineCoord, plotAreaBounds.w, lineCoord);
    
    // Set style attributes
    var lineWidth = DvtChartRefObjUtils.getLineWidth(refObj);
    var stroke = new DvtSolidStroke(color, 1, lineWidth);
    if(refObj['lineStyle'])
      stroke.setStyle(DvtStroke.convertTypeString(refObj['lineStyle']));
    
    shape.setStroke(stroke);
    shape.setPixelHinting(true);
  }
  else // no line created
    return null;
  
  return shape;
}

/**
 * Returns the coordinate of the specified value on the axis.  If the coordinate cannot be located, then returns null.
 * @param {DvtChartImpl} chart
 * @param {DvtAxis} axis The axis corresponding to the reference object.
 * @param {object} value The value whose coordinate will be returned.
 * @return {number}
 * @private
 */
DvtRefObjRenderer._getAxisCoord = function(chart, axis, value) {
  if(axis.isGroupAxis()) {
    // For group axis, find the index of the group and pass it to the axis
    var index = DvtChartDataUtils.getGroupIndex(chart, value);
    if(index >= 0)
      return axis.getCoordAt(index);
    else
      return null;
  }
  else 
    return axis.getCoordAt(value);
}
/**
 *  Data cursor component.
 *  @extends DvtContainer
 *  @class DvtDataCursor  Creates a data cursor component.
 *  @constructor
 *  @param {DvtContext} context The context object
 *  @param {boolean} bHoriz True if this is a data cursor for horizontal graphs
 */
var DvtDataCursor = function(context, bHoriz) {
  this.Init(context, bHoriz);
}

DvtObj.createSubclass(DvtDataCursor, DvtContainer, "DvtDataCursor");

DvtDataCursor._DEFAULT_COLOR = "#5a5a5a";
DvtDataCursor.BEHAVIOR_SNAP = "SNAP";
DvtDataCursor.BEHAVIOR_SMOOTH = "SMOOTH";
DvtDataCursor.BEHAVIOR_AUTO = "AUTO";

DvtDataCursor._CURSOR_LINE_WIDTH = 2;
DvtDataCursor._DATATIP_BORDER_WIDTH = 2;
DvtDataCursor._DATATIP_TEXT_PADDING = 2;
DvtDataCursor._MARKER_SIZE_OUTER = 16;
DvtDataCursor._MARKER_SIZE_MIDDLE = 12;
DvtDataCursor._MARKER_SIZE_INNER = 8;

DvtDataCursor.TOOLTIP_ID = "_dvtDataCursor";

/**
 * Initializes the data cursor.
 * @param {DvtContext} context The context object
 * @param {boolean} bHoriz True if this is a data cursor for horizontal graphs
 */
DvtDataCursor.prototype.Init = function (context, bHoriz) {
  DvtDataCursor.superclass.Init.call(this, context);
  this._bHoriz = bHoriz;
  
  // Data cursor is never the target of mouse events
  this.setMouseEnabled(false);
  
  // Initially invisible until shown
  this.setVisible(false);
  
  //******************************************* Data Cursor Line ******************************************************/
  if(bHoriz) {
    this._cursorLineRect = new DvtRect(this.getCtx(), 0, 0, 0, DvtDataCursor._CURSOR_LINE_WIDTH, "dcLine");
    this._cursorLineRect.setTranslateY(-DvtDataCursor._CURSOR_LINE_WIDTH/2);
  }
  else { // Vertical
    this._cursorLineRect = new DvtRect(this.getCtx(), 0, 0, DvtDataCursor._CURSOR_LINE_WIDTH, 0, "dcLine");
    this._cursorLineRect.setTranslateX(-DvtDataCursor._CURSOR_LINE_WIDTH/2);
  }
  this._cursorLineRect.setSolidFill(DvtDataCursor._DEFAULT_COLOR);
  this._cursorLineRect.setMouseEnabled(false);
  this.addChild(this._cursorLineRect);

  //****************************************** Data Cursor Marker *****************************************************/
  this._marker = new DvtContainer(this._context, "dotContainer");
  this._marker.setMouseEnabled(false);
  this.addChild(this._marker);
  
  var outerCircle = new DvtMarker(this._context, DvtMarker.CIRCLE, null, 0, 0, DvtDataCursor._MARKER_SIZE_OUTER, DvtDataCursor._MARKER_SIZE_OUTER);
  outerCircle.setTranslate(-DvtDataCursor._MARKER_SIZE_OUTER/2, -DvtDataCursor._MARKER_SIZE_OUTER/2);
  outerCircle.setSolidFill(DvtDataCursor._DEFAULT_COLOR);
  outerCircle.setMouseEnabled(false);
  this._marker.addChild(outerCircle);
  
  var middleCircle = new DvtMarker(this._context, DvtMarker.CIRCLE, null, 0, 0, DvtDataCursor._MARKER_SIZE_MIDDLE, DvtDataCursor._MARKER_SIZE_MIDDLE);
  middleCircle.setTranslate(-DvtDataCursor._MARKER_SIZE_MIDDLE/2, -DvtDataCursor._MARKER_SIZE_MIDDLE/2);
  middleCircle.setSolidFill("white");
  middleCircle.setMouseEnabled(false);
  this._marker.addChild(middleCircle);
      
  // Inner circle will be filled to correspond to the data item color    
  this._markerInnerCircle = new DvtMarker(this._context, DvtMarker.CIRCLE, null, 0, 0, DvtDataCursor._MARKER_SIZE_INNER, DvtDataCursor._MARKER_SIZE_INNER);
  this._markerInnerCircle.setTranslate(-DvtDataCursor._MARKER_SIZE_INNER/2, -DvtDataCursor._MARKER_SIZE_INNER/2);
  this._markerInnerCircle.setMouseEnabled(false);
  this._marker.addChild(this._markerInnerCircle);
}

/**
 * Renders this data cursor.
 * @param {DvtRectangle} plotAreaBounds The bounds of the plot area.
 * @param {number} dataX The x coordinate of the actual data point, where the marker should be placed. 
 * @param {number} dataY The y coordinate of the actual data point, where the marker should be placed. 
 * @param {number} lineCoord The x coordinate of a vertical data cursor, or the y coordinate of a horizontal data cursor.
 * @param {string} text The text for the datatip.
 * @param {string} dataColor The primary color of the associated data item.
 */
DvtDataCursor.prototype.render = function(plotAreaBounds, dataX, dataY, lineCoord, text, dataColor) {
  var bHoriz = this.isHorizontal();
  var bRtl = DvtAgent.isRightToLeft(this.getCtx());
    
  // First render the datatip to retrieve its size.
  var stagePageCoords = this.getCtx().getStageAbsolutePosition();
  var tooltipManager = this.getCtx().getTooltipManager(DvtDataCursor.TOOLTIP_ID);
  tooltipManager.showDatatip(dataX + stagePageCoords.x, dataY + stagePageCoords.y, text, dataColor, false); 
  var tooltipBounds = tooltipManager.getTooltipBounds(); // tooltipBounds is in the page coordinate space
  
  // Then reposition to the right location
  var tooltipX, tooltipY; // tooltipX and tooltipY in the stage coordinate space
  if(bHoriz) {
    tooltipX = bRtl ? plotAreaBounds.x - 0.75*tooltipBounds.w : plotAreaBounds.x + plotAreaBounds.w - tooltipBounds.w/4;
    tooltipY = lineCoord - tooltipBounds.h/2;
    
    // Add a buffer between the tooltip and data point. This may be rejected in positionTip due to viewport location.
    if(!bRtl && tooltipX - dataX < DvtDataCursor._MARKER_SIZE_OUTER)
      tooltipX = dataX + DvtDataCursor._MARKER_SIZE_OUTER;
    else if(bRtl && dataX - (tooltipX + tooltipBounds.w) < DvtDataCursor._MARKER_SIZE_OUTER)
      tooltipX = dataX - DvtDataCursor._MARKER_SIZE_OUTER - tooltipBounds.w;
  }
  else {
    tooltipX = lineCoord - tooltipBounds.w/2;
    tooltipY = plotAreaBounds.y - 0.75*tooltipBounds.h;
    
    // Add a buffer between the tooltip and data point. This may be rejected in positionTip due to viewport location.
    if(dataY - (tooltipY + tooltipBounds.h) < DvtDataCursor._MARKER_SIZE_OUTER)
      tooltipY = dataY - DvtDataCursor._MARKER_SIZE_OUTER - tooltipBounds.h;
  }
  tooltipManager.positionTip(tooltipX + stagePageCoords.x, tooltipY + stagePageCoords.y);
  
  // Finally retrieve the rendered bounds to calculate the attachment point for the cursor line.
  tooltipBounds = tooltipManager.getTooltipBounds(); // tooltipBounds is in the page coordinate space
  tooltipX = tooltipBounds.x - stagePageCoords.x;
  tooltipY = tooltipBounds.y - stagePageCoords.y;
  
  // Set the datatip and marker color
  this._markerInnerCircle.setSolidFill(dataColor);
  
  // Position the data cursor and its subcomponents
  if(bHoriz) {
    // Translate the entire data cursor to the lineCoord
    this.setTranslate(plotAreaBounds.x, lineCoord);
    
    // Position the marker
    this._marker.setTranslate(dataX - plotAreaBounds.x, dataY - lineCoord);
    
    // Position the cursor line
    this._cursorLineRect.setWidth(Math.max(tooltipX + DvtDataCursor._DATATIP_BORDER_WIDTH/2 - plotAreaBounds.x, 0));
    if(bRtl) {
      var startX = tooltipX + tooltipBounds.w + DvtDataCursor._DATATIP_BORDER_WIDTH/2 - plotAreaBounds.x;
      this._cursorLineRect.setX(startX);
      this._cursorLineRect.setWidth(Math.max(plotAreaBounds.w - startX, 0));
    }
  }
  else { // Vertical
    this.setTranslate(lineCoord, plotAreaBounds.y + DvtDataCursor._DATATIP_BORDER_WIDTH/2); // half the border lies outside the rect
    
    // Position the marker
    this._marker.setTranslate(dataX - lineCoord, dataY - plotAreaBounds.y);
    
    // Position the cursor line
    this._cursorLineRect.setTranslateY(tooltipY + tooltipBounds.h - (plotAreaBounds.y + DvtDataCursor._DATATIP_BORDER_WIDTH/2));
    this._cursorLineRect.setHeight(Math.max(plotAreaBounds.y + plotAreaBounds.h - tooltipY - tooltipBounds.h, 0));  
  }
  
  // Bug 17944859: Workaround firefox issue
  DvtAgent.workaroundFirefoxRepaint(this._marker)
}

/**
 * Returns true if this is a data cursor for a horizontal graph.
 * @return {boolean}
 */ 
DvtDataCursor.prototype.isHorizontal = function() {
  return this._bHoriz;
}

/**
 * Specifies the color of the data cursor line.
 */
DvtDataCursor.prototype.setLineColor = function (lineColor) {
  this._cursorLineRect.setSolidFill(lineColor);
}

/**
 * Specifies the fill for the datatip.
 * @param {DvtFill} fill
 */
DvtDataCursor.prototype.setTooltipFill = function (tooltipFill) {
  // TODO remove this function and clean up all usages (in the graph)
}

/**
 * Returns the behavior of the data cursor.
 * @return {string}
 */
DvtDataCursor.prototype.getBehavior = function () {
  return this._behavior ? this._behavior : DvtDataCursor.BEHAVIOR_AUTO;
}

/**
 * Specifies the behavior of the data cursor.
 * @param {string} behavior
 */
DvtDataCursor.prototype.setBehavior = function (behavior) {
  this._behavior = behavior;
}
// Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.
/*---------------------------------------------------------------------*/
/*  DvtDCEH                 Data Cursor Event Handler                  */
/*---------------------------------------------------------------------*/
/**
 *  @class  DvtDCEH
 *  @extends DvtObj
 *  @constructor
 */
var DvtDCEH = function (context, dataCursor) {};

DvtObj.createSubclass(DvtDCEH, DvtObj, "DvtDCEH");

// TODO CLEANUP: Major cleanup needed

DvtDCEH.prototype._Init = function (context, dataCursor) {
  this._context = context;
  this._dataCursorShown = false;
  this._horizontal = false;
  this._useAllInGroup = false;
  this._isNumericMainAxis = false;
  this._dataCursor = dataCursor;
  this._threeDHorizontalOffset = 0;
};

// Show/hide the data cursor based on the global page coordinates of the action
// Returns whether or not data cursor is shown
DvtDCEH.prototype.processMove = function (pageX, pageY, targetObj, logicalObj) {
  if (!targetObj) {
    this._removeDataCursor();
    return;
  }

  var pos = this._context.pageToStageCoords(pageX, pageY);
  var x = pos.x;
  var y = pos.y;

  var blockEventsRect = this.getActionablePlotRect(x, y, logicalObj);
  if (blockEventsRect) {
    // Show the data cursor only if the current point is within the plot area
    this._showDataCursor(blockEventsRect, x, y, targetObj);
    return true;
  }
  else {
    this._removeDataCursor();
  }
  return false;

}

DvtDCEH.prototype.processEnd = function () {
  this._removeDataCursor();
}

DvtDCEH.prototype.processOut = function (pos) {
  var plotRect = this.getPlotRect();
  if (!plotRect.containsPoint(pos.x, pos.y)) {
    this._removeDataCursor();
  }
}

/**
 * Displays the data cursor.
 * @param {DvtRectangle} plotRect The bounds of the plot area
 * @param {number} x
 * @param {number} y
 * @param {object} targetObj
 * @private
 */
DvtDCEH.prototype._showDataCursor = function (plotRect, x, y, targetObj) {
  var dataCursor = this._dataCursor;

  // Find the closest data point
  var closestMatch = this.getClosestMatch(x, y, targetObj, plotRect);
  if (closestMatch == null) {
    this._removeDataCursor();
    return;
  }
  
  // Find the center of the data item
  var centerPoint = DvtGeomUtils.getCenterPoint(closestMatch.matchRegion);

  var dcX = x;
  var dcY = y;
  // Adjust for snap behavior
  if (dataCursor.getBehavior() == DvtDataCursor.BEHAVIOR_SNAP) {
    if (dataCursor.isHorizontal())
      dcY = Math.min(Math.max(centerPoint.y, plotRect.y), plotRect.y + plotRect.h);
    else
      dcX = Math.min(Math.max(centerPoint.x, plotRect.x), plotRect.x + plotRect.w);
  }

  // Regardless of behavior, the data cursor itself should always be within the front plane of the plot area (in 3d graphs)
  if (this._threeDHorizontalOffset) {
    var xExtent = plotRect.x + plotRect.w - this._threeDHorizontalOffset;
    if (dcX > xExtent)
      dcX = xExtent;
  }

  // Don't show the data cursor if no tooltip text is present
  var tooltipText = this.getTooltipText(closestMatch);
  if (!tooltipText || tooltipText == "") {
    dataCursor.setVisible(false);
    return;
  }
  else 
    dataCursor.setVisible(true);

  var seriesColor = this.getSeriesColor(closestMatch.sidx, closestMatch.gidx);
  var lineCoord = dataCursor.isHorizontal() ? dcY : dcX;
  dataCursor.render(plotRect, centerPoint.x, centerPoint.y, lineCoord, tooltipText, seriesColor);
  
  this._dataCursorShown = true;
}

// Remove the data cursor
DvtDCEH.prototype._removeDataCursor = function () {
  if (this._dataCursor.getVisible())
    this._dataCursor.setVisible(false);
  
  this._context.getTooltipManager(DvtDataCursor.TOOLTIP_ID).hideTooltip();
  
  this._dataCursorShown = false;
}

DvtDCEH.prototype.isDataCursorShown = function () {
  return this._dataCursorShown;
}

DvtDCEH.AddPotentialMatch = function (matches, matchObj, plotRect, isHorizontal) {
  var region = matchObj.matchRegion;
  if (isHorizontal) {
    if (region.y + region.h < plotRect.y || region.y > plotRect.y + plotRect.h) {
      return false;
    }
  }
  else {
    if (region.x + region.w < plotRect.x || region.x > plotRect.x + plotRect.w) {
      return false;
    }
  }
  matches.push(matchObj);
  return true;
}

DvtDCEH.GetClosestMatchSecondDirection = function (matchesInBounds, horizontal, x, y) {
  var closestMatch = null;
  var minDiff = 100000000;
  for (var i = 0;i < matchesInBounds.length;i++) {
    var match = matchesInBounds[i];
    var lowerBound = (horizontal) ? match.matchRegion.x : match.matchRegion.y;
    var higherBound = (horizontal) ? match.matchRegion.x + match.matchRegion.w : match.matchRegion.y + match.matchRegion.h;
    var value = (horizontal) ? x : y;
    var midPoint = (lowerBound + higherBound) / 2;
    var diffValue = Math.abs(midPoint - value);
    if (diffValue < minDiff) {
      minDiff = diffValue;
      closestMatch = match;
    }
  }
  return closestMatch;
}

DvtDCEH.GetClosestMatchesFirstDirection = function (matches, horizontal, x, y) {
  var minDiff = 10000000;
  var closestFirstDirectionMatches = new Array();
  // Get closest matches
  for (var i = 0;i < matches.length;i++) {
    var matchObj = matches[i];
    var lowerBound = (horizontal) ? matchObj.matchRegion.y : matchObj.matchRegion.x;
    var higherBound = (horizontal) ? matchObj.matchRegion.y + matchObj.matchRegion.h : matchObj.matchRegion.x + matchObj.matchRegion.w;
    var value = (horizontal) ? y : x;

    var midPoint = (lowerBound + higherBound) / 2;
    var diffValue = Math.abs(midPoint - value);
    if (diffValue <= minDiff) {
      if (diffValue < minDiff) {
        closestFirstDirectionMatches = new Array();
      }
      closestFirstDirectionMatches.push(matchObj);
      minDiff = diffValue;
    }
  }
  return closestFirstDirectionMatches;
}

DvtDCEH.prototype.getActionablePlotRect = function (x, y, logicalObj) {
  return null;
}

DvtDCEH.prototype.getPlotRect = function () {
  return null;
}

DvtDCEH.prototype.getSeriesColor = function (series) {
  return "black";
}

DvtDCEH.prototype.getTooltipText = function (closestMatch) {
  return "Base class should override";
}

DvtDCEH.prototype.findMatches = function (x, y, targetObj, matches, plotRect, targetSeriesIndex) {
  return null;
}

DvtDCEH.prototype.getClosestMatch = function (x, y, targetObj, plotRect) {
  var horizontal = this._horizontal;
  var useAllInGroup = this._useAllInGroup;
  var isNumericMainAxis = this._isNumericMainAxis;

  var matches = new Array();
  var immediateMatch = this.findMatches(x, y, targetObj, matches, plotRect)
  if (immediateMatch)
    return immediateMatch;

  var closestFirstDirectionMatches = DvtDCEH.GetClosestMatchesFirstDirection(matches, horizontal, x, y);

  var matchesInBounds = closestFirstDirectionMatches;

  // Non-numerical x axis
  if (!isNumericMainAxis) {
    var closestLowerBound = 1000000;
    var closestHigherBound =  - 1000000;
    var closestGroup = null;

    for (var i = 0;i < closestFirstDirectionMatches.length;i++) {
      var closestFirstDirectionMatch = closestFirstDirectionMatches[i];
      closestLowerBound = Math.min(closestLowerBound, (horizontal) ? closestFirstDirectionMatch.matchRegion.y : closestFirstDirectionMatch.matchRegion.x);
      closestHigherBound = Math.max(closestHigherBound, (horizontal) ? closestFirstDirectionMatch.matchRegion.y + closestFirstDirectionMatch.matchRegion.h : closestFirstDirectionMatch.matchRegion.x + closestFirstDirectionMatch.matchRegion.w);
      closestGroup = closestFirstDirectionMatch.gidx;
    }

    for (var i = 0;i < matches.length;i++) {
      var match = matches[i];
      var itemGroup = match.gidx;
      if (useAllInGroup) {
        if (closestGroup == itemGroup) {
          matchesInBounds.push(match);
        }
      }
      else {
        var lowerBound = (horizontal) ? match.matchRegion.y : match.matchRegion.x;
        var higherBound = (horizontal) ? match.matchRegion.y + match.matchRegion.h : match.matchRegion.x + match.matchRegion.w;
        var midPoint = (lowerBound + higherBound) / 2;
        if (closestHigherBound >= midPoint && closestLowerBound <= midPoint) {
          matchesInBounds.push(match);
        }

      }
    }
  }
  return DvtDCEH.GetClosestMatchSecondDirection(matchesInBounds, horizontal, x, y);
}
/**
 * @constructor
 */
var  DvtChartDCEH = function(chart)
{
  this._Init(chart)
};

DvtObj.createSubclass(DvtChartDCEH, DvtDCEH, "DvtChartDCEH") ;

// TODO CLEANUP: Major cleanup needed

DvtChartDCEH.prototype._Init = function(chart)
{
   DvtChartDCEH.superclass._Init.call(this, chart.getCtx(), chart.DataCursor) ;
   this._Chart  = chart ;
   this._horizontal = DvtChartTypeUtils.isHorizontal(chart);
   this._useAllInGroup = DvtChartTypeUtils.isArea(chart) || DvtChartTypeUtils.isLine(chart);
   this._isNumericMainAxis = DvtChartTypeUtils.isScatterBubble(chart);
   this._isStockChart = false;
   
   this._isArea = DvtChartTypeUtils.isArea(chart);
};

DvtChartDCEH.prototype.getPlotRect = function() {
   var plot = this._Chart._plotRect;
   var dim = plot.getDimensionsSelf();
   var stagePoint = plot.localToStage(new DvtPoint(dim.x, dim.y));
   dim.x = stagePoint.x;
   dim.y = stagePoint.y;
   return dim;
}

DvtChartDCEH.prototype.getActionablePlotRect = function(x, y, logicalObj) {
   var plotRect = this.getPlotRect();
   if (plotRect.containsPoint(x, y)) {
       return plotRect;
   }
   return null;
}

// TODO JSDOC: This class needs to be rewritten to not access private properties and get rid of these implicit object returns.
DvtChartDCEH.prototype.findMatches = function(x, y, targetObj, matches, plotRect) {
  var chart = this._Chart;
  var context = chart.getCtx();
  var stage = context.getStage();
  var eventManager = chart.getEventManager();
    
  var immediateMatch = null;
  if (!chart._currentMarkers)
    return null;

  for (var i=0; i<chart._currentMarkers.length;i++) {
    var markers = chart._currentMarkers[i];
    var numMarkers = markers.length;

    for (var idx = 0;idx < numMarkers; idx++)  {
      var item = markers[idx];
      var logicalObject = eventManager.GetLogicalObject(item);
      
      // Find the bounding box of the item.  We use getDimensionsSelf, an optimized version of getDimensions, where 
      // possible.  It's safe to use either API since chart data objects do not have children.
      var dims = item.getDimensionsSelf ? item.getDimensionsSelf(stage) : item.getDimensions(stage);
    
      var match = { obj: item, matchRegion: dims, gidx: logicalObject.getGroupIndex(), sidx: logicalObject.getSeriesIndex(), marker: null };
      matches.push(match);
    }
  }
  return immediateMatch;
}

/**
 * @override
 */
DvtChartDCEH.prototype.getSeriesColor = function(seriesIndex, groupIndex) {
  return DvtChartTooltipUtils.getDatatipColor(this._Chart, seriesIndex, groupIndex);
}

/**
 * @override
 */
DvtChartDCEH.prototype.getTooltipText = function(closestMatch) {
  return DvtChartTooltipUtils.getDatatip(closestMatch.obj, this._Chart, closestMatch.sidx, closestMatch.gidx);
}
// Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.

/**
 * Spark chart component.  This chart should never be instantiated directly.  Use the
 * newInstance function instead.
 * @class
 * @constructor
 * @extends {DvtBaseComponent} 
 * @export
 */
var DvtSparkChart = function() {}

DvtObj.createSubclass(DvtSparkChart, DvtBaseComponent, "DvtSparkChart");

/**
 * Returns a new instance of DvtSparkChart.
 * @param {DvtContext} context The rendering context.
 * @param {string} callback The function that should be called to dispatch component events.
 * @param {object} callbackObj The optional object instance on which the callback function is defined.
 * @return {DvtSparkChart}
 * @export
 */
DvtSparkChart.newInstance = function(context, callback, callbackObj) {
  var sparkChart = new DvtSparkChart();
  sparkChart.Init(context, callback, callbackObj);
  return sparkChart;
}

/**
 * Returns a copy of the default options for the specified skin.
 * @param {string} skin The skin whose defaults are being returned.
 * @return {object} The object containing defaults for this component.
 * @export
 */
DvtSparkChart.getDefaults = function(skin) 
{  
  return (new DvtSparkChartDefaults()).getDefaults(skin);
}

/**
 * @override
 */
DvtSparkChart.prototype.Init = function(context, callback, callbackObj) {
  DvtSparkChart.superclass.Init.call(this, context, callback, callbackObj);
  
  // Create the defaults object
  this.Defaults = new DvtSparkChartDefaults();
  
  // Create the event handler and add event listeners
  this._eventHandler = new DvtEventManager(context);
  this._eventHandler.addListeners(this);
  
  // Create the underlying chart instance for the component
  this._chart = DvtChart.newInstance(context);
  this.addChild(this._chart);
  
  // Create the masking shape used for the tooltip
  this._tooltipMask = new DvtRect(context);
  this.addChild(this._tooltipMask);
  
  // Make sure the object has an id for clipRect naming
  this.setId("sparkChart" + 1000 + Math.floor(Math.random()*1000000000));
}

/**
 * @override
 */
DvtSparkChart.prototype.SetOptions = function(options) {
  if(options) {
    // Combine the user options with the defaults and store
    this.Options = this.Defaults.calcOptions(options);
    
    // Disable animation for canvas and xml
    if (!DvtAgent.isEnvironmentBrowser()) {
      this.Options['animationOnDisplay']    = 'none';
      this.Options['animationOnDataChange'] = 'none';
    }
  }
  else if(!this.Options)
    this.Options = this.GetDefaults();
}

/**
 * @override
 */
DvtSparkChart.prototype.setId = function(id){
  DvtSparkChart.superclass.setId.call(this, id);
  if(this._chart)
    this._chart.setId(id+'chart');
}

/**
 * @override
 * @export
 */
DvtSparkChart.prototype.render = function(options, width, height) 
{  
  // Update if a new options object has been provided or initialize with defaults if needed.
  this.SetOptions(options);
  
  // Update the store width and height if provided
  if(!isNaN(width) && !isNaN(height)) {
    this.Width = width;
    this.Height = height;
  }

  // Render the spark chart
  DvtSparkChartRenderer.render(this, this.Width, this.Height);
  
  // Apply the tooltip
  var tooltip = this.Options['shortDesc'];
  this._tooltipMask.setWidth(this.Width);
  this._tooltipMask.setHeight(this.Height);
  this._tooltipMask.setInvisibleFill();
  if(tooltip)
    this._eventHandler.associate(this._tooltipMask, new DvtSimpleObjPeer(null, tooltip, this.Options['color']));
  
  // WAI-ARIA
  this.setAriaRole('img');
  this.setAriaProperty('label', tooltip);
}

/**
 * Returns the underlying chart instance for the component.
 * @return {DvtChart} The underlying chart instance for this component.
 */
DvtSparkChart.prototype.__getChart = function() {
  return this._chart;
}

/**
 * Returns the evaluated options object, which contains the user specifications
 * merged with the defaults.
 * @return {object} The options object.
 */
DvtSparkChart.prototype.__getOptions = function() {
  return this.Options;
}
/**
 * Default values and utility functions for chart versioning.
 * @class
 * @constructor
 * @extends {DvtBaseComponentDefaults}
 */
var DvtSparkChartDefaults = function() {
  this.Init({'skyros': DvtSparkChartDefaults.VERSION_1, 'alta': DvtSparkChartDefaults.SKIN_ALTA});
}

DvtObj.createSubclass(DvtSparkChartDefaults, DvtBaseComponentDefaults, "DvtSparkChartDefaults");

/**
 * Contains overrides for the 'alta' skin.
 */ 
DvtSparkChartDefaults.SKIN_ALTA = {
  'skin': DvtCSSStyle.SKIN_ALTA,
  'color': "#267db3"
}

/**
 * Defaults for version 1.
 */ 
DvtSparkChartDefaults.VERSION_1 = {
  'skin': DvtCSSStyle.SKIN_SKYROS,
  'type': "line",
  'animationOnDisplay': "none",
  'animationOnDataChange': "none",
  'emptyText': null, 
  'color': "#666699",
  'firstColor': null, 
  'lastColor': null, 
  'highColor': null, 
  'lowColor': null,  
  'visualEffects': "auto",
  'baselineScaling': "min",
  'barSpacing': "auto",
  'lineWidth': 1,
  'lineStyle': "solid",
  'markerSize': 5,
  'markerShape': "auto",
  'barGapRatio': 0.25
}
/**
 * Renderer for DvtSparkChart.
 * @class
 */
var DvtSparkChartRenderer = new Object();

DvtObj.createSubclass(DvtSparkChartRenderer, DvtObj, "DvtSparkChartRenderer");

/**
 * @this {DvtSparkChartRenderer}
 * Renders the spark chart in the specified area.
 * @param {DvtSparkChart} spark The spark chart being rendered.
 * @param {number} width The width of the component.
 * @param {number} height The height of the component.
 */
DvtSparkChartRenderer.render = function (spark, width, height) {
  // Convert spark options into chart options
  var chart = spark.__getChart();
  var chartOptions = DvtSparkChartRenderer._convertOptionsObj(spark);
  
  // Allocate a gap for markers if they are enabled.
  var options = spark.__getOptions();
  if(options['type'] == "area" || options['type'] == "line") 
  {
    var items = DvtSparkChartRenderer._getDataItems(spark);
    var hasMarkers = false;
    
    // Look for the first/last/high/lowColor attributes, which cause markers to display
    if(options['firstColor'] || options['lastColor'] || options['highColor'] || options['lowColor'])
      hasMarkers = true;
    else {
      // Loop through the data to look for markerDisplayed
      for(var i=0; i<items.length; i++) {
        if(items[i] && items[i]['markerDisplayed'] == "on") {
          hasMarkers = true;
          break;
        }
      }
    }
    
    // Allocate the gap if markers were found
    if(hasMarkers && items.length > 0) {
      var markerGap = options['markerSize']/2;
      width -= 2*markerGap;
      height -= 2*markerGap;
      chart.setTranslate(markerGap, markerGap);
    }
  }

  // Render the chart
  chart.render(chartOptions, width, height);
}

/**
 * Returns the array of spark data items.
 * @param {DvtSparkChart} spark
 * @return {array}
 */
DvtSparkChartRenderer._getDataItems = function(spark) {
  var options = spark.__getOptions();
  return (options && options['items']) ? options['items'] : [];
}

/**
 * Converts the spark chart options object into a chart options object.
 * @param {DvtSparkChart} The spark chart.
 * @return {object} The resulting chart options object.
 * @private
 */
DvtSparkChartRenderer._convertOptionsObj = function(spark) {
  var options = spark.__getOptions();
  var chartOptions = {'styleDefaults': {}, 'xAxis': {}, 'yAxis': {}, '__layout': {}};

  //**************************** Data Attributes *****************************/
  var bFloatingBar = (options['type'] == "floatingBar");
  var chartItems = [];
  var floatItems = [];
  
  // Loop through the data
  var highIndex = -1;
  var lowIndex = -1;
  var highValue = -Infinity;
  var lowValue = Infinity;
  var items = DvtSparkChartRenderer._getDataItems(spark);
  for(var i=0; i<items.length; i++) {
    var item = items[i];
    
    // Parse the spark data item properties
    var chartItem = {};
    if(item instanceof Object) {
      chartItem['y'] = item['value'];
      
      if(item['date']) {
        chartItem['x'] = item['date'];
        chartOptions['timeAxisType'] = "enabled";
      }
      
      if(item['markerDisplayed'] == "on")
        chartItem['markerDisplayed'] = "on";
      
      if(item['color']) 
        chartItem['color'] = item['color'];
      
      if(item['borderColor']) 
        chartItem['borderColor'] = item['borderColor'];
      
      if(item['markerShape']) 
        chartItem['markerShape'] = item['markerShape'];
      
      if(item['markerSize']) 
        chartItem['markerSize'] = item['markerSize'];
      
      // Floating Bar Support
      if(bFloatingBar) {
        var floatValue = item['floatValue'];
        if(isNaN(floatValue))
          floatValue = 0;
        
        floatItems.push(floatValue);
      }
    }
    else {
      // Item is just the value, wrap and push onto the array.
      chartItem['y'] = item;
      
      // If floating bar, pass float value of 0
      if(bFloatingBar)
        floatItems.push(0);
    }
      
    // Push onto the array  
    chartItems.push(chartItem);
    
    // Keep track of low and high values
    if(highValue < chartItem['y']) {
      highValue = chartItem['y'];
      highIndex = i; 
    }
    
    if(lowValue > chartItem['y']) {
      lowValue = chartItem['y'];
      lowIndex = i; 
    }
  }
  
  // First/Last/High/LowColor Support: Process high and low first since they take precedence
  if(options['highColor'] && highIndex >= 0) {
    chartItems[highIndex]['markerDisplayed'] = "on";
    if(!chartItems[highIndex]['color'])
      chartItems[highIndex]['color'] = options['highColor'];
  }
  
  if(options['lowColor'] && lowIndex >= 0) {
    chartItems[lowIndex]['markerDisplayed'] = "on";
    if(!chartItems[lowIndex]['color'])
      chartItems[lowIndex]['color'] = options['lowColor'];
  }
  
  if(options['firstColor'] && chartItems.length > 0) {
    chartItems[0]['markerDisplayed'] = "on";
    if(!chartItems[0]['color'])
      chartItems[0]['color'] = options['firstColor'];
  }
    
  if(options['lastColor'] && chartItems.length > 0) {
    chartItems[chartItems.length-1]['markerDisplayed'] = "on";
    if(!chartItems[chartItems.length-1]['color'])
      chartItems[chartItems.length-1]['color'] = options['lastColor'];
  }
  
  // Add the data items into a data object
  chartOptions['series'] = [{'items': chartItems}];
  if(bFloatingBar) {
    var floatSeries = {'items': floatItems, 'color': "rgba(0, 0, 0, 0)"};
    chartOptions['series'].splice(0, 0, floatSeries);
  }
  
  // Reference Objects
  if(options['referenceObjects'])
    chartOptions['yAxis']['referenceObjects'] = options['referenceObjects'];

  //**************************** Style Attributes ****************************/
  chartOptions['__spark'] = true;
  
  // barSpacing default is based on device
  var barSpacing = options['barSpacing'];
  if(barSpacing == "auto") 
    barSpacing = DvtAgent.getDevicePixelRatio() > 1 ? "subpixel" : "pixel";
  chartOptions['__sparkBarSpacing'] = barSpacing;
  
  chartOptions['type'] = options['type'];
  chartOptions['animationOnDataChange'] = options['animationOnDataChange'];
  chartOptions['animationOnDisplay'] = options['animationOnDisplay'];
  chartOptions['emptyText'] = options['emptyText'];
  
  chartOptions['styleDefaults']['colors'] = [options['color']];
  chartOptions['styleDefaults']['animationDuration'] = options['animationDuration'];
  chartOptions['styleDefaults']['animationIndicators'] = "none";
  chartOptions['styleDefaults']['lineWidth'] = options['lineWidth'];
  chartOptions['styleDefaults']['lineStyle'] = options['lineStyle'];
  chartOptions['styleDefaults']['markerSize'] = options['markerSize'];
  chartOptions['styleDefaults']['markerShape'] = options['markerShape'];
  chartOptions['styleDefaults']['barGapRatio'] = options['barGapRatio'];
  chartOptions['styleDefaults']['seriesTooltipType'] = "none";
  chartOptions['styleDefaults']['groupTooltipType'] = "none";
  chartOptions['styleDefaults']['valueTooltipType'] = "none";
  
  chartOptions['xAxis']['rendered'] = "off";
  
  chartOptions['yAxis']['baselineScaling'] = options['baselineScaling'];  
  chartOptions['yAxis']['rendered'] = "off";
  
  // Floating bar support
  if(bFloatingBar) {
    chartOptions['type'] = "bar";
    chartOptions['stack'] = "on";
  }
  
  // Visual Effects Support: Only for areas
  if(options['visualEffects'] == "none" || options['type'] != "area")
    chartOptions['styleDefaults']['seriesEffect'] = "color";
  else
    chartOptions['styleDefaults']['seriesEffect'] = "gradient";
  
  // Remove Gaps
  chartOptions['layout'] = {'gapRatio': 0}; 
  
  // Disable Legend
  chartOptions['legend'] = {'rendered': "off"}; 
  
  // Empty Text Style
  chartOptions['title'] = chartOptions['title'] ? chartOptions['title'] : {};
  chartOptions['title']['style'] = "font-size: 12px; color: #404259;";
  
  return chartOptions;
}
// Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.

/**
 * Abstract Base Class for Gauge component.
 * @class
 * @constructor
 * @extends {DvtBaseComponent} 
 * @export
 */
var DvtGauge = function() {}

DvtObj.createSubclass(DvtGauge, DvtBaseComponent, "DvtGauge");

/** @private **/
DvtGauge._DEFAULT_MIN_VALUE = 0;

/** @private **/
DvtGauge._DEFAULT_MAX_VALUE = 100;

/**
 * @override
 */
DvtGauge.prototype.Init = function(context, callback, callbackObj) {
  DvtGauge.superclass.Init.call(this, context, callback, callbackObj);
  
  // Create the resource bundle
  this.Bundle = new DvtGaugeBundle();
  
  // Create the event handler and add event listeners 
  this._eventHandler = this.CreateEventHandler();
  this._eventHandler.addListeners(this);

  // Make sure the object has an id for clipRect naming
  this.setId("gauge" + 1000 + Math.floor(Math.random()*1000000000));
  
  // Create an editing overlay to prevent touch conflicts
  this._editingOverlay = new DvtRect(context, 0, 0);
  this._editingOverlay.setInvisibleFill();
  this.addChild(this._editingOverlay);
  
  /** @private **/
  this._bEditing = false;
  
  /** @private **/
  this._oldValue = null;
}

/**
 * @override
 */
DvtGauge.prototype.SetOptions = function(options) {
  this.Options = options;
  
  // Disable animation for canvas and xml
  if (!DvtAgent.isEnvironmentBrowser()) {
    this.Options['animationOnDisplay']    = 'none';
    this.Options['animationOnDataChange'] = 'none';
  }
}

/**
 * @override
 * @export
 */
DvtGauge.prototype.render = function(options, width, height) 
{  
  // Update if a new options object has been provided or initialize with defaults if needed.
  if(options)
    this.SetOptions(options);
  else if(!this.Options)
    this.SetOptions(null);
  
  // Sort the thresholds by value if defined
  if(this.Options['thresholds']) {
    var thresholds = this.Options['thresholds'];
    this.Options['thresholds'] = thresholds.sort(DvtGauge._thresholdComparator);
  }
  
  // Update the store width and height if provided
  if(!isNaN(width) && !isNaN(height)) {
    this.Width = width;
    this.Height = height;
  }

  var oldShapes = this.__shapes;
  this.__shapes = [];
  
  // Render the gauge.  Add the container at index 0 to avoid interfering with the editable overlay.
  var container = new DvtContainer(this.getCtx());
  this.addChildAt(container, 0);
  this.Render(container, this.Width, this.Height);
  
  this._setAnimation(container, (options != null), oldShapes, this.Width, this.Height);
  
  // Set the size of the editing overlay if editable and touch device
  if(this.Options['readOnly'] === false && DvtAgent.isTouchDevice()) {
    this._editingOverlay.setWidth(this.Width);
    this._editingOverlay.setHeight(this.Height);
  }
  else {
    this._editingOverlay.setWidth(0);
    this._editingOverlay.setHeight(0);
  }
  
  // WAI-ARIA
  container.setAriaRole('img');
  var tooltip = this.Options['shortDesc'];
  container.setAriaProperty('label', tooltip);
}

/**
 * Renders the component at the specified size.
 * @param {DvtContainer} container The container to render within.
 * @param {number} width The width of the component.
 * @param {number} height The height of the component.
 */
DvtGauge.prototype.Render = function(container, width, height) 
{  
  // subclasses should override
}

/**
 * Checks animation settings for the gauge and creates and plays animation on display
 * or animation on data change.
 * @param {DvtContainer} container The container to render within.
 * @param {boolean} bData True if new data was provided to the gauge.
 * @param {Array} oldShapes The array of DvtShapes that can be animated
 * @param {number} width The width of the component.
 * @param {number} height The height of the component.
 * @private
 */
DvtGauge.prototype._setAnimation = function(container, bData, oldShapes, width, height) {
  // Stop any animation in progress before starting new animation
  if(this._animation)
    this._animation.stop();
  
  var bBlackBoxUpdate = false;
  var animationOnDataChange = this._bEditing ? "none" : this.__getOptions()['animationOnDataChange'];
  var animationOnDisplay = this._bEditing ? "none" : this.__getOptions()['animationOnDisplay'];
  var animationDuration = this.__getOptions()['animationDuration']/1000;
  
  if (!animationOnDisplay && !animationOnDataChange)
    return;
  
  var bounds = new DvtRectangle(0, 0, width, height);
  var context = this.getCtx();
  
  if(!this._container && animationOnDisplay !== "none") { // animationOnDisplay
    this._animation = DvtBlackBoxAnimationHandler.getInAnimation(context, animationOnDisplay, container, bounds, animationDuration);
    if(!this._animation) 
      this._animation = this.CreateAnimationOnDisplay(this.__shapes, animationOnDisplay, animationDuration);
  }
  else if (this._container && animationOnDataChange != "none" && bData) { // animationOnDataChange
    this._animation = DvtBlackBoxAnimationHandler.getCombinedAnimation(context, animationOnDataChange, 
                                                                      this._container, container, bounds, animationDuration);   
    if (this._animation)
      bBlackBoxUpdate = true;
    else
      this._animation = this.CreateAnimationOnDataChange(oldShapes, this.__shapes, animationOnDisplay, animationDuration);
  }
  
  if(!bBlackBoxUpdate)
    this.removeChild(this._container);
  
  if(this._animation) {  
    this._animation.play();  
    this._animation.setOnEnd(this._onAnimationEnd, this);
  }
  
  if(bBlackBoxUpdate)
    this._oldContainer = this._container;
  
  this._container = container;
}

/**
  * Creates a DvtPlayable that performs animation upon inital gauge display.
  * @param {Array} objs The array of DvtShapes to animate to.
  * @param {string} animationType The animation type.
  * @param {number} animationDuration The duration of the animation in seconds.
  * @return {DvtPlayable}
  * @protected
  */
DvtGauge.prototype.CreateAnimationOnDisplay = function(objs, animationType, animationDuration) {
  // subclasses may implement
  return null;
}

/**
  * Creates a DvtPlayable that performs animation for a gauge update.
  * @param {Array} oldObjs The array of DvtShapes to animate from.
  * @param {Array} newObjs The array of DvtShapes to animate to.
  * @param {string} animationType The animation type.
  * @param {number} animationDuration The duration of the animation in seconds.
  * @return {DvtPlayable}
  * @protected
  */
DvtGauge.prototype.CreateAnimationOnDataChange = function(oldObjs, newObjs, animationType, animationDuration) {
  var animatedObjs = [];
  for (var i=0; i<oldObjs.length; i++) {
    var oldObj = oldObjs[i];
    var newObj = newObjs[i];
    var startState = oldObj.getAnimationParams();
    var endState = newObj.getAnimationParams();
    
    newObj.setAnimationParams(startState);
    var animation = new DvtCustomAnimation(this.getCtx(), newObj, animationDuration);
    animation.getAnimator().addProp(DvtAnimator.TYPE_NUMBER_ARRAY, newObj, newObj.getAnimationParams, newObj.setAnimationParams, endState);
    animatedObjs.push(animation);
  }
  return new DvtParallelPlayable(this.getCtx(), animatedObjs);
}

/**
 * Returns the value at the specified coordinates.  Subclasses must override to support editing behavior.
 * @param {number} x The x coordinate of the value change.
 * @param {number} y The y coordinate of the value change.
 * @protected
 */
DvtGauge.prototype.GetValueAt = function(x, y) {
  return null;
}

/**
 * Cleans up the old container used by black box updates.
 * @private
 */
DvtGauge.prototype._onAnimationEnd = function() {
  if(this._oldContainer) {
    this.removeChild(this._oldContainer);
    this._oldContainer = null;
  }
  
  // Reset the animation reference
  this._animation = null;
}

/**
 * Returns the resource bundle for this component.
 * @return {DvtGaugeBundle}
 */
DvtGauge.prototype.__getBundle = function() {
  return this.Bundle;
}

/**
 * Returns the evaluated options object, which contains the user specifications
 * merged with the defaults.
 * @return {object} The options object.
 */
DvtGauge.prototype.__getOptions = function() {
  return this.Options;
}

/**
 * Returns the DvtEventManager for this component.
 * @return {DvtEventManager}
 */
DvtGauge.prototype.__getEventManager = function() {
  return this._eventHandler;
}

/**
 * Handles the start of a value change update driven by a touch or mouse gesture at the specified coordinates.
 * @param {number} x The x coordinate of the value change.
 * @param {number} y The y coordinate of the value change.
 */
DvtGauge.prototype.__processValueChangeStart = function(x, y) {
  this._bEditing = true;
  this._oldValue = this.Options['value'];
  this.__processValueChangeMove(x, y);
}

/**
 * Handles the continuation of a value change update driven by a touch or mouse gesture at the specified coordinates.
 * @param {number} x The x coordinate of the value change.
 * @param {number} y The y coordinate of the value change.
 */
DvtGauge.prototype.__processValueChangeMove = function(x, y) {
  // Update the data value and re-render
  this.Options['value'] = DvtGaugeRenderer.adjustForStep(this.Options, this.GetValueAt(x, y));
  this.render();
  
  // Fire the value change input event
  this.__dispatchEvent(new DvtValueChangeEvent(this._oldValue, this.Options['value'], false));
}

/**
 * Handles the end of a value change update driven by a touch or mouse gesture at the specified coordinates.
 * @param {number} x The x coordinate of the value change.
 * @param {number} y The y coordinate of the value change.
 */
DvtGauge.prototype.__processValueChangeEnd = function(x, y) {  
  // Render again in case a move was skipped
  this.__processValueChangeMove(x, y);

  // Fire the event and reset
  this.__dispatchEvent(new DvtValueChangeEvent(this._oldValue, this.Options['value'], true));
  this._bEditing = false;
  this._oldValue = null;
}

/**
 * Creates the event handler for the gauge
 * @return new Event handler
 */
DvtGauge.prototype.CreateEventHandler = function() {  
  return new DvtGaugeEventManager(this)
}

/**
 * Comparison function
 * @param {object} a threshold object.
 * @param {object} b threshold object.
 * @private
 */
 DvtGauge._thresholdComparator= function(a, b) {  
  if(a['max'] && b['max'])
    return Math.abs(a['max']) - Math.abs(b['max']);
  else
    return a['max']? -Infinity : Infinity;
}
/**
 * Resource bundle for DvtGauge.
 * @class
 * @constructor
 * @extends {DvtBundle}
 */
var DvtGaugeBundle = function() {}

DvtObj.createSubclass(DvtGaugeBundle, DvtBundle, "DvtGaugeBundle");

DvtGaugeBundle["_defaults"] = {
  'EMPTY_TEXT': 'No data to display'
}

/**
 * @override
 */
DvtGaugeBundle.prototype.GetDefaultStringForKey = function(key) {
  return DvtGaugeBundle["_defaults"][key];
}

/**
 * @override
 */
DvtGaugeBundle.prototype.GetBundlePrefix = function() {
  return "DvtGaugeBundle";
}
/**
 * Default values and utility functions for component versioning.
 * @class
 * @constructor
 * @extends {DvtBaseComponentDefaults}
 */
var DvtGaugeDefaults = function() {}

DvtObj.createSubclass(DvtGaugeDefaults, DvtBaseComponentDefaults, "DvtGaugeDefaults");

/**
 * Defaults for ALTA.
 */ 
DvtGaugeDefaults.SKIN_ALTA = {
  'skin': DvtCSSStyle.SKIN_ALTA,
  'color': "#393737",
  'metricLabel': {'style': new DvtCSSStyle("font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;")}
}

/**
 * Defaults for version 1.
 */ 
DvtGaugeDefaults.VERSION_1 = {
  'skin': DvtCSSStyle.SKIN_SKYROS,
  'min': 0, 'max': 100,
  'color': "#313842", 'borderColor': null, 'visualEffects': "auto", 'emptyText': null,
  'animationOnDataChange': "none", 'animationOnDisplay': "none", 'animationDuration': 1000,
  'readOnly': 'true',
  'metricLabel': {
    'rendered': "off", 
    'scaling': "auto",
    'style': new DvtCSSStyle(),
    'textType': 'number'
  },

  // Internal layout constants
  '__layout': {'outerGap': 1, 'labelGap': 3}
}

/**
 * @override
 */
DvtGaugeDefaults.prototype.Init = function(defaultsMap) {
  // This will only be called via subclasses.  Combine with defaults from this class before passing to super.
  var ret = {
    'skyros': DvtJSONUtils.merge(defaultsMap['skyros'], DvtGaugeDefaults.VERSION_1),
    'alta': DvtJSONUtils.merge(defaultsMap['alta'], DvtGaugeDefaults.SKIN_ALTA)
  };

  DvtGaugeDefaults.superclass.Init.call(this, ret);
}

/**
 * Returns true if the skyros skin effects should be used.
 * @param {DvtGauge} gauge
 * @return {boolean}
 */
DvtGaugeDefaults.isSkyrosSkin = function(gauge) 
{
  return (gauge.__getOptions()['skin'] == DvtCSSStyle.SKIN_SKYROS);
}
/**
 * Style related utility functions for gauge components.
 * @class
 */
var DvtGaugeDataUtils = new Object();

DvtObj.createSubclass(DvtGaugeDataUtils, DvtObj, "DvtGaugeDataUtils");

/**
 * Returns true if the specified chart has data.
 * @param {DvtGauge} gauge
 * @return {boolean}
 */
DvtGaugeDataUtils.hasData = function(gauge) {
  var options = gauge.__getOptions();
  
  // Check that there is a data object with a valid value
  if(!options || isNaN(options['value']) || options['value'] === null)
    return false;
  else
    return true;
}

/**
 * Returns the index of the threshold corresponding to the gauge value.
 * @param {DvtGauge}
 * @return {number} The index of the threshold definition or null if none is available.
 */
DvtGaugeDataUtils.getValueThresholdIndex = function(gauge) {
  var options = gauge.__getOptions();
  var value = options['value'];
  var thresholds = options['thresholds'];
  
  // Return -1 if no thresholds exist
  if(!thresholds)
    return -1;
  
  // Loop through and find the threshold
  for(var i=0; i<thresholds.length; i++) {
    if(value <= thresholds[i]['max'])
      return i;
  }

  // None found, but thresholds exist, this means the last threshold
  return thresholds.length-1;
}

/**
 * Returns the specified threshold.
 * @param {DvtGauge}
 * @param {number} index The index of the threshold.
 * @return {object} The threshold definition or null if none is available.
 */
DvtGaugeDataUtils.getThreshold = function(gauge, index) {
  var thresholds = gauge.__getOptions()['thresholds'];

  if(thresholds && index >= 0 && index < thresholds.length)
    return thresholds[index];
  else
    return null;
}

/**
 * Returns the specified referenceObject.
 * @param {DvtGauge}
 * @param {number} index The index of the referenceObject.
 * @return {object} The referenceObject definition or null if none is available.
 */
DvtGaugeDataUtils.getReferenceObject = function(gauge, index) {
  var options = gauge.__getOptions();
  var referenceObjects = options['referenceLines'];
  if(referenceObjects && index >= 0 && index < referenceObjects.length)
    return referenceObjects[index];
  else
    return null;
}
/**
 * Event Manager for DvtGauge.
 * @param {DvtGauge} gauge
 * @class
 * @extends DvtEventManager
 * @constructor
 */
var DvtGaugeEventManager = function(gauge) {
  this.Init(gauge.getCtx(), gauge.__dispatchEvent, gauge);
  this._gauge = gauge;
  this.isEditing = false;
};

DvtObj.createSubclass(DvtGaugeEventManager, DvtEventManager, "DvtGaugeEventManager");

/**
 * @override
 */
DvtGaugeEventManager.prototype.OnMouseDown = function(event) {
  // Set the editing flag so moves are tracked
  if(this._gauge.__getOptions()['readOnly'] === false) {
    this.isEditing = true;
    this.hideTooltip();
    var coords = this.GetRelativePosition(event.pageX, event.pageY);
    this._gauge.__processValueChangeStart(coords.x, coords.y);
  }
  else // Don't call super if editing, just handle it in this subclass
    DvtGaugeEventManager.superclass.OnMouseDown.call(this, event);
}

/**
 * @override
 */
DvtGaugeEventManager.prototype.OnMouseUp = function(event) {  
  // Reset the editing flag
  if(this.isEditing) {
    this.isEditing = false;
    var coords = this.GetRelativePosition(event.pageX, event.pageY);
    this._gauge.__processValueChangeEnd(coords.x, coords.y);
  }
  else // Don't call super if editing, just handle it in this subclass
    DvtGaugeEventManager.superclass.OnMouseUp.call(this, event);
}

/**
 * @override
 */
DvtGaugeEventManager.prototype.OnMouseMove = function(event) {
  // Only process move events when editing
  if(this.isEditing) {
    var coords = this.GetRelativePosition(event.pageX, event.pageY);
    this._gauge.__processValueChangeMove(coords.x, coords.y);
  }
  if (this.IsShowingTooltipWhileEditing() || !this.isEditing)
    DvtGaugeEventManager.superclass.OnMouseMove.call(this, event);
}

/**
 * Controls whether the tooltip shows up on hover/mousemove
 * @return {boolean}
 */
DvtGaugeEventManager.prototype.IsShowingTooltipWhileEditing = function(){
  return false;
}

/**
 * @override
 */
DvtGaugeEventManager.prototype.PreEventBubble = function(event) {
  if (DvtTouchEvent.TOUCHSTART === event.type && this._gauge.__getOptions()['readOnly'] === false) {
    // Set the editing flag so moves are tracked
    this.isEditing = true;
    var coords = this.GetRelativePosition(event.touches[0].pageX, event.touches[0].pageY);
    this._gauge.__processValueChangeStart(coords.x, coords.y);
    
    // Prevent default action from occuring
    event.preventDefault();
  }
  else if (DvtTouchEvent.TOUCHMOVE === event.type && this.isEditing) {
    var coords = this.GetRelativePosition(event.touches[0].pageX, event.touches[0].pageY);
    this._gauge.__processValueChangeMove(coords.x, coords.y);
    
    // Prevent default action from occuring
    event.preventDefault();
  }
  else if (DvtTouchEvent.TOUCHEND === event.type && this.isEditing) {
    this.isEditing = false;
    var coords = this.GetRelativePosition(event.changedTouches[0].pageX, event.changedTouches[0].pageY);
    this._gauge.__processValueChangeEnd(coords.x, coords.y);
    
    // Prevent default action from occuring
    event.preventDefault();    
  }
  else { // Don't call super if editing, just handle it in this subclass
    DvtGaugeEventManager.superclass.PreEventBubble.call(this, event);
  } 
}

/**
 * Returns the position of the specified page coords, relative to the component.
 * @param {number} pageX
 * @param {number} pageY
 * @return {DvtPoint}
 * @protected
 */
DvtGaugeEventManager.prototype.GetRelativePosition = function(pageX, pageY) {
  var stageCoords = this.getCtx().pageToStageCoords(pageX, pageY);
  return this._gauge.stageToLocal(stageCoords);
}
/**
 * Style related utility functions for gauge components.
 * @class
 */
var DvtGaugeStyleUtils = new Object();

DvtObj.createSubclass(DvtGaugeStyleUtils, DvtObj, "DvtGaugeStyleUtils");

/** @private */
DvtGaugeStyleUtils._THRESHOLD_COLOR_RAMP = ["#ed6647", "#fad55c", "#68c182"];
DvtGaugeStyleUtils._SKYROS_THRESHOLD_COLOR_RAMP = ["#D62800", "#FFCF21", "#84AE31"];

/**
 * Returns the color, taking into account the thresholds if specified.
 * @param {DvtGauge} gauge
 * @return {string} The color of the gauge.
 */
DvtGaugeStyleUtils.getColor = function(gauge) {
  // Options Object
  var options = gauge.__getOptions();
  
  // Thresholds
  var thresholdIndex = DvtGaugeDataUtils.getValueThresholdIndex(gauge);
  var threshold = DvtGaugeDataUtils.getThreshold(gauge, thresholdIndex);
  if(threshold && (!(gauge instanceof DvtStatusMeterGauge)|| 
  ((gauge instanceof DvtStatusMeterGauge) && options['thresholdDisplay']=="onIndicator"))) {
    return  DvtGaugeStyleUtils.getThresholdColor(gauge, threshold, thresholdIndex);
  }
 
  return options['color'];  
}

/**
 * Returns the border color, taking into account the thresholds if specified.
 * @param {DvtGauge} gauge
 * @return {string} The border color of the gauge.
 */
DvtGaugeStyleUtils.getBorderColor = function(gauge) {
  // Options Object
  var options = gauge.__getOptions();
    
  // Thresholds
  var thresholdIndex = DvtGaugeDataUtils.getValueThresholdIndex(gauge);
  var threshold = DvtGaugeDataUtils.getThreshold(gauge, thresholdIndex);
    
  if( threshold && threshold['borderColor'] && 
  (!(gauge instanceof DvtStatusMeterGauge) ||
  (gauge instanceof DvtStatusMeterGauge) && (options['thresholdDisplay']=="onIndicator")))
    return threshold['borderColor'];
  
  return options['borderColor'];  
}

/**
 * Returns the color, taking into account the thresholds if specified.
 * @param {DvtGauge} gauge
 * @return {string} The color of the gauge.
 */
DvtGaugeStyleUtils.getPlotAreaColor = function(gauge) {
  // Options Object
  var options = gauge.__getOptions();
  
  // Thresholds
  var thresholdIndex = DvtGaugeDataUtils.getValueThresholdIndex(gauge);
  var threshold = DvtGaugeDataUtils.getThreshold(gauge, thresholdIndex);
  if(threshold && (!(gauge instanceof DvtStatusMeterGauge)|| ((gauge instanceof DvtStatusMeterGauge) && options['thresholdDisplay']!="onIndicator"))) {
    return DvtGaugeStyleUtils.getThresholdColor(gauge, threshold, thresholdIndex);
  }
  

  return options['plotArea']['color'];  
}

/**
 * Returns the defined threshold color or gets it from the threshold color ramp
 * @param {DvtGauge} gauge
 * @param {object} threshold
 * @param {number} thresholdIndex
 * @return {string} The Threshold color of the gauge.
 */
DvtGaugeStyleUtils.getThresholdColor = function(gauge, threshold, thresholdIndex) {
  if(threshold['color'])
    return threshold['color'];
  else if(thresholdIndex < DvtGaugeStyleUtils._THRESHOLD_COLOR_RAMP.length) {
    if(DvtGaugeDefaults.isSkyrosSkin(gauge))
        return DvtGaugeStyleUtils._SKYROS_THRESHOLD_COLOR_RAMP[thresholdIndex];
    else
        return DvtGaugeStyleUtils._THRESHOLD_COLOR_RAMP[thresholdIndex];
  }
}
/**
 * Renderer for DvtGauge.
 * @class
 */
var DvtGaugeRenderer = new Object();

DvtObj.createSubclass(DvtGaugeRenderer, DvtObj, "DvtGaugeRenderer");

/** @private */
DvtGaugeRenderer._EMPTY_TEXT_GAP_WIDTH = 2;
DvtGaugeRenderer._EMPTY_TEXT_GAP_HEIGHT = 1;

/**
 * Renders the empty text for the component. 
 * @param {DvtGauge} gauge The gauge being rendered.
 * @param {DvtContainer} container The container to render into.
 * @param {DvtRectangle} availSpace The available space.
 */
DvtGaugeRenderer.renderEmptyText = function(gauge, container, availSpace) {
  // Get the empty text string
  var options = gauge.__getOptions();
  var emptyTextStr = options['emptyText'];
  if(!emptyTextStr) 
    emptyTextStr = gauge.__getBundle().getTranslatedString('EMPTY_TEXT', null);
  
  // Calculate the alignment point and available space
  var x = availSpace.x + availSpace.w/2;
  var y = availSpace.y + availSpace.h/2;
  var width = availSpace.w - 2*DvtGaugeRenderer._EMPTY_TEXT_GAP_WIDTH;
  var height = availSpace.h - 2*DvtGaugeRenderer._EMPTY_TEXT_GAP_HEIGHT;

  // Create and position the label
  var label = new DvtOutputText(gauge.getCtx(), emptyTextStr, x, y);
  
  // Set font size
  if(!options['metricLabel']['style'].getStyle("font-size"))
    options['metricLabel']['style'].setStyle("font-size", "13px");
  label.setCSSStyle(options['metricLabel']['style']);
  label.alignCenter();
  label.alignMiddle();
  
  // Truncate if needed, null is returned if the label doesn't fit
  if(DvtTextUtils.fitText(label, width, height, container)) {
    // Show tooltip for truncated text
    if(label.isTruncated())
      gauge.__getEventManager().associate(label, new DvtSimpleObjPeer(emptyTextStr));
  }
};

/**
 * Formats gauge label.
 * @param {float} value The value to render into.
 * @param {Object} gauge The gauge.
 * 
 */
DvtGaugeRenderer.getFormattedMetricLabel = function(value, gauge) {
    var options = gauge.__getOptions();
    var isPercent = (options['metricLabel']['textType'] == "percent");
    if(isPercent)
      value = DvtGaugeRenderer.getFillPercentage(options, options['min'], options['max'], value) * 100;
      
    var converter = null;
    if(options['metricLabel']['rendered'] == "on" && options['metricLabel']['converter']) 
        converter = options['metricLabel']['converter'];
        
    var scaling = null;
    if(options['metricLabel']['rendered'] == "on" && options['metricLabel']['scaling']) 
        scaling = options['metricLabel']['scaling'];
        
    var autoPrecision = options['metricLabel']['autoPrecision']? options['metricLabel']['autoPrecision'] : 'on';
    return DvtGaugeRenderer._formatLabelValue(value, gauge, converter, scaling, autoPrecision, isPercent);
}

/**
 * Formats dial gauge tick labels.
 * @param {float} value The value to render into.
 * @param {Object} gauge The gauge.
 * 
 */
DvtGaugeRenderer.formatTickLabelValue = function(value, gauge) {
    var options = gauge.__getOptions();
    var isPercent = (options['tickLabel']['textType'] == "percent");
    if(isPercent)
      value = DvtGaugeRenderer.getFillPercentage(options, options['min'], options['max'], value) * 100;
      
    var converter = null;
    if(options['tickLabel']['rendered'] == "on" && options['tickLabel']['converter']) 
        converter = options['tickLabel']['converter'];
    
    var scaling = null;
    if(options['tickLabel']['rendered'] == "on" && options['tickLabel']['scaling']) 
        scaling = options['tickLabel']['scaling'];
        
    var autoPrecision = options['tickLabel']['autoPrecision']? options['tickLabel']['autoPrecision'] : 'on';
    return DvtGaugeRenderer._formatLabelValue(value, gauge, converter, scaling, autoPrecision, isPercent);
}

/**
 * Formats gauge label.
 * @param {float} value The value to render into.
 * @param {Object} gauge The gauge.
 * 
 */
DvtGaugeRenderer._formatLabelValue = function(value, gauge, converter, scaling, autoPrecision, isPercent) {
  var options = gauge.__getOptions();
  var output = value;
  
  var minValue = options['min'];
  var maxValue = options['max'];

  var difference = maxValue - minValue;
  var divider = difference < 1000 ? 100 : 1000;
  var increment = null;
  if (!isNaN(difference))
    increment = difference / divider;

  // when scaling is set then init formatter
  var formatter = new DvtLinearScaleAxisValueFormatter(minValue, maxValue, increment, scaling, autoPrecision);
  if (converter && converter.getAsString)
    output = formatter.format(value, converter);
  else if (converter && converter['format'])
    return converter['format'](value);
  else 
    output = formatter.format(value);
  
  
  return (isPercent ? String(output) + "%" : output);
}

/**
 * Determine percent of total area to fill
 * @param {object} options The object containing the data.
 * @param {number} min Min value.
 * @param {number} max Max value.
 * @param {number} value Value to draw to.
 * @return {number} Percent of the area filled
 */
DvtGaugeRenderer.getFillPercentage = function(options, min, max, value) {
  var percentFill = ((value - min) / (options['max'] - options['min']));
  percentFill = Math.min(Math.max(0, percentFill), 1);
  return percentFill;
}

/**
 * Renders the label into the specified area.
 * @param {DvtGauge} gauge The gauge being rendered.
 * @param {DvtContainer} container The container to render into.
 * @param {DvtRectangle} bounds The available bounds for rendering.
 * @param {color} color Label color
 */
DvtGaugeRenderer.renderLabel = function(gauge, container, bounds, color) {
  var options = gauge.__getOptions();

  // Create and position the label
  if(options['metricLabel']['rendered'] == "on") {
    var labelString = DvtGaugeRenderer.getFormattedMetricLabel(options['value'], gauge);
    var labelWidth = bounds.w;
    var labelHeight = bounds.h;

    // Create the label and align
    var label = new DvtOutputText(gauge.getCtx(), labelString, bounds.x + bounds.w/2, bounds.y + bounds.h/2);
    label.setCSSStyle(options['metricLabel']['style']);
    if(!options['metricLabel']['style'].getStyle("font-size")) {
      var longestLabel = Math.max(options['max'].toString().length, options['min'].toString().length, labelString.length);
      var maxString = "";
      if(options['metricLabel']['textType'] == "percent") {
        longestLabel = Math.max(3, labelString.length);
        maxString += "%";
      }
      for(var i = 0; i < longestLabel; i++) 
        maxString += "0";
      label.setTextString(maxString);
      var size = label.getOptimalFontSize(bounds);
      label.setTextString(labelString);
      label.setFontSize(size);
    }
    label.alignMiddle();
    label.alignCenter();
    
    // Fudge Factor for Webkit bug
    if(DvtAgent.isBrowserChrome())
      label.setY(label.getY() + size * .1);
      
    // Set color
    if(color != null)
      label.setSolidFill(color);
   
    // Truncate if needed, null is returned if the label doesn't fit
    if(DvtTextUtils.fitText(label, labelWidth, labelHeight, container)) {
      // Show tooltip for truncated text
      if(label.isTruncated())
        gauge.__getEventManager().associate(label, new DvtSimpleObjPeer(labelString));
    }
  }
}

/**
 * Get step adjusted value.
 * @param {object} options The object containing the data.
 * @param {number} value Current value
 * @return {number} Adjusted value
 */
DvtGaugeRenderer.adjustForStep = function(options, value) {
  var step = Number(options['step']);
  if(step && step > 0) {
    var stepNum = (value - options['min'])/step;
    if(stepNum > .5) {
      var adjustedValue = Math.ceil(stepNum) * step + options['min'];
      return Math.max(Math.min(options['max'], adjustedValue), options['min']);
    }
    else
      return options['min'];
  }
  return value;
}
// Copyright (c) 2008, 2013, Oracle and/or its affiliates. 
// All rights reserved. 

/**
 * LED Gauge component.  This class should never be instantiated directly.  Use the
 * newInstance function instead.
 * @class
 * @constructor
 * @extends {DvtGauge} 
 * @export
 */
var DvtLedGauge = function() {}

DvtObj.createSubclass(DvtLedGauge, DvtGauge, "DvtLedGauge");

/**
 * Returns a new instance of DvtLedGauge.
 * @param {DvtContext} context The rendering context.
 * @param {string} callback The function that should be called to dispatch component events.
 * @param {object} callbackObj The optional object instance on which the callback function is defined.
 * @return {DvtLedGauge}
 * @export
 */
DvtLedGauge.newInstance = function(context, callback, callbackObj) {
  var gauge = new DvtLedGauge();
  gauge.Init(context, callback, callbackObj);
  return gauge;
}

/**
 * @override
 */
DvtLedGauge.prototype.Init = function(context, callback, callbackObj) {
  DvtLedGauge.superclass.Init.call(this, context, callback, callbackObj);
  
  // Create the defaults object
  this.Defaults = new DvtLedGaugeDefaults();
}

/**
 * @override
 */
DvtLedGauge.prototype.SetOptions = function(options) {
  // Combine the user options with the defaults and store
  DvtLedGauge.superclass.SetOptions.call(this, this.Defaults.calcOptions(options));
  
  // animationOnDisplay="auto" will do "zoom"
  if(this.Options['animationOnDisplay'] == "auto")
    this.Options['animationOnDisplay'] = "zoom";
    
  // animationOnDataChange="auto" will do "alphaFade"
  if(this.Options['animationOnDataChange'] == "auto")
    this.Options['animationOnDataChange'] = "alphaFade";
  
  // readOnly="false" is not supported
  this.Options['readOnly'] = true;
}

/**
 * @override
 */
DvtLedGauge.prototype.Render = function(container, width, height) 
{  
  DvtLedGaugeRenderer.render(this, container, width, height);
}
/**
 * Default values and utility functions for component versioning.
 * @class
 * @constructor
 * @extends {DvtGaugeDefaults}
 */
var DvtLedGaugeDefaults = function() {
  this.Init({'skyros': DvtLedGaugeDefaults.VERSION_1, 'alta': {}});
}

DvtObj.createSubclass(DvtLedGaugeDefaults, DvtGaugeDefaults, "DvtLedGaugeDefaults");

/**
 * Defaults for version 1.
 */ 
DvtLedGaugeDefaults.VERSION_1 = {
  'type': "circle"
}
/**
 * Renderer for DvtLedGauge.
 * @class
 */
var DvtLedGaugeRenderer = new Object();

DvtObj.createSubclass(DvtLedGaugeRenderer, DvtObj, "DvtLedGaugeRenderer");

/** @private **/
DvtLedGaugeRenderer.__RECTANGLE_CORNER_RADIUS = 1/6;

/** @private **/
DvtLedGaugeRenderer._SKYROS_SHAPE_TRIANGLE_CMDS = "M8,86.6Q0,86.6,3.46,78.6L46,6.93Q50,0,54,6.93L96.54,78.6Q100,86.6,92,86.6Z";
                                            
/** @private **/
DvtLedGaugeRenderer._SHAPE_TRIANGLE_CMDS = "M0,86.6L50,0L100,86.6Z";                                          
                                           
/** @private **/
DvtLedGaugeRenderer._SKYROS_SHAPE_TRIANGLE_INNER_CMDS = "M0,86.6L50,0L100,86.6Z";

/** @private **/ 
DvtLedGaugeRenderer._SKYROS_SHAPE_STAR_CMDS = "M26.72,48.82L28.094,20.746L45.594,42.738L72.714,35.382L57.2,58.812L72.59,82.328L45.504,74.816L27.894,96.722L26.666,68.652L.398,58.688Z"; 

/** @private **/ 
DvtLedGaugeRenderer._SHAPE_STAR_CMDS = "M34.55,2.45L28.16,34.13L0,50L28.16,65.87L34.55,97.55L58.34,75.38L90.45,79.39L77,50L90.45,20.61L58.34,24.62Z"; 

/** @private **/
DvtLedGaugeRenderer._SKYROS_SHAPE_ARROW_CMDS = "M50,95L71,95Q74.414,94.414,75,91L75,60L92,60Q98.5,59.1,95,54L52,12Q50,11,48,12L5,54Q1.5,59.1,8,60L25,60L25,91Q25.586,94.414,29,95Z";

DvtLedGaugeRenderer._SHAPE_ARROW_CMDS = "M75,98L75,58L97.5,58L50,11L2.5,58L25,58L25,98Z";
                                        
/** @private **/
DvtLedGaugeRenderer._SKYROS_SHAPE_ARROW_INNER_CMDS = "M75,98L75,58L97.5,58L50,11L2.5,58L25,58L25,98Z";

/**
 * Renders the gauge in the specified area.
 * @param {DvtLedGauge} gauge The gauge being rendered.
 * @param {DvtContainer} container The container to render into.
 * @param {number} width The width of the component.
 * @param {number} height The height of the component.
 */
DvtLedGaugeRenderer.render = function(gauge, container, width, height) {
  if(DvtGaugeDataUtils.hasData(gauge)) {
    // Allocate the outer gap for the component
    var options = gauge.__getOptions();
    var outerGap = options['__layout']['outerGap'];
    var size = options && (options['size'] >= 0 || options['size'] < 1) ? Math.sqrt(options['size']) : 1;    
    var bounds = new DvtRectangle(outerGap + ((width - 2 * outerGap) * (1 - size) / 2), 
    outerGap + ((height - 2 * outerGap) * (1 - size) / 2), 
    (width - 2*outerGap) * size, (height - 2*outerGap)* size);
    
    // Render the LED shape first
    DvtLedGaugeRenderer._renderShape(gauge, container, bounds);
    
    // Render the visual effects
    DvtLedGaugeRenderer._renderVisualEffects(gauge, container, bounds);
    
    // Render the label on top of the LED
    if(options['metricLabel']['style'].getStyle("color") != null) {
      DvtGaugeRenderer.renderLabel(gauge, container, DvtLedGaugeRenderer._getLabelBounds(gauge, container, bounds));
    }
    else
    {
      var labelColor = DvtGaugeStyleUtils.getColor(gauge);
      labelColor = DvtColorUtils.getContrastingTextColor(labelColor);
      options['metricLabel']['style'].setStyle("color", labelColor);
      DvtGaugeRenderer.renderLabel(gauge, container, DvtLedGaugeRenderer._getLabelBounds(gauge, container, bounds), labelColor);
    }
  }
  else // Render the empty text
    DvtGaugeRenderer.renderEmptyText(gauge, container, new DvtRectangle(0, 0, width, height));
}

/**
 * Renders the led shape into the specified area.
 * @param {DvtLedGauge} gauge The gauge being rendered.
 * @param {DvtContainer} container The container to render into.
 * @param {DvtRectangle} bounds The available bounds for rendering.
 */
DvtLedGaugeRenderer._renderShape = function(gauge, container, bounds) {
  var context = gauge.getCtx();
  var options = gauge.__getOptions();
  
  // Find the styles
  var type = options['type'];
  var color = DvtGaugeStyleUtils.getColor(gauge);
  var borderColor = DvtGaugeStyleUtils.getBorderColor(gauge);
  
  // Calculate the center and radius for convenience
  var cx = bounds.x + bounds.w/2;
  var cy = bounds.y + bounds.h/2;
  var r = Math.min(bounds.w, bounds.h)/2;
  var isSkyros = DvtGaugeDefaults.isSkyrosSkin(gauge);
  
  // Render the LED shape
  var shape;
  var cmds;
  if(type == "rectangle") {
    shape = new DvtRect(context, bounds.x, bounds.y, bounds.w, bounds.h);
  }
  else if(type == "diamond") {
    shape = new DvtPolygon(context, [cx - r, cy, cx, cy - r, cx + r, cy, cx, cy + r]);
  }
  else if(type == "triangle") {
    cmds = isSkyros ? DvtLedGaugeRenderer._SKYROS_SHAPE_TRIANGLE_CMDS : DvtLedGaugeRenderer._SHAPE_TRIANGLE_CMDS
    shape = new DvtPath(context, cmds);
  }
  else if(type == "star") {
    cmds = isSkyros ? DvtLedGaugeRenderer._SKYROS_SHAPE_STAR_CMDS : DvtLedGaugeRenderer._SHAPE_STAR_CMDS
    shape = new DvtPath(context, cmds);
  }
  else if(type == "arrow") {
    cmds = isSkyros ? DvtLedGaugeRenderer._SKYROS_SHAPE_ARROW_CMDS : DvtLedGaugeRenderer._SHAPE_ARROW_CMDS
    shape = new DvtPath(context, cmds);
  }
  else { // circle
    shape = new DvtCircle(context, cx, cy, r);
  }
  
  // Apply the style properties
  if(isSkyros || options['visualEffects'] == "none")
    shape.setSolidFill(color);
  else {
    var arColors = [DvtColorUtils.adjustHSL(color, 0, -.09, .04), DvtColorUtils.adjustHSL(color, 0, -.04, -.05)];
    var rotation = options && (options['rotation'] % 90 == 0) ? options['rotation'] : 0;
    var gradientRotation = type == "arrow" || type == "star" || type == "triangle" ? 360 - rotation : 270;
    shape.setFill( new DvtLinearGradientFill(gradientRotation, arColors, [1, 1], [0, 1]));
  }
  if(borderColor)
    shape.setSolidStroke(borderColor);
    
  // Tooltip Support
  var tooltip = options['shortDesc'];
  if(tooltip)
    gauge.__getEventManager().associate(shape, new DvtSimpleObjPeer(null, tooltip, color));
    
  // Scale and rotate the shape if needed
  shape = DvtLedGaugeRenderer._scaleAndRotate(gauge, container, shape, bounds);  
  
  // Add the shape to the container
  container.addChild(shape);
}

/**
 * Scales and rotates the shape into the specified bounds.
 * @param {DvtLedGauge} gauge The gauge being rendered.
 * @param {DvtContainer} container The container to render into.
 * @param {DvtDisplayable} shape The shape for the gauge.
 * @param {DvtRectangle} bounds The bounds of the shape.
 * @return {DvtDisplayable} The scaled shape
 * @private
 */
DvtLedGaugeRenderer._scaleAndRotate = function(gauge, container, shape, bounds) {
  var options = gauge.__getOptions();
  
  // Return the existing shape if already fitted
  var type = options['type'];
  if(!(type == "triangle" || type == "arrow"|| type == "star"))
    return shape;
    
  // Add containers for the tranforms, add to display list to calc dimensions
  var translateGroup = new DvtContainer(gauge.getCtx());
  var scaleGroup = new DvtContainer(gauge.getCtx());
  container.addChild(translateGroup);
  translateGroup.addChild(scaleGroup);
  scaleGroup.addChild(shape);
  
  // Rotate the shape, non-90 degree rotation values are ignored
  var rotation = options && (options['rotation'] % 90 == 0) ? options['rotation'] : 0;
  rotation = (type == "star") ? 0 : rotation; // star does not support custom rotation 
  var rotationMatrix = new DvtMatrix();
  rotationMatrix.rotate(Math.PI * (90 - rotation)/180);
  shape.setMatrix(rotationMatrix);

  // Scale the shape so that it's fitted within the bounds
  var dims = scaleGroup.getDimensions();
  var sx = bounds.w/dims.w;
  var sy = bounds.h/dims.h;
  var s = Math.min(sx, sy);
  var scaleMatrix = new DvtMatrix();
  scaleMatrix.scale(s, s);
  scaleGroup.setMatrix(scaleMatrix);
  
  // Translate the shape so that it's centered within the bounds
  var groupDims = translateGroup.getDimensions();
  var tx = (bounds.x + bounds.w/2) - (groupDims.x + groupDims.w/2);
  var ty = (bounds.y + bounds.h/2) - (groupDims.y + groupDims.h/2);
  
  var matrix = new DvtMatrix();
  matrix.translate(tx, ty);
  translateGroup.setMatrix(matrix);
  
  // Remove the shape
  container.removeChild(translateGroup);
  
  // Adjust the border of the shape to account for the scale transformation.
  var stroke = shape.getStroke();
  if(stroke) {
    stroke = stroke.clone();
    stroke.setWidth(stroke.getWidth()/s);
    shape.setStroke(stroke);
  }
  
  // Return the group with its transform
  return translateGroup;
}

/**
 * Renders the visual effects for the shape into the specified area.
 * @param {DvtLedGauge} gauge The gauge being rendered.
 * @param {DvtContainer} container The container to render into.
 * @param {DvtRectangle} bounds The bounds of the shape.
 * @private
 */
DvtLedGaugeRenderer._renderVisualEffects = function(gauge, container, bounds) {
  var options = gauge.__getOptions();
  var type = options['type'];
  
  if(options['visualEffects'] == "none")
    return;

  // Render the visual effects
  if(DvtGaugeDefaults.isSkyrosSkin(gauge))
  {
    if(type == "rectangle") 
      DvtLedGaugeRenderer._renderOverlayRectangle(gauge, container, bounds);
    else if(type == "diamond") 
      DvtLedGaugeRenderer._renderOverlayDiamond(gauge, container, bounds);
    else if(type == "triangle") 
      DvtLedGaugeRenderer._renderOverlayTriangle(gauge, container, bounds);
    else if(type == "star") 
      DvtLedGaugeRenderer._renderOverlayStar(gauge, container, bounds);
    else if(type == "arrow") 
      DvtLedGaugeRenderer._renderOverlayArrow(gauge, container, bounds);
    else // circle
      DvtLedGaugeRenderer._renderOverlayCircle(gauge, container, bounds);
  }
}

/**
 * Renders the visual effects for the rectangle LED into the specified area.
 * @param {DvtLedGauge} gauge The gauge being rendered.
 * @param {DvtContainer} container The container to render into.
 * @param {DvtRectangle} bounds The bounds of the shape.
 */
DvtLedGaugeRenderer._renderOverlayRectangle = function(gauge, container, bounds) {
  // Overlay Shape
  var dx = bounds.w * 0.05;
  var dy = bounds.h * 0.05;
  var overlayBounds = new DvtRectangle(bounds.x + dx, bounds.y + dy, bounds.w - 2*dx, bounds.h - 2*dy);
  var overlay = new DvtRect(gauge.getCtx(), overlayBounds.x, overlayBounds.y, overlayBounds.w, overlayBounds.h);
  overlay.setMouseEnabled(false);
  container.addChild(overlay);
  
  // Gradient
  var arColors = ["#FFFFFF", "#FFFFFF", "#FFFFFF", "#FFFFFF", "#FFFFFF", "#FFFFFF", "#FFFFFF"];
  var arAlphas = [0.75, 0.5, 0.15, 0, 0.2, 0.4, 0.2];
  var arStops = [0, 0.05, 0.4, 0.6, 0.8, 0.9, 1.0];
  var gradient = new DvtLinearGradientFill(270, arColors, arAlphas, arStops);
  overlay.setFill(gradient);
}

/**
 * Renders the visual effects for the diamond LED into the specified area.
 * @param {DvtLedGauge} gauge The gauge being rendered.
 * @param {DvtContainer} container The container to render into.
 * @param {DvtRectangle} bounds The bounds of the shape.
 */
DvtLedGaugeRenderer._renderOverlayDiamond = function(gauge, container, bounds) {
  // Overlay Shape
  var dx = bounds.w * 0.05;
  var dy = bounds.h * 0.05;
  var overlayBounds = new DvtRectangle(bounds.x + dx, bounds.y + dy, bounds.w - 2*dx, bounds.h - 2*dy);
  var cx = overlayBounds.x + overlayBounds.w/2;
  var cy = overlayBounds.y + overlayBounds.h/2;
  var r = Math.min(overlayBounds.w, overlayBounds.h)/2;
  var overlay = new DvtPolygon(gauge.getCtx(), [cx - r, cy, cx, cy - r, cx + r, cy, cx, cy + r])
  overlay.setMouseEnabled(false);
  container.addChild(overlay);
  
  // Gradient
  var arColors = ["#FFFFFF", "#FFFFFF", "#FFFFFF", "#FFFFFF", "#FFFFFF", "#FFFFFF", "#FFFFFF"];
  var arAlphas = [0.75, 0.5, 0.15, 0, 0.2, 0.4, 0.2];
  var arStops = [0, 0.05, 0.4, 0.6, 0.8, 0.9, 1.0];
  var gradient = new DvtLinearGradientFill(270, arColors, arAlphas, arStops);
  overlay.setFill(gradient);
}

/**
 * Renders the visual effects for the triangle LED into the specified area.
 * @param {DvtLedGauge} gauge The gauge being rendered.
 * @param {DvtContainer} container The container to render into.
 * @param {DvtRectangle} bounds The bounds of the shape.
 */
DvtLedGaugeRenderer._renderOverlayTriangle = function(gauge, container, bounds) {
  // Overlay Shape
  var dx = bounds.w * 0.05;
  var dy = bounds.h * 0.05;
  var overlayBounds = new DvtRectangle(bounds.x + dx, bounds.y + dy, bounds.w - 2*dx, bounds.h - 2*dy);
  var overlay = new DvtPath(gauge.getCtx(), DvtLedGaugeRenderer._SKYROS_SHAPE_TRIANGLE_INNER_CMDS);
  
  // Calculate the gradient params
  var options = gauge.__getOptions();
  var rotation = options && (options['rotation'] % 90 == 0) ? options['rotation'] : 0;
  var gradientRotation = 360 - rotation;
  var arColors = ["#FFFFFF", "#FFFFFF", "#FFFFFF", "#FFFFFF", "#FFFFFF"];
  var arAlphas = [0.3, 0.55, 0.0, 0.25, 0.1];
  var arStops = [0, 0.05, 0.4, 0.9, 1.0];
  var gradient = new DvtLinearGradientFill(gradientRotation, arColors, arAlphas, arStops);
  overlay.setFill(gradient);
  
  // Add to display list
  overlay = DvtLedGaugeRenderer._scaleAndRotate(gauge, container, overlay, overlayBounds);  
  overlay.setMouseEnabled(false);
  container.addChild(overlay);
}

/**
 * Renders the visual effects for the arrow LED into the specified area.
 * @param {DvtLedGauge} gauge The gauge being rendered.
 * @param {DvtContainer} container The container to render into.
 * @param {DvtRectangle} bounds The bounds of the shape.
 */
DvtLedGaugeRenderer._renderOverlayArrow = function(gauge, container, bounds) {
  // Overlay Shape
  var dx = bounds.w * 0.05;
  var dy = bounds.h * 0.05;
  var overlayBounds = new DvtRectangle(bounds.x + dx, bounds.y + dy, bounds.w - 2*dx, bounds.h - 2*dy);
  var overlay = new DvtPath(gauge.getCtx(), DvtLedGaugeRenderer._SKYROS_SHAPE_ARROW_INNER_CMDS);
  
  // Calculate the gradient params
  var options = gauge.__getOptions();
  var rotation = options && (options['rotation'] % 90 == 0) ? options['rotation'] : 0;
  var gradientRotation = 360 - rotation;
  var arColors = ["#FFFFFF", "#FFFFFF", "#FFFFFF", "#FFFFFF", "#FFFFFF"];
  var arAlphas = [0.3, 0.55, 0.0, 0.25, 0.1];
  var arStops = [0, 0.05, 0.4, 0.9, 1.0];
  var gradient = new DvtLinearGradientFill(gradientRotation, arColors, arAlphas, arStops);
  overlay.setFill(gradient);
  
  // Add to display list
  overlay = DvtLedGaugeRenderer._scaleAndRotate(gauge, container, overlay, overlayBounds);  
  overlay.setMouseEnabled(false);
  container.addChild(overlay);
}
/**
 * Renders the visual effects for the star LED into the specified area.
 * @param {DvtLedGauge} gauge The gauge being rendered.
 * @param {DvtContainer} container The container to render into.
 * @param {DvtRectangle} bounds The bounds of the shape.
 */
DvtLedGaugeRenderer._renderOverlayStar = function(gauge, container, bounds) {
  // Overlay Shape
  var dx = bounds.w * 0.05;
  var dy = bounds.h * 0.05;
  var overlayBounds = new DvtRectangle(bounds.x + dx, bounds.y + dy, bounds.w - 2*dx, bounds.h - 2*dy);
  var overlay = new DvtPath(gauge.getCtx(), DvtLedGaugeRenderer._SKYROS_SHAPE_STAR_CMDS);
  
  // Calculate the gradient params
  var options = gauge.__getOptions();
  var rotation = options && (options['rotation'] % 90 == 0) ? options['rotation'] : 0;
  var gradientRotation = 360 - rotation;
  var color = DvtGaugeStyleUtils.getColor(gauge);
  var arColors = [DvtColorUtils.getDarker(color, .9), color, DvtColorUtils.getBrighter(color, .7)];
  var arAlphas = [1, 1, 1];
  var arStops = [0.10, 0.40, 0.80];
  var gradient = new DvtLinearGradientFill(gradientRotation, arColors, arAlphas, arStops);
  overlay.setFill(gradient);
  
  // Add to display list
  overlay = DvtLedGaugeRenderer._scaleAndRotate(gauge, container, overlay, overlayBounds);  
  overlay.setMouseEnabled(false);
  container.addChild(overlay);
}
/**
 * Renders the visual effects for the circle LED into the specified area.
 * @param {DvtLedGauge} gauge The gauge being rendered.
 * @param {DvtContainer} container The container to render into.
 * @param {DvtRectangle} bounds The bounds of the shape.
 */
DvtLedGaugeRenderer._renderOverlayCircle = function(gauge, container, bounds) {
  // The circle uses two overlays.
  var dx = bounds.w * 0.05;
  var dy = bounds.h * 0.05;
  var gradientBounds = new DvtRectangle(bounds.x + dx, bounds.y + dy, bounds.w - 2*dx, bounds.h - 2*dy);

  //********************* First Overlay: "Overlay" ************************/
 
  // Shape
  var cx = gradientBounds.x + gradientBounds.w/2;
  var cy = gradientBounds.y + gradientBounds.h/2;
  var radius = Math.min(gradientBounds.w, gradientBounds.h)/2;
  var overlay = new DvtCircle(gauge.getCtx(), cx, cy, radius);
  overlay.setMouseEnabled(false);
  container.addChild(overlay);
  
  // Gradient
  var arColors = ["#FFFFFF", "#FFFFFF", "#FFFFFF"];
  var arAlphas = [0, 0.25, 0.5];
  var arStops = [0.15, 0.7, 0.95];
  var gradientCx = cx;
  var gradientCy = cy - radius * 0.6; // per UX
  var gradientRadius = radius * 1.5;
  var gradient = new DvtRadialGradientFill(arColors, arAlphas, arStops, gradientCx, gradientCy, gradientRadius,
                                                                                    [gradientBounds.x, gradientBounds.y,
                                                                                     gradientBounds.w, gradientBounds.h]);
  overlay.setFill(gradient);
  
  //********************* Second Overlay: "Highlight" ************************/
  
  // Shape
  var rx = radius * 0.6; // per UX
  var ry = radius * 0.4; // per UX
  cy = cy - 0.3*ry; // per UX
  var highlight = new DvtOval(gauge.getCtx(), cx, cy-ry, rx, ry);
  highlight.setMouseEnabled(false);
  container.addChild(highlight);
  
  // Gradient
  var highlightColors = ["#FFFFFF", "#FFFFFF", "#FFFFFF"];
  var highlightAlphas = [0, 0.2, 0.5];
  var highlightStops = [0.6, 0.8, 1.0];
  var highlightCx = cx;
  var highlightCy = cy;
  var highlightRadius = rx;
  var highlightGradient = new DvtRadialGradientFill(highlightColors, highlightAlphas, highlightStops, highlightCx, highlightCy, highlightRadius,
                                                                                    [gradientBounds.x, gradientBounds.y,
                                                                                     gradientBounds.w, gradientBounds.h]);
  highlight.setFill(highlightGradient);
}

/**
 * Find correct label bounds
 * @param {DvtLedGauge} gauge The gauge being rendered.
 * @param {DvtContainer} container The container to render into.
 * @param {DvtRectangle} bounds The bounds of the shape.
 * @return {DvtRectangle} Bounds for the label
 * @private
 */
DvtLedGaugeRenderer._getLabelBounds = function(gauge, container, bounds) {
  var options = gauge.__getOptions();
  var type = options['type'];
  var rotation = (options['rotation'] % 90 == 0) ? options['rotation'] : 0;
  var minDim = Math.min(bounds.w, bounds.h); 
  var newX = bounds.x + bounds.w/2 - minDim/2;
  var newY = bounds.y + bounds.h/2 - minDim/2;
  var newWidth = minDim;
  var newHeight = minDim;
  if(type == "triangle") {
    if(rotation == 0) {
      newX += minDim * .05;
      newY += minDim * .2;
      newWidth -= minDim * .3;
      newHeight -= minDim * .4;
    }
    else if(rotation == 90) {
      newX += minDim * .2;
      newY += minDim * .25;
      newWidth -= minDim * .4;
      newHeight -= minDim * .3;
    }
    else if(rotation == 180) {
      newX += minDim * .25;
      newY += minDim * .2;
      newWidth -= minDim * .3;
      newHeight -= minDim * .4;
    }
    else if(rotation == 270) {
      newX += minDim * .2;
      newY += minDim * .05;
      newWidth -= minDim * .4;
      newHeight -= minDim * .3;
    }
  }
  else if(type == "arrow") {
    if(rotation == 0) {
      newX += minDim * .05;
      newY += minDim * .2;
      newWidth -= minDim * .28;
      newHeight -= minDim * .4
    }
    else if(rotation == 90) {
      newX += minDim * .2;
      newY += minDim * .2;
      newWidth -= minDim * .4;
      newHeight -= minDim * .4;
    }
    else if(rotation == 180) {
      newX += minDim * .23;
      newY += minDim * .2;
      newWidth -= minDim * .28;
      newHeight -= minDim * .4;
    }
    else if(rotation == 270) {
      newX += minDim * .2;
      newY += minDim * .2;
      newWidth -= minDim * .4;
      newHeight -= minDim * .4;
    }
  }
  else if(type == "star") {
    newX += minDim * .25;
    newY += minDim * .25;
    newWidth -= minDim * .5;
    newHeight -= minDim * .4;
  }
  else if(type == "diamond") {
    newX += minDim * .15;
    newY += minDim * .15;
    newWidth -= minDim * .3;
    newHeight -= minDim * .3;
  }
  else if(type == "rectangle") {
    newX += minDim * .1;
    newY += minDim * .1;
    newWidth -= minDim * .2;
    newHeight -= minDim * .2;
  }
  else if(type == "circle") {
    newX += minDim * .15;
    newY += minDim * .15;
    newWidth -= minDim * .3;
    newHeight -= minDim * .3;
  }
  return new DvtRectangle(newX, newY, newWidth, newHeight)
}
// Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.

/**
 * Status Meter Gauge component.  This class should never be instantiated directly.  Use the
 * newInstance function instead.
 * @class
 * @constructor
 * @extends {DvtGauge} 
 * @export
 */
var DvtStatusMeterGauge = function() {}

DvtObj.createSubclass(DvtStatusMeterGauge, DvtGauge, "DvtStatusMeterGauge");

/**
 * Returns a new instance of DvtStatusMeterGauge.
 * @param {DvtContext} context The rendering context.
 * @param {string} callback The function that should be called to dispatch component events.
 * @param {object} callbackObj The optional object instance on which the callback function is defined.
 * @return {DvtStatusMeterGauge}
 * @export
 */
DvtStatusMeterGauge.newInstance = function(context, callback, callbackObj) {
  var gauge = new DvtStatusMeterGauge();
  gauge.Init(context, callback, callbackObj);
  return gauge;
}

/**
 * @override
 */
DvtStatusMeterGauge.prototype.Init = function(context, callback, callbackObj) {
  DvtStatusMeterGauge.superclass.Init.call(this, context, callback, callbackObj);
  
  // Create the defaults object
  this.Defaults = new DvtStatusMeterGaugeDefaults();
  
  /**
   * The axis info of the chart. This will be set during render time and is used for editing support.
   * @type {DvtAxisInfo}
   */
  this.__axisInfo = null;
}

/**
 * @override
 */
DvtStatusMeterGauge.prototype.SetOptions = function(options) {
  // Combine the user options with the defaults and store
  DvtStatusMeterGauge.superclass.SetOptions.call(this, this.Defaults.calcOptions(options));
}

/**
 * @override
 */
DvtStatusMeterGauge.prototype.Render = function(container, width, height) 
{  
  DvtStatusMeterGaugeRenderer.render(this, container, width, height);
}

/**
 * @override
 */
DvtStatusMeterGauge.prototype.CreateAnimationOnDisplay = function(objs, animationType, animationDuration) {
  var animatedObjs = [];
  for (var i=0; i<objs.length; i++) {
    var obj = objs[i];
    var endState = obj.getAnimationParams();
    if(this.Options['orientation'] == "horizontal")
      obj.setAnimationParams([endState[0], endState[0], endState[2], endState[3]]);
    else 
      obj.setAnimationParams([endState[0], endState[1], 0, endState[3], endState[4]]);
    var animation = new DvtCustomAnimation(this.getCtx(), obj, animationDuration);
    animation.getAnimator().addProp(DvtAnimator.TYPE_NUMBER_ARRAY, obj, obj.getAnimationParams, obj.setAnimationParams, endState);
    animation.getAnimator().setEasing(function(progress) {return DvtEasing.backOut(progress, 0.7);});
    animatedObjs.push(animation);
    }
  return new DvtParallelPlayable(this.getCtx(), animatedObjs);
}

/**
 * @override
 */
DvtStatusMeterGauge.prototype.GetValueAt = function(x, y) {
  if(this.Options['orientation'] == "horizontal") {
    return this.__axisInfo.getBoundedValueAt(x);
  }
  else if(this.Options['orientation'] == "circular") {
    var angleRads = Math.atan2(y - this.Height / 2, x - this.Width / 2); 
    var angle = DvtMath.radsToDegrees(angleRads) - 270;
    angle = (angle + 720) % 360;      
    if(!(angle >= 0 && angle <= 360)) {
      // Input angle is not between the start and end
      if(angle > 360)
        angle = (360 - angle < angle - 360) ? 0 : 360;
      else 
        angle = (0 - angle < angle ) ? 0 : 360;
    }
    if(DvtAgent.isRightToLeft(this.getCtx())) {
      angle = 360 - angle;
      while(angle < 0) {
        angle += 360;
      }
    }
    // Calculate and adjust ratio to keep in bounds
    var ratio = (angle)/360;  
    var minValue = this.Options['min'];
    var maxValue = this.Options['max'];
    var value = (ratio * (maxValue-minValue)) + minValue;
    return value;
  }
}
/**
 * Default values and utility functions for component versioning.
 * @class
 * @constructor
 * @extends {DvtGaugeDefaults}
 */
var DvtStatusMeterGaugeDefaults = function() {
  this.Init({'skyros': DvtStatusMeterGaugeDefaults.VERSION_1, 'alta': DvtStatusMeterGaugeDefaults.SKIN_ALTA});
}

DvtObj.createSubclass(DvtStatusMeterGaugeDefaults, DvtGaugeDefaults, "DvtStatusMeterGaugeDefaults");

/**
 * Defaults for alta.
 */ 
DvtStatusMeterGaugeDefaults.SKIN_ALTA = {
  'color': "#393737",
  'metricLabel': {'style': new DvtCSSStyle("font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;")},
  'plotArea' : {'color':"#f5f6f7", 'borderColor': "#D6DFE6"}
}

/**
 * Defaults for version 1.
 */ 
DvtStatusMeterGaugeDefaults.VERSION_1 = {
  'color': "#313842",
  'indicatorSize':1,
  'metricLabel': {'style': new DvtCSSStyle("color: #333333;")},
  'orientation': "horizontal",
  'plotArea' : {'color':"#AAAAAA", 'borderColor': "#C6C6C6", 'rendered': "auto"},
  'thresholdDisplay': "onIndicator"
}
/**
 * Renderer for DvtStatusMeterGauge.
 * @class
 */
var DvtStatusMeterGaugeRenderer = new Object();

DvtObj.createSubclass(DvtStatusMeterGaugeRenderer, DvtObj, "DvtStatusMeterGaugeRenderer");

/**
 * Renders the gauge in the specified area.
 * @param {DvtStatusMeterGauge} gauge The gauge being rendered.
 * @param {DvtContainer} container The container to render into.
 * @param {number} width The width of the component.
 * @param {number} height The height of the component.
 */
DvtStatusMeterGaugeRenderer.render = function(gauge, container, width, height) {
  if(DvtGaugeDataUtils.hasData(gauge)) {
    // Allocate the outer gap for the component
    var options = gauge.__getOptions();
    var outerGap = options['__layout']['outerGap'];
    var bounds = new DvtRectangle(outerGap, outerGap, width - 2*outerGap, height - 2*outerGap);
    
    if(options['orientation'] == "horizontal") {
      DvtStatusMeterGaugeRenderer._renderLabel(gauge, container, bounds);
      DvtStatusMeterGaugeRenderer._renderShape(gauge, container, bounds);
    }
    else if(options['orientation'] == "circular") {
      var maxDiameter = Math.min(bounds.w, bounds.h);
      // Center label bounds within the space available. 
      var labelBounds = new DvtRectangle(bounds.x + bounds.w/2 - maxDiameter * .325, bounds.y + bounds.h/2 - maxDiameter * .25, maxDiameter * .65, maxDiameter * .5);
      DvtGaugeRenderer.renderLabel(gauge, container, labelBounds);
      DvtStatusMeterGaugeRenderer._renderCircularShape(gauge, container, bounds);
    }
  }
  else // Render the empty text
    DvtGaugeRenderer.renderEmptyText(gauge, container, new DvtRectangle(0, 0, width, height));
}

/**
 * Renders the circular shape into the specified area.
 * @param {DvtStatusMeterGauge} gauge The gauge being rendered.
 * @param {DvtContainer} container The container to render into.
 * @param {DvtRectangle} bounds The available bounds for rendering.
 */
DvtStatusMeterGaugeRenderer._renderCircularShape = function (gauge, container, bounds) {
  var options = gauge.__getOptions();
  var percentFill = 0;
  var value = options['value'];
  var thresholds = options['thresholds'];
  var maxDiameter = Math.min(bounds.w, bounds.h);
  var innerRadius = maxDiameter * .3125;
  var outerRadius = maxDiameter * .4625;
  var startAngle = Math.PI * 1.5;
  var angleExtent = 2 * percentFill * Math.PI;
  if (thresholds && options['plotArea']['rendered'] != "off" && options['thresholdDisplay'] == "all") {
    for (var currentThresholdIndex = 0;currentThresholdIndex < thresholds.length;currentThresholdIndex++) {
      var thresholdColor = DvtGaugeStyleUtils.getThresholdColor(gauge, thresholds[currentThresholdIndex], currentThresholdIndex);
      var max = thresholds[currentThresholdIndex]['max'] ? thresholds[currentThresholdIndex]['max'] : options['max'];
      var min = currentThresholdIndex == 0 ? options['min'] : thresholds[currentThresholdIndex - 1]['max'];
      startAngle = Math.PI * 1.5 + 2 * Math.PI * DvtGaugeRenderer.getFillPercentage(options, options['min'], max, min);
      percentFill = DvtGaugeRenderer.getFillPercentage(options, min, max, max);
      angleExtent = 2 * percentFill * Math.PI;
      DvtStatusMeterGaugeRenderer._drawCircularArc(gauge, container, bounds, startAngle, angleExtent, innerRadius, outerRadius, thresholdColor, false);
    }
  }
  else if (!(options['plotArea']['rendered'] == "off") && !((options['plotArea']['rendered'] == "auto") && (options['thresholdDisplay'] == "onIndicator")) && options['thresholdDisplay'] != "all") {
    thresholdColor = DvtGaugeStyleUtils.getPlotAreaColor(gauge);
    startAngle = Math.PI * 1.5;
    angleExtent = 2 * Math.PI;
    DvtStatusMeterGaugeRenderer._drawCircularArc(gauge, container, bounds, startAngle, angleExtent, innerRadius, outerRadius, thresholdColor, true);
  }
  var indicatorSize = options['indicatorSize'];
  if (indicatorSize && indicatorSize != 1) {
    var totalWidth = ((1 - indicatorSize) * .075 * maxDiameter);
    innerRadius = innerRadius + totalWidth;
    outerRadius = outerRadius - totalWidth;
  }
  startAngle = Math.PI * 1.5;
  percentFill = DvtGaugeRenderer.getFillPercentage(options, options['min'], options['max'], value);
  angleExtent = 2 * percentFill * Math.PI;
  DvtStatusMeterGaugeRenderer._drawCircularArc(gauge, container, bounds, startAngle, angleExtent, innerRadius, outerRadius, DvtGaugeStyleUtils.getColor(gauge), false);

  // Reference lines
  var referenceObjects = options['referenceLines'];
  if (referenceObjects) {
    for (var i = 0;i < referenceObjects.length;i++) {
      var referenceLineColor = referenceObjects[i]['color'] ? referenceObjects[i]['color'] : "black";
      value = referenceObjects[i]['value'];
      angle = Math.PI * 1.5 + DvtGaugeRenderer.getFillPercentage(options, options['min'], options['max'], value) * 2 * Math.PI;
      DvtStatusMeterGaugeRenderer._drawCircularReferenceLine(gauge, container, bounds, angle, referenceLineColor);
    }
  }
  // Overlay rectangle to catch mouse clicks
  var overlayRect = new DvtRect(gauge.getCtx(), bounds.x, bounds.y, bounds.w, bounds.h);
  overlayRect.setInvisibleFill();
  container.addChild(overlayRect);

  // Tooltip
  var tooltip = options['shortDesc'];
  if (tooltip || gauge.__getOptions()['readOnly'] === false)
    gauge.__getEventManager().associate(overlayRect, new DvtSimpleObjPeer(null, tooltip, DvtGaugeStyleUtils.getColor(gauge)));
}

/**
 * Renders the status meter shape into the specified area.
 * @param {DvtStatusMeterGauge} gauge The gauge being rendered.
 * @param {DvtContainer} container The container to render into.
 * @param {DvtRectangle} bounds The available bounds for rendering.
 */
DvtStatusMeterGaugeRenderer._renderShape = function(gauge, container, bounds) {
  var options = gauge.__getOptions();
  var isRTL = DvtAgent.isRightToLeft(gauge.getCtx());
  // Create an axis info to find the coords of values.
  var axisOptions = {'layout': {}};
  axisOptions['layout']['gapRatio'] = 0;
  axisOptions['timeAxisType'] = "disabled";
  axisOptions['position'] = "bottom";
  axisOptions['min'] = options['min'];
  axisOptions['max'] = options['max'];
  axisOptions['dataMin'] = options['min'];
  axisOptions['dataMax'] = options['max'];
  axisOptions['tickLabel'] = {'rendered': "off"};

  var axisInfo = DvtAxisInfo.newInstance(gauge.getCtx(), axisOptions, bounds);

  // Store the axisInfo on the gauge for editing support
  gauge.__axisInfo = axisInfo;

  // First calculate the baseline coordinate.
  var baseline = 0;
  if(options['max'] < 0)
    baseline = options['max'];
  else if(options['min'] > 0)
    baseline = options['min'];

  var baselineCoord = axisInfo.getCoordAt(baseline);
  // For statusmeters with plot area on, always draw from min value
  if(options['plotArea']['rendered']!="off" &&
  !((options['plotArea']['rendered']=="auto") && (options['thresholdDisplay'] == "onIndicator"))) 
    baselineCoord=axisInfo.getUnboundedCoordAt(options['min']);
    
  // Calculate the endCoord.  Adjust to keep within the axis.
  var endCoord = axisInfo.getUnboundedCoordAt(options['value']);
  endCoord = Math.max(bounds.x, Math.min(bounds.x + bounds.w, endCoord));
  var plotAreaEnd = 0;
  
  if(options['min'] < 0 && options['value'] < 0)
    plotAreaEnd = axisInfo.getUnboundedCoordAt(options['min']);
  else 
    plotAreaEnd = axisInfo.getUnboundedCoordAt(options['max']);
  plotAreaEnd = Math.max(bounds.x, Math.min(bounds.x + bounds.w, plotAreaEnd));
  
  var plotY1 = bounds.y;
  var plotY2 = bounds.y + bounds.h;
  
  var indicatorY1 = bounds.y + (1 - options['indicatorSize']) / 2 * bounds.h;
  var indicatorY2 = bounds.y + bounds.h * (1 - (1 - options['indicatorSize']) / 2);
  
  var roundCorners = true;
  var bRender = true;
  if(endCoord == baselineCoord)
    bRender = false;// don't draw an empty bar
  // Create plotArea
  var borderColor = DvtGaugeStyleUtils.getBorderColor(gauge);
  var plotAreaBorderColor=options['plotArea']['borderColor'];
  var thresholds = options['thresholds'];
  
  // Case for plot area with all thresholds displayed
  if(thresholds && options['plotArea']['rendered']!="off" && options['thresholdDisplay'] == "all") {
    for(var i = thresholds.length - 1;i >= 0;i--) {
      var currentThresholdIndex=i;
      var plotArea = DvtStatusMeterGaugeRenderer._createShape(gauge, gauge.getCtx(), baselineCoord, plotAreaEnd, plotY1, plotY2, roundCorners);
      
      var cp = new DvtClipPath("pacp" + gauge.getId());
      
      // For each threshold clip everything above the particular threshold maximum from the plot area shape
      if(currentThresholdIndex == thresholds.length - 1) {
        // Bug 16318242, need to add 1 to width clip path to account for border.
        if(isRTL)
          cp.addRect(axisInfo.getUnboundedCoordAt(options['max']), 0, bounds.w + 2, plotY2 - plotY1 + 2, 0, 0);
        else
          cp.addRect(0, 0, bounds.w + 2, plotY2 - plotY1 + 2, 0, 0);
      }
      else
      {
        if(isRTL) {
          var thresholdMax = thresholds[thresholds.length - 2 - currentThresholdIndex]['max'] == null ? 100 : thresholds[thresholds.length - 2 - currentThresholdIndex]['max'];
          cp.addRect(axisInfo.getUnboundedCoordAt(options['max']), 0, (options['max'] - thresholdMax) * 1 / (Math.abs(baseline - options['max'])) * bounds.w, plotY2 - plotY1 + 2, 0, 0);
        }
        else
          cp.addRect(0, 0, (thresholds[currentThresholdIndex]['max']) * 1 / (Math.abs(baseline - options['max'])) * bounds.w, plotY2 - plotY1 + 2, 0, 0);
      }
      plotArea.setClipPath(cp);

      // Color threshold with defined color, or use the color ramp if possible
      if(isRTL)
        currentThresholdIndex = thresholds.length - 1-i;
        
      plotArea.setSolidFill(DvtGaugeStyleUtils.getThresholdColor(gauge, thresholds[currentThresholdIndex],currentThresholdIndex));
      plotArea.setSolidStroke(plotAreaBorderColor);
      DvtStatusMeterGaugeRenderer._renderPlotAreaVisualEffects(gauge, container, plotArea, DvtGaugeStyleUtils.getThresholdColor(gauge, thresholds[currentThresholdIndex],currentThresholdIndex));
    }
  }
  else if(!(options['plotArea']['rendered']=="off") && 
  !((options['plotArea']['rendered']=="auto") && (options['thresholdDisplay'] == "onIndicator")) &&
  options['thresholdDisplay'] != "all") {
    var plotArea = DvtStatusMeterGaugeRenderer._createShape(gauge, gauge.getCtx(),  axisInfo.getUnboundedCoordAt(options['min']),  axisInfo.getUnboundedCoordAt(options['max']), plotY1, plotY2, roundCorners);
    var plotAreaColor = DvtGaugeStyleUtils.getPlotAreaColor(gauge);
    plotArea.setSolidFill(plotAreaColor);
    plotArea.setSolidStroke(plotAreaBorderColor);
    DvtStatusMeterGaugeRenderer._renderPlotAreaVisualEffects(gauge, container, plotArea, plotAreaColor);
  }

  // Create the indicator. 

  var startX = isRTL ? baselineCoord - .5 : baselineCoord + .5;
  var endX = isRTL ?  endCoord + .5 : endCoord - .5;
  var shape = DvtStatusMeterGaugeRenderer._createShape(gauge, gauge.getCtx(), startX, endX, indicatorY1+.5, indicatorY2-.5, true);
  gauge.__shapes.push(shape);
   
  // Apply style properties
  var color = DvtGaugeStyleUtils.getColor(gauge);
  if(!DvtGaugeDefaults.isSkyrosSkin(gauge) && options['visualEffects'] != "none") {
    var arColors = [DvtColorUtils.adjustHSL(color, 0, -.09, .04), DvtColorUtils.adjustHSL(color, 0, -.04, -.05)];
    var arAlphas = [1, 1];
    var arStops = [0, 1];
    var gradient = new DvtLinearGradientFill(270, arColors, arAlphas, arStops);  
    shape.setFill(gradient);
  }
  else
    shape.setSolidFill(color);
    
  if(borderColor)
    shape.setSolidStroke(borderColor);

  // Add the shape  
  if(bRender)
    container.addChild(shape);
    
  // Render the visual effects
  var overlay = DvtStatusMeterGaugeRenderer._createShape(gauge, gauge.getCtx(), baselineCoord, endCoord, indicatorY1, indicatorY2, true);
  DvtStatusMeterGaugeRenderer._renderVisualEffects(gauge, container, overlay, bRender);

  // Render referenceObjects
  var referenceObjects = options['referenceLines'];
  if(referenceObjects)
  {
    for(var i=0; i<referenceObjects.length; i++) {
      var color = referenceObjects[i]['color'] ? referenceObjects[i]['color'] : "white";
      var value = referenceObjects[i]['value'];
      var indicatorHeight = options['indicatorSize'];
      var referenceLineHeight = ((1 - indicatorHeight) / 2 +indicatorHeight)* bounds.h
      var referenceLine = new DvtRect(gauge.getCtx(), axisInfo.getUnboundedCoordAt(value)-1, bounds.y+((1 - indicatorHeight) / 4) * bounds.h, 2, referenceLineHeight);
      referenceLine.setSolidFill(color); 
      // Shadowing effect
      var shadowRGBA = DvtColorUtils.makeRGBA(0,0,0,0.8);
      var shadow =  new DvtShadow(shadowRGBA, 0.75, 3, 3, 50, 1, 2, false, false, false);
      container.addChild(referenceLine);
      referenceLine.addDrawEffect(shadow);
    }
  } 
  
  // Tooltip and Editable Support: Draw a shape containing the entire axis area
  var axisArea = new DvtRect(gauge.getCtx(), bounds.x, bounds.y, bounds.w, bounds.h);
  axisArea.setInvisibleFill(); // set to invisible
  container.addChild(axisArea);
  
  var tooltip = options['shortDesc'];
  if(tooltip || options['readOnly'] === false)
    gauge.__getEventManager().associate(axisArea, new DvtSimpleObjPeer(null, tooltip, color));
}

/**
 * Creates and returns the shape for the statusmeter.
 * @param {DvtStatusMeterGauge} gauge The gauge being rendered.
 * @param {DvtContext} context
 * @param {number} baselineCoord
 * @param {number} endCoord
 * @param {number} y1
 * @param {number} y2
 * @param {Boolean} roundCorners
 * @return {DvtShape}
 */
DvtStatusMeterGaugeRenderer._createShape = function(gauge, context, baselineCoord, endCoord, y1, y2, roundCorners) {
  return new DvtStatusMeterGaugeIndicator(gauge, context, baselineCoord, endCoord, y1, y2, roundCorners);
}

/**
 * Renders the visual effects for the shape into the specified area.
 * @param {DvtStatusMeterGauge} gauge The gauge being rendered.
 * @param {DvtContainer} container The container to render into.
 * @param {DvtShape} shape The shape to use for the visual effects.
 * @param {boolean} bRender True if the shape should be rendered at this time.
 */
DvtStatusMeterGaugeRenderer._renderVisualEffects = function(gauge, container, shape, bRender) {
  var options = gauge.__getOptions();
  
  if(options['visualEffects'] == "none")
    return;
  
  // Gradient
  if(DvtGaugeDefaults.isSkyrosSkin(gauge)) {
    var arColors = ["#FFFFFF", "#FFFFFF", "#FFFFFF"];
    var arAlphas = [0.5, 0.3125, 0];
    var arStops = [0, 0.3, 1.0];
    var gradient = new DvtLinearGradientFill(270, arColors, arAlphas, arStops);
    shape.setFill(gradient);
    gauge.__shapes.push(shape);
    
    // Overlay Shape
    shape.setMouseEnabled(false);
    if(bRender)
      container.addChild(shape);
  }
}

/**
 * Renders the visual effects for the plot area.
 * @param {DvtStatusMeterGauge} gauge The gauge being rendered.
 * @param {DvtContainer} container The container to render into.
 * @param {DvtShape} shape The plot area.
 */
DvtStatusMeterGaugeRenderer._renderPlotAreaVisualEffects = function(gauge, container, shape, color) {
  var options = gauge.__getOptions();
  shape.setMouseEnabled(false);
  container.addChild(shape);
  
  if(options['visualEffects'] == "none")
    return;
    
  // Gradient
  if(DvtGaugeDefaults.isSkyrosSkin(gauge)) {
    var arColors = [DvtColorUtils.getDarker(color, .9), color, DvtColorUtils.getBrighter(color, .7)];
    var gradient = new DvtLinearGradientFill(270, arColors, [1, 1, 1], [0, 0.04, 0.73]);
  }
  else {
    var arColors = [DvtColorUtils.adjustHSL(color, 0, -.04, -.05), DvtColorUtils.adjustHSL(color, 0, -.09, .04)];
    var gradient = new DvtLinearGradientFill(270, arColors, [1, 1], [0, 1]);
  }
  shape.setFill(gradient);
}

/**
 * Renders the label into the specified area.  Updates the bounds after rendering to reserve space
 * for the labels.
 * @param {DvtStatusMeterGauge} gauge The gauge being rendered.
 * @param {DvtContainer} container The container to render into.
 * @param {DvtRectangle} bounds The available bounds for rendering.
 */
DvtStatusMeterGaugeRenderer._renderLabel = function(gauge, container, bounds) {
  var options = gauge.__getOptions();
  var isRTL = DvtAgent.isRightToLeft(gauge.getCtx());
  // Set font size if there isn't any
  if(options['metricLabel']['style'] && (!options['metricLabel']['style'].getStyle("font-size"))) 
    options['metricLabel']['style'].setStyle("font-size", "13px");
    
  // Allocate space for the label
  if(options['metricLabel']['rendered'] == "on") 
  {
    // Check if the metric label's height will fit
    var label = new DvtOutputText(gauge.getCtx(), "");
    label.setCSSStyle(options['metricLabel']['style']);
    if(DvtTextUtils.guessTextDimensions(label).h > bounds.h)
      return;
  
    var labelGap = options['__layout']['labelGap'];
    var alignCoord; // The horizontal alignment point for the label

    // Allocate space to the right for positive values and any values with plotArea
    if(options['max'] > 0 || options['plotArea']['rendered']!="off" ||
       !((options['plotArea']['rendered']=="auto") && (options['thresholdDisplay'] == "onIndicator"))) {
      var bound=options['max'] > 0 ? options['max'] : options['min'];  
      var maxValue = DvtGaugeRenderer.getFormattedMetricLabel(bound, gauge);
      var maxLabel = new DvtOutputText(gauge.getCtx(), maxValue);
      maxLabel.setCSSStyle(options['metricLabel']['style']);
      var maxLabelDims = maxLabel.measureDimensions();
      
      // Align the label
      alignCoord = isRTL ? bounds.x + maxLabelDims.w: bounds.x + bounds.w;
      labelSpace = maxLabelDims.w;
      
      // Update the allocated space
      if(isRTL) { // Allocate to the left
        bounds.x += (maxLabelDims.w + labelGap);
        bounds.w -= (maxLabelDims.w + labelGap);
      }
      else // Allocate to the right
        bounds.w -= (maxLabelDims.w + labelGap);
    } 
    
    // Allocate space to the left for negative values
    if(options['min'] < 0 && options['plotArea']['rendered'] != "on" && !(options['plotArea']['rendered'] == "auto" && (options['thresholdDisplay'] == "onIndicator"))) {
      var minValue = DvtGaugeRenderer.getFormattedMetricLabel(options['min'], gauge);
      var minLabel = new DvtOutputText(gauge.getCtx(), minValue);
      minLabel.setCSSStyle(options['metricLabel']['style']);
      var minLabelDims = minLabel.measureDimensions();
      
      // Align the label
      if(options['value'] < 0 || options['max'] <= 0) {
        alignCoord = isRTL ? bounds.x + bounds.w: bounds.x + minLabelDims.w;
        labelSpace = minLabelDims.w; 
      }
      
      // Update the allocated space
      if(isRTL)  // Allocate to the right
        bounds.w -= (minLabelDims.w + labelGap);
      else { // Allocate to the left
        bounds.x += (minLabelDims.w + labelGap);
        bounds.w -= (minLabelDims.w + labelGap);
      }
    }
    
    // Create and position the text
    var labelString = DvtGaugeRenderer.getFormattedMetricLabel(options['value'], gauge);
    label.setTextString(labelString);
    label.setX(alignCoord);
    label.setY(bounds.y + bounds.h/2);
    label.alignMiddle();
    label.alignRight();
    
    // Truncate if needed, null is returned if the label doesn't fit
    if(DvtTextUtils.fitText(label, labelSpace, bounds.h, container)) {
      // Show tooltip for truncated text
      if(label.isTruncated())
        gauge.__getEventManager().associate(label, new DvtSimpleObjPeer(labelString));
    }
  }
}

/**
 * Returns the location of the point on the arc with the specified radius 
 * at the specified angle.
 * @private
 */
DvtStatusMeterGaugeRenderer._calcPointOnArc = function(bounds, radius, angle) {
  var x = Math.cos(angle) * radius + bounds.w/2 + bounds.x;
  var y = Math.sin(angle) * radius + bounds.h/2 + bounds.y;
  return {x:x, y:y};
}

/**
 * Draw specified segment for circular status meter
 * @param {DvtStatusMeterGauge} gauge The gauge being rendered.
 * @param {DvtContainer} container The container to render into.
 * @param {DvtRectangle} bounds The available bounds for rendering.
 * @param {Number} startAngle Start angle.
 * @param {Number} angleExtent Angle from start to end.
 * @param {Number} innerRadius Radius to inner border of arc.
 * @param {Number} outerRadius Radius to outer border of arc..
 * @param {color} color Color of the arc.
 * @param {Boolean} isPlotArea True if arc being drawn is the plot area.
 */
DvtStatusMeterGaugeRenderer._drawCircularArc = function(gauge, container, bounds, startAngle, angleExtent, innerRadius, outerRadius, color, isPlotArea) {
  var context = gauge.getCtx();
  var isRTL = DvtAgent.isRightToLeft(gauge.getCtx());
  if(isRTL) {
    startAngle = Math.PI - startAngle - angleExtent;
    startAngle = startAngle > 0 ? startAngle : startAngle + 2 * Math.PI; 
  }

  var shape = new DvtStatusMeterGaugeCircularIndicator(context, bounds, startAngle, angleExtent, innerRadius, outerRadius);
  gauge.__shapes.push(shape);
  shape.setSolidFill(color);
  var borderColor = DvtGaugeStyleUtils.getBorderColor(gauge);
  if(borderColor && !isPlotArea)
    shape.setSolidStroke(borderColor);
  container.addChild(shape);
}

/**
 * Draw reference line
 * @param {DvtStatusMeterGauge} gauge The gauge being rendered.
 * @param {DvtContainer} container The container to render into.
 * @param {DvtRectangle} bounds The available bounds for rendering.
 * @param {Number} angle Angle at which line is drawn.
 * @param {color} color Color of the arc.
 */
DvtStatusMeterGaugeRenderer._drawCircularReferenceLine = function(gauge, container, bounds, angle, color) {
  var context = gauge.getCtx();
  var maxDiameter = Math.min(bounds.w, bounds.h);
  var innerRadius = maxDiameter * .275;
  var outerRadius = maxDiameter * .5;
  if(DvtAgent.isRightToLeft(gauge.getCtx())) {
    angle = Math.PI - angle;
    angle = angle > 0 ? angle : angle + 2 * Math.PI; 
  }
  p1 = DvtStatusMeterGaugeRenderer._calcPointOnArc(bounds, innerRadius, angle);
  p2 = DvtStatusMeterGaugeRenderer._calcPointOnArc(bounds, outerRadius, angle);
  var shape = new DvtLine(context, p1.x, p1.y, p2.x, p2.y);
  shape.setSolidFill(color);
  shape.setSolidStroke(color, 1, 2);
  container.addChild(shape);
}
// Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.

/**
 * Indicator for DvtStatusMeterGauge.
 * @class
 * @constructor
 * @extends {DvtRect}
 */
 DvtStatusMeterGaugeIndicator = function(gauge, context, baselineCoord, endCoord, y1, y2, roundCorners) {
  this.Init(gauge, context, baselineCoord, endCoord, y1, y2, roundCorners);
}

DvtObj.createSubclass(DvtStatusMeterGaugeIndicator, DvtRect, "DvtStatusMeterGaugeIndicator");

/** @private **/
DvtStatusMeterGaugeIndicator._MIN_CORNER_RADIUS = 2.5;


/**
 * Initializes the component.
 * @param {DvtStatusMeterGauge} gauge The gauge being rendered.
 * @param {DvtContext} context The rendering context
 * @param {number} baselineCoord
 * @param {number} endCoord
 * @param {number} y1
 * @param {number} y2
 * @param {Boolean} roundCorners
 * @protected
 */
DvtStatusMeterGaugeIndicator.prototype.Init = function(gauge, context, baselineCoord, endCoord, y1, y2, roundCorners) {
  DvtStatusMeterGaugeIndicator.superclass.Init.call(this, context);
  this._gauge = gauge;
  this._roundCorners = roundCorners
  // Set the coordinates of the shape based on the params
  this.setCoords(baselineCoord, endCoord, y1, y2);
}

/**
 * Specifies the coordinates for the indicator.
 * @param {DvtStatusMeterGauge} gauge The gauge being rendered.
 * @param {number} baselineCoord
 * @param {number} endCoord
 * @param {number} y1
 * @param {number} y2
 * @param {Boolean} roundCorners
 */
DvtStatusMeterGaugeIndicator.prototype.setCoords = function(baselineCoord, endCoord, y1, y2) {
  // Store these params
  this._baselineCoord = baselineCoord;
  this._endCoord = endCoord;
  this._y1 = y1;
  this._y2 = y2;

  // Convert into rectangle coordinates and set
  var x = Math.min(baselineCoord, endCoord);
  var y = y1;
  var width = Math.abs(baselineCoord - endCoord);
  var height = y2 - y1;
  this.setRect(x, y, width, height);
  
  // Apply rounded corners
  if(this._roundCorners){
    var radius = height * (DvtGaugeDefaults.isSkyrosSkin(this._gauge) ? .25 : .15);
    if(radius >= DvtStatusMeterGaugeIndicator._MIN_CORNER_RADIUS)
      this.setCornerRadius(radius, radius);
  }
}

/**
 * Animation support.
 * @return {array}
 */
DvtStatusMeterGaugeIndicator.prototype.getAnimationParams = function() {
  return [this._baselineCoord, this._endCoord, this._y1, this._y2];
}

/**
 * Animation support.
 * @param {array} params
 */
DvtStatusMeterGaugeIndicator.prototype.setAnimationParams = function(params) {
  if(params && params.length == 4) 
    this.setCoords(params[0], params[1], params[2], params[3]);
}
// Copyright (c) 2008, 2013, Oracle and/or its affiliates. 
// All rights reserved. 

/**
 * Indicator for the circular DvtStatusMetergauge.
 * @class
 * @constructor
 * @extends {DvtPath}
 */
var DvtStatusMeterGaugeCircularIndicator = function(context, bounds, startAngle, angleExtent, innerRadius, outerRadius) {
  this.Init(context, bounds, startAngle, angleExtent, innerRadius, outerRadius);
}

DvtObj.createSubclass(DvtStatusMeterGaugeCircularIndicator, DvtPath, "DvtStatusMeterGaugeCircularIndicator");


/**
 * Initializes the component.
 * @param {DvtContext} context The rendering context
 * @param {number} baselineCoord
 * @param {number} endCoord
 * @param {number} y1
 * @param {number} y2
 * @param {Boolean} roundCorners
 * @protected
 */
DvtStatusMeterGaugeCircularIndicator.prototype.Init = function(context, bounds, startAngle, angleExtent, innerRadius, outerRadius) {
  DvtStatusMeterGaugeCircularIndicator.superclass.Init.call(this, context);
  
  // Set the coordinates of the shape based on the params
  this.setPath(bounds, startAngle, angleExtent, innerRadius, outerRadius);
}

/**
 * Specifies the coordinates for the indicator.
 * @param {number} baselineCoord
 * @param {number} endCoord
 * @param {number} y1
 * @param {number} y2
 * @param {Boolean} roundCorners
 */
DvtStatusMeterGaugeCircularIndicator.prototype.setPath = function(bounds, startAngle, angleExtent, innerRadius, outerRadius) {
  var cmd;
  var p1, p2, p3, p4;
  if(bounds && (bounds instanceof DvtRectangle))
    this._bounds = bounds;
  else
    bounds = this._bounds;
  this._startAngle = startAngle;
  this._angleExtent = angleExtent;
  this._innerRadius = innerRadius;
  this._outerRadius = outerRadius;
  if(angleExtent < Math.PI*2) 
  {
    // Calc the 4 points.  We will draw:
    // 1. Arc from p1 to p2
    // 2. Line/Move from p2 to p3
    // 3. Arc from p3 to p4
    // 4. Line from p4 to p1    
    p1 = DvtStatusMeterGaugeRenderer._calcPointOnArc(bounds, outerRadius, startAngle);
    p2 = DvtStatusMeterGaugeRenderer._calcPointOnArc(bounds, outerRadius, startAngle + angleExtent);
    p3 = DvtStatusMeterGaugeRenderer._calcPointOnArc(bounds, innerRadius, startAngle + angleExtent);
    p4 = DvtStatusMeterGaugeRenderer._calcPointOnArc(bounds, innerRadius, startAngle);
    
    // Create the command and feed it into the path
    cmd = DvtPathUtils.moveTo(p1.x,p1.y) + 
          DvtPathUtils.arcTo(outerRadius,outerRadius,angleExtent,1,p2.x,p2.y) +
          DvtPathUtils.lineTo(p3.x,p3.y) + 
          DvtPathUtils.arcTo(innerRadius,innerRadius,angleExtent,0,p4.x,p4.y) + 
          DvtPathUtils.closePath();
  }
  else 
  {
    // To work around a chrome/safari bug, we draw two segments around each of the outer and inner arcs 
    p1 = DvtStatusMeterGaugeRenderer._calcPointOnArc(bounds, outerRadius, startAngle);
    p2 = DvtStatusMeterGaugeRenderer._calcPointOnArc(bounds, outerRadius, startAngle + angleExtent/2);
    p3 = DvtStatusMeterGaugeRenderer._calcPointOnArc(bounds, innerRadius, startAngle);
    p4 = DvtStatusMeterGaugeRenderer._calcPointOnArc(bounds, innerRadius, startAngle + angleExtent/2);
    
    // Create the command and return it
    cmd = DvtPathUtils.moveTo(p1.x,p1.y) + 
          DvtPathUtils.arcTo(outerRadius,outerRadius,angleExtent/2,1,p2.x,p2.y) + 
          DvtPathUtils.arcTo(outerRadius,outerRadius,angleExtent/2,1,p1.x,p1.y);
    
    // Add the inner segment for a hollow center        
    if(innerRadius > 0)
      cmd += DvtPathUtils.moveTo(p4.x,p4.y) + 
             DvtPathUtils.arcTo(innerRadius,innerRadius,angleExtent/2,0,p3.x,p3.y) + 
             DvtPathUtils.arcTo(innerRadius,innerRadius,angleExtent/2,0,p4.x,p4.y);
             
    cmd += DvtPathUtils.closePath();
  }
  this.setCmds(cmd);
}

/**
 * Animation support.
 * @return {array}
 */
DvtStatusMeterGaugeCircularIndicator.prototype.getAnimationParams = function() {
  return [this._bounds, this._startAngle, this._angleExtent, this._innerRadius, this._outerRadius];
}

/**
 * Animation support.
 * @param {array} params
 */
DvtStatusMeterGaugeCircularIndicator.prototype.setAnimationParams = function(params) {
  if(params && params.length == 5) 
    this.setPath(params[0], params[1], params[2], params[3], params[4]);
}
// Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.

/**
 * Dial Gauge component.  This class should never be instantiated directly.  Use the
 * newInstance function instead.
 * @class
 * @constructor
 * @extends {DvtGauge}
 * @export
 */
var DvtDialGauge = function() {}

DvtObj.createSubclass(DvtDialGauge, DvtGauge, "DvtDialGauge");

/**
 * Returns a new instance of DvtDialGauge.
 * @param {DvtContext} context The rendering context.
 * @param {string} callback The function that should be called to dispatch component events.
 * @param {object} callbackObj The optional object instance on which the callback function is defined.
 * @return {DvtDialGauge}
 * @export
 */
DvtDialGauge.newInstance = function(context, callback, callbackObj) {
  var gauge = new DvtDialGauge();
  gauge.Init(context, callback, callbackObj);
  return gauge;
}

/**
 * @override
 */
DvtDialGauge.prototype.Init = function(context, callback, callbackObj) {
  DvtDialGauge.superclass.Init.call(this, context, callback, callbackObj);
  
  // Create the defaults object
  this.Defaults = new DvtDialGaugeDefaults();
  
  /**
   * The anchor point of the indicator on the gauge. This will be set during render time and is used for editing support.
   * @type {DvtPoint}
   */
  this.__anchorPt = null;
}

/**
 * @override
 */
DvtDialGauge.prototype.SetOptions = function(options) {
  // Combine the user options with the defaults and store
  DvtDialGauge.superclass.SetOptions.call(this, this.Defaults.calcOptions(options));
}

/**
 * @override
 */
DvtDialGauge.prototype.Render = function(container, width, height) 
{  
  DvtDialGaugeRenderer.render(this, container, width, height);
}

/**
 * @override
 */
DvtDialGauge.prototype.CreateAnimationOnDisplay = function(objs, animationType, animationDuration) {
  // The only object in objs will be a DvtDialGaugeIndicator
  var animatedObjs = [];
  for (var i=0; i<objs.length; i++) {
    var obj = objs[i];
    var endState = obj.getAnimationParams();
    
    // Set the initial state, which is the start angle
    var startAngle = DvtDialGaugeRenderer.__getStartAngle(this)
    obj.setAngle(startAngle);
    
    // Create the animation
    var animation = new DvtCustomAnimation(this.getCtx(), obj, animationDuration);
    animation.getAnimator().addProp(DvtAnimator.TYPE_NUMBER_ARRAY, obj, obj.getAnimationParams, obj.setAnimationParams, endState);
    animation.getAnimator().setEasing(function(progress) {return DvtEasing.backOut(progress, 0.7);});
    animatedObjs.push(animation);
  }
  return new DvtParallelPlayable(this.getCtx(), animatedObjs);
}

/**
 * @override
 */
DvtDialGauge.prototype.GetValueAt = function(x, y) {
  var angleRads = Math.atan2(y - this.__anchorPt.y, x - this.__anchorPt.x); 
  var angle = DvtMath.radsToDegrees(angleRads);
  if(angle <= 0) // adjust to (0, 360]
    angle += 360;
  
  // Calculate the start angle and extent
  var isRTL = DvtAgent.isRightToLeft(this.getCtx());
  var backgroundOptions = this.__getOptions()['background'];
  var startAngle = isRTL ? 180+backgroundOptions['startAngle'] : 360-backgroundOptions['startAngle'];
  var angleExtent = backgroundOptions['angleExtent'];  
  var endAngle = startAngle + angleExtent;
  
  // Adjust for BIDI
  if(isRTL) {
    endAngle = startAngle;
    startAngle = startAngle - angleExtent;
    while(startAngle < 0) {
      startAngle += 360;
      endAngle += 360;
    }
  }
  
  // Normalize the angles.  At this point: 
  // start angle is between [0, 360)
  // input angle is between (0, 360]
  // end angle is between (0 and 720)
  if(angle + 360 >= startAngle && angle + 360 <= endAngle) {
    // Angle is between the start and endAngle, where angle and endAngle > 360
    angle += 360;
  }
  else if(!(angle >= startAngle && angle <= endAngle)) 
  {
    // Input angle is not between the start and end
    if(angle > endAngle)
      angle = (startAngle + 360 - angle < angle - endAngle) ? startAngle : endAngle;
    else 
      angle = (startAngle - angle < angle + 360 - endAngle) ? startAngle : endAngle;
  }
 
  // Calculate and adjust ratio to keep in bounds
  var ratio = (angle - startAngle)/angleExtent;
  if(isRTL) // flip for BIDI, since we flipped the start and end
    ratio = 1 - ratio;
  
  var minValue = this.Options['min'];
  var maxValue = this.Options['max'];
  var value = (ratio * (maxValue-minValue)) + minValue;
  return value;
}
/**
 * Default values and utility functions for component versioning.
 * @class
 * @constructor
 * @extends {DvtGaugeDefaults}
 */
var DvtDialGaugeDefaults = function() {
  this.Init({'skyros': DvtDialGaugeDefaults.VERSION_1, 'alta': {}});
}

DvtObj.createSubclass(DvtDialGaugeDefaults, DvtGaugeDefaults, "DvtDialGaugeDefaults");

/**
 * Defaults for version 1.
 */ 
DvtDialGaugeDefaults.VERSION_1 = {
  'background': {'startAngle': 180, 'angleExtent': 180, 'indicatorLength': 0.7},
  'metricLabel': {'style': new DvtCSSStyle("font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;")},
  'tickLabel': {
    'scaling': "auto",
    'style': new DvtCSSStyle("font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;")
  }
}
/**
 * Renderer for DvtDialGauge.
 * @class
 */
var DvtDialGaugeRenderer = new Object();

DvtObj.createSubclass(DvtDialGaugeRenderer, DvtObj, "DvtDialGaugeRenderer");

/**
 * Renders the gauge in the specified area.
 * @param {DvtDialGauge} gauge The gauge being rendered.
 * @param {DvtContainer} container The container to render into.
 * @param {number} width The width of the component.
 * @param {number} height The height of the component.
 */
DvtDialGaugeRenderer.render = function(gauge, container, width, height) {
  if(DvtGaugeDataUtils.hasData(gauge)) {
    // Create the bounds.  No outer gap is allocated to retain image fidelity.
    var bounds = new DvtRectangle(0, 0, width, height);

    // Render the bar
    DvtDialGaugeRenderer._renderShape(gauge, container, bounds);

    // Render the label
    DvtDialGaugeRenderer._renderLabel(gauge, container, bounds);
  }
  else // Render the empty text
    DvtGaugeRenderer.renderEmptyText(gauge, container, new DvtRectangle(0, 0, width, height));
}

/**
 * Renders the led shape into the specified area.
 * @param {DvtDialGauge} gauge The gauge being rendered.
 * @param {DvtContainer} container The container to render into.
 * @param {DvtRectangle} bounds The available bounds for rendering.
 */
DvtDialGaugeRenderer._renderShape = function(gauge, container, bounds) {
  var options = gauge.__getOptions();
  
  // Create the background
  var background = DvtDialGaugeRenderer._createBackground(gauge, bounds);
  container.addChild(background);
  
  //Add Tick Labels if needed
  if(options['background']['majorTickCount'] && options['background']['radius'])
    DvtDialGaugeRenderer._renderTickLabels(gauge, container, bounds);
  
  // Create the indicator
  var indicator = DvtDialGaugeRenderer._createIndicator(gauge, bounds);
  
  // Create containers to separate the transforms so they can be adjusted later
  var translateContainer = new DvtContainer(gauge.getCtx());
  var rotateContainer = new DvtDialGaugeIndicator(gauge.getCtx());
  container.addChild(translateContainer);
  translateContainer.addChild(rotateContainer);
  rotateContainer.addChild(indicator);
  
  // Calculate the anchor points and the rotation
  var indicatorBounds = indicator.getDimensions();
  var angleRads = DvtDialGaugeRenderer._getRotation(gauge, options['value']);
  var backgroundAnchor = DvtDialGaugeRenderer._getBackgroundAnchorPoint(gauge, bounds);
  var indicatorAnchor = DvtDialGaugeRenderer._getIndicatorAnchorPoint(gauge, bounds, indicatorBounds);
  var scale = DvtDialGaugeRenderer._getIndicatorScaleFactor(gauge, bounds, indicatorBounds);
  
  // Apply the transformations to correctly position the indicator
  // 1. Translate the indicator so that the anchor point is at the origin
  var mat = new DvtMatrix();
  mat.translate(-indicatorAnchor.x, -indicatorAnchor.y);
  mat.scale(scale, scale);
  indicator.setMatrix(mat);
  
  // 2. Rotate the indicator
  rotateContainer.setAngle(angleRads);
  
  // 3. Translate to the anchor point on the background 
  mat = new DvtMatrix();
  mat.translate(backgroundAnchor.x, backgroundAnchor.y);
  translateContainer.setMatrix(mat);
  
  // Add the DvtDialGaugeIndicator for rotation support
  gauge.__shapes.push(rotateContainer);
    
  // Tooltip Support
  var tooltip = options['shortDesc'];
  if(tooltip || gauge.__getOptions()['readOnly'] === false)
    gauge.__getEventManager().associate(container, new DvtSimpleObjPeer(null, tooltip));
    
  // Store the axisInfo on the gauge for editing support
  gauge.__anchorPt = backgroundAnchor;
}

/**
 * Creates and returns the background.
 * @param {DvtDialGauge} gauge The gauge being rendered.
 * @param {DvtRectangle} bounds The available bounds for rendering.
 * @retun {DvtDisplayable}
 */
DvtDialGaugeRenderer._createBackground = function(gauge, bounds) {
  var backgroundOptions = gauge.__getOptions()['background'];
  var isRTL = DvtAgent.isRightToLeft(gauge.getCtx());
  
  // Calculate the required resolution needed.  This check isn't ideal, but it's close enough for now.
  var isTouchDevice = DvtAgent.isTouchDevice();
  var widthRes = isTouchDevice ? 2*bounds.w : bounds.w;
  var heightRes = isTouchDevice ? 2*bounds.h : bounds.h;
  
  // Use the images from the list provided
  var images = backgroundOptions['images'];
  if(images && images.length > 0) {
    var i;
    var refWidth;
    var refHeight;
  
    // Filter the list to images matching the locale type (bidi or not)
    var locImages = [];
    for(i=0; i<images.length; i++) {
      var isImageRTL = (images[i]['dir'] == "rtl");
      if(isRTL && isImageRTL) 
        locImages.push(images[i]);
      else if(!isRTL && !isImageRTL)
        locImages.push(images[i]);
    }
    images = locImages.length > 0 ? locImages : images; // Use all images if none match the bidi flag
    
    // Iterate and use the first image with enough detail
    for(i=0; i<images.length; i++) {
      var image = images[i];
      var source = image['src'];
      var width = image['width'];
      var height = image['height'];
      var isSvg = (source && source.search(".svg") > -1);
      
      // Store the size of the first image as the reference size
      if(i == 0) {
        refWidth = width;
        refHeight = height;
      }
      
      // Use the image if it's SVG, a PNG whose size > resolution, or the last image provided.
      if(isSvg || (width >= widthRes && height >= heightRes) || i == images.length-1) {
        var shape = new DvtImage(gauge.getCtx(), source, 0, 0, width, height); 
        
        // Scale and translate to center
        var matrix = new DvtMatrix();
        var scale = Math.min(bounds.w/width, bounds.h/height);
        var tx = (bounds.w - scale*width)/2;
        var ty = (bounds.h - scale*height)/2;
        matrix.scale(scale, scale);
        matrix.translate(tx, ty);
        shape.setMatrix(matrix);
        
        // Create an image loader to set the width and height of the image after loads.  This is 
        // needed to correctly load svg images in webkit.
        if(isSvg && DvtAgent.isPlatformWebkit()) {
          var imageDims = DvtImageLoader.loadImage(gauge.getCtx(), source, DvtObj.createCallback(shape, shape.__setDimensions));
          if(imageDims) 
            shape.__setDimensions(imageDims);
        }
        
        // Adjust the bounds for the space used
        bounds.x += tx;
        bounds.y += ty;
        bounds.w = scale * width;
        bounds.h = scale * height;
        
        // Adjust the anchor for the bounds
        if(!isNaN(backgroundOptions['anchorX']) && !isNaN(backgroundOptions['anchorY'])) {
          // Store in private fields to avoid modifying the app provided copies
          backgroundOptions['_anchorX'] = isRTL ? bounds.x + bounds.w - bounds.w * backgroundOptions['anchorX']/refWidth : bounds.x + bounds.w * backgroundOptions['anchorX']/refWidth;
          backgroundOptions['_anchorY'] = bounds.y + bounds.h * backgroundOptions['anchorY']/refHeight;
        }
        // Adjust the metric label bounds
        if(backgroundOptions['metricLabelBounds']) {
          var metLblBounds = {};
          metLblBounds['width'] = bounds.w * backgroundOptions['metricLabelBounds']['width']/refWidth;
          metLblBounds['height'] = bounds.h * backgroundOptions['metricLabelBounds']['height']/refHeight;
          metLblBounds['y'] = bounds.y + bounds.h * backgroundOptions['metricLabelBounds']['y']/refHeight;
          if(isRTL)
            metLblBounds['x'] = bounds.x + bounds.w - bounds.w * backgroundOptions['metricLabelBounds']['x']/refWidth - metLblBounds['width'];
          else
            metLblBounds['x'] = bounds.x + bounds.w * backgroundOptions['metricLabelBounds']['x']/refWidth;
            
          backgroundOptions['_metricLabelBounds'] = metLblBounds;
          
          // Helper for integration of new custom gauges, comment out when not using
          /*var metBounds = new DvtRect(gauge.getCtx(), metLblBounds['x'], metLblBounds['y'], metLblBounds['width'], metLblBounds['height']);
          metBounds.setSolidFill("#0000FF", 0.3);
          gauge.addChild(metBounds);*/
        }
        
        // Scale radius of tick labels based on reference image size
        var radiusScale = Math.min(bounds.w/refWidth, bounds.h/refHeight);
        backgroundOptions['_radius'] = backgroundOptions['radius'] * radiusScale;      
        backgroundOptions['_tickLabelHeight'] = backgroundOptions['tickLabelHeight'] * bounds.h/refHeight; 
        backgroundOptions['_tickLabelWidth'] = backgroundOptions['tickLabelWidth'] * bounds.w/refWidth; 
        
        return shape;
      }
    }
  }
  return null;
}

/**
 * Creates and returns the indicator.
 * @param {DvtDialGauge} gauge The gauge being rendered.
 * @param {DvtRectangle} bounds The available bounds for rendering.
 * @return {DvtDisplayable}
 */
DvtDialGaugeRenderer._createIndicator = function(gauge, bounds) {
  var indicatorOptions = gauge.__getOptions()['indicator'];
  var indicatorLength = DvtDialGaugeRenderer._getIndicatorLength(gauge, bounds);
  
  // Calculate the required resolution needed.  This check isn't ideal, but it's close enough for now.
  var heightRes = DvtAgent.isTouchDevice() ? 2*indicatorLength : indicatorLength;
  
  // Iterate and use the first image with enough detail
  var refWidth;
  var refHeight;
  var images = indicatorOptions['images'];
  if(images && images.length > 0) {
    for(var i=0; i<images.length; i++) {
      var image = images[i];
      var source = image['src'];
      var width = image['width'];
      var height = image['height'];
      var isSvg = (source && source.search(".svg") > -1);
      
      // Store the size of the first image as the reference size
      if(i == 0) {
        refWidth = width;
        refHeight = height;
      }
      
      // Use the image if it's SVG, a PNG whose height > indicatorLength, or the last image provided.
      if(isSvg || height >= heightRes || i == images.length-1) {
        var shape = new DvtImage(gauge.getCtx(), source, 0, 0, width, height);
        
        // Create an image loader to set the width and height of the image after loads.  This is 
        // needed to correctly load svg images in webkit.
        if(isSvg && DvtAgent.isPlatformWebkit()) {
          var imageDims = DvtImageLoader.loadImage(gauge.getCtx(), source, DvtObj.createCallback(shape, shape.__setDimensions));
          if(imageDims) {
            // Once the image is initially loaded, ping it with the given size.  This is needed to get the
            // browser to correctly render the SVG.  The returned size from imageDims may not be correct
            // for SVG, so use the specified size instead.
            shape.setWidth(width);
            shape.setHeight(height);
          }
        }
       
        // Adjust the anchor for the image used
        if(!isNaN(indicatorOptions['anchorX']) && !isNaN(indicatorOptions['anchorY'])) {
          // Store in private fields to avoid modifying the app provided copies
          indicatorOptions['_anchorX'] = indicatorOptions['anchorX'] * width/refWidth;
          indicatorOptions['_anchorY'] = indicatorOptions['anchorY'] * height/refHeight;
        }
      
        // Return the image
        return shape;
      }
    }
  }
  return null;
}

/**
 * Returns the rotation angle for the start angle in radians.
 * @param {DvtDialGauge} gauge The gauge being rendered.
 * @return {Number}
 */
DvtDialGaugeRenderer.__getStartAngle = function(gauge) {
  var backgroundOptions = gauge.__getOptions()['background'];
  var isRTL = DvtAgent.isRightToLeft(gauge.getCtx());
  var startAngle = isRTL ? 180-backgroundOptions['startAngle'] : backgroundOptions['startAngle'];
  return Math.PI * (90 - startAngle)/180;
}

/**
 * Returns the rotation angle of the indicator in radians.
 * @param {DvtDialGauge} gauge The gauge being rendered.
 * @param {Number} value The value to be rotated to
 * @return {Number}
 */
DvtDialGaugeRenderer._getRotation = function(gauge, value) {
  var options = gauge.__getOptions();
  var backgroundOptions = options['background'];
  
  // Calculate the value as a ratio between the min and max
  var minValue = options['min'];
  var maxValue = options['max'];
  value = Math.max(Math.min(value, maxValue), minValue);
  var ratio = (value - minValue)/(maxValue - minValue);
  
  // Calculate the start angle and extent
  var isRTL = DvtAgent.isRightToLeft(gauge.getCtx());
  var startAngle = isRTL ? 180-backgroundOptions['startAngle'] : backgroundOptions['startAngle'];
  var angleExtent = isRTL ? -backgroundOptions['angleExtent'] : backgroundOptions['angleExtent'];
  
  // Convert to angles and return in radians
  var angleDegrees = startAngle - (ratio * angleExtent);
  return Math.PI * (90 - angleDegrees)/180;
}

/**
 * Returns the anchor point for the indicator on the background relative to the rendering bounds.
 * @param {DvtDialGauge} gauge The gauge being rendered.
 * @param {DvtRectangle} bounds The available bounds for rendering.
 * @return {DvtPoint}
 */
DvtDialGaugeRenderer._getBackgroundAnchorPoint = function(gauge, bounds) {
  var backgroundOptions = gauge.__getOptions()['background'];
  var anchorX = backgroundOptions['_anchorX'];
  var anchorY = backgroundOptions['_anchorY'];
  
  if(!isNaN(anchorX) && !isNaN(anchorY)) // private fields are calculated earlier and already scaled
    return new DvtPoint(anchorX, anchorY);
  else // default to center
    return new DvtPoint(bounds.x + bounds.w/2, bounds.y + bounds.h/2);
}

/**
 * Returns the length of the indicator.
 * @param {DvtDialGauge} gauge The gauge being rendered.
 * @param {DvtRectangle} bounds The available bounds for rendering.
 * @return {Number} The length of the indicator.
 */
DvtDialGaugeRenderer._getIndicatorLength = function(gauge, bounds) {
  var radius = Math.min(bounds.w, bounds.h)/2;
  return gauge.__getOptions()['background']['indicatorLength'] * radius;
}

/**
 * Returns the anchor point of the indicator relative to the indicator image.
 * @param {DvtDialGauge} gauge The gauge being rendered.
 * @param {DvtRectangle} bounds The available bounds for rendering.
 * @param {DvtRectangle} indicatorBounds The bounds for the indicator.
 * @return {DvtPoint}
 */
DvtDialGaugeRenderer._getIndicatorAnchorPoint = function(gauge, bounds, indicatorBounds) {
  var indicatorOptions = gauge.__getOptions()['indicator'];
  var anchorX = indicatorOptions['_anchorX'];
  var anchorY = indicatorOptions['_anchorY']; 
  
  if(!isNaN(anchorX) && !isNaN(anchorY)) 
    return new DvtPoint(anchorX, anchorY); // already adjusted for image size
  else // default to center of the bottom edge
    return new DvtPoint(indicatorBounds.x + indicatorBounds.w/2, indicatorBounds.y + indicatorBounds.h);
}

/**
 * Returns the scaling transform value for the indicator.
 * @param {DvtDialGauge} gauge The gauge being rendered.
 * @param {DvtRectangle} bounds The available bounds for rendering.
 * @param {DvtRectangle} indicatorBounds The bounds for the indicator.
 * @return {Number}
 */
DvtDialGaugeRenderer._getIndicatorScaleFactor = function(gauge, bounds, indicatorBounds) {
  var indicatorLength = DvtDialGaugeRenderer._getIndicatorLength(gauge, bounds);
  return indicatorLength/indicatorBounds.h;
}

/**
 * Renders the label into the specified area.
 * @param {DvtLedGauge} gauge The gauge being rendered.
 * @param {DvtContainer} container The container to render into.
 * @param {DvtRectangle} bounds The available bounds for rendering.
 */
DvtDialGaugeRenderer._renderLabel = function(gauge, container, bounds) {
  var options = gauge.__getOptions();

  // Create and position the label
  if(options['metricLabel']['rendered'] == "on") {
    var labelString = DvtGaugeRenderer.getFormattedMetricLabel(options['value'], gauge);
    var cx = bounds.x + bounds.w/2;
    var cy = bounds.y + bounds.h/2;
    var labelWidth = bounds.w;
    var labelHeight = bounds.h;
    
    // Use the metricLabelBounds if specified
    var metricLabelBounds = options['background']['_metricLabelBounds'];
    if(metricLabelBounds) {
      cx = metricLabelBounds['x'] + metricLabelBounds['width']/2;
      cy = metricLabelBounds['y'] + metricLabelBounds['height']/2;
      bounds.w = metricLabelBounds['width'];
      bounds.h = metricLabelBounds['height'];
    }
    
    // Create the label and align
    var label = new DvtOutputText(gauge.getCtx(), labelString, cx, cy);
    if(!options['metricLabel']['style'].getStyle("color") && options['background']['_isDark']) 
      options['metricLabel']['style'].setStyle("color", "#CCCCCC");
    label.setCSSStyle(options['metricLabel']['style']);
    var size = parseInt(options['metricLabel']['style'].getFontSize());
    if(!size) {
      var longestLabel = Math.max(DvtGaugeRenderer.getFormattedMetricLabel(options['max'], gauge).length,DvtGaugeRenderer.getFormattedMetricLabel(options['min'], gauge).length, labelString.length);
      var maxString = "";
      if(options['metricLabel']['textType'] == "percent") {
        longestLabel = Math.max(3, labelString.length);
        maxString += "%";
      }
      for(var i = 0; i < longestLabel; i++) 
        maxString += "0";
      label.setTextString(maxString);
      size = label.getOptimalFontSize(bounds);
      label.setTextString(labelString);
      label.setFontSize(size);
    }
    label.alignCenter();
    label.alignMiddle();

    // Truncate if needed, null is returned if the label doesn't fit
    if(DvtTextUtils.fitText(label, labelWidth, labelHeight, container)) {
      // Fudge Factor for Webkit bug
      if(DvtAgent.isBrowserChrome() && size)
        label.setY(label.getY() + size * .1);
        
      // Show tooltip for truncated text
      if(label.isTruncated())
        gauge.__getEventManager().associate(label, new DvtSimpleObjPeer(labelString));
    }
  }
}

/**
 * Renders the tick labels into the specified area.
 * @param {DvtLedGauge} gauge The gauge being rendered.
 * @param {DvtContainer} container The container to render into.
 * @param {DvtRectangle} bounds The available bounds for rendering.
 * @private
 */
DvtDialGaugeRenderer._renderTickLabels = function(gauge, container, bounds) {
  var options = gauge.__getOptions();
  var isRTL = DvtAgent.isRightToLeft(gauge.getCtx());
  // Create and position the label
  if(options['background']['radius'] && options['background']['majorTickCount']) {
    var radius = options['background']['_radius'];
    var minValue = options['min'];
    var maxValue = options['max'];
    var majorTickCount=options['background']['majorTickCount'];
    var fontSize = 12;
    var labelBounds  = new DvtRectangle(cx, cy, bounds.w, bounds.h);
    var style = options['metricLabel']['style'].getStyle("font-size");
    if(options['background']['_tickLabelHeight'] && (!style))
      labelBounds.h = options['background']['_tickLabelHeight'];
    if(options['background']['_tickLabelWidth'] && (!style))       
      labelBounds.w = options['background']['_tickLabelWidth'];
    if(!style) {
      var label = new DvtOutputText(gauge.getCtx(), "", cx, cy);
      var longestLabel = Math.max(DvtGaugeRenderer.formatTickLabelValue(options['max'], gauge).length, DvtGaugeRenderer.formatTickLabelValue(options['min'], gauge).length);
      var maxString = "";
      if(options['tickLabel']['textType'] == "percent") {
        // Check the length of the longet possible label ("100%") after it is formated.
        longestLabel = Math.max(3, (DvtGaugeRenderer.formatTickLabelValue(100, gauge).length - 1));
        maxString += "%";
      }
      for(var i = 0; i < longestLabel; i++) 
        maxString += "0";
      label.setTextString(maxString);
      fontSize = label.getOptimalFontSize(labelBounds);
    }
    for(var x = 0;x < majorTickCount;x++)
    {
      var labelValue = minValue + Math.abs(maxValue - minValue) * x  / (majorTickCount - 1);
      if(isRTL)
        labelValue = minValue + Math.abs(maxValue - minValue) * (majorTickCount - 1 - x)  / (majorTickCount-1);
        
      var labelString = DvtGaugeRenderer.formatTickLabelValue(labelValue, gauge); 
      var angleRads = DvtDialGaugeRenderer._getRotation(gauge, labelValue);
      var anchor=DvtDialGaugeRenderer._getBackgroundAnchorPoint(gauge, bounds)
      
      var cx = anchor.x + radius * Math.cos(angleRads - Math.PI/2);
      var cy = anchor.y + radius * Math.sin(angleRads - Math.PI/2) ;

      // Create the label and align
      var label = new DvtOutputText(gauge.getCtx(), labelString, cx, cy);
      if(!options['tickLabel']['style'].getStyle("color") && options['background']['_isDark']) 
        options['tickLabel']['style'].setStyle("color", "#CCCCCC");
      label.setCSSStyle(options['tickLabel']['style']);
      if(!options['tickLabel']['style'].getStyle("font-size")) 
        label.setFontSize(fontSize);
      label.alignCenter();
      label.alignMiddle();
          
      // Fudge Factor for Webkit bug
      if(DvtAgent.isBrowserChrome())
        label.setY(label.getY() - fontSize * .1);
      
      // Truncate if needed, null is returned if the label doesn't fit
      if(DvtTextUtils.fitText(label, labelBounds.w, labelBounds.h, container)) {
        // Show tooltip for truncated text
        if(label.isTruncated())
          gauge.__getEventManager().associate(label, new DvtSimpleObjPeer(label.getUntruncatedTextString()));
      }
    }
  }
}
// Copyright (c) 2008, 2013, Oracle and/or its affiliates. 
// All rights reserved. 

/**
 * Indicator for DvtDialGauge.
 * @class
 * @constructor
 * @extends {DvtContainer}
 */
var DvtDialGaugeIndicator = function(context) {
  this.Init(context);
}

DvtObj.createSubclass(DvtDialGaugeIndicator, DvtContainer, "DvtDialGaugeIndicator");

/**
 * Specifies the angle for the indicator.
 * @param {number} angleRads The angle of the indicator in radians.
 */
DvtDialGaugeIndicator.prototype.setAngle = function(angleRads) {
  // Use a matrix to prevent the angles from being cumulative
  var mat = new DvtMatrix();
  mat.rotate(angleRads);
  this.setMatrix(mat);
  
  // Store the param
  this._angleRads = angleRads;
}

/**
 * Animation support.
 * @return {array}
 */
DvtDialGaugeIndicator.prototype.getAnimationParams = function() {
  return [this._angleRads];
}

/**
 * Animation support.
 * @param {array} params
 */
DvtDialGaugeIndicator.prototype.setAnimationParams = function(params) {
  if(params && params.length == 1) 
    this.setAngle(params[0]);
}
// Copyright (c) 2008, 2013, Oracle and/or its affiliates. All rights reserved.

/**
 * Rating Gauge component.  This class should never be instantiated directly.  Use the
 * newInstance function instead.
 * @class
 * @constructor
 * @extends {DvtGauge}
 * @export
 */
var DvtRatingGauge = function() {}

DvtObj.createSubclass(DvtRatingGauge, DvtGauge, "DvtRatingGauge");

/**
 * Returns a new instance of DvtRatingGauge.
 * @param {DvtContext} context The rendering context.
 * @param {string} callback The function that should be called to dispatch component events.
 * @param {object} callbackObj The optional object instance on which the callback function is defined.
 * @return {DvtRatingGauge}
 * @export
 */
DvtRatingGauge.newInstance = function(context, callback, callbackObj) {
  var gauge = new DvtRatingGauge();
  gauge.Init(context, callback, callbackObj);
  return gauge;
}

/**
 * @override
 */
DvtRatingGauge.prototype.Init = function(context, callback, callbackObj) {
  DvtRatingGauge.superclass.Init.call(this, context, callback, callbackObj);
  
  // Create the defaults object
  this.Defaults = new DvtRatingGaugeDefaults();
}

/**
 * @override
 */
DvtRatingGauge.prototype.SetOptions = function(options) {
  // Combine the user options with the defaults and store
  DvtRatingGauge.superclass.SetOptions.call(this, this.Defaults.calcOptions(options));
}

/**
 * @override
 */
DvtRatingGauge.prototype.Render = function(container, width, height) 
{
  var outerGap = this.__getOptions()['__layout']['outerGap'];
  var maxValue = this.Options['max'];
  this._size = Math.min(height - 2*outerGap, (width - 2*outerGap)/maxValue);
  this._bounds = new DvtRectangle((this.Width-this._size*maxValue)/2.0, outerGap, this._size*maxValue, this.Height - 2*outerGap);

  DvtRatingGaugeRenderer.render(this, container, width, height);
}

/**
 * @override
 */
DvtRatingGauge.prototype.GetValueAt = function(x,y){
    
  if (DvtGaugeDataUtils.hasData(this)){
    x = Math.max(Math.min(x, this._bounds.x + this._bounds.w), this._bounds.x);
  
    var incr = this.__getOptions()['step'];
    // calculating the val depends on locale, but the rounding doesn't
    var val = 0;
    if (!DvtAgent.isRightToLeft(this.getCtx()))
      val = Math.max((x-this._bounds.x)/this._size, this.Options['min']);
    else
      val = Math.max((this._bounds.x + this._bounds.w - x)/this._size, this.Options['min']);
      
    return DvtGaugeRenderer.adjustForStep(this.Options, val);
    
  }
  return null;
}

/**
 * Handles the start of a hover event due to mouse over at the specified coordinates.
 * @param {number} x The x coordinate of the value change.
 * @param {number} y The y coordinate of the value change.
 */
DvtRatingGauge.prototype.__processHoverStart = function(x, y) {
  this.__updateClipRects(this.GetValueAt(x, y), "hover");
}

/**
 * Handles the end of a hover event due to mouse out at the specified coordinates.
 * @param {number} x The x coordinate of the value change.
 * @param {number} y The y coordinate of the value change.
 */
 DvtRatingGauge.prototype.__processHoverEnd = function(x, y) {
  this.__updateClipRects(this.Options['value'], "render");
}

/**
 * @override
 */
DvtRatingGauge.prototype.__processValueChangeStart = function(x, y) {
  this.__processHoverStart(x, y);
}

/**
 * @override
 */
DvtRatingGauge.prototype.__processValueChangeMove = function(x, y) {
  var value = this.GetValueAt(x, y);
  this.__updateClipRects(value, "hover");
  
  // Fire the value change input event
  this.__dispatchEvent(new DvtValueChangeEvent(this.Options['value'], value, false));
}

/**
 * @override
 */
DvtRatingGauge.prototype.__processValueChangeEnd = function(x, y) {  
  // Render again because a click was registerd
  var oldValue = this.Options['value'];
  this.Options['value'] = this.GetValueAt(x, y);
  this.Options['changed'] = true;
  this.render();

  // Fire the both the change and input events on complete
  this.__dispatchEvent(new DvtValueChangeEvent(oldValue, this.Options['value'], false));
  this.__dispatchEvent(new DvtValueChangeEvent(oldValue, this.Options['value'], true));
}

/**
 * Updates the cliprects used in the rating gauge for hover and the different states.
 * @param {number} value The point at which the clips rects are drawn.
 * @param {string} proc The process being done- "hover" or "render"
 * @param {DvtContainer} container The container that holds this gauge- allowing us to access the three subcontainers with selected/changed, unselected, and hover shapes.
 */
DvtRatingGauge.prototype.__updateClipRects = function(value, proc, container){
  if(!DvtGaugeDataUtils.hasData(this)) 
    return;
    
  if (!container)
    container = this._container;
  
  var isRTL = DvtAgent.isRightToLeft(this.getCtx());
  
  // which  to show and which to hide based on whether we're hovering or not
  value = Math.max(Math.min(value, this.Options['max']), 0);  //clipping the data value 
  var a = 0;
  var b = value*this._size;
  var c = value*this._size;
  if (proc == "render"){
    a = value*this._size;
    b = 0;
  }
    
  if (!isRTL){
    // Set the clip rect size.
    var unselContainer = container.getChildAt(0);
    var unselClip = new DvtClipPath("unsel" + this.getId());
    unselClip.addRect(this._bounds.x+c, this._bounds.y, this._bounds.w-c, this._bounds.h);
    unselContainer.setClipPath(unselClip);
      
    var selContainer = container.getChildAt(1);
    var selClip = new DvtClipPath("sel" + this.getId());
    selClip.addRect(this._bounds.x, this._bounds.y,  a, this._bounds.h);
    selContainer.setClipPath(selClip);
      
    var hoverContainer = container.getChildAt(2);
    var hoverClip = new DvtClipPath("hover" + this.getId());
    hoverClip.addRect(this._bounds.x, this._bounds.y, b, this._bounds.h);
    hoverContainer.setClipPath(hoverClip);
  } else {
    // Set the clip rect size.
    var unselContainer = container.getChildAt(0);
    var unselClip = new DvtClipPath("unsel" + this.getId());
    unselClip.addRect(this._bounds.x, this._bounds.y, this._bounds.w-c, this._bounds.h);
    unselContainer.setClipPath(unselClip);
      
    var selContainer = container.getChildAt(1);
    var selClip = new DvtClipPath("sel" + this.getId());
    selClip.addRect(this._bounds.x+this._bounds.w-c, this._bounds.y,  a, this._bounds.h);
    selContainer.setClipPath(selClip);
      
    var hoverContainer = container.getChildAt(2);
    var hoverClip = new DvtClipPath("hover" + this.getId());
    hoverClip.addRect(this._bounds.x+this._bounds.w-c, this._bounds.y, b, this._bounds.h);
    hoverContainer.setClipPath(hoverClip);
  }
}

/**
 * @override
 */
DvtRatingGauge.prototype.CreateEventHandler = function() {  
  return new DvtRatingGaugeEventManager(this)
}
/**
 * Default values and utility functions for component versioning.
 * @class
 * @constructor
 * @extends {DvtGaugeDefaults}
 */
var DvtRatingGaugeDefaults = function() {
  this.Init({'skyros': DvtRatingGaugeDefaults.VERSION_1, 'alta': DvtRatingGaugeDefaults.SKIN_ALTA});
}

DvtObj.createSubclass(DvtRatingGaugeDefaults, DvtGaugeDefaults, "DvtRatingGaugeDefaults");

/**
 * Defaults for ALTA.
 */ 
DvtRatingGaugeDefaults.SKIN_ALTA = {
  'unselectedState': {'shape': "star", 'color': "#C4CED7", 'borderColor': null},
  'selectedState': {'shape': "star", 'color': "#F8C15A", 'borderColor': null},
  'hoverState': {'shape': "star", 'color': "#007CC8", 'borderColor': null},
  'changedState': {'shape': "star", 'color': "#ED2C02", 'borderColor': null}
}

/**
 * Defaults for version 1.
 */ 
DvtRatingGaugeDefaults.VERSION_1 = {
  'min': 0, 'max': 5,
  'unselectedState': {'shape': "star", 'color': "#F2F2F2", 'borderColor': "#B6B6B6"},
  'selectedState': {'shape': "star", 'color': "#F8C15A", 'borderColor': "#F5A700"},
  'hoverState': {'shape': "star", 'color': "#66A7DA", 'borderColor': "#4A86C5"},
  'changedState': {'shape': "star", 'color': "#F8C15A", 'borderColor': "#959595"},
  'step': 1
}
/**
 * Renderer for DvtRatingGauge.
 * @class
 */
var DvtRatingGaugeRenderer = new Object();

DvtObj.createSubclass(DvtRatingGaugeRenderer, DvtObj, "DvtRatingGaugeRenderer");

DvtRatingGaugeRenderer._VALID_SHAPES = ["circle", "diamond", "rectangle",  "star"];
/**
 * Renders the gauge in the specified area.
 * @param {DvtRatingGauge} gauge The gauge being rendered.
 * @param {DvtContainer} container The container to render into.
 * @param {number} width The width of the component.
 * @param {number} height The height of the component.
 */
DvtRatingGaugeRenderer.render = function(gauge, container, width, height) {
  if(DvtGaugeDataUtils.hasData(gauge)) {
    // Allocate the bounds for rendering the component
    var options = gauge.__getOptions();
    var outerGap = options['__layout']['outerGap'];
    var maxValue = options['max'];
    var size = Math.min(height - 2*outerGap, (width - 2*outerGap)/maxValue);
    var bounds = new DvtRectangle((width-size*maxValue)/2.0, outerGap, size*maxValue, height - 2*outerGap);
    
    // Create the options objects for the LED gauges
    var unselectedOptions = {'value': 0, 'type': options['unselectedState']['shape'], 'color': options['unselectedState']['color'], 
                             'borderColor': options['unselectedState']['borderColor'], 'visualEffects': options['visualEffects']};
    var selectedOptions = {'value': 0, 'type': options['selectedState']['shape'], 'color': options['selectedState']['color'], 
                           'borderColor': options['selectedState']['borderColor'], 'visualEffects': options['visualEffects']};
    var changedOptions = {'value': 0, 'type': options['changedState']['shape'], 'color': options['changedState']['color'], 
                          'borderColor': options['changedState']['borderColor'], 'visualEffects': options['visualEffects']};
    var hoverOptions = {'value': 0, 'type': options['hoverState']['shape'], 'color': options['hoverState']['color'], 
                        'borderColor': options['hoverState']['borderColor'], 'visualEffects': options['visualEffects']};
                        
    if (options['unselectedState']['shape'] == "dot") {
      unselectedOptions['type'] = "circle";
      unselectedOptions['visualEffects'] = "none";
      unselectedOptions['size'] = 0.05;
    }
    
    // Create containers for clipping.
    var unselContainer = new DvtContainer(gauge.getCtx());
    container.addChild(unselContainer);
    var selContainer = new DvtContainer(gauge.getCtx());
    container.addChild(selContainer);
    var hoverContainer = new DvtContainer(gauge.getCtx());
    container.addChild(hoverContainer);

    gauge.__updateClipRects(options['value'], "render", container);
    
    for (var i = 0;i < maxValue;i++) {
      // The unselectedState shapes
      if (options['unselectedState']['shape']!= 'none'){
        var unselectedLED = DvtLedGauge.newInstance(gauge.getCtx());
        unselectedLED.setId(gauge.getId() + "_unselected" + i);
        unselContainer.addChild(unselectedLED);
        unselectedLED.setTranslate(bounds.x + i*size, bounds.y + bounds.h/2 - size/2);
        if(DvtArrayUtils.getIndex(DvtRatingGaugeRenderer._VALID_SHAPES, unselectedOptions['type']) == -1)
          unselectedOptions['type'] = "star";
        unselectedLED.render(unselectedOptions, size, size);
      }
      
      // The selected/changed shapes use the same container and cliprect
      if (options['changed']){
          var changedLED = DvtLedGauge.newInstance(gauge.getCtx());
          changedLED.setId(gauge.getId() + "_changed" + i);
          selContainer.addChild(changedLED);
          changedLED.setTranslate(bounds.x + i*size, bounds.y + bounds.h/2 - size/2);
          if(DvtArrayUtils.getIndex(DvtRatingGaugeRenderer._VALID_SHAPES, changedOptions['type']) == -1)
            changedOptions['type'] = "star";
          changedLED.render(changedOptions, size, size);
      }
      else{    
          var selectedLED = DvtLedGauge.newInstance(gauge.getCtx());
          selectedLED.setId(gauge.getId() + "_selected" + i);
          selContainer.addChild(selectedLED);
          selectedLED.setTranslate(bounds.x + i*size, bounds.y + bounds.h/2 - size/2);  
          if(DvtArrayUtils.getIndex(DvtRatingGaugeRenderer._VALID_SHAPES, selectedOptions['type']) == -1)
            selectedOptions['type'] = "star";
          selectedLED.render(selectedOptions, size, size);
      }
      
      // The hover shapes
      var hoverLED = DvtLedGauge.newInstance(gauge.getCtx());
      hoverLED.setId(gauge.getId() + "_hover" + i);
      hoverContainer.addChild(hoverLED);
      hoverLED.setTranslate(bounds.x + i*size, bounds.y + bounds.h/2 - size/2); 
      if(DvtArrayUtils.getIndex(DvtRatingGaugeRenderer._VALID_SHAPES, hoverOptions['type']) == -1)
        hoverOptions['type'] = "star";
      hoverLED.render(hoverOptions, size, size);  
    }
    
    // Overlay rectangle to catch mosue clicks
    var overlayRect = new DvtRect(gauge.getCtx(), bounds.x, bounds.y, bounds.w, bounds.h); 
    overlayRect.setInvisibleFill();
    container.addChild(overlayRect);
    
    // Tooltip Support
    var tooltip = options['shortDesc'];
    if(tooltip)
      gauge.__getEventManager().associate(overlayRect, new DvtSimpleObjPeer(null, tooltip));
  }
  else // Render the empty text
    DvtGaugeRenderer.renderEmptyText(gauge, container, new DvtRectangle(0, 0, width, height));
}
/**
 * Event Manager for DvtRatingGauge.
 * @param {DvtGauge} gauge
 * @class
 * @extends DvtEventManager
 * @constructor
 */
var DvtRatingGaugeEventManager = function(gauge) {
  this.Init(gauge.getCtx(), gauge.__dispatchEvent, gauge);
  this._gauge = gauge;
  this.isEditing = false;
  this._bValueChanged = false;
  
  // Bug 17463663
  this._isIE = DvtAgent.isPlatformIE();
  this._stopAutoMouseOut = false;
};

DvtObj.createSubclass(DvtRatingGaugeEventManager, DvtGaugeEventManager, "DvtRatingGaugeEventManager");

/**
 * @override
 */
DvtRatingGaugeEventManager.prototype.OnMouseOver = function(event) {
  // Only editable gauges
  if(this._gauge.__getOptions()['readOnly'] === false && !this._bValueChanged) {
    var coords = this.GetRelativePosition(event.pageX, event.pageY);
    this._gauge.__processHoverStart(coords.x, coords.y);
    this.isEditing = true; //this is to continue using the OnMouseMove function as defined 
  }
  
  // Need to call the superclass here to support tooltips during hover. 
  DvtGaugeEventManager.superclass.OnMouseOver.call(this, event);
}

/**
 * @override
 */
DvtRatingGaugeEventManager.prototype.OnMouseOut = function(event) {
  // Only editable gauges
  if(this._gauge.__getOptions()['readOnly'] === false) {
   // Stop IE from firing mouseOut after _bValueChanged becomes true and gauge is re-rendered
   if(this._isIE && this._bValueChanged && this._stopAutoMouseOut){
      this._stopAutoMouseOut = false;
      return;
    }
    else{
      var coords = this.GetRelativePosition(event.pageX, event.pageY);
      this._gauge.__processHoverEnd(coords.x, coords.y);
      this._bValueChanged = false;
    }
  }
  // To dismiss the tooltip if it's showing.
  DvtGaugeEventManager.superclass.OnMouseOut.call(this, event);
}

/**
 * @override
 */
DvtRatingGaugeEventManager.prototype.OnMouseDown = function(event) {
  // Set the editing flag so moves are tracked
  if(!this._bValueChanged) {
    if(this._gauge.__getOptions()['readOnly'] === false) {
      this.isEditing = true;
      this.hideTooltip();
      var coords = this.GetRelativePosition(event.pageX, event.pageY);
      this._gauge.__processValueChangeStart(coords.x, coords.y);
    //  this._gauge.__processHoverStart(coords.x, coords.y);
    }
    else // Don't call super if editing, just handle it in this subclass
      DvtGaugeEventManager.superclass.OnMouseDown.call(this, event);
  }
}

/**
 * @override
 */
DvtRatingGaugeEventManager.prototype.OnMouseUp = function(event) {  
  // Reset the editing flag
  if(this.isEditing) {
    if(this._gauge.__getOptions()['readOnly'] === false) {
      this.isEditing = false;
      var coords = this.GetRelativePosition(event.pageX, event.pageY);
      this._gauge.__processValueChangeEnd(coords.x, coords.y);
      this._gauge.__processHoverEnd(coords.x, coords.y);
      this._bValueChanged = true;
      
      // Bug 17463663
      if(this._isIE)
        this._stopAutoMouseOut = true;
    }
    else // Don't call super if editing, just handle it in this subclass
      DvtGaugeEventManager.superclass.OnMouseUp.call(this, event);
  }
}

/**
 * @override
 */
DvtRatingGaugeEventManager.prototype.IsShowingTooltipWhileEditing = function(){
  return true;
}
/**
 * Axis component.  This class should never be instantiated directly.  Use the
 * newInstance function instead.
 * @class
 * @constructor
 * @extends {DvtBaseComponent}
 * @export
 */
var DvtAxis = function() {}

DvtObj.createSubclass(DvtAxis, DvtBaseComponent, "DvtAxis");

/**
 * Returns a new instance of DvtAxis.
 * @param {DvtContext} context The rendering context.
 * @param {string} callback The function that should be called to dispatch component events.
 * @param {object} callbackObj The optional object instance on which the callback function is defined.
 * @return {DvtAxis}
 * @export
 */
DvtAxis.newInstance = function(context, callback, callbackObj) {
  var axis = new DvtAxis();
  axis.Init(context, callback, callbackObj);
  return axis;
}

/**
 * Returns a copy of the default options for the specified skin.
 * @param {string} skin The skin whose defaults are being returned.
 * @return {object} The object containing defaults for this component.
 * @export
 */
DvtAxis.getDefaults = function(skin) 
{  
  return (new DvtAxisDefaults()).getDefaults(skin);
}

/**
 * @override
 * @protected
 */
DvtAxis.prototype.Init = function(context, callback, callbackObj) {
  DvtAxis.superclass.Init.call(this, context, callback, callbackObj);
  
  // Create the defaults object
  this.Defaults = new DvtAxisDefaults();
  
  // Create the event handler and add event listeners
  this._eventHandler = new DvtAxisEventManager(this);
  this._eventHandler.addListeners(this);
  
  this._labelTruncationNeeded = true;
}

/**
 * Minimum buffer for horizontal axis.
 */
DvtAxis.MINIMUM_AXIS_BUFFER = 10;

/**
 * @override
 * @protected
 */
DvtAxis.prototype.SetOptions = function(options) {
  if(options) // Combine the user options with the defaults and store
    this.Options = this.Defaults.calcOptions(options);
  else if(!this.Options) // Create a default options object if none has been specified
    this.Options = this.GetDefaults();
}

/**
 * Returns the preferred dimensions for this component given the maximum available space.
 * @param {object} options The object containing specifications and data for this component.
 * @param {Number} maxWidth The maximum width available.
 * @param {Number} maxHeight The maximum height available.
 * @return {DvtDimension} The preferred dimensions for the object.
 */
DvtAxis.prototype.getPreferredSize = function(options, maxWidth, maxHeight) {
  // Update the options object.
  this.SetOptions(options);

  // Set the layout flag to indicate this is a layout pass only
  this.__getOptions()['isLayout'] = true;

  // Ask the axis to render its context in the max space and find the space used
  this.render(null, maxWidth, maxHeight);
  var dims = this.getDimensions();
  
  // Clear the rendered contents and reset state
  this.__getOptions()['isLayout'] = false;
  this.removeChildren();
  
  // Return the height needed.  Reserve the full space along the edge of the axis.
  var position = this.__getOptions()['position'];
  if(position == "top" || position == "bottom") {
    if (dims.h <= maxHeight)
      this._labelTruncationNeeded = false;
    return new DvtDimension(maxWidth, Math.min(dims.h, maxHeight));
  } else {
    // In Chrome, when getDimensioins is called on DvtAxis the width will sometimes be less the widest text element
    // that is a child of it. When we actually render text labels can get dropped or truncated incorrectly. Work around 
    // is to add 10% to the width calculated. To see this, do not add 10% to the dims.w and render a default bar graph
    // in Chrome 13.0.782.215
    var extraWidth = Math.max(1, dims.w * .1);
    if (dims.w + extraWidth <= maxWidth)
      this._labelTruncationNeeded = false;
    return new DvtDimension(Math.min(dims.w + extraWidth, maxWidth), maxHeight);
  }
}

/**
 * Renders the component at the specified size.
 * @param {object} options The object containing specifications and data for this component.
 * @param {number} width The width of the component.
 * @param {number} height The height of the component.
 * @param {x} optional x position of the component.
 * @param {y} optional y position of the component.
 * @export
 */
DvtAxis.prototype.render = function(options, width, height, x, y) 
{  
  // Update the options object.
  this.SetOptions(options);
  
  this.Width = width;
  this.Height = height;
  
  // Clear any contents rendered previously  
  this.removeChildren();
  
  // Set default values to undefined properties.
  if(!x){
   x = 0;
  }      
  
  if(!y){
   y = 0;
  } 
  
  // Render the axis
  var availSpace = new DvtRectangle(x, y, width, height);
  DvtAxisRenderer.render(this, availSpace);
}

/**
 * Processes the specified event.  
 * @param {object} event
 * @param {object} source The component that is the source of the event, if available.
 */
DvtAxis.prototype.processEvent = function(event, source) {
  // Dispatch the event to the callback if it originated from within this component.
  if(this === source) {
    this.__dispatchEvent(event);
  }
}

/**
 * Returns the evaluated options object, which contains the user specifications
 * merged with the defaults.
 * @return {object} The options object.
 */
DvtAxis.prototype.__getOptions = function() {
  return this.Options;
}

/**
 * Returns the DvtEventManager for this component.
 * @return {DvtEventManager}
 */
DvtAxis.prototype.__getEventManager = function() {
  return this._eventHandler;
}

/**
 * Returns the axisInfo for the axis
 * @return {DvtAxisInfo} the axisInfo
 */
 DvtAxis.prototype.__getInfo = function() {
   return this.Info;
 }

/**
 * Sets the object containing calculated axis information and support
 * for creating drawables.
 * @param {DvtAxisInfo} axisInfo
 */
DvtAxis.prototype.__setInfo = function(axisInfo) {
  this.Info = axisInfo;
}

/**
 * Returns whether label truncation is needed for this axis
 * @return {Boolean}
 */
DvtAxis.prototype.__isLabelTruncationNeeded = function() {
  return this._labelTruncationNeeded;
}

/**
 * Returns the axis width
 * @return {number}
 */
DvtAxis.prototype.getWidth = function() {
  return this.Width;
}

/**
 * Returns the axis height
 * @return {number}
 */
DvtAxis.prototype.getHeight = function() {
  return this.Height;
}
/**
 * Axis Constants
 * @class
 * @export
 */
var DvtAxisConstants = {};

DvtObj.createSubclass(DvtAxisConstants, DvtObj, "DvtAxisConstants");

/**
 * @const
 * @export
 */
DvtAxisConstants.TICK_LABEL = "tickLabel";

/**
 * @const
 * @export
 */
DvtAxisConstants.TITLE = "title";
/**
 * Abstact formatter for an axis label value.
 *
 * @param {object} bundle translations bundle
 * @constructor
 */
var DvtAbstractAxisValueFormatter = function (bundle) {
  this._bundle = bundle;
}

DvtObj.createSubclass(DvtAbstractAxisValueFormatter, DvtObj, "DvtAbstractAxisValueFormatter");

/**
 * Abstract method which purpose is to format given numeric value.
 * @param {number} value value to be formatted
 * @return {string} formatted value as string
 */
DvtAbstractAxisValueFormatter.prototype.format = function (value) {
}

/**
 * Returns currently used bundle
 * @protected
 * @return {object} currently used bundle
 */
DvtAbstractAxisValueFormatter.prototype.GetBundle = function () {
  return this._bundle;
}
/**
 * Default values and utility functions for component versioning.
 * @class
 * @constructor
 * @extends {DvtBaseComponentDefaults}
 */
var DvtAxisDefaults = function() {
  this.Init({'skyros': DvtAxisDefaults.VERSION_1, 'alta': DvtAxisDefaults.SKIN_ALTA});
}

DvtObj.createSubclass(DvtAxisDefaults, DvtBaseComponentDefaults, "DvtAxisDefaults");

/**
 * Contains overrides for the 'alta' skin.
 */ 
DvtAxisDefaults.SKIN_ALTA = {
  'axisLine': {'lineColor': "#9E9E9E"},
  'majorTick': {'lineColor': "rgba(196,206,215,0.4)"},
  'minorTick': {'lineColor': "rgba(196,206,215,0.2)"},
  'tickLabel': {'style': new DvtCSSStyle("font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;")},
  'titleStyle': new DvtCSSStyle("font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 12px;")
}

/**
 * Defaults for version 1.
 */ 
DvtAxisDefaults.VERSION_1 = {
  'position': null,
  'baselineScaling': "zero",
  'axisLine': {'lineColor': "#8A8DAC", 'lineWidth': 1, 'rendered': "on"},
  'majorTick': {'lineColor': "rgba(138,141,172,0.4)", 'lineWidth': 1, 'rendered': "auto", 'lineStyle': "solid"},
  'minorTick': {'lineColor': "rgba(138,141,172,0.20)", 'lineWidth': 1, 'rendered': "off", 'lineStyle': "solid"},
  'tickLabel': {
    'scaling': "auto",
    'style': new DvtCSSStyle("font-size: 11px; color: #333333;"), 'rotation': "auto", 'rendered': "on"
  },
  'titleStyle': new DvtCSSStyle("font-size: 11px; color: #737373;"), 
  
  // For group axis, an optional offset expressed as a factor of the group size.
  'startGroupOffset': 0, 'endGroupOffset': 0,
  
  //*********** Internal Attributes *************************************************//
  'layout': {
    // Gap ratio is multiplied against all gap sizes
    'gapRatio': 1.0,
    'titleGap': 4,
    'verticalAxisGap': 3,
    'horizontalAxisGap': 5
  },
  
  '_useBaselineColor': false, // when true, will render the baseline in a slightly more prominent color
  
  'isLayout': false // true if rendering for layout purposes
}

/**
 * Scales down gap sizes based on the size of the component.
 * @param {object} options The object containing options specifications for this component.
 * @param {Number} defaultSize The default gap size.
 * @return {Number} 
 */
DvtAxisDefaults.getGapSize = function(options, defaultSize) {
  return Math.ceil(defaultSize * options['layout']['gapRatio']);
}
/**
 * Event Manager for DvtAxis.
 * @param {DvtAxis} axis
 * @class
 * @extends DvtEventManager
 * @constructor
 */
var DvtAxisEventManager = function (axis) {
  this.Init(axis.getCtx(), axis.processEvent, axis);
  this._axis = axis;
};

DvtObj.createSubclass(DvtAxisEventManager, DvtEventManager, "DvtAxisEventManager");

/**
 * Returns the parameters for the DvtComponentUIEvent for an object with the specified arguments.
 * @param {string} type The type of object that was the target of the event.
 * @param {object} [id] The id of the object, if one exists.
 */
DvtAxisEventManager.getUIEventParams = function(type, id) {
  return {'type': type, 'id': id};
}

/**
 * @override
 */
DvtAxisEventManager.prototype.FireUIEvent = function(type, logicalObj) {
  if(logicalObj instanceof DvtSimpleObjPeer && logicalObj.getParams() != null) 
    this.FireEvent(new DvtComponentUIEvent(type, logicalObj.getParams()), this._axis);
}
/**
 * Renderer for DvtAxis.
 * @class
 */
var DvtAxisRenderer = new Object();

DvtObj.createSubclass(DvtAxisRenderer, DvtObj, "DvtAxisRenderer");

DvtAxisRenderer._RADIAL_LABEL_GAP = 5;

/**
 * Renders the axis and updates the available space.
 * @param {DvtAxis} axis The axis being rendered.
 * @param {DvtRectangle} availSpace The available space.
 */
DvtAxisRenderer.render = function(axis, availSpace) {
  // Calculate the axis extents and increments
  var options = axis.__getOptions();
  var axisInfo = DvtAxisInfo.newInstance(axis.getCtx(), options, availSpace);
  axis.__setInfo(axisInfo);
  
  if (options['rendered'] == "off")
    return;
  
  // Render the title
  DvtAxisRenderer._renderTitle(axis, axisInfo, availSpace);
  
  // Render the tick labels
  DvtAxisRenderer._renderLabels(axis, axisInfo, availSpace);
}

/**
 * Renders the axis title and updates the available space.
 * @param {DvtAxis} axis The axis being rendered.
 * @param {DvtAxisInfo} axisInfo The axis model.
 * @param {DvtRectangle} availSpace The available space.
 * @private
 */
DvtAxisRenderer._renderTitle = function(axis, axisInfo, availSpace) {
  var options = axis.__getOptions();  
  
  if(!options['title'])
    return;
    
  // Create the title object and add to axis
  var position = options['position'];

  if (position == "radial" || position == "tangential")
    return; // polar chart doesn't have axis titles
  
  // In layout mode, treat "bottom" as "top" for space calculation
  if(options['isLayout'] && position == "bottom")
    position = "top";
    
  var title;
  if (position == "top" || position == "bottom")
    title = DvtAxisRenderer._createText(axis.__getEventManager(), axis, options['title'], options['titleStyle'], 
                                         0, 0, availSpace.w, availSpace.h, 
                                         DvtAxisEventManager.getUIEventParams(DvtAxisConstants.TITLE));
  else 
    title = DvtAxisRenderer._createText(axis.__getEventManager(), axis, options['title'], options['titleStyle'], 
                                         0, 0, availSpace.h, availSpace.w, 
                                         DvtAxisEventManager.getUIEventParams(DvtAxisConstants.TITLE));
 
  if (title) {
    // Position the title based on text size and axis position 
    var titleDims = title.measureDimensions();
    var gap = DvtAxisDefaults.getGapSize(options, options['layout']['titleGap']);
    
    // Position the label and update the space
    if(position == "top") {
      title.setX(availSpace.x + availSpace.w/2 - titleDims.w/2); 
      title.setY(availSpace.y);
      availSpace.y += (titleDims.h + gap);
      availSpace.h -= (titleDims.h + gap);
    }
    else if(position == "bottom") {
      title.setX(availSpace.x + availSpace.w/2 - titleDims.w/2); 
      title.setY(availSpace.y + availSpace.h - titleDims.h);
      availSpace.h -= (titleDims.h + gap);
    }
    else if(position == "left") {
      title.setRotation(3*Math.PI/2);
      title.setTranslate(availSpace.x, availSpace.y + availSpace.h/2 + titleDims.w/2);
      availSpace.x += (titleDims.h + gap);
      availSpace.w -= (titleDims.h + gap);
    }
    else if(position == "right") {
      title.setRotation(Math.PI/2);
      title.setTranslate(availSpace.x + availSpace.w, availSpace.y + availSpace.h/2 - titleDims.w/2);
      availSpace.w -= (titleDims.h + gap);
    }
  }
}

/**
 * Renders the tick labels and updates the available space.
 * @param {DvtAxis} axis The axis being rendered.
 * @param {DvtAxisInfo} axisInfo The axis model.
 * @param {DvtRectangle} availSpace The available space.
 * @private
 */
DvtAxisRenderer._renderLabels = function(axis, axisInfo, availSpace) {
  var options = axis.__getOptions();
  if(options['tickLabel']['rendered'] == "on") {
    // Axis labels are positioned based on the position of the axis.  In layout
    // mode, the labels will be positioned as close to the title as possible to
    // calculate the actual space used.
    var position = options['position'];
    if(position == "top" || position == "bottom") 
      DvtAxisRenderer._renderLabelsHoriz(axis, axisInfo, availSpace);
    else if (position == "tangential")
       DvtAxisRenderer._renderLabelsTangent(axis, axisInfo, availSpace);
    else 
      DvtAxisRenderer._renderLabelsVert(axis, axisInfo, availSpace);
  }
}

/**
 * Renders tick labels for a horizontal axis and updates the available space.
 * @param {DvtAxis} axis The axis being rendered.
 * @param {DvtAxisInfo} axisInfo The axis model.
 * @param {DvtRectangle} availSpace The available space.
 * @private
 */
DvtAxisRenderer._renderLabelsHoriz = function(axis, axisInfo, availSpace) {
  // Position and add the axis labels.  
  var labels = axisInfo.getLabels(axis.getCtx());
  var isLayout = axis.__getOptions()['isLayout'];
  var maxLv1Height = 0;
  
  // For BIDI
  var isRTL = DvtAgent.isRightToLeft(axis.getCtx());
  
  for (var i=0; i<labels.length; i++) {
    var label = labels[i];
    if (label == null) 
      continue;
    
    if (axisInfo.isLabelRotated()) {
      //truncate if necesssary
      if (!isLayout && axis.__isLabelTruncationNeeded()) {
        label = DvtTextUtils.fitText(label, availSpace.h, availSpace.w, axis) ? label : null; // swap h and w
      }
      if (!label)
        continue;
      
      //position and add the axis labels
      if (!isRTL)
        label.alignRight();
      else
        label.alignLeft();
      label.setTranslateY(availSpace.y);
    
    } else { // not rotated
      label.alignTop();
      label.setY(availSpace.y);
    }  
      
    // Associate with logical object to support DvtComponentUIEvent and tooltips
    var params = DvtAxisEventManager.getUIEventParams(DvtAxisConstants.TICK_LABEL, label.getTextString());
    axis.__getEventManager().associate(label, new DvtSimpleObjPeer(label.getUntruncatedTextString(), null, null, params));    
    
    axis.addChild(label);
    maxLv1Height = Math.max(maxLv1Height, DvtTextUtils.guessTextDimensions(label).h);
  }
  
  // Render the nested labels (level 2).
  var lv2Labels = axisInfo.getLabels(axis.getCtx(), 1);
  var offset = 0;
  
  if (lv2Labels != null) {
    for(i=0; i<lv2Labels.length; i++) {
      label = lv2Labels[i];
      if (label == null) 
        continue;
      
      // Associate with logical object to support DvtComponentUIEvent and tooltips
      axis.__getEventManager().associate(label, new DvtSimpleObjPeer(null, null, null, DvtAxisEventManager.getUIEventParams(DvtAxisConstants.TICK_LABEL, label.getTextString())));    
      
      // align with level 1 label
      if (labels[i] != null)
        offset = labels[i].measureDimensions().w / 2;   
      if (isRTL) {
        label.setX(label.getX() + offset);
      } else {
        label.setX(label.getX() - offset);
      }
      
      label.alignTop();
      label.setY(availSpace.y + maxLv1Height);
      axis.addChild(label);
    }
  }
}

/**
 * Renders tick labels for a vertical axis and updates the available space.
 * @param {DvtAxis} axis The axis being rendered.
 * @param {DvtAxisInfo} axisInfo The axis model.
 * @param {DvtRectangle} availSpace The available space.
 * @private
 */
DvtAxisRenderer._renderLabelsVert = function(axis, axisInfo, availSpace) {
  var options = axis.__getOptions();
  var isLayout = options['isLayout'];
  var position = options['position'];
  var isRTL = DvtAgent.isRightToLeft(axis.getCtx());
  
  var labelX;
  if (position == "radial") {
    labelX = availSpace.x + availSpace.w/2;
    labelX += DvtAxisRenderer._RADIAL_LABEL_GAP * (isRTL ? 1 : -1);
  }
  else {  
    // All vertical axis labels are aligned to the end, unless in layout mode
    labelX = availSpace.x + availSpace.w;
    if(isLayout && position == "left")
      labelX = availSpace.x;
  }

  var formatLabelVert = function(label) {
    if (!isLayout && axis.__isLabelTruncationNeeded()) {
      label = DvtTextUtils.fitText(label, availSpace.w, availSpace.h, axis) ? label : null;
    }
    if (!label)
      return;
    
    // Associate with logical object to support DvtComponentUIEvent and tooltips
    var params = DvtAxisEventManager.getUIEventParams(DvtAxisConstants.TICK_LABEL, label.getTextString());
    axis.__getEventManager().associate(label, new DvtSimpleObjPeer(label.getUntruncatedTextString(), null, null, params));  
      
    label.setX(labelX);
    label.alignRight();
    axis.addChild(label);

    if (position == "radial") {
      label.setY(availSpace.y + availSpace.h/2 - label.getY());
      if (isRTL)
        label.alignLeft(); // TODO: should be alignEnd and repositioned!
    }

    if(isLayout && position == "left")
      label.alignLeft();
  }
  
  // Position and add the axis labels (level 1).  
  var labels = axisInfo.getLabels(axis.getCtx());
  for(var i=0; i<labels.length; i++) {
    var label = labels[i];
    if (label != null)
      formatLabelVert(label);
  }
  
  // Render the nested labels (level 2).
  var lv2Labels = axisInfo.getLabels(axis.getCtx(), 1);
  if (lv2Labels != null) {  
    for(i=0; i<lv2Labels.length; i++) {
      label = lv2Labels[i];
      if (label != null)
        formatLabelVert(label);
    }
  }
}

/**
 * Renders tick labels for a tangential axis and updates the available space.
 * @param {DvtAxis} axis The axis being rendered.
 * @param {DvtAxisInfo} axisInfo The axis model.
 * @param {DvtRectangle} availSpace The available space.
 * @private
 */
DvtAxisRenderer._renderLabelsTangent = function(axis, axisInfo, availSpace) {
  var labels = axisInfo.getLabels(axis.getCtx());
  for(var i=0; i<labels.length; i++) {
    var label = labels[i];
    if (label != null) {
      // TODO: fit text
      var textBefore = label.getTextString();

      // Associate with logical object to support DvtComponentUIEvent and tooltips
      var params = DvtAxisEventManager.getUIEventParams(DvtAxisConstants.TICK_LABEL, textBefore);
      var tooltip = label.isTruncated() ? textBefore : null;
      axis.__getEventManager().associate(label, new DvtSimpleObjPeer(tooltip, null, null, params)); 

      label.setTranslateX(availSpace.x + availSpace.w/2);
      label.setTranslateY(availSpace.y + availSpace.h/2);
      axis.addChild(label);
    }
  }
}

/**
 * Creates and adds a DvtText object to a container. Will truncate and add tooltip as necessary.
 * @param {DvtEventManager} eventManager
 * @param {DvtContainer} container The container to add the text object to.
 * @param {String} textString The text string of the text object.
 * @param {DvtCSSStyle} cssStyle The css style to apply to the text object.
 * @param {number} x The x coordinate of the text object.
 * @param {number} y The y coordinate of the text object.
 * @param {number} width The width of available text space.
 * @param {number} height The height of the available text space.
 * @param {object} params Additional parameters that will be passed to the logical object.
 * @return {DvtOutputText} The created text object. Can be null if no text object could be created in the given space.
 */  
DvtAxisRenderer._createText = function(eventManager, container, textString, cssStyle, x, y, width, height, params) {
  var text = new DvtOutputText(container.getCtx(), textString, x, y);
  text.setCSSStyle(cssStyle);
  if (DvtTextUtils.fitText(text, width, height, container)) {
    // Associate with logical object to support DvtComponentUIEvent and truncation
    eventManager.associate(text, new DvtSimpleObjPeer(text.getUntruncatedTextString(), null, null, params));
    return text;
  }
  else
    return null;
}

/**
 * Calculated axis information and drawable creation.  This class should
 * not be instantiated directly.
 * @class
 * @constructor
 * @extends {DvtObj}
 */
var DvtAxisInfo = function() {}

DvtObj.createSubclass(DvtAxisInfo, DvtObj, "DvtAxisInfo");

/**
 * Creates an appropriate instance of DvtAxisInfo with the specified parameters.
 * @param {DvtContext} context
 * @param {object} options The object containing specifications and data for this component.
 * @param {DvtRectangle} availSpace The available space.
 * @return {DvtAxisInfo}
 */
DvtAxisInfo.newInstance = function(context, options, availSpace) {
  if(options['timeAxisType'] && options['timeAxisType'] != "disabled")
    return new DvtTimeAxisInfo(context, options, availSpace);
  else if(isNaN(options['dataMin']) && isNaN(options['dataMax']))
    return new DvtGroupAxisInfo(context, options, availSpace);
  else
    return new DvtDataAxisInfo(context, options, availSpace);
}

/**
 * Calculates and stores the axis information.
 * @param {DvtContext} context
 * @param {object} options The object containing specifications and data for this component.
 * @param {DvtRectangle} availSpace The available space.
 * @protected
 */
DvtAxisInfo.prototype.Init = function(context, options, availSpace) {
  this._context = context;

  // Figure out the start and end coordinate of the axis
  this.Position = options['position'];
  this._radius = options['_radius']; // for polar charts

  if(this.Position == "top" || this.Position == "bottom") {
    this.StartCoord = availSpace.x;
    this.EndCoord = availSpace.x + availSpace.w;
  }
  else if(this.Position == "left" || this.Position == "right") {
    this.StartCoord = availSpace.y;
    this.EndCoord = availSpace.y + availSpace.h;
  }
  else if(this.Position == "radial") {
    this.StartCoord = 0;
    this.EndCoord = this._radius;
  }
  else if(this.Position == "tangential") {
    if(DvtAgent.isRightToLeft(context)) {
      this.StartCoord = 2 * Math.PI;
      this.EndCoord = 0;
    }
    else {
      this.StartCoord = 0;
      this.EndCoord = 2 * Math.PI;
    }
  }
  
  // Axis min and max value. Subclasses should set.
  this.MinValue = null;
  this.MaxValue = null;
  this.GlobalMin = null;
  this.GlobalMax = null;
  this.DataMin = null;
  this.DataMax = null;
  
  // Set the maximum zoom for this axis
  this.MinViewportExtent = null;
  
  // The overflows at the two ends of the axis
  this.StartOverflow = 0;
  this.EndOverflow = 0;
  
  // Sets the buffers (the maximum amount the labels can go over before they overflow)
  if (options['leftBuffer'] == null)
    options['leftBuffer'] = Infinity;
  if (options['rightBuffer'] == null)
    options['rightBuffer'] = Infinity;
  
  // Store the options object
  this.Options = options;
}

/**
 * Returns the DvtContext associated with this instance.
 * @return {DvtContext}
 */
DvtAxisInfo.prototype.getCtx = function() {
  return this._context;
}

/**
 * Returns the options settings for the axis.
 * @return {object} The options for the axis.
 */
DvtAxisInfo.prototype.getOptions = function() {
  return this.Options;
}

/**
 * Returns an array containing the tick labels for this axis.
 * @param {DvtContext} context
 * @param {Number} levelIdx The level index (optional). 0 indicates the first level, 1 the second, etc. If skipped, 0 (the first level) is assumed.
 * @return {Array} The Array of DvtText objects.
 */
DvtAxisInfo.prototype.getLabels = function(context, levelIdx) {
  return null; // subclasses should override
}

/**
 * Returns the axis line for this axis.
 * @param {DvtContext} context
 * @return {DvtLine} The axis line.
 */
DvtAxisInfo.prototype.getAxisLine = function(context) {
  return null; // subclasses should override
}

/**
 * Returns an array containing the majorTick grid lines for this axis.  Objects
 * are returned in the desired z-order.
 * @param {DvtContext} context
 * @return {Array} The Array of DvtLine objects.
 */
DvtAxisInfo.prototype.getMajorGridLines = function(context) {
  return []; // subclasses should override
}

/**
 * Returns an array containing the minorTick grid lines for this axis.  Objects
 * are returned in the desired z-order.
 * @param {DvtContext} context
 * @return {Array} The Array of DvtLine objects.
 */
DvtAxisInfo.prototype.getMinorGridLines = function(context) {
  return []; // subclasses should override
}

/**
 * Returns the value for the specified coordinate along the axis.  Returns null
 * if the coordinate is not within the axis.
 * @param {number} coord The coordinate along the axis.
 * @return {object} The value at that coordinate.
 */
DvtAxisInfo.prototype.getValueAt = function(coord) {
  return null; // subclasses should override
}

/**
 * Returns the coordinate for the specified value.  Returns null if the value is
 * not within the axis.
 * @param {object} value The value to locate.
 * @return {number} The coordinate for the value.
 */
DvtAxisInfo.prototype.getCoordAt = function(value) {
  return null; // subclasses should override
}

/**
 * Returns the value for the specified coordinate along the axis.  If a coordinate
 * is not within the axis, returns the value of the closest coordinate within the axis.
 * @param {number} coord The coordinate along the axis.
 * @return {object} The value at that coordinate.
 */
DvtAxisInfo.prototype.getBoundedValueAt = function(coord) {
  return null; // subclasses should override
}

/**
 * Returns the coordinate for the specified value along the axis.  If a value
 * is not within the axis, returns the coordinate of the closest value within the axis.
 * @param {object} value The value to locate.
 * @return {number} The coordinate for the value.
 */
DvtAxisInfo.prototype.getBoundedCoordAt = function(value) {
  return null; // subclasses should override
}

/**
 * Returns the value for the specified coordinate along the axis.
 * @param {number} coord The coordinate along the axis.
 * @return {object} The value at that coordinate.
 */
DvtAxisInfo.prototype.getUnboundedValueAt = function(coord) {
  return null; // subclasses should override
}

/**
 * Returns the coordinate for the specified value.
 * @param {object} value The value to locate.
 * @return {number} The coordinate for the value.
 */
DvtAxisInfo.prototype.getUnboundedCoordAt = function(value) {
  return null; // subclasses should override
}

/**
 * Returns the baseline coordinate for the axis, if applicable.
 * @return {number} The baseline coordinate for the axis.
 */
DvtAxisInfo.prototype.getBaselineCoord = function() {
  return null;
}

/**
 * Returns if the labels of the horizontal axis are rotated by 90 degrees.
 * @return {boolean} Whether the labels are rotated.
 */
DvtAxisInfo.prototype.isLabelRotated = function() {
  return false;
}

/**
 * Creates a DvtText instance for the specified text label.
 * @param {DvtContext} context
 * @param {string} label The label string.
 * @param {number} coord The coordinate for the text.
 * @return {DvtOutputText} 
 * @protected
 */
DvtAxisInfo.prototype.CreateLabel = function(context, label, coord) {
  var text;
  
  if (this.Position == "tangential") {
    var vTol = 16/180 * Math.PI; // the mid area (15 degrees) where labels will be middle aligned.
    var hTol = 1/180 * Math.PI; // the tolerance (1 degree) where labels will be center aligned.
    
    var dist = this._radius + 5;
    if (coord < hTol || coord > 2*Math.PI - hTol)
      dist += 5; // avoild collision with radial label
    text = new DvtOutputText(context, label, dist * Math.sin(coord), -dist * Math.cos(coord));
    
    // Align the label according to the angular position
    if (coord < hTol || Math.abs(coord-Math.PI) < hTol || coord > 2*Math.PI - hTol)
      text.alignCenter();
    else if (coord < Math.PI)
      text.alignLeft();
    else
      text.alignRight();

    if (Math.abs(coord-Math.PI/2) < vTol || Math.abs(coord-3*Math.PI/2) < vTol)
      text.alignMiddle();
    else if (coord < Math.PI/2 || coord > 3*Math.PI/2)
      text.alignBaseline();
    else
      text.alignTop();
  }
  else {
    text = new DvtOutputText(context, label, coord, coord);
    text.alignMiddle();
    text.alignCenter();
  }

  text.setCSSStyle(this.Options['tickLabel']['style']);
  return text;
}

/**
 * Gets the points array for a polygon with n sides and radius r.
 * @param {number} n The number of sides.
 * @param {number} r the radius (distance from center to vertex).
 * @return {array} Points array.
 * @private
 */
DvtAxisInfo.getPolygonPoints = function(n, r) {
  var points = [];
  var angle;
  for (var i = 0; i < n; i++) {
    angle = i / n * 2 * Math.PI;
    points.push(r * Math.sin(angle), -r * Math.cos(angle))
  }
  return points;
}

/**
 * Creates a DvtShape instance with the specified stroke and coordinate.
 * @param {DvtContext} context
 * @param {DvtSolidStroke} stroke The stroke for the grid line.
 * @param {number} coord The coordinate for the grid line.
 * @return {DvtShape} 
 * @protected
 */
DvtAxisInfo.prototype.CreateGridLine = function(context, stroke, coord) {
  var line;
  if (this.Position == "radial") {
    if (this.Options['majorTick']['gridType'] == "straight") {
      var points = DvtAxisInfo.getPolygonPoints(this.Options['_numGroups'], coord);
      line = new DvtPolygon(context, points);
    }
    else
      line = new DvtCircle(context, 0, 0, coord);
    line.setInvisibleFill();
  }
  else if (this.Position == "tangential")
    line = new DvtLine(context, 0, 0, this._radius * Math.sin(coord), -this._radius * Math.cos(coord));
  else {
    line = new DvtLine(context, coord, coord, coord, coord);
    if (!DvtAgent.isTouchDevice() || DvtAgent.getDevicePixelRatio() > 1)
      line.setPixelHinting(true);
  }
  line.setStroke(stroke);
  line.setMouseEnabled(false);
  return line;
}

/**
 * Checks all the labels for the axis and returns whether they overlap.
 * @param {Array} labelDims An array of DvtRectangle objects that describe the x, y, height, width of the axis labels.
 * @param {number} skippedLabels The number of labels to skip. If skippedLabels is 1 then every other label will be skipped.
 * @return {boolean} True if any labels overlap.
 * @protected
 */
DvtAxisInfo.prototype.IsOverlapping = function(labelDims, skippedLabels) {
  // If there are no labels, return
  if(!labelDims || labelDims.length <= 0)
    return false;
  
  // Get font-size of label and create gap based on font-size
  // GroupAxis and TimeAxis have smaller gaps since these axes become less useable as more labels are dropped
  var fontSize = parseInt(this.Options['tickLabel']['style'].getStyle('font-size'));
  var gapHoriz = (this instanceof DvtDataAxisInfo) ? fontSize * 0.55 : fontSize * 0.3;
  var gapVert = (this instanceof DvtDataAxisInfo) ? fontSize * 0.35 : fontSize * 0.1;

  var isVert = (this.Position == "left" || this.Position == "right" || this.Position == "radial");
  var gap = (isVert || this.isLabelRotated()) ? gapVert : gapHoriz;

  var isRTL = DvtAgent.isRightToLeft(this.getCtx());
  
  var pointA1, pointA2, pointB1, pointB2;
  for (var j=0; j<labelDims.length; j+= skippedLabels+1) {
    if (labelDims[j] == null)
      continue;
    
    if (pointA1 == null || pointA2 == null) {
      // Set the first points
      if (isVert) {
        pointA1 = labelDims[j].y;
        pointA2 = labelDims[j].y + labelDims[j].h;
      } else {
        pointA1 = labelDims[j].x;
        pointA2 = labelDims[j].x + labelDims[j].w;
      }
      continue;
    }
    
    if (isVert) {
      pointB1 = labelDims[j].y;
      pointB2 = labelDims[j].y + labelDims[j].h;
      
      // Broken apart for clarity, next label may be above or below
      if(pointB1 >= pointA1 && pointB1 - gap < pointA2) // next label below
        return true;
      else if(pointB1 < pointA1 && pointB2 + gap > pointA1) // next label above
        return true;
    } 
    else {
      pointB1 = labelDims[j].x;
      pointB2 = labelDims[j].x + labelDims[j].w;
      
      // Broken apart for clarity, next label is on the right for non-BIDI, left for BIDI
      if(!isRTL && (pointB1 - gap < pointA2))
        return true;
      else if(isRTL && (pointB2 + gap > pointA1))
        return true;
    }
    
    // Otherwise start evaluating from label j
    pointA1 = pointB1;
    pointA2 = pointB2;
  }
  return false;
}

/**
 * Checks the labels for the axis and skips them as necessary.
 * @param {Array} labels An array of DvtText labels for the axis.
 * @param {Array} labelDims An array of DvtRectangle objects that describe the x, y, height, width of the axis labels.
 * @return {Array} The array of DvtText labels for the axis.
 * @protected
 */
DvtAxisInfo.prototype.SkipLabels = function(labels, labelDims) {
  var skippedLabels = 0;
  var bOverlaps = this.IsOverlapping(labelDims, skippedLabels);
  while (bOverlaps) {
    skippedLabels++;
    bOverlaps = this.IsOverlapping(labelDims, skippedLabels);
  }

  if (skippedLabels > 0) {
    var renderedLabels = [];
    for (var j=0; j<labels.length; j+= skippedLabels+1) {
      renderedLabels.push(labels[j]);
    }
    return renderedLabels;
  } else {
    return labels
  }
}

/**
 * Returns an array of DvtRectangle objects that describe the x, y, width, height of the axis labels.
 * @param {Array} labels An array of DvtText labels for the axis.
 * @param {DvtContainer} container
 * @return {Array} An array of DvtRectangle objects
 * @protected
 */
DvtAxisInfo.prototype.GetLabelDims = function(labels, container) {
  var labelDims = [];
  
  // Get the text dimensions
  for(var i=0; i<labels.length; i++) {
    var text = labels[i];
    if (text == null) {
      labelDims.push(null);
    } else {
      var dims = text.measureDimensions(container);
      labelDims.push(dims);
    }
  }
  
  return labelDims;
}

/**
 * Returns an array of DvtRectangle objects that contains a conservative guess the x, y, width, height of the axis labels.
 * Assumes that the labels are center-middle aligned.
 * @param {Array} labels An array of DvtText labels for the axis.
 * @param {DvtContainer} container
 * @param {Number} fudgeFactor (optional) A factor the would be multiplied to the text width. If not provided, assumed to be 1.
 * @return {Array} An array of DvtRectangle objects
 * @protected
 */
DvtAxisInfo.prototype.GuessLabelDims = function(labels, container, fudgeFactor) {
  var labelDims = [];
  if (typeof fudgeFactor == 'undefined')
    fudgeFactor = 1;
  
  // Get the text dimensions
  for(var i=0; i<labels.length; i++) {
    var text = labels[i];
    if (text == null) {
      labelDims.push(null);
    } else { 
      // get a conservative estimate of the dimensions
      container.addChild(text);
      var estimatedSize = DvtTextUtils.guessTextDimensions(text);
      var estW = estimatedSize.w * fudgeFactor;
      var estH = estimatedSize.h;
      container.removeChild(text);
      
      var dims;
      if (this.isLabelRotated()) {
        dims = new DvtRectangle(text.getTranslateX() - estH/2, text.getTranslateY() - estW/2, estH, estW);
      } else {
        dims = new DvtRectangle(text.getX() - estW/2, text.getY() - estH/2, estW, estH);
      }
      labelDims.push(dims);
    }
  }
  
  return labelDims;
}

/**
 * Returns the number of major tick counts for the axis.
 * @return {number} The number of major tick counts.
 */
DvtAxisInfo.prototype.getMajorTickCount = function() {
   return null; // subclasses that allow major gridlines should implement
}

/**
 * Sets the number of major tick counts for the axis.
 * @param {number} count The number of major tick counts.
 */
DvtAxisInfo.prototype.setMajorTickCount = function(count) {
  // subclasses that allow major gridlines should implement
}

/**
 * Returns the number of minor tick counts for the axis.
 * @return {number} The number of minor tick counts.
 */
DvtAxisInfo.prototype.getMinorTickCount = function() {
   return null; // subclasses that allow minor gridlines should implement
}

/**
 * Sets the number of minor tick counts for the axis.
 * @param {number} count The number of minor tick counts.
 */
DvtAxisInfo.prototype.setMinorTickCount = function(count) {
  // subclasses that allow minor gridlines should implement
}

/**
 * Returns the major increment for the axis.
 * @return {number} The major increment.
 */
DvtAxisInfo.prototype.getMajorIncrement = function() {
   return null; // subclasses that allow major gridlines should implement
}

/**
 * Returns the minor increment for the axis.
 * @return {number} The minor increment.
 */
DvtAxisInfo.prototype.getMinorIncrement = function() {
   return null; // subclasses that allow minor gridlines should implement
}

/**
 * Returns the global min value of the axis.
 * @return {number} The global min value.
 */
DvtAxisInfo.prototype.getGlobalMin = function() {
   return this.GlobalMin;
}

/**
 * Returns the global max value of the axis.
 * @return {number} The global max value.
 */
DvtAxisInfo.prototype.getGlobalMax = function() {
   return this.GlobalMax;
}

/**
 * Returns the viewport min value of the axis.
 * @return {number} The viewport min value.
 */
DvtAxisInfo.prototype.getViewportMin = function() {
   return this.MinValue;
}

/**
 * Returns the viewport max value of the axis.
 * @return {number} The viewport max value.
 */
DvtAxisInfo.prototype.getViewportMax = function() {
   return this.MaxValue;
}

/**
 * Returns the data min value of the axis.
 * @return {number} The data min value.
 */
DvtAxisInfo.prototype.getDataMin = function() {
   return this.DataMin;
}

/**
 * Returns the data max value of the axis.
 * @return {number} The data max value.
 */
DvtAxisInfo.prototype.getDataMax = function() {
   return this.DataMax;
}

/**
 * Returns the minimum extent of the axis, i.e. the (minValue-maxValue) during maximum zoom.
 * @return {number} The minimum extent.
 */
DvtAxisInfo.prototype.getMinimumExtent = function() {
  return 0;
}

/**
 * Returns how much the axis labels overflow over the start coord.
 * @return {number}
 */
DvtAxisInfo.prototype.getStartOverflow = function() {
  return this.StartOverflow;
}

/**
 * Returns how much the axis labels overflow over the end coord.
 * @return {number}
 */
DvtAxisInfo.prototype.getEndOverflow = function() {
  return this.EndOverflow;
}
/**
 * Calculated axis information and drawable creation for a data axis.
 * @param {DvtContext} context
 * @param {object} options The object containing specifications and data for this component.
 * @param {DvtRectangle} availSpace The available space.
 * @class
 * @constructor
 * @extends {DvtAxisInfo}
 */
var DvtDataAxisInfo = function(context, options, availSpace) {
  this.Init(context, options, availSpace);
}

DvtObj.createSubclass(DvtDataAxisInfo, DvtAxisInfo, "DvtDataAxisInfo");

DvtDataAxisInfo._MAX_NUMBER_OF_GRIDS_AUTO = 10;
DvtDataAxisInfo._MINOR_TICK_COUNT = 2;
DvtDataAxisInfo._MAX_ZOOM_FACTOR = 64;


/**
 * @override
 */
DvtDataAxisInfo.prototype.Init = function(context, options, availSpace) {
  DvtDataAxisInfo.superclass.Init.call(this, context, options, availSpace);

  // Figure out the coords for the min/max values
  if(this.Position == "top" || this.Position == "bottom") {
    // Provide at least the minimum buffer at each side to accommodate labels
    if (options['tickLabel']['rendered'] == "on") {
      this.StartOverflow = Math.max(DvtAxis.MINIMUM_AXIS_BUFFER - options['leftBuffer'], 0);
      this.EndOverflow = Math.max(DvtAxis.MINIMUM_AXIS_BUFFER - options['rightBuffer'], 0);
    }
    
    // Axis is horizontal, so flip for BIDI if needed
    if(DvtAgent.isRightToLeft(context)) {
      this._minCoord = this.EndCoord - this.EndOverflow;
      this._maxCoord = this.StartCoord + this.StartOverflow;
    }
    else {
      this._minCoord = this.StartCoord + this.StartOverflow;
      this._maxCoord = this.EndCoord - this.EndOverflow;
    }
  }
  else if(this.Position == "tangential" || this.Position == "radial") {
    this._minCoord = this.StartCoord;
    this._maxCoord = this.EndCoord;
  }
  else {
    this._minCoord = this.EndCoord;
    this._maxCoord = this.StartCoord;
  }

  this.GlobalMin = options['min'];
  this.GlobalMax = options['max'];
  this.MinValue = options['viewportMin'] == null ? this.GlobalMin : options['viewportMin'];
  this.MaxValue = options['viewportMax'] == null ? this.GlobalMax : options['viewportMax'];
  
  this._majorIncrement = options['step'];
  this._minorIncrement = options['minorStep'];
  this._minMajorIncrement = options['minStep'];
  this._converter = null;
  if (options['tickLabel'] != null) {
    this._converter = options['tickLabel']['converter'];
  }
  
  this.DataMin = options['dataMin'];
  this.DataMax = options['dataMax']
  this._calcAxisExtents();
}

/**
 * Returns the value correspoding to the first tick label (or gridline) of the axis.
 * @return {number} The value of the min label.
 */
DvtDataAxisInfo.prototype.getMinLabel = function() {
  if (this.Options['baselineScaling'] == 'zero' || (this.Options['_continuousExtent'] == "on" && this.Options['min'] == null)) {
    // the tickLabels and gridlines should be at integer intervals from zero
    return Math.ceil(this.MinValue/this._majorIncrement) * this._majorIncrement;
  } else {  
    // the tickLabels and gridlines should be at integer intervals from the globalMin
    return Math.ceil((this.MinValue-this.GlobalMin)/this._majorIncrement) * this._majorIncrement + this.GlobalMin;
  }
}

/**
 * @override
 */
DvtDataAxisInfo.prototype.getLabels = function(context, levelIdx) {
  if (levelIdx && levelIdx > 0) // data axis has only one level
    return null;

  var labels = [];
  var labelDims = [];
  var container = context.getStage();
  var isTangential = this.Position == "tangential";
  
  // when scaling is set then init formatter
  if(this.Options['tickLabel'] && this.Options['tickLabel']['scaling']){
    var autoPrecision = this.Options['tickLabel']['autoPrecision'] ? this.Options['tickLabel']['autoPrecision'] : 'on';
    this._axisValueFormatter = new DvtLinearScaleAxisValueFormatter(this.MinValue, this.MaxValue, this._majorIncrement, this.Options['tickLabel']['scaling'], autoPrecision);
  }
  
  // Iterate on an integer to reduce rounding error.  We use <= since the first
  // tick is not counted in the tick count.
  for(var i=0; i<=this._majorTickCount; i++) {
    var value = i*this._majorIncrement + this.getMinLabel();
    if (isTangential && value == this.MaxValue)
      continue; // the last label of tangential axis is skipped bc it overlaps the first.
    var label = this._formatValue(value);
    var coord = this.getUnboundedCoordAt(value);
    var text = this.CreateLabel(context, label, coord);
    labels.push(text);
  }
  
  if(!isTangential) {
    labelDims = this.GetLabelDims(labels, container);
    labels = this.SkipLabels(labels, labelDims);
  }

  return labels;
}

/**
 * @override
 */
DvtDataAxisInfo.prototype.getAxisLine = function(context) {
  var axisLineOptions = this.Options['axisLine'];
  if(axisLineOptions['rendered'] == "on") {
    // TODO hzhang Check Axis Line behavior for negative/mixed axes.
    var axisLineStroke = new DvtSolidStroke(axisLineOptions['lineColor'], 1, axisLineOptions['lineWidth']);
    return this.CreateGridLine(context, axisLineStroke, this._maxCoord);
  }
  else 
    return null;
}

/**
 * @override
 */
DvtDataAxisInfo.prototype.getMajorGridLines = function(context) {
  var gridlines = [];
  // Major Ticks
  var coord, line;
  
  var majorTickOptions = this.Options['majorTick'];
  if(majorTickOptions['rendered'] == "off")
    return gridlines;
    
  var majorTickStroke = new DvtSolidStroke(majorTickOptions['lineColor'], 1, majorTickOptions['lineWidth']);
  if(majorTickOptions['lineStyle'])
    majorTickStroke.setStyle(DvtStroke.convertTypeString(majorTickOptions['lineStyle']));
    
  var baselineStroke = majorTickStroke.clone();
  if(this.Options['_useBaselineColor']) {
    // Derive the baseline color from the axis line color and major tick color
    var axisLineColor = this.Options['axisLine']['lineColor'];
    var baselineColor = DvtColorUtils.setAlpha(axisLineColor, 0.75);
    baselineStroke.setColor(baselineColor);
  }
    
  // Iterate on an integer to reduce rounding error.  We use <= since the first
  // tick is not counted in the tick count.
  for(var i=0; i<=this._majorTickCount; i++) {
    var value = i*this._majorIncrement + this.getMinLabel();
    if (this.Position == "tangential" && value == this.MaxValue)
      continue;
    var stroke = (value == 0) ? baselineStroke : majorTickStroke;
    coord = this.getUnboundedCoordAt(value);
    line = this.CreateGridLine(context, stroke, coord);
    gridlines.push(line);
  }
  
  return gridlines;
}

/**
 * @override
 */
DvtDataAxisInfo.prototype.getMinorGridLines = function(context) {
  var gridlines = [];
  // Minor Ticks
  var coord, line;

  var minorTickOptions = this.Options['minorTick'];
  if(minorTickOptions['rendered'] != "on")
    return gridlines;
  
  var minorTickStroke = new DvtSolidStroke(minorTickOptions['lineColor'], 1, minorTickOptions['lineWidth']);
  if(minorTickOptions['lineStyle'])
    minorTickStroke.setStyle(DvtStroke.convertTypeString(minorTickOptions['lineStyle']));
    
  // Iterate on an integer to reduce rounding error.  We use <= since the first
  // tick is not counted in the tick count.
  // Start from i=-1 so that minorTicks that should get rendered before the first majorTick are evaluated
  for(var i=-1; i<=this._majorTickCount; i++) {
    var value = i*this._majorIncrement + this.getMinLabel();
    for (var j=1; j<this._minorTickCount; j++) {
      var minorValue = value+(j*this._minorIncrement);
      if(minorValue > this.MaxValue)
        break;
      if(minorValue < this.MinValue)
        continue;        
      coord = this.getUnboundedCoordAt(minorValue);
      line = this.CreateGridLine(context, minorTickStroke, coord);
      gridlines.push(line);
    }
  }
  return gridlines;
}

/**
 * @override
 */
DvtDataAxisInfo.prototype.getValueAt = function(coord) {
  var minCoord = Math.min(this._minCoord, this._maxCoord);
  var maxCoord = Math.max(this._minCoord, this._maxCoord);
  
  // Return null if the coord is outside of the axis
  if(coord < minCoord || coord > maxCoord)
    return null;

  return this.getUnboundedValueAt(coord);
}

/**
 * @override
 */
DvtDataAxisInfo.prototype.getCoordAt = function(value) {
  // Return null if the value is outside of the axis
  if(value < this.MinValue || value > this.MaxValue)
    return null;

  return this.getUnboundedCoordAt(value);
}

/**
 * @override
 */
DvtDataAxisInfo.prototype.getBoundedValueAt = function(coord) {
  var minCoord = Math.min(this._minCoord, this._maxCoord);
  var maxCoord = Math.max(this._minCoord, this._maxCoord);

  if(coord < minCoord)
    coord = minCoord;
  else if(coord > maxCoord)
    coord = maxCoord;

  return this.getUnboundedValueAt(coord);
}

/**
 * @override
 */
DvtDataAxisInfo.prototype.getBoundedCoordAt = function(value) {
  if(value < this.MinValue)
    value = this.MinValue;
  else if(value > this.MaxValue)
    value = this.MaxValue;

  return this.getUnboundedCoordAt(value);
}

/**
 * @override
 */
DvtDataAxisInfo.prototype.getUnboundedValueAt = function(coord) {
  var ratio = (coord - this._minCoord)/(this._maxCoord - this._minCoord);
  return this.MinValue + (ratio * (this.MaxValue - this.MinValue));
}

/**
 * @override
 */
DvtDataAxisInfo.prototype.getUnboundedCoordAt = function(value) {
  var ratio = (value - this.MinValue)/(this.MaxValue - this.MinValue);
  return this._minCoord + (ratio * (this._maxCoord - this._minCoord));
}

/**
 * @override
 */
DvtDataAxisInfo.prototype.getBaselineCoord = function() {
  // First find the value of the baseline
  var baseline = 0;
  if(this.MaxValue < 0)
    baseline = this.MaxValue;
  else if(this.MinValue > 0)
    baseline = this.MinValue;
    
  // Return its coordinate
  return this.getCoordAt(baseline);
}

/**
 * @private
 */
DvtDataAxisInfo.prototype._formatValue = function(value) {
  
  if (this._converter && this._converter.getAsString) {
    if (this._axisValueFormatter)
      return this._axisValueFormatter.format(value, this._converter);
    else
      return this._converter.getAsString(value);
  } 
  else if (this._converter && this._converter['format'])
    return this._converter['format'](value);
    
  else if (this._axisValueFormatter) 
    return this._axisValueFormatter.format(value);    
    
  else {
    // set the # of decimals of the value to the # of decimals of the major increment
    var t = Math.log(this._majorIncrement) / Math.log(10);
    var decimals = Math.max(Math.ceil(-t), 0);
    return value.toFixed(decimals);
  }
}

/**
 * Determines the number of major and minor tick counts and increments for the axis if values were not given.
 * The default minor tick count is 2.
 * @param {number} scaleUnit The scale unit of the axis.
 * @private
 */
DvtDataAxisInfo.prototype._calcMajorMinorIncr = function(scaleUnit) {
  this._majorIncrement = this._majorIncrement ? this._majorIncrement : scaleUnit;
  if(this._minMajorIncrement != null && this._majorIncrement < this._minMajorIncrement)
    this._majorIncrement = this._minMajorIncrement;
  
  this._majorTickCount = (this.MaxValue - this.getMinLabel())/this._majorIncrement;
  
  if (this._minorIncrement != null && this._majorIncrement/this._minorIncrement >= 2) {
    this._minorTickCount = this._majorIncrement/this._minorIncrement;
  } else {
    this._minorTickCount = DvtDataAxisInfo._MINOR_TICK_COUNT;
    this._minorIncrement = this._majorIncrement/this._minorTickCount;
  }
}

/**
 * Determines the axis extents based on given start and end value
 * or calculated from the min and max data values of the chart.
 * @private
 */
DvtDataAxisInfo.prototype._calcAxisExtents = function() {
  var zeroBaseline = this.Options['baselineScaling'] == "zero";
  var continuousExtent = this.Options['_continuousExtent'] == "on";
  
  // Include 0 in the axis if we're scaling from the baseline
  if(zeroBaseline) {
    this.DataMin = Math.min(0, this.DataMin);
    this.DataMax = Math.max(0, this.DataMax);
  }
  
  var scaleUnit = this._calcAxisScale((this.GlobalMin != null ? this.GlobalMin : this.DataMin), 
                                      (this.GlobalMax != null ? this.GlobalMax : this.DataMax));
                   
  // If there's only a single value on the axis, we need to adjust the
  // this.DataMin and this.DataMax to produce a nice looking axis with around 10 ticks.
  if(this.DataMin == this.DataMax) {
    scaleUnit = Math.pow(10, Math.floor(Math.log(this.DataMin)/Math.LN10)-1);
    this.DataMin -= 3*scaleUnit;
    this.DataMax += 2*scaleUnit;
  }
  
  // Set the default global min
  if (this.GlobalMin == null) {
    if (zeroBaseline && this.DataMin >= 0) {
      this.GlobalMin = 0;
    } else if (continuousExtent) { // allow smooth pan/zoom transition
      this.GlobalMin = this.DataMin - (this.DataMax - this.DataMin) * 0.1;
      if (this.DataMin >= 0)
        this.GlobalMin = Math.max(this.GlobalMin, 0);
    } else if (!zeroBaseline && this.GlobalMax != null) {
      this.GlobalMin = this.GlobalMax;
      while (this.GlobalMin > this.DataMin) 
        this.GlobalMin -= scaleUnit;
    } else {
      this.GlobalMin = Math.floor(this.DataMin/scaleUnit) * scaleUnit;
    }
  }
  
  // Set the default global max
  if (this.GlobalMax == null) {
    if (zeroBaseline && this.DataMax <= 0) {
      this.GlobalMax = 0;
    } else if (continuousExtent) { // allow smooth pan/zoom transition
      this.GlobalMax = this.DataMax + (this.DataMax - this.DataMin) * 0.1;
      if (this.DataMax <= 0)
        this.GlobalMax = Math.min(this.GlobalMax, 0);
    } else if (!zeroBaseline) {
      this.GlobalMax = this.GlobalMin;
      while (this.GlobalMax <= this.DataMax)
        this.GlobalMax += scaleUnit;
    } else {
      this.GlobalMax = (Math.floor(this.DataMax/scaleUnit)+1) * scaleUnit;
    }
  }
  
  if (this.GlobalMax == this.GlobalMin) { // happens if this.DataMin == this.DataMax == 0
    this.GlobalMax = 100;
    this.GlobalMin = 0;
    scaleUnit = (this.GlobalMax - this.GlobalMin) / DvtDataAxisInfo._MAX_NUMBER_OF_GRIDS_AUTO;
  }
  
  if (this.MinValue == null)
    this.MinValue = this.GlobalMin;
  if (this.MaxValue == null)
    this.MaxValue = this.GlobalMax;
  
  // Recalc the scale unit if the axis viewport is limited
  if (this.MinValue != this.GlobalMin || this.MaxValue != this.GlobalMax)
    scaleUnit = this._calcAxisScale(this.MinValue, this.MaxValue);
  
  // Calculate major and minor gridlines
  this._calcMajorMinorIncr(scaleUnit);
}

/**
 * Determines the scale unit of the axis based on a given start and end axis extent.
 * @param {number} min The start data value for the axis.
 * @param {number} max The end data value for the axis.
 * @return {number} The scale unit of the axis.
 * @private
 */
DvtDataAxisInfo.prototype._calcAxisScale = function(min, max) {
  if (this._majorIncrement)
    return this._majorIncrement;
  
  var spread =  max - min;
  var t = Math.log(spread)/Math.log(10);
  var testVal = Math.pow(10, Math.ceil(t) - 2);
  var first2Digits = Math.round(spread/testVal);
  
  // Aesthetically choose a scaling factor limiting to a max number of steps 
  var scaleFactor = 1;
  if (first2Digits >= 10 && first2Digits <= 14)
    scaleFactor = 2;
  else if (first2Digits >= 15 && first2Digits <= 19)
    scaleFactor = 3;
  else if (first2Digits >= 20 && first2Digits <= 24)
    scaleFactor = 4;
  else if (first2Digits >= 25 && first2Digits <= 45)
    scaleFactor = 5;
  else if (first2Digits >= 46 && first2Digits <= 80)
    scaleFactor = 10;
  else if (first2Digits >= 81 && first2Digits <= 99)
    scaleFactor = 15; 
  else
    scaleFactor = 20;
  
  return scaleFactor * testVal;
}

/**
 * @override
 */
DvtDataAxisInfo.prototype.getMajorTickCount = function() {
   return this._majorTickCount;
}

/**
 * @override
 */
DvtDataAxisInfo.prototype.setMajorTickCount = function(count) {
  this._majorTickCount = count;
  this._majorIncrement = (this.MaxValue - this.MinValue)/this._majorTickCount;
}

/**
 * @override
 */
DvtDataAxisInfo.prototype.getMinorTickCount = function() {
   return this._minorTickCount;
}

/**
 * @override
 */
DvtDataAxisInfo.prototype.setMinorTickCount = function(count) {
   this._minorTickCount = count;
   this._minorIncrement = this._majorIncrement/this._minorTickCount;
}

/**
 * @override
 */
DvtDataAxisInfo.prototype.getMajorIncrement = function() {
   return this._majorIncrement;
}

/**
 * @override
 */
DvtDataAxisInfo.prototype.getMinorIncrement = function() {
   return this._minorIncrement;
}

/**
 * @override
 */
DvtDataAxisInfo.prototype.getMinimumExtent = function() {
  return (this.GlobalMax - this.GlobalMin) / DvtDataAxisInfo._MAX_ZOOM_FACTOR;
}

/**
 * @override
 */
DvtDataAxisInfo.prototype.getStartOverflow = function() {
  if ((this.Position == "top" || this.Position == "bottom") && DvtAgent.isRightToLeft(this.getCtx()))
    return this.EndOverflow;
  else
    return this.StartOverflow;
}

/**
 * @override
 */
DvtDataAxisInfo.prototype.getEndOverflow = function() {
  if ((this.Position == "top" || this.Position == "bottom") && DvtAgent.isRightToLeft(this.getCtx()))
    return this.StartOverflow;
  else
    return this.EndOverflow;
}
/**
 * Calculated axis information and drawable creation for a group axis.
 * @param {DvtContext} context
 * @param {object} options The object containing specifications and data for this component.
 * @param {DvtRectangle} availSpace The available space.
 * @class
 * @constructor
 * @extends {DvtAxisInfo}
 */
var DvtGroupAxisInfo = function(context, options, availSpace) {
  this.Init(context, options, availSpace);
}

DvtObj.createSubclass(DvtGroupAxisInfo, DvtAxisInfo, "DvtGroupAxisInfo");

/**
 * @override
 */
DvtGroupAxisInfo.prototype.Init = function(context, options, availSpace) {
  DvtGroupAxisInfo.superclass.Init.call(this, context, options, availSpace);

  // Flip horizontal axes for BIDI
  var isRTL = DvtAgent.isRightToLeft(context);
  if((this.Position == "top" || this.Position == "bottom") && isRTL) {
    var temp = this.StartCoord;
    this.StartCoord = this.EndCoord;
    this.EndCoord = temp;
  }

  // Cache the groups
  this._groups = options['groups'];
  
  // Calculate the increment and add offsets if specified
  var endOffset = (options['endGroupOffset'] > 0) ? Number(options['endGroupOffset']) : 0;
  var startOffset = (options['startGroupOffset'] > 0) ? Number(options['startGroupOffset']) : 0;
  
  // Set the axis min/max
  this.DataMin = 0;
  this.DataMax = this._groups.length - 1;
  
  this.GlobalMin = options['min'] == null ? this.DataMin - startOffset : options['min'];
  this.GlobalMax = options['max'] == null ? this.DataMax + endOffset : options['max'];
  
  this.MinValue = options['viewportMin'] == null ? this.GlobalMin : options['viewportMin'];
  this.MaxValue = options['viewportMax'] == null ? this.GlobalMax : options['viewportMax'];
  
  // Set min/max by start/endGroup
  var startIndex = this.getIndexByLabel(options['viewportStartGroup']);
  var endIndex = this.getIndexByLabel(options['viewportEndGroup']);
  if (startIndex != -1)
    this.MinValue = startIndex - startOffset;
  if (endIndex != -1)
    this.MaxValue = endIndex + endOffset;
    
  this._startBuffer = isRTL ? options['rightBuffer'] : options['leftBuffer'];
  this._endBuffer = isRTL ? options['leftBuffer'] : options['rightBuffer'];
  
  this._isLabelRotated = false;
  
  this._renderGridAtLabels = options['_renderGridAtLabels'];
}

/**
 * Rotates the labels of the horizontal axis by 90 degrees and skips the labels if necessary.
 * @param {Array} labels An array of DvtText labels for the axis.
 * @param {DvtContainer} container
 * @param {number} overflow How much overflow the rotated labels will have.
 * @return {Array} The array of DvtText labels for the axis.
 * @private
 */
DvtGroupAxisInfo.prototype._rotateLabels = function(labels, container, overflow) {
  var text;
  var x;  
  var isRTL = DvtAgent.isRightToLeft(this.getCtx());
  
  this._isLabelRotated = true;
  this._setOverflow(overflow, overflow, labels);
  
  for(var i=0; i<labels.length; i++) {
    text = labels[i];
    if (text == null)
      continue;  
    x = text.getX();
    text.setX(0);
    text.setY(0);
    if (isRTL)
      text.setRotation(Math.PI/2);
    else
      text.setRotation(3*Math.PI/2); 
    text.setTranslateX(x);
  }
  
  var labelDims = this.GuessLabelDims(labels, container); // the guess returns the exact heights
  return this.SkipLabels(labels, labelDims);
}

/**
 * @override
 */
DvtGroupAxisInfo.prototype.isLabelRotated = function() {
  return this._isLabelRotated;
}

/**
 * Sets the start/end overflow of the axis.
 * @param {number} startOverflow How much the first label overflows beyond the start coord.
 * @param {number} endOverflow How much the last label overflows beyonod the end coord.
 * @param {array} labels An array of DvtText labels. The x of the labels will be adjusted according to the overflow amount.
 * @private
 */
DvtGroupAxisInfo.prototype._setOverflow = function(startOverflow, endOverflow, labels) {
  startOverflow = Math.max(startOverflow - this._startBuffer, 0);
  endOverflow = Math.max(endOverflow - this._endBuffer, 0);
  
  // Revert the start/endCoord to the original positions before applying the new overflow values
  var isRTL = DvtAgent.isRightToLeft(this.getCtx());
  this.StartCoord += (startOverflow - this.StartOverflow) * (isRTL ? -1 : 1);
  this.EndCoord -= (endOverflow - this.EndOverflow) * (isRTL ? -1 : 1);
  
  // Adjust the label coords
  for (var i=0; i<labels.length; i++) {
    var text = labels[i];
    if (text)
      text.setX(this.getCoordAt(i));
  }
  
  this.StartOverflow = startOverflow;
  this.EndOverflow = endOverflow;
}


/**
 * @override
 */
DvtGroupAxisInfo.prototype.getLabels = function(context, levelIdx) {
  if (levelIdx && levelIdx > 0) // group axis has only one level
    return null;

  var labels = [];
  var container = context.getStage();
  var isHoriz = this.Position == "top" || this.Position == "bottom";
  var isRTL = DvtAgent.isRightToLeft(context);
  
  // Iterate and create the labels
  var numLabels = this._groups.length;
  var firstLabel, lastLabel;
  for(var i=0; i<numLabels; i++) {
    // Get the label from the group
    var label = this.getLabelAt(i);
    
    // Create and position the label
    var coord = this.getCoordAt(i);
    if (coord != null) {
      var text = this.CreateLabel(context, label, coord);
      labels.push(text);
      
      // Store first and last label
      if (!firstLabel)
        firstLabel = text;
      lastLabel = text;
    }
    else
      labels.push(null);
  }

  if (this.Position == "tangential") // for polar charts, no further computation is needed
    return labels;

  var firstLabelDim = firstLabel.measureDimensions();
  
  if (isHoriz) {
    var startOverflow, endOverflow;
    if (this.Options['_startOverflow'] != null && this.Options['_endOverflow'] != null) {
      // Use the preset value if available (during z&s animation)
      startOverflow = this.Options['_startOverflow'];
      endOverflow = this.Options['_endOverflow'];
    }
    else {
      // Set the overflow depending on how much the first and the last label go over the bounds
      var lastLabelDim = lastLabel.measureDimensions();
      startOverflow = isRTL ? firstLabelDim.w + firstLabelDim.x - this.StartCoord : this.StartCoord - firstLabelDim.x;
      endOverflow = isRTL ? this.EndCoord - lastLabelDim.x : lastLabelDim.w + lastLabelDim.x - this.EndCoord;
    }
    
    if (startOverflow > this._startBuffer || endOverflow > this._endBuffer)
      this._setOverflow(startOverflow, endOverflow, labels);
  }
  
  var labelDims = []; // actual dims
  var minLabelDims = this.GuessLabelDims(labels, container, 0.3); // minimum estimate
  var maxLabelDims = this.GuessLabelDims(labels, container);      // maximum estimate
  
  if (!this.IsOverlapping(maxLabelDims, 0))
    return labels; // all labels can fit
  
  // Rotate and skip the labels if necessary
  if (isHoriz) { // horizontal axis
    if (this.Options['tickLabel']['rotation'] == "auto") {
      if (this.IsOverlapping(minLabelDims, 0)) {
        return this._rotateLabels(labels, container, firstLabelDim.h/2);
      } else {
        labelDims = this.GetLabelDims(labels, container);
        if (this.IsOverlapping(labelDims, 0))
          return this._rotateLabels(labels, container, firstLabelDim.h/2);
        else
          return labels;  // all labels can fit
      }
    } else { // no rotation
      labelDims = this.GetLabelDims(labels, container); // get actual dims for skipping
      return this.SkipLabels(labels, labelDims);
    }
  } else { // vertical axis
    return this.SkipLabels(labels, maxLabelDims); // maxLabelDims contain the actual heights
  }
}

/**
 * @override
 */
DvtGroupAxisInfo.prototype.getAxisLine = function(context) {
  var axisLineOptions = this.Options['axisLine'];
  if(axisLineOptions['rendered'] == "on") {
    // Create and return the axis line
    var axisLineStroke = new DvtSolidStroke(axisLineOptions['lineColor'], 1, axisLineOptions['lineWidth']);
    return this.CreateGridLine(context, axisLineStroke, 0);
  }
  else
    return null;
}

/**
 * @override
 */
DvtGroupAxisInfo.prototype.getMajorGridLines = function(context) {
  var gridlines = [];
  
  // Major Ticks
  var coord, line;
  
  var majorTickOptions = this.Options['majorTick'];
  var majorTickStroke = new DvtSolidStroke(majorTickOptions['lineColor'], 1, majorTickOptions['lineWidth']);
  if(majorTickOptions['lineStyle'])
    majorTickStroke.setStyle(DvtStroke.convertTypeString(majorTickOptions['lineStyle']));
  
  var rendered = majorTickOptions['rendered'];
  if(rendered == "on" || (rendered == "auto" && this.Position == "tangential")) {
    var numGroups = this._groups.length;
    
    for(var i=0; i<numGroups; i++) {
      /* If placing gridlines at labels, use the coordinates at the labels
       * Else if placing gridlines in between labels, use the value halfway between two consecutive coordinates*/
      if(this._renderGridAtLabels)
        coord = this.getCoordAt(i);
      else {
        // Check to see if we are not an edge case
        if(this.getCoordAt(i+.5))
          coord = this.getCoordAt(i+.5); 
        // If we are at edge case don't draw a gridline  
        else
          continue;
      }
      
      if(coord != null){
        line = this.CreateGridLine(context, majorTickStroke, coord);
        gridlines.push(line);
      }
      
    }
  }
  
  return gridlines;
}

/**
 * @return {number} The group index.
 * @override
 */
DvtGroupAxisInfo.prototype.getValueAt = function(coord) {
  var minCoord = Math.min(this.StartCoord, this.EndCoord);
  var maxCoord = Math.max(this.StartCoord, this.EndCoord);
  
  // Return null if the coord is outside of the axis
  if(coord < minCoord || coord > maxCoord)
    return null;

  return this.getUnboundedValueAt(coord);
}

/**
 * @param {number} value The group index.
 * @override
 */
DvtGroupAxisInfo.prototype.getCoordAt = function(value) {
  if (value < this.MinValue || value > this.MaxValue)
    return null;
  else
    return this.getUnboundedCoordAt(value);
}

/**
 * @return {number} The group index.
 * @override
 */
DvtGroupAxisInfo.prototype.getBoundedValueAt = function(coord) {
  var minCoord = Math.min(this.StartCoord, this.EndCoord);
  var maxCoord = Math.max(this.StartCoord, this.EndCoord);

  if(coord < minCoord)
    coord = minCoord;
  else if(coord > maxCoord)
    coord = maxCoord;

  return this.getUnboundedValueAt(coord);
}

/**
 * @param {number} value The group index.
 * @override
 */
DvtGroupAxisInfo.prototype.getBoundedCoordAt = function(value) {
  if (value < this.MinValue)
    value = this.MinValue;
  else if (value >= this.MaxValue)
    value = this.MaxValue;

  return this.getUnboundedCoordAt(value);
}

/**
 * @return {number} The group index.
 * @override
 */
DvtGroupAxisInfo.prototype.getUnboundedValueAt = function(coord) {
  var incr = (this.EndCoord - this.StartCoord)/(this.MaxValue - this.MinValue);
  return this.MinValue + (coord - this.StartCoord) / incr;
}

/**
 * @param {number} value The group index.
 * @override
 */
DvtGroupAxisInfo.prototype.getUnboundedCoordAt = function(value) {
  var incr = (this.EndCoord - this.StartCoord)/(this.MaxValue - this.MinValue);
  return this.StartCoord + (value - this.MinValue) * incr;
}

/**
 * Returns the group label for the specified group.
 * @param {number} index The group index.
 * @return {string} The group label.
 */
DvtGroupAxisInfo.prototype.getLabelAt = function(index) {
  index = Math.round(index);
  if (index < 0 || index >= this._groups.length)
    return null;
  
  var label = this._groups[index];
  if(label && label.name)
    label = label.name;
  return label;
}

/**
 * Returns the index for the specified group label.
 * @param {string} label The group label.
 * @return {number} The group index. -1 if the group doesn't exist.
 */
DvtGroupAxisInfo.prototype.getIndexByLabel = function(label) {
  if (label == null)
    return -1;
    
  var index = -1;
  var lb;
  for (var i = 0; i < this._groups.length; i++) {
    lb = this._groups[i];
    if (lb && lb.name)
      lb = lb.name;
    if (label == lb) {
      index = i;
      break;
    }
  }
  return index;
}

/**
 * @override
 */
DvtGroupAxisInfo.prototype.getMinimumExtent = function() {
  return 1;
}
/**
 * Formatter for an axis with a linear scale.
 * Following cases can occur:
 * 1. scaling is set to none:
 *    No scaling is used in this case.
 * 2. scaling is set to auto, null or undefined:
 *    Scaling is computed. The nearest (less or equal) known scale is used. Regarding fraction part, if autoPrecision equals "on" then the count of significant decimal places 
 *    is based on tickStep otherwise fraction part is not formatted.
 * 3. otherwise
 *    Defined scaling is used. 
 *    Examples (autoPrecision = "on"): 
 *    minValue = 0, maxValue=10000, tickStep=1000, scale="thousand" -> formatted axis values: 0K , ..., 10K
 *    minValue = 0, maxValue=100, tickStep=10, scale="thousand" -> formatted axis values: 0.00K, 0.01K, ..., 0.10K
 *
 * @param {object} bundle translations bundle
 * @param {number} minValue the minimum value on the axis
 * @param {number} maxValue the maximum value on the axis
 * @param {number} tickStep the tick step between values on the axis
 * @param {string} scale the scale of values on the axis; if null or undefined then auto scaling is used.
 * @param {string} autoPrecision "on" if auto precision should be applied otherwise "off"; if null or undefined then auto precision is applied.
 * @constructor
 */
var DvtLinearScaleAxisValueFormatter = function (minValue, maxValue, tickStep, scale, autoPrecision) {
  var bundle = new DvtUtilBundle();
  DvtAbstractAxisValueFormatter.call(this, bundle);
  this.Init(minValue, maxValue, tickStep, scale, autoPrecision);
};

DvtObj.createSubclass(DvtLinearScaleAxisValueFormatter, DvtAbstractAxisValueFormatter, "DvtLinearScaleAxisValueFormatter");

/**
 * Allowed scales that can be used as formatter scale param values
 */
DvtLinearScaleAxisValueFormatter.SCALE_NONE = "none";
DvtLinearScaleAxisValueFormatter.SCALE_AUTO = "auto";
DvtLinearScaleAxisValueFormatter.SCALE_THOUSAND = "thousand";
DvtLinearScaleAxisValueFormatter.SCALE_MILLION = "million";
DvtLinearScaleAxisValueFormatter.SCALE_BILLION = "billion";
DvtLinearScaleAxisValueFormatter.SCALE_TRILLION = "trillion";
DvtLinearScaleAxisValueFormatter.SCALE_QUADRILLION = "quadrillion";

/**
 * The scaling factor difference between successive scale values
 */
DvtLinearScaleAxisValueFormatter.SCALING_FACTOR_DIFFERENCE = 3;

/**
 * Initializes the instance.
 */
DvtLinearScaleAxisValueFormatter.prototype.Init = function (minValue, maxValue, tickStep, scale, autoPrecision) {
  // array of successive scale values
  this._scales = {
  };
  // array of scale values ordered by scale factor asc
  this._scalesOrder = [];
  // mapping of scale factors to corresponding scale objects
  this._factorToScaleMapping = {
  };

  this.InitScales();
  this.InitFormatter(minValue, maxValue, tickStep, scale, autoPrecision)
};

/**
 * Initializes scale objects.
 * @protected
 *
 */
DvtLinearScaleAxisValueFormatter.prototype.InitScales = function () {
  /**
   * Creates scale object and refreshes formatter properties using it.
   * @param {string} scaleName one of allowed scale names (e.g. DvtLinearScaleAxisValueFormatter.SCALE_THOUSAND)
   * @param {number} scaleFactor scale factor of corresponding scale, i.e. 'x' such that 10^x represents corresponding scale (e.g. for scale DvtLinearScaleAxisValueFormatter.SCALE_THOUSAND x = 3)
   * @param {string} scaleBundleSuffix translation key which value (translated) represents given scale (e.g. for DvtLinearScaleAxisValueFormatter.SCALE_THOUSAND an translated english suffix is 'K')
   */
  var createScale = function (scaleName, scaleFactor, scaleKey) {
    var suffix;
    if (this.GetBundle()) {
      if (scaleKey) {
        // when bundle and bundle suffix is defined then init suffix
        suffix = this.GetBundle().getTranslatedString(scaleKey, null);
      }
    }

    var scale = {
      scaleFactor : scaleFactor, localizedSuffix : suffix
    }

    // update private properties
    this._scales[scaleName] = scale;
    this._scalesOrder.push(scale);
    this._factorToScaleMapping[scaleFactor] = scale;
  };

  var diff = DvtLinearScaleAxisValueFormatter.SCALING_FACTOR_DIFFERENCE;

  createScale.call(this, DvtLinearScaleAxisValueFormatter.SCALE_NONE, 0 * diff);
  createScale.call(this, DvtLinearScaleAxisValueFormatter.SCALE_THOUSAND, 1 * diff, "SCALING_SUFFIX_THOUSAND");
  createScale.call(this, DvtLinearScaleAxisValueFormatter.SCALE_MILLION, 2 * diff, "SCALING_SUFFIX_MILLION");
  createScale.call(this, DvtLinearScaleAxisValueFormatter.SCALE_BILLION, 3 * diff, "SCALING_SUFFIX_BILLION");
  createScale.call(this, DvtLinearScaleAxisValueFormatter.SCALE_TRILLION, 4 * diff, "SCALING_SUFFIX_TRILLION");
  createScale.call(this, DvtLinearScaleAxisValueFormatter.SCALE_QUADRILLION, 5 * diff, "SCALING_SUFFIX_QUADRILLION");

  // sort _scalesOrder array
  this._scalesOrder.sort(function (scale1, scale2) {
    if (scale1.scaleFactor < scale2.scaleFactor) {
      return  - 1;
    }
    else if (scale1.scaleFactor > scale2.scaleFactor) {
      return 1;
    }
    else {
      return 0;
    }
  });
};

/**
 * Initializes properties used for values formatting (e.g. scale factor that should be applied etc.).
 *
 * @param {number} minValue the minimum value on the axis
 * @param {number} maxValue the maximum value on the axis
 * @param {number} tickStep the tick step between values on the axis
 * @param {string} scale the scale of values on the axis
 * @param {boolean} autoPrecision true if auto precision should be applied otherwise false
 * @protected
 *
 */
DvtLinearScaleAxisValueFormatter.prototype.InitFormatter = function (minValue, maxValue, tickStep, scale, autoPrecision) {
  var findScale = false, decimalPlaces, scaleFactor, useAutoPrecision = false;

  // if autoPrecision doesn't equal "off" (i.e. is "on", null, undefined) then auto precision should be used.
  if(!(autoPrecision === "off")){
    useAutoPrecision = true;
  } 
  // try to use scale given by "scale" param and if no scale factor is found find appropriate scale
  scaleFactor = this._getScaleFactor(scale);
  if ((typeof scaleFactor) !== "number") {
    findScale = true;
  }

  // base a default scale factor calculation on the order of
  // magnitude (power of ten) of the maximum absolute value on the axis
  if (findScale) {
    // get the axis endpoint with the largest absolute value,
    // and find its base 10 exponent
    var absMax = Math.max(Math.abs(minValue), Math.abs(maxValue));

    var power = this._getPowerOfTen(absMax);
    scaleFactor = this._findNearestLEScaleFactor(power);
  }

  if(useAutoPrecision === true){
    if(tickStep == 0 && minValue == maxValue) {
      // TODO: HZHANG Remove this hack for chart tooltips, which currently passes 0 as the tick step in all cases.
      // Workaround for now will be to add decimal places to show at least 1 and at most 4 significant digits
      var valuePowerOfTen = this._getPowerOfTen(maxValue);
      var scaleFactorDiff = scaleFactor - valuePowerOfTen;
      if(scaleFactorDiff <= 0) // Value is same or larger than the scale factor, ensure 4 significant digits.
        decimalPlaces = 3 + scaleFactorDiff;
      else // Value is smaller, ensure enough decimals to show 1 significant digit
        decimalPlaces = Math.max(scaleFactorDiff, 4);
    }
    else {  
      // get the number of decimal places in the number by subtracting
      // the order of magnitude of the tick step from the order of magnitude
      // of the scale factor
      // (e.g.: scale to K, tick step of 50 -> 3 - 1 = 2 decimal places)
      var tickStepPowerOfTen = this._getPowerOfTen(tickStep);
      decimalPlaces = Math.max(scaleFactor - tickStepPowerOfTen, 0);
    }
  }

  // init private properties with computed values
  this._useAutoPrecision = useAutoPrecision;
  this._scaleFactor = scaleFactor;
  this._decimalPlaces = decimalPlaces;
};

/**
 * Finds a scale factor 'x' such that x <= value (e.g. if value equals 4 then returned scale factor equals 3)
 * @param {number} value value representing an order of magnitude
 * @return {number} a scale factor 'x' such that x <= value
 * @private
 */
DvtLinearScaleAxisValueFormatter.prototype._findNearestLEScaleFactor = function (value) {
  var scaleFactor = 0;

  if (value <= this._scalesOrder[0].scaleFactor) {
    // if the number is less than 10, don't scale
    scaleFactor = this._scalesOrder[0].scaleFactor;
  }
  else if (value >= this._scalesOrder[this._scalesOrder.length - 1].scaleFactor) {
    // if the data is greater than or equal to 10 quadrillion, scale to quadrillions
    scaleFactor = this._scalesOrder[this._scalesOrder.length - 1].scaleFactor;
  }
  else {
    // else find the nearest scaleFactor such that scaleFactor <= value
    var end = this._scalesOrder.length - 1;
    for (var i = end;i >= 0;i--) {
      if (this._scalesOrder[i].scaleFactor <= value) {
        scaleFactor = this._scalesOrder[i].scaleFactor;
        break;
      }
    }
  }
  return scaleFactor;
};

/**
 * Returns scale factor of scale given by scale name.
 * @return scale factor of scale given by scale name
 * @private
 */
DvtLinearScaleAxisValueFormatter.prototype._getScaleFactor = function (scaleName) {
  // If no scaling factor defined, use auto by default.
  if(!scaleName)
    scaleName = DvtLinearScaleAxisValueFormatter.SCALE_AUTO;

  var scaleFactor, scale = this._scales[scaleName];
  if (scale) {
    scaleFactor = scale.scaleFactor;
  }
  return scaleFactor;
};

/**
 * Formats given value using previously computed scale factor and decimal digits count. In case that parsed value equals NaN an unformatted value is returned.
 * @override
 * @param {object} value to be formatted.
 * @return {string} formatted value as string
 */
DvtLinearScaleAxisValueFormatter.prototype.format = function (value, converter) {
  var parsed = parseFloat(value);
  if (!isNaN(parsed)) {
    // Find the suffix for the scale factor
    var suffix;
    if (this._scaleFactor > 0) {
      for (var i = 0;i < this._scaleFactor;i++) {
        parsed /= 10;
      }
      suffix = this._factorToScaleMapping[this._scaleFactor].localizedSuffix;
    }
    
    // Convert the number itself
    if (converter && converter.getAsString) {
      parsed = converter.getAsString(parsed);
    } 
    else if (converter && converter['format'])
      parsed = converter['format'](parsed);
    else if (this._useAutoPrecision && !isNaN(parseFloat(parsed))) {
      parsed = parseFloat(new Number(parsed).toFixed(this._decimalPlaces));
      parsed = this._formatFraction(parsed);
    }
    
    // Add the scale factor suffix
    if (typeof suffix === "string") {
      parsed += suffix;
    }
    return parsed;
  }
  else {
    return value;
  }
};

/**
 * Formats fraction part of given value (adds zeroes if needed).
 * @param {number} number to be formatted
 * @return {string} number with fraction part formatted as string
 * @private
 */
DvtLinearScaleAxisValueFormatter.prototype._formatFraction = function (value) {
  var formatted = "" + value;
  if (this._decimalPlaces > 0) {
    if (formatted.indexOf(".") ==  - 1) {
      formatted += ".";
    }
    var existingPlacesCount = formatted.substring(formatted.indexOf(".") + 1).length;

    while (existingPlacesCount < this._decimalPlaces) {
      formatted += "0";
      existingPlacesCount++;
    }
  }
  return formatted;
};

/**
 * Fro given value it returns its order of magnitude.
 * @param {number} value for which order of magnitude should be found
 * @return {number} order of magnitude for given value
 * @private
 */
DvtLinearScaleAxisValueFormatter.prototype._getPowerOfTen = function (value) {
  // more comprehensive and easier than working with value returned by Math.log(value)/Math.log(10)
  value = (value >= 0) ? value :  - value;
  var power = 0;

  // Check for degenerate and zero values
  if (value < 1E-15) {
    return 0;
  }
  else if (value == Infinity) {
    return Number.MAX_VALUE;
  }

  if (value >= 10) {
    // e.g. for 1000 the power should be 3
    while (value >= 10) {
      power += 1;
      value /= 10;
    }
  }
  else if (value < 1) {
    while (value < 1) {
      power -= 1;
      value *= 10;
    }
  }
  return power;
};
/**
 * Calculated axis information and drawable creation for a time axis.
 * @param {DvtContext} context
 * @param {object} options The object containing specifications and data for this component.
 * @param {DvtRectangle} availSpace The available space.
 * @class
 * @constructor
 * @extends {DvtAxisInfo}
 */
var DvtTimeAxisInfo = function (context, options, availSpace) {
  this.Init(context, options, availSpace);
}

DvtObj.createSubclass(DvtTimeAxisInfo, DvtAxisInfo, "DvtTimeAxisInfo");

// ------------------------
// Constants
//
DvtTimeAxisInfo.TIME_SECOND = 1000;
DvtTimeAxisInfo.TIME_MINUTE = 60 * DvtTimeAxisInfo.TIME_SECOND;
DvtTimeAxisInfo.TIME_HOUR = 60 * DvtTimeAxisInfo.TIME_MINUTE;
DvtTimeAxisInfo.TIME_DAY = 24 * DvtTimeAxisInfo.TIME_HOUR;
DvtTimeAxisInfo.TIME_MONTH_MIN = 28 * DvtTimeAxisInfo.TIME_DAY;// minimum # of days in a month
DvtTimeAxisInfo.TIME_MONTH = (365 / 12) * DvtTimeAxisInfo.TIME_DAY;// approx.
DvtTimeAxisInfo.TIME_YEAR = 365 * DvtTimeAxisInfo.TIME_DAY;

// For time localization. Not currently used yet.
DvtTimeAxisInfo.AM_INDEX = 12;
DvtTimeAxisInfo.PM_INDEX = 13;
DvtTimeAxisInfo.AMPM_BEFORE_INDEX = 14;
DvtTimeAxisInfo.DMY_ORDER_INDEX = 15;
DvtTimeAxisInfo.YEAR_TRAILING_CHAR_INDEX = 16;
DvtTimeAxisInfo.DAY_TRAILING_CHAR_INDEX = 17;

/**
 * @override
 */
DvtTimeAxisInfo.prototype.Init = function (context, options, availSpace) {
  DvtTimeAxisInfo.superclass.Init.call(this, context, options, availSpace);
  
  // Figure out the coords for the min/max values
  if (this.Position == "top" || this.Position == "bottom") {
    // Provide at least the minimum buffer at each side to accommodate labels
    if (!options['_isOverview'] && options['tickLabel']['rendered'] == "on") {
      this.StartOverflow = Math.max(DvtAxis.MINIMUM_AXIS_BUFFER - options['leftBuffer'], 0);
      this.EndOverflow = Math.max(DvtAxis.MINIMUM_AXIS_BUFFER - options['rightBuffer'], 0);
    }
    
    // Axis is horizontal, so flip for BIDI if needed
    if (DvtAgent.isRightToLeft(context)) {
      this._minCoord = this.EndCoord - this.EndOverflow;
      this._maxCoord = this.StartCoord + this.StartOverflow;
    }
    else {
      this._minCoord = this.StartCoord + this.StartOverflow;
      this._maxCoord = this.EndCoord - this.EndOverflow;
    }
  }
  else {
    // Vertical axis should go from top to bottom
    this._minCoord = this.StartCoord;
    this._maxCoord = this.EndCoord;
  }

  this._converter = null;
  if (options['tickLabel'] != null) {
    this._converter = options['tickLabel']['converter'];
  }

  this._groups = options['groups'];
  
  this.DataMin = options['dataMin'];
  this.DataMax = options['dataMax'];
  
  this._averageInterval = this._groups.length > 0 ? (this.DataMax - this.DataMin) / (this._groups.length - 1) : 0;
  
  // Calculate the increment and add offsets if specified
  var endOffset = options['endGroupOffset'] > 0 ? options['endGroupOffset'] * this._averageInterval : 0;
  var startOffset = options['startGroupOffset'] > 0 ? options['startGroupOffset'] * this._averageInterval : 0;
  
  this.GlobalMin = options['min'] != null ? options['min'] : this.DataMin - startOffset;
  this.GlobalMax = options['max'] != null ? options['max'] : this.DataMax + endOffset;
  
  this.MinValue = options['viewportMin'] == null ? this.GlobalMin : options['viewportMin'];
  this.MaxValue = options['viewportMax'] == null ? this.GlobalMax : options['viewportMax'];
  
  // Set min/max by start/endGroup
  if (options['viewportStartGroup'] != null)
    this.MinValue = options['viewportStartGroup'] - startOffset;
  if (options['viewportEndGroup'] != null)
    this.MaxValue = options['viewportEndGroup'] + endOffset;
  
  this._timeZoneOffset = 0;
  this._timeRange = this.MaxValue - this.MinValue;

  this._level1Labels = null;
  this._level2Labels = null;
  // Coordinates of labels need to be stored for gridline rendering
  this._level1Coords = null;
  this._level2Coords = null;
  this._isOneLevel = true;
  
  var bundle = new DvtUtilBundle();
  this._timeAxisResources = [
    bundle.getTranslatedString('MONTH_SHORT_JANUARY', null),
    bundle.getTranslatedString('MONTH_SHORT_FEBRUARY', null),
    bundle.getTranslatedString('MONTH_SHORT_MARCH', null),
    bundle.getTranslatedString('MONTH_SHORT_APRIL', null),
    bundle.getTranslatedString('MONTH_SHORT_MAY', null),
    bundle.getTranslatedString('MONTH_SHORT_JUNE', null),
    bundle.getTranslatedString('MONTH_SHORT_JULY', null),
    bundle.getTranslatedString('MONTH_SHORT_AUGUST', null),
    bundle.getTranslatedString('MONTH_SHORT_SEPTEMBER', null),
    bundle.getTranslatedString('MONTH_SHORT_OCTOBER', null),
    bundle.getTranslatedString('MONTH_SHORT_NOVEMBER', null),
    bundle.getTranslatedString('MONTH_SHORT_DECEMBER', null)
  ];
  
  this._renderGridAtLabels = options['_renderGridAtLabels'];
}

/**
 * Formats the label given an axis value (used for generating tooltips).
 * @param {Number} axisValue The axis value (in milliseconds)
 * @return {String} A formatted axis label
 */
DvtTimeAxisInfo.prototype.formatLabel = function (axisValue) {
  var date = new Date(axisValue + this._timeZoneOffset);
  var twoLabels = this._formatAxisLabel(date, null);
  if (twoLabels[1] != null)
    return twoLabels[0] + " " + twoLabels[1];
  else 
    return twoLabels[0];
}

/**
 * Formats the level 1 and level 2 axis labels
 * @param {Date} date The current date
 * @param {Date} prevDate The date of the previous set of labels
 * @return {Array} An array [level1Label, level2Label]
 * @private
 */
DvtTimeAxisInfo.prototype._formatAxisLabel = function (date, prevDate) {
  var label1 = null;// level 1 label
  var label2 = null;// level 2 label
  // If dateTimeFormatter is used, use it
  if (this._converter && this._converter.getAsString && this._converter.getAsObject) {
    label1 = this._converter.getAsString(date);
  }
  else if (this._converter && this._converter['format']) {
    label1 = this._converter['format'](date);
  }
  else if (this._averageInterval >= DvtTimeAxisInfo.TIME_YEAR) {
    label1 = this._formatDate(date, false, false, true);// Year
  }

  else if (this._timeRange >= DvtTimeAxisInfo.TIME_YEAR || this._averageInterval >= DvtTimeAxisInfo.TIME_MONTH_MIN) {
    if (prevDate == null || prevDate.getMonth() != date.getMonth())
      label1 = this._formatDate(date, false, true, false);// Month
    if (prevDate == null || prevDate.getYear() != date.getYear())
      label2 = this._formatDate(date, false, false, true);// Year
  }

  else if (this._timeRange >= DvtTimeAxisInfo.TIME_MONTH_MIN || this._averageInterval >= DvtTimeAxisInfo.TIME_DAY) {
    if (prevDate == null || prevDate.getDate() != date.getDate())
      label1 = this._formatDate(date, true, false, false);// Day
    if (prevDate == null || prevDate.getYear() != date.getYear())
      label2 = this._formatDate(date, false, true, true);// Year, Month
    else if (prevDate.getMonth() != date.getMonth())
      label2 = this._formatDate(date, false, true, false);// Month
  }

  else if (this._timeRange >= DvtTimeAxisInfo.TIME_HOUR || this._averageInterval >= DvtTimeAxisInfo.TIME_MINUTE) {
    if (prevDate == null || (prevDate.getHours() != date.getHours() || prevDate.getMinutes() != date.getMinutes()))
      label1 = this._formatTime(date, false);// HH:MM
    if (prevDate == null || prevDate.getMonth() != date.getMonth())
      label2 = this._formatDate(date, true, true, false);// Month, Day
    else if (prevDate.getDate() != date.getDate()) {
      if (this.Position == 'left' || this.Position == 'right')
        label2 = this._formatDate(date, true, true, false);// Month, Day
      else 
        label2 = this._formatDate(date, true, false, false);// Day
    }
  }

  else {
    if (prevDate == null || prevDate.getSeconds() != date.getSeconds())
      label1 = this._formatTime(date, true);// HH:MM:SS
    if (prevDate == null || prevDate.getMonth() != date.getMonth())
      label2 = this._formatDate(date, true, true, false);// Month, Day
    else if (prevDate.getDate() != date.getDate()) {
      if (this.Position == 'left' || this.Position == 'right')
        label2 = this._formatDate(date, true, true, false);// Month, Day
      else 
        label2 = this._formatDate(date, true, false, false);// Day
    }
  }

  return [label1, label2];
}

/**
 * Returns the date as a DMY string
 * @param {Date} date The date
 * @param {boolean} showDay Whether the day is shown
 * @param {boolean} showMonth Whether the month is shown
 * @param {boolean} showYear Whether the year is shown
 * @return {string} The formatted string
 * @private
 */
DvtTimeAxisInfo.prototype._formatDate = function (date, showDay, showMonth, showYear) {
  var yearStr = date.getFullYear();
  var monthStr;
  if (this._timeAxisResources && this._timeAxisResources.length >= 12)
    monthStr = this._timeAxisResources[date.getMonth()];
  else 
    monthStr = date.toString().split(" ")[1];// date.toString() returns "Day Mon Date HH:MM:SS TZD YYYY"
  var dayStr = date.getDate();
  
  // Add the day and year trailing characters if needed
  // TODO: Localize properly!
  if (this._timeAxisResources && this._timeAxisResources.length > DvtTimeAxisInfo.DAY_TRAILING_CHAR_INDEX) {
    var yearChar = this._timeAxisResources[DvtTimeAxisInfo.YEAR_TRAILING_CHAR_INDEX];
    var dayChar = this._timeAxisResources[DvtTimeAxisInfo.DAY_TRAILING_CHAR_INDEX];
    // These will be "" if not needed
    yearStr += yearChar;
    dayStr += dayChar;
  }

  // Process the DMY Order
  // TODO: Localize properly!
  var dmyOrder = "DMY";
  if (this._timeAxisResources && this._timeAxisResources.length > DvtTimeAxisInfo.DMY_ORDER_INDEX) {
    dmyOrder = this._timeAxisResources[DvtTimeAxisInfo.DMY_ORDER_INDEX];
  }

  var dateStr = "";

  for (var i = 0;i < dmyOrder.length;i++) {
    if (showDay && dmyOrder[i] == 'D') {
      dateStr += dayStr + " ";
    }
    else if (showMonth && dmyOrder[i] == 'M') {
      dateStr += monthStr + " ";
    }
    else if (showYear && dmyOrder[i] == 'Y') {
      dateStr += yearStr + " ";
    }
  }

  return dateStr.length > 0 ? dateStr.slice(0, dateStr.length - 1) : dateStr;
}

/**
 * Returns the date as an HH:MM:SS string
 * @param {Date} date The date
 * @param {boolean} showSecond Whether the second is shown
 * @return {string} The formatted string
 * @private
 */
DvtTimeAxisInfo.prototype._formatTime = function (date, showSecond) {
  var hours = date.getHours();
  var mins = date.getMinutes();
  var secs = date.getSeconds();

  var am = "";
  var pm = "";
  var ampmBefore = false;
  
  // TODO: Localize properly!
  if (this._timeAxisResources != null && this._timeAxisResources > DvtTimeAxisInfo.AMPM_BEFORE_INDEX) {
    am = this._timeAxisResources[DvtTimeAxis.AM_INDEX];
    pm = this._timeAxisResources[DvtTimeAxis.PM_INDEX];
    ampmBefore = this._timeAxisResources[DvtTimeAxisInfo.AMPM_BEFORE_INDEX] == "t";
  }

  var b12HFormat = (am != "" && pm != "");
  var ampm;

  if (b12HFormat) {
    ampm = pm;
    if (hours > 12) {
      hours -= 12;
      ampm = pm;
    }
    else if (hours == 0) {
      ampm = am;
      hours = 12;
    }
    else if (hours < 12) {
      ampm = am;
    }
  }

  var timeLabel = this._doubleDigit(hours) + ":" + this._doubleDigit(mins);

  if (showSecond) {
    timeLabel += ":" + this._doubleDigit(secs);
  }

  if (b12HFormat) {
    if (ampmBefore)
      return ampm + " " + timeLabel;
    else 
      return timeLabel + " " + ampm;
  }
  else {
    return timeLabel;
  }
}

/**
 * Creates a double-digit number string for the HH:MM:SS format
 * @param {Number} num A number less than 100
 * @return {String} A double-digit number string
 * @private
 */
DvtTimeAxisInfo.prototype._doubleDigit = function (num) {
  if (num < 10) {
    return "0" + num;
  }
  return "" + num;
}

/**
 * Returns the time label interval for mixed frequency data.
 * Makes sure that the interval is a regular time unit.
 * @return {number} The interval.
 * @private
 */
DvtTimeAxisInfo.prototype._getMixedFrequencyInterval = function() {
  if (this._averageInterval >= DvtTimeAxisInfo.TIME_YEAR)
    return DvtTimeAxisInfo.TIME_YEAR;
  if (this._averageInterval >= DvtTimeAxisInfo.TIME_MONTH)
    return DvtTimeAxisInfo.TIME_MONTH;
  if (this._averageInterval >= DvtTimeAxisInfo.TIME_DAY)
    return DvtTimeAxisInfo.TIME_DAY;
  if (this._averageInterval >= DvtTimeAxisInfo.TIME_HOUR)
    return DvtTimeAxisInfo.TIME_HOUR;
  if (this._averageInterval >= DvtTimeAxisInfo.TIME_MINUTE)
    return DvtTimeAxisInfo.TIME_MINUTE;
  return DvtTimeAxisInfo.TIME_SECOND;
}

/**
 * Generates the level 1 and level 2 tick labels
 * @param {DvtContext} context
 * @private
 */
DvtTimeAxisInfo.prototype._generateLabels = function (context) {
  var labels1 = []; 
  var labels2 = []; 
  var coords1 = [];
  var coords2 = [];
  var prevDate = null;
  var c1 = 0;// number of level 1 labels
  var c2 = 0;// number of level 2 labels
  var container = context.getStage(context);
  var isRTL = DvtAgent.isRightToLeft(context);
  var isVert = (this.Position == "left" || this.Position == "right");
  var scrollable = this.Options['zoomAndScroll'] != 'off';
 
  if (scrollable)
    var first = true;
  
  // Bug #17046187 : On Chrome, creating a gap value to be used for spacing level1 labels and level2 labels
  var levelsGap = 0; 
  if (isVert && DvtAgent.isBrowserChrome()) {
    levelsGap = parseInt(this.Options['tickLabel']['style'].getStyle('font-size')) * .2;
  }
  
  // Find the time positions where labels can be located
  var times = [];
  var minSkip = 0;
  if (this.Options['timeAxisType'] == "mixedFrequency") {
    var time = this.MinValue;
    var interval = this._getMixedFrequencyInterval();
    while (time <= this.MaxValue) {
      times.push(time);
      time += interval;
    }
    minSkip = Math.floor(this._averageInterval / interval) - 1; // to avoid label overcrowding
  }
  else
    times = this._groups;
  
  // Create and format the labels
  for (var i = 0; i < times.length; i++) {
    var time = times[i];
    var coord = this.getCoordAt(time);
    if (coord == null)
      continue;
        
    var date = new Date(time + this._timeZoneOffset);
    var twoLabels = this._formatAxisLabel(date, prevDate);
    
    var label1 = twoLabels[0];
    var label2 = twoLabels[1];
    //level 1 label
    if (label1 != null) { 
      // If level 2 exists put a levelsGap space between labels. levelsGap is only non-zero on Chrome.
      if(label2 != null) 
        labels1.push(this.CreateLabel(context, label1, coord + levelsGap));
      else 
        labels1.push(this.CreateLabel(context, label1, coord));
      coords1.push(coord);  
    }
    else {
      labels1.push(null);
      coords1.push(null);
    }
    
    if (scrollable) {
      if (first) {
        coord = this.MinValue ? this.getCoordAt(this.MinValue) : coord;
        first = false;
      }
    }
    
    //level 2 label    
    if (label2 != null) {
      var text = null;
      if(label2 != null)
        text = this.CreateLabel(context, label2, coord - levelsGap);
      else 
        text = this.CreateLabel(context, label2, coord);
      coords2.push(coord);
      if (!isVert) //set alignment now in order to determine if the labels will overlap
        isRTL ? text.alignRight() : text.alignLeft();
      labels2.push(text);
      this._isOneLevel = false;
    }
    else {
      labels2.push(null);
      coords2.push(null);
    }

    prevDate = date;
  }
  
  // skip level 1 labels every uniform interval
  c1 = this._skipLabelsUniform(labels1, this.GetLabelDims(labels1, container), minSkip);
  
  // skip level 2 labels greedily
  c2 = this._skipLabelsGreedy(labels2, this.GetLabelDims(labels2, container));

  if (!scrollable) {
    if (c1 <= 1.5 * c2 && c2 > 1) {
      // too few level 1 labels
      labels1 = labels2;
      labels2 = null; 
      // center align the new level1 labels
      for (var j = 0; j < labels1.length; j++) {
        if (labels1[j] != null)
          labels1[j].alignCenter();
      }
    }  
    else if (c2 < 2) {
      // too few level 2 labels
      labels2 = null;
    }
  }
  
  if (c2 < 2)
    this._isOneLevel = true;

  if (isVert && labels2 != null)
    this._skipVertLabels(labels1, labels2, container);

  this._level1Labels = labels1;
  this._level2Labels = labels2;

  // Store coordinates of labels for gridline rendering
  this._level1Coords = coords1;
  this._level2Coords = coords2;
}

/**
 * Determines if rectangle A (bounded by pointA1 and pointA2) and rectangle B (bounded by pointB1 and B2) overlap.
 * All the points should lie in one dimension.
 * @param {Number} pointA1
 * @param {Number} pointA2
 * @param {Number} pointB1
 * @param {Number} pointB2
 * @param {Number} gap The minimum gap between the two rectangles
 * @return {Boolean} whether rectangle A and B overlap
 * @private
 */
DvtTimeAxisInfo._isOverlapping = function (pointA1, pointA2, pointB1, pointB2, gap) {
  if (pointB1 >= pointA1 && pointB1 - gap < pointA2)
    return true;
  else if (pointB1 < pointA1 && pointB2 + gap > pointA1)
    return true;
  return false;
}

/**
 * Skip labels greedily. Delete all labels that overlap with the last rendered label.
 * @param {Array} labels An array of DvtText labels for the axis. This array will be modified by the method.
 * @param {Array} labelDims An array of DvtRectangle objects that describe the x, y, height, width of the axis labels.
 * @return {Number} The number of remaining labels after skipping.
 * @private
 */
DvtTimeAxisInfo.prototype._skipLabelsGreedy = function (labels, labelDims) {
  // If there are no labels, return
  if (!labelDims || labelDims.length <= 0)
    return false;

  var isVert = (this.Position == "left" || this.Position == "right");
  var gap = (isVert ? this.Options['layout']['verticalAxisGap'] : this.Options['layout']['horizontalAxisGap']);

  var count = 0;// the number of non-null labels 
  var pointA1, pointA2, pointB1, pointB2;

  if (labelDims[0] == null) {
    return count;
  }
  else {
    if (isVert) {
      pointA1 = labelDims[0].y;
      pointA2 = labelDims[0].y + labelDims[0].h;
    }
    else {
      pointA1 = labelDims[0].x;
      pointA2 = labelDims[0].x + labelDims[0].w;
    }
    count++;
  }

  for (var j = 1;j < labelDims.length;j++) {
    if (labelDims[j] == null)
      continue;

    if (isVert) {
      pointB1 = labelDims[j].y;
      pointB2 = labelDims[j].y + labelDims[j].h;

      if (DvtTimeAxisInfo._isOverlapping(pointA1, pointA2, pointB1, pointB2, gap))
        labels[j] = null;
    }
    else {
      pointB1 = labelDims[j].x;
      pointB2 = labelDims[j].x + labelDims[j].w;

      if (DvtTimeAxisInfo._isOverlapping(pointA1, pointA2, pointB1, pointB2, gap))
        labels[j] = null;
    }

    if (labels[j] != null) {
      // start evaluating from label j
      pointA1 = pointB1;
      pointA2 = pointB2;
      count++;
    }
  }

  return count;
}

/**
 * Skip labels uniformly (every regular interval).
 * @param {Array} labels An array of DvtText labels for the axis. This array will be modified by the method.
 * @param {Array} labelDims An array of DvtRectangle objects that describe the x, y, height, width of the axis labels.
 * @param {number} minSkip The minimum label skipping frequency.
 * @return {number} The number of remaining labels after skipping.
 * @private
 */
DvtAxisInfo.prototype._skipLabelsUniform = function(labels, labelDims, minSkip) {
  var shortLabelDims = []; // labelDims with null elements removed
  for (var j=0; j<labelDims.length; j++) {
    if (labelDims[j] != null)
      shortLabelDims.push(labelDims[j]);
  }

  var skippedLabels = minSkip;
  var bOverlaps = this.IsOverlapping(shortLabelDims, skippedLabels);
  while (bOverlaps) {
    skippedLabels++;
    bOverlaps = this.IsOverlapping(shortLabelDims, skippedLabels);
  }
  
  var count = shortLabelDims.length; // # of rendered labels
  if (skippedLabels > 0) {
    var n = 0; // non-null label counter
    for (var j=0; j<labels.length; j++) {
      if (labels[j] != null) {
        if (n % (skippedLabels+1) != 0) {
          labels[j] = null;
          count--;
        }
        n++;
      }
    }
  }
  return count;
}

/**
 * Format the alignments of the vertical axis labels and skip them accordingly so that level1 and level2 don't overlap.
 * @param {Array} labels1 An array of level 1 DvtText labels for the axis. This array will be modified by the method.
 * @param {Array} labels2 An array of level 2 DvtText labels for the axis. This array will be modified by the method.
 * @param {DvtContainer} container
 * @private
 */
DvtTimeAxisInfo.prototype._skipVertLabels = function (labels1, labels2, container) {
  // returns the dimensions of the label
  var getDims = function (label) {
    return label.measureDimensions();
  }

  var gap = parseInt(this.Options['tickLabel']['style'].getStyle('font-size')) * .1;

  // returns if two rectangles (dimsA and dimsB) overlap vertically
  var isOverlapping = function (dimsA, dimsB) {
    return DvtTimeAxisInfo._isOverlapping(dimsA.y, dimsA.y + dimsA.h, dimsB.y, dimsB.y + dimsB.h, gap);
  }

  var lastDims = null;
  var overlapping = false;

  // attempt to render both level 1 and level 2 and see if they fit on the axis
  for (var i = 0;i < labels1.length;i++) {
    if (labels1[i] && labels2[i]) {
      labels1[i].alignTop();
      labels2[i].alignBottom();
      if (lastDims && isOverlapping(lastDims, getDims(labels1[i]))) {
        overlapping = true;
        break;
      }
      else if(labels1[i+1] && isOverlapping(getDims(labels1[i]),getDims(labels1[i+1]))){
        overlapping = true;
        break;
      }
      else {
        lastDims = getDims(labels2[i]);
      }
    }
    else if (labels1[i] || labels2[i]) {
      var label = labels1[i] ? labels1[i] : labels2[i];
      if (lastDims && isOverlapping(lastDims, getDims(label))) {
        overlapping = true;
        break;
      }
      else {
        lastDims = getDims(label);
      }
    }
  }

  if (!overlapping)
    return;// if both levels fit, we're done
  var lastLv1Idx = null;
  var lastLv1Dims = null;
  var lastLv2Dims = null;
  var dims;

  // if they don't fit:
  // - for points that have level 2 labels, don't generate the level 1 (one level nesting)
  // - skip all level 1 labels that overlaps with level 2 labels
  for (i = 0;i < labels1.length;i++) {
    if (labels2[i]) {
      // if level 2 exists
      labels1[i] = null;// delete level 1
      labels2[i].alignMiddle();
      dims = getDims(labels2[i]);
      if (lastLv1Dims && isOverlapping(lastLv1Dims, dims)) {
        labels1[lastLv1Idx] = null;
      }
      lastLv2Dims = dims;
    }
    else if (labels1[i]) {
      // if level 1 exists but not level 2
      dims = getDims(labels1[i]);
      if (lastLv2Dims && isOverlapping(lastLv2Dims, dims)) {
        labels1[i] = null;
      }
      else {
        lastLv1Dims = dims;
        lastLv1Idx = i;
      }
    }
  }
}

/**
 * @override
 */
DvtTimeAxisInfo.prototype.getLabels = function (context, levelIdx) {
  if (levelIdx && levelIdx > 1)// time axis has no more than two levels
    return null;

  if (!this._level1Labels)
    this._generateLabels(context);
  
  if (levelIdx == 1) {
    return this._level2Labels;
  }

  return this._level1Labels;
}

/**
 * @override
 */
DvtTimeAxisInfo.prototype.getAxisLine = function (context) {
  var axisLineOptions = this.Options['axisLine'];
  if (axisLineOptions['rendered'] == "on") {
    // TODO hzhang Check Axis Line behavior for negative/mixed axes.
    var axisLineStroke = new DvtSolidStroke(axisLineOptions['lineColor'], 1, axisLineOptions['lineWidth']);
    return this.CreateGridLine(context, axisLineStroke, 10);
  }
  else 
    return null;
}

/**
 * Returns the grid line shift at index i.
 * @param {number} i
 * @return {number} Grid line shift.
 * @private
 */
DvtTimeAxisInfo.prototype._getGridLineShift = function(i) {
  if (this._renderGridAtLabels)
    return 0;
    
  var curr = this._level1Coords[i];
  var prev = null;
  for (var j = i-1; j >= 0; j--) { // find the coord before the current one
    if (this._level1Coords[j] != null) {
      prev = this._level1Coords[j];
      break;
    }
  }
  
  if (prev == null)
    return Infinity;
  
  return (curr - prev) / 2;
}

/**
 * @override
 */
DvtTimeAxisInfo.prototype.getMajorGridLines = function(context) {
  var majorTickOptions = this.Options['majorTick']; 
  if (majorTickOptions['rendered'] != "on")
    return [];
  
  var coords = [];
  if (this._isOneLevel){ // only one level, level1 is majorTick
    for (var i = 0; i < this._level1Coords.length; i++) {
      if (this._level1Coords[i] != null && this._level1Labels[i] != null)
        coords.push(this._level1Coords[i] - this._getGridLineShift(i));
    }
  }
  else { // level1 is minorTick, level2 is majorTick
    for (var i = 1; i < this._level2Coords.length; i++) { // don't draw first gridline for level2 label
      if (this._level2Coords[i] != null)
        coords.push(this._level2Coords[i] - this._getGridLineShift(i)); // render gridline even if label is skipped
    }
  }
  
  var majorTickStroke = new DvtSolidStroke(majorTickOptions['lineColor'], 1, majorTickOptions['lineWidth']);
  if (majorTickOptions['lineStyle'])
    majorTickStroke.setStyle(DvtStroke.convertTypeString(majorTickOptions['lineStyle']));
  
  var gridlines = [];
  for (var i = 0; i < coords.length; i++) {
    if (coords[i] >= this._minCoord && coords[i] <= this._maxCoord)
      gridlines.push(this.CreateGridLine(context, majorTickStroke, coords[i]));
  }
  
  return gridlines;
}

/**
 * @override
 */
DvtTimeAxisInfo.prototype.getMinorGridLines = function(context) {
  var minorTickOptions = this.Options['minorTick'];
  if (minorTickOptions['rendered'] != "on" || this._isOneLevel) // minorTick only applies on timeAxis if there is more than one level
    return [];
  
  var coords = [];
  for (var i = 0; i < this._level1Coords.length; i++) {
    if (this._level1Coords[i] != null && this._level1Labels[i] != null)
      coords.push(this._level1Coords[i] - this._getGridLineShift(i));
  }
  
  var minorTickStroke = new DvtSolidStroke(minorTickOptions['lineColor'], 1, minorTickOptions['lineWidth']);
  if (minorTickOptions['lineStyle'])
    minorTickStroke.setStyle(DvtStroke.convertTypeString(minorTickOptions['lineStyle'])); 
   
  var gridlines = [];
  for (var i = 0; i < coords.length; i++) {
    if (coords[i] >= this._minCoord && coords[i] <= this._maxCoord)
      gridlines.push(this.CreateGridLine(context, minorTickStroke, coords[i]));
  }
  
  return gridlines;
}

/**
 * @override
 */
DvtTimeAxisInfo.prototype.getValueAt = function (coord) {
  var minCoord = Math.min(this._minCoord, this._maxCoord);
  var maxCoord = Math.max(this._minCoord, this._maxCoord);
  
  // Return null if the coord is outside of the axis
  if(coord < minCoord || coord > maxCoord)
    return null;

  return this.getUnboundedValueAt(coord);
}

/**
 * @override
 */
DvtTimeAxisInfo.prototype.getCoordAt = function (value) {
  // Return null if the value is outside of the axis
  if (value < this.MinValue || value > this.MaxValue)
    return null;

  return this.getUnboundedCoordAt(value);
}

/**
 * @override
 */
DvtTimeAxisInfo.prototype.getBoundedValueAt = function (coord) {
  var minCoord = Math.min(this._minCoord, this._maxCoord);
  var maxCoord = Math.max(this._minCoord, this._maxCoord);

  if(coord < minCoord)
    coord = minCoord;
  else if(coord > maxCoord)
    coord = maxCoord;

  return this.getUnboundedValueAt(coord);
}

/**
 * @override
 */
DvtTimeAxisInfo.prototype.getBoundedCoordAt = function (value) {
  if (value < this.MinValue)
    value = this.MinValue;
  else if (value > this.MaxValue)
    value = this.MaxValue;

  return this.getUnboundedCoordAt(value);
}

/**
 * @override
 */
DvtTimeAxisInfo.prototype.getUnboundedValueAt = function (coord) {
  var ratio = (coord - this._minCoord) / (this._maxCoord - this._minCoord);
  return this.MinValue + (ratio * (this.MaxValue - this.MinValue));
}

/**
 * @override
 */
DvtTimeAxisInfo.prototype.getUnboundedCoordAt = function (value) {
  var ratio = (value - this.MinValue) / (this.MaxValue - this.MinValue);
  return this._minCoord + (ratio * (this._maxCoord - this._minCoord));
}

/**
 * Gets the width of a group (for rendering bar chart)
 * @return {Number} the width of a group
 */
DvtTimeAxisInfo.prototype.getGroupWidth = function () {
  return Math.abs(this.getUnboundedCoordAt(this.MinValue + this._averageInterval) - this.getUnboundedCoordAt(this.MinValue));
}

/**
 * @override
 */
DvtTimeAxisInfo.prototype.getMinimumExtent = function() {
  return this._averageInterval;
}

/**
 * @override
 */
DvtTimeAxisInfo.prototype.getStartOverflow = function() {
  if ((this.Position == "top" || this.Position == "bottom") && DvtAgent.isRightToLeft(this.getCtx()))
    return this.EndOverflow;
  else
    return this.StartOverflow;
}

/**
 * @override
 */
DvtTimeAxisInfo.prototype.getEndOverflow = function() {
  if ((this.Position == "top" || this.Position == "bottom") && DvtAgent.isRightToLeft(this.getCtx()))
    return this.StartOverflow;
  else
    return this.EndOverflow;
}
/**
 * The base class for tree components.
 * @extends {DvtBaseComponent}
 * @class The base class for tree components.
 * @constructor
 */
var DvtBaseTreeView = function() {}

DvtObj.createSubclass(DvtBaseTreeView, DvtBaseComponent, "DvtBaseTreeView");

// Layout Constants
DvtBaseTreeView._EMPTY_TEXT_BUFFER = 2;

// Style
DvtBaseTreeView.BACKGROUND_STYLE = "BACKGROUND_STYLE";
DvtBaseTreeView.TEXT_STYLE = "TEXT_STYLE";
DvtBaseTreeView.ATTRIBUTE_TYPE_STYLE = "ATTRIBUTE_TYPE_STYLE";
DvtBaseTreeView.ATTRIBUTE_VALUE_STYLE = "ATTRIBUTE_VALUE_STYLE";
DvtBaseTreeView.DRILL_TEXT_STYLE = "DRILL_TEXT_STYLE";
DvtBaseTreeView.CURRENT_TEXT_STYLE = "CURRENT_TEXT_STYLE";

/**
 * Initializes the tree view.
 * @param {DvtContext} context The rendering context.
 * @param {object} callback The function that should be called to dispatch component events.
 * @param {object} callbackObj The object context for the callback function
 * @protected
 */
DvtBaseTreeView.prototype.Init = function(context, callback, callbackObj) {
  DvtBaseTreeView.superclass.Init.call(this, context, callback, callbackObj);
  
  // Create the event handler and add event listeners
  this._eventHandler = this.CreateEventManager(this, context, this.__dispatchEvent, this);
  this._eventHandler.addListeners(this);
  
  // Drag and drop support
  this._dragSource = new DvtDragSource(context);
  this._dropTarget = new DvtBaseTreeDropTarget(this); 
  this._eventHandler.setDragSource(this._dragSource);
 
  this._Automation     = new DvtTreeAutomation(this) ;     
  
  /** 
   * Field used to store the legend displayable during render. 
   * @private 
   */
  this._legend = null;
  
  this.LastXml = null;
  
  // boolean to indicate whether or not this view has current keyboard focus
  this._hasFocus = false;
  
  // String to indicate the id of the node that should get keyboard focus
  // Used when an event causes the view to re-render or animate and we want to re-set the keyboard focus to a 
  // non-default node, for example when we
  // 1. drill up (set keyboard focus to the node that was the previous, drilled-in root of the treemap)
  // 2. restore a treemap after isolating a node (set focus to the node that was previously isolated)
  // 3. expand or collapse a sunburst node (set focus to the node that was expanded/collapsed)  
  this._navigableIdToFocus = null;
}

/**
 * Renders the component using the specified xml.  If no xml is supplied to a component
 * that has already been rendered, this function will rerender the component with the
 * specified size.
 * @param {string} xmlString The component xml.
 * @param {number} width The width of the component.
 * @param {number} height The height of the component.
 */
DvtBaseTreeView.prototype.render = function(xmlString, width, height) 
{  
  // Store the size
  this.Width = width;
  this.Height = height;
  
  // Hide any currently shown tooltips
  if(this._eventHandler)
    this._eventHandler.hideTooltip();

  if (this.Animation && !xmlString) {
      xmlString = this.LastXml;
  }
  if (xmlString)
      this.LastXml = xmlString;
      
  // If new xml is provided, parse it and apply the properties
  if(xmlString) {
    var props = this.Parse(xmlString);
    this.ApplyParsedProperties(props);
  }
  
  // Relayout the component (for resize or new data)
  var availSpace = new DvtRectangle(0, 0, this.Width, this.Height);
  this.Layout(availSpace); 
  
  // Create a new container and render the component into it
  var container = new DvtContainer(this.getCtx());
  this.addChild(container);

  // content facet: create afContext
  if (this._templates) {
    this._afContext = new DvtAfContext(this.getCtx(), this._eventHandler);
    //remove any components that don't fit in the tree node
    this._afContext.setRmIfNotFit(true);
  }

  this.Render(container, availSpace);
  
  // Animation Support
  // Stop any animation in progress
  if(this.Animation) {
    this.AnimationStopped = true; 
    this.Animation.stop();
  }
  
  // Construct the new animation playable
  var bounds = new DvtRectangle(0, 0, this.Width, this.Height);
  var bBlackBoxUpdate = false; // true if this is a black box update animation
  if(!this._container) {
    this.Animation = this.GetDisplayAnimation(container, bounds);
  }
  else if(this.AnimationOnDataChange && xmlString) {
    // AnimationOnDataChange
    if(DvtBlackBoxAnimationHandler.isSupported(this.AnimationOnDataChange)) {
      // Black Box Animation
      this.Animation = DvtBlackBoxAnimationHandler.getCombinedAnimation(this.getCtx(), this.AnimationOnDataChange, this._container, container, bounds, this.AnimationDuration);   
      bBlackBoxUpdate = true;
    }
    else if(this._oldRoot) {
      // Data Change Animation
      // Create the animation handler, calc, and play the animation
      this._deleteContainer = this.GetDeleteContainer();
      this.addChild(this._deleteContainer);
      var ah = new DvtBaseTreeAnimationHandler(this.getCtx(), this._deleteContainer);
      ah.animate(this._oldRoot, this._root, this._oldAncestors, this._ancestors);
      this.Animation = ah.getAnimation();
    }
  }
  
  // Clear out the old info, not needed anymore
  this._oldRoot = null;
  this._oldAncestors = null;
  
  // If an animation was created, play it
  if(this.Animation) {  
    // Disable event listeners temporarily
    this._eventHandler.removeListeners(this);
  
    // Start the animation
    this.Animation.setOnEnd(this.OnAnimationEnd, this); 
    this.Animation.play();
  }
  
  // Clean up the old container.  If doing black box animation, store a pointer and clean
  // up after animation is complete.  Otherwise, remove immediately.
  if(bBlackBoxUpdate) {
    this._oldContainer = this._container;
  }
  else if(this._container) { 
    // Not black box animation, so clean up the old contents
    this.removeChild(this._container);
  }
  
  // Update the pointer to the new container
  this._container = container;
  
  // Selection Support
  if(xmlString) {
    // Update the selection manager with the initial selections.  This must be done after
    // the shapes are created to apply the selection effects.
    this._processInitialSelections();
    
    // Update the event manager with the initial focus
    this._processInitialFocus(!this.Animation);
  }
  else 
    this.ReselectNodes(); // Resize or Rerender: Reselect the nodes using the selection handler's state
}

/**
 * Parses the xml and returns the root node.
 * @return {object} An object containing the parsed properties.
 * @protected
 */
DvtBaseTreeView.prototype.Parse = function(xmlString) {
  // subclasses should override
  return null;
}

/**
 * Performs layout for the component.
 * @param {DvtRect} availSpace The rectangle within which to perform layout.
 * @protected
 */
DvtBaseTreeView.prototype.Layout = function(availSpace) {
  // subclasses should override
}

/**
 * Renders the component.
 * @param {DvtContainer} container The container to render within.
 * @param {DvtRectangle} bounds The bounds of the node area.
 * @protected
 */
DvtBaseTreeView.prototype.Render = function(container, bounds) {
  // subclasses should override
}

/**
 * Renders the background.
 * @param {DvtContainer} container The container to render within.
 * @protected
 */
DvtBaseTreeView.prototype.RenderBackground = function(container, defaultStyle) {
  // Render an invisible fill for eventing
  var background = new DvtRect(this.getCtx(), 0, 0, this.Width, this.Height);
  background.setInvisibleFill();
  container.addChild(background);
}

/**
 * Lays out the breadcrumbs and updates the available space.
 * @param {DvtRect} availSpace The rectangle within which to perform layout.
 * @protected
 */
DvtBaseTreeView.prototype.LayoutBreadcrumbs = function(availSpace) {
  if(this._ancestors && this._ancestors.length > 0) {
    var rootLabel = this._root ? this._root.getLabel() : null;
    
    if(this._breadcrumbs)
      this._eventHandler.removeComponentKeyboardHandler(this._breadcrumbs);  
    
    this._breadcrumbs = DvtTreeBreadcrumbsRenderer.render(this, availSpace, this._ancestors, rootLabel);    
    this._eventHandler.addComponentKeyboardHandlerAt(this._breadcrumbs, 0);
  }
  else {
    this._eventHandler.removeComponentKeyboardHandler(this._breadcrumbs);
    this._breadcrumbs = null;
  }
}

/**
 * Renders the breadcrumbs.
 * @param {DvtContainer} container The container to render within.
 * @protected
 */
DvtBaseTreeView.prototype.RenderBreadcrumbs = function(container) {
  // The breadcrumbs are actually already rendered in _layoutBreadcrumbs, so just add it to the tree here.
  if(this._breadcrumbs) {
    container.addChild(this._breadcrumbs);
  }
}

/**
 * Lays out the legend component and updates the available space.
 * @param {DvtRect} availSpace The rectangle within which to perform layout.
 * @protected
 */
DvtBaseTreeView.prototype.LayoutLegend = function(availSpace) {
  // If a legend source is specified, find the associated attribute groups and render the legend
  var attrGroups = null;
  if(this._legendSource && this._attrGroups) {
    for(var i=0; i<this._attrGroups.length; i++) {
      var agDef = this._attrGroups[i];
      if(agDef.id == this._legendSource) {
        attrGroups = agDef.attrGroups;
        break;
      }
    }
  }
  
  // Render the legend
  if(this._sizeValueStr || this._colorValueStr || attrGroups)
    this._legend = DvtTreeLegendRenderer.render(this, availSpace, 
                                                this.__getResources()['legendSize'], this.__getResources()['legendColor'], 
                                                this._sizeValueStr, this._colorValueStr, attrGroups);
}

/**
 * Renders the legend.
 * @param {DvtContainer} container The container to render within.
 * @protected
 */
DvtBaseTreeView.prototype.RenderLegend = function(container) {
  // The legend is actually already rendered in _layoutLegend, so just add it to the tree here.
  if(this._legend) {
    container.addChild(this._legend);
    
    // Clear the pointer, since we don't need it anymore
    this._legend = null;
  }
}

/**
 * Renders the empty text message, centered in the available space.
 * @param {DvtContainer} container The container to render within.
 * @protected
 */
DvtBaseTreeView.prototype.RenderEmptyText = function(container) {
  if(this._emptyText) {
    // Create the text and position it in the middle of the available space
    var text = new DvtOutputText(this.getCtx(), this._emptyText, this.Width/2, this.Height/2);
    text.alignCenter();
    text.alignMiddle();
    DvtTextUtils.fitText(text, 
                         this.Width - 2*DvtBaseTreeView._EMPTY_TEXT_BUFFER, 
                         this.Height - 2*DvtBaseTreeView._EMPTY_TEXT_BUFFER,
                         this);
    container.addChild(text);
  }
}

/**
 * Checks whether the component has valid data.
 * @return {boolean} True if the component has valid data.
 * @protected
 */
DvtBaseTreeView.prototype.HasValidData = function() {
  return (this._root && this._root.getSize() > 0);
}

/**
 * Returns the animation to use on initial display of this component.
 * @return {DvtBaseAnimation} The initial display animation.
 * @protected
 */
DvtBaseTreeView.prototype.GetDisplayAnimation = function(container, bounds) {
  if(DvtBlackBoxAnimationHandler.isSupported(this.AnimationOnDisplay))
    return DvtBlackBoxAnimationHandler.getInAnimation(this.getCtx(), this.AnimationOnDisplay, container, bounds, this.AnimationDuration);   
  else
    return null;
}

/**
 * Hook for cleaning up animation behavior at the end of the animation.
 * @protected
 */
DvtBaseTreeView.prototype.OnAnimationEnd = function() {
  // Remove the container containing the delete animations
  if(this._deleteContainer) {
    this.removeChild(this._deleteContainer);
    this._deleteContainer = null;
  }
  
  // Clean up the old container used by black box updates
  if(this._oldContainer) {
    this.removeChild(this._oldContainer);
    this._oldContainer = null;
  }
  
  // Reset the animation stopped flag
  this.AnimationStopped = false;
  
  // Remove the animation reference
  this.Animation = null;
  
  // Restore event listeners
  this._eventHandler.addListeners(this);

  // Restore visual effects on node with keyboard focus
  this._processInitialFocus(true);  
}

/**
 * Creates a container that can be used for storing delete animation content.
 */
DvtBaseTreeView.prototype.GetDeleteContainer = function() {
  return new DvtContainer(this.getCtx());
}

/**
 * Returns a keyboard handler that can be used by the view's event manager
 * @param {DvtEventManager} The owning event manager
 * @return {DvtKeyboardHandler}
 * @protected 
 */
DvtBaseTreeView.prototype.CreateKeyboardHandler = function(manager)
{
  return new DvtBaseTreeKeyboardHandler(manager);
}

/**
 * Returns an event manager that will handle events on this view
 * @param {DvtContainer} view
 * @param {DvtContext} context
 * @param {object} callback The function that should be called to dispatch component events.
 * @param {object} callbackObj The object context for the callback function
 * @return {DvtEventManager}
 * @protected
 */
DvtBaseTreeView.prototype.CreateEventManager = function(view, context, callback, callbackObj)
{
  return new DvtBaseTreeEventManager(view, context, callback, callbackObj);
}

/**
 * Returns the node that should receive initial keyboard focus when the view first gets focus
 * @param {DvtBaseTreeNode} root
 * @param {DvtBaseTreeNode} The node that should receive initial keyboard focus
 * @protected
 */
DvtBaseTreeView.prototype.GetInitialFocusedItem = function(root)
{
  return root;
}

/**
 * Returns the DvtEventManager for this component.
 * @return {DvtEventManager}
 */
DvtBaseTreeView.prototype.__getEventManager = function() {
  return this._eventHandler;
}

/**
 * Returns the map of resources for use in rendering this component.
 * @return {object}
 */
DvtBaseTreeView.prototype.__getResources = function() {
  return this._resources;
}

/**
 * Returns the maximum depth of the tree.
 * @return {number} The maximum depth of the tree.
 */
DvtBaseTreeView.prototype.__getMaxDepth = function() {
  return this._maxDepth;
}

/**
 * Returns the node count of the tree.
 * @return {number} The node count of the tree.
 */
DvtBaseTreeView.prototype.__getNodeCount = function() {
  return this._nodeCount;
}

/**
 * Returns the maximum depth of the tree rooted at the specified node.
 * @param {DvtBaseTreeNode} node The subtree to find the depth for.
 * @param {number} depth The depth of the specified node.
 * @return {number} The maximum depth of the tree.
 * @private
 */
DvtBaseTreeView._calcMaxDepth = function(node, depth) {
  var maxDepth = depth;  // Initialize to current depth
  
  // Search children
  var children = node.getChildNodes();
  if(children) {
    for(var i=0; i<children.length; i++) {
      var childDepth = DvtBaseTreeView._calcMaxDepth(children[i], depth+1);
      maxDepth = Math.max(maxDepth, childDepth);
    }
  }
  
  return maxDepth;
}

/**
 * Applies the parsed properties to this component.
 * @param {object} props An object containing the parsed properties for this component.
 * @protected
 */
DvtBaseTreeView.prototype.ApplyParsedProperties = function(props) {
  // Save the old info for animation support
  this._oldRoot = this._root;
  this._oldAncestors = this._ancestors;

  // Save the parsed properties
  this._nodeCount = props.nodeCount;
  this._resources = props.resources ? props.resources : {};
  this._root = props.root;
  this._emptyText = props.emptyText;
  this._ancestors = props.ancestors;
  this._dropSiteFill = new DvtSolidFill(props.dropSiteFillColor, props.dropSiteOpacity);
  this._dropSiteStroke = new DvtSolidStroke(props.dropSiteBorderColor);
  
  this.AnimationOnDisplay = props.animationOnDisplay;
  this.AnimationOnDataChange = props.animationOnDataChange;
  this.AnimationDuration = props.animationDuration;
  this.Sorting = props.sorting;

  this._styles = props.styles;
  
  this._nodeSelection = props.nodeSelection;
  
  if (props.templates) {
    this._templates = props.templates;
  }
 
  // Selection Support
  if(this._nodeSelection) {
    this._selectionHandler = new DvtSelectionHandler(props.nodeSelection);
    this._initialSelection = props.selectedIds;
  }
  else
    this._selectionHandler = null;

  // Event Handler delegates to other handlers
  this._eventHandler.setSelectionHandler(this._selectionHandler);
  this._eventHandler.setContextMenuHandler(props.contextMenuHandler);
  
  // Keyboard support only available if selection is enabled
  if(this._selectionHandler)
    this._eventHandler.setKeyboardHandler(this.CreateKeyboardHandler(this._eventHandler));
  else
    this._eventHandler.setKeyboardHandler(null);
   
  // Update the max depth of the tree  
  if(this._root) 
    this._maxDepth = DvtBaseTreeView._calcMaxDepth(this._root, 0);
    
  // Attribute Groups Support
  this._attrGroups = props.attrGroups;
    
  // Legend
  this._legendSource = props.legendSource; 
  this._sizeValueStr = props.sizeValueStr;
  this._colorValueStr = props.colorValueStr;
}

/**
 * Reselects the selected nodes after a re-render.
 * @protected
 */
DvtBaseTreeView.prototype.ReselectNodes = function() {
  var selectedNodes = this._selectionHandler ? this._selectionHandler.getSelection() : new Array();
  for(var i=0; i<selectedNodes.length; i++)
    selectedNodes[i].setSelected(true);
}

/**
 * Update the selection handler with the initial selections.
 * @private
 */
DvtBaseTreeView.prototype._processInitialSelections = function() {
  if(this._selectionHandler && this._initialSelection) {
    var targets = new Array();
    this._addSelectableObjectsToArray(this._root, targets); // adds all selectable objects to array
    this._selectionHandler.processInitialSelections(this._initialSelection, targets);
    this._initialSelection = null;
  }
}

/**
 * Update the event manager with the initial focused item
 * @param {Boolean} applyVisualEffects True if we want to apply visual effects to indicate which node has 
 *                  keyboard focus.
 */
DvtBaseTreeView.prototype._processInitialFocus = function(applyVisualEffects) {

  var initialFocus = null;
  var id = this.__getNavigableIdToFocus();
  
  if(id)
  {
    initialFocus = DvtBaseTreeNode.getNodeById(this._root, id);
    this._eventHandler.setFocus(initialFocus);
  }

  if(applyVisualEffects)
  {
    // if we are applying visual effects in response to an event that caused a re-render or animation, and this
    // event specified a non-default node to set keyboard focus on, clear that value now that we've used it
    this.__setNavigableIdToFocus(null);
  }

  if(!initialFocus)
  {
    // set the item that has initial keyboard focus to a default if none was previously defined
    initialFocus = this.GetInitialFocusedItem(this._root);
    this._eventHandler.setFocus(initialFocus);
  }

  // have the event manager apply any needed visual effects
  // however, do this only if we are not animating so as to prevent the focus visual effect
  // from appearing during the duration of the animation
  if(applyVisualEffects)
    this.setFocused(this.isFocused());

}


/**
 * Update the visual effects on view when it receives or loses keyboard focus 
 * 
 * @param {boolean} isFocused
 */
DvtBaseTreeView.prototype.setFocused = function(isFocused)
{
  this._hasFocus = isFocused;
  this._eventHandler.setFocused(isFocused);
}

/**
 * Returns true if the view currently has keyboard focus
 */
DvtBaseTreeView.prototype.isFocused = function()
{
  return this._hasFocus;
}

/**
 * Recursively returns an array containing all nodes in the subtree of a given node.
 * @param {DvtBaseTreeNode} node The root of the subtree whose children will be returned.
 * @param {array} ret The array onto which to add the subtree.
 * @private
 */
DvtBaseTreeView.prototype._addSelectableObjectsToArray = function(node, ret) {  
  if(!node)
    return;

  // Add this node
  ret.push(node);
  
  // Add its children
  var children = node.getChildNodes();
  if(children) {
    for(var i=0; i<children.length; i++) {
      this._addSelectableObjectsToArray(children[i], ret);
    }
  }
}

/**
 * Returns the animation duration, in milliseconds.
 * @return {number}
 */
DvtBaseTreeView.prototype.__getAnimationDuration = function() {
  return this.AnimationDuration;
}

/**
 * get templates of content facet
 * @return {array} array of templates
 */
DvtBaseTreeView.prototype.__getTemplates = function() {
  return this._templates;
}

DvtBaseTreeView.prototype.__getStyles = function() {
  return this._styles;
}

/**
 * get afComponent context
 */
DvtBaseTreeView.prototype.__getAfContext = function() {
  return this._afContext;
}

/**
 * Returns the node under the specified coordinates.
 * @param {number} x
 * @param {number} y
 * @param {DvtBaseTreeNode} node The node to search from, null to search from the root.
 * @return {DvtBaseTreeView}
 */
DvtBaseTreeView.prototype.__getNodeUnderPoint = function(x, y) {
  return this._root.getNodeUnderPoint(x, y);
}

/**
 * Returns the clientId of the drag source owner if dragging is supported.
 * @param {array} clientIds
 * @return {string} 
 */
DvtBaseTreeView.prototype.__isDragAvailable = function(clientIds) {
  // Drag and drop supported when selection is enabled, only 1 drag source
  if(this._selectionHandler)
    return clientIds[0];
  else
    return null;
}

/**
 * Returns the row keys for the current drag.
 * @param {DvtBaseTreeNode} node The node where the drag was initiated.
 * @return {array} The row keys for the current drag.
 */
DvtBaseTreeView.prototype.__getDragTransferable = function(node) {
  // Select the node if not already selected
  if(!node.isSelected()) {
    this._selectionHandler.processClick(node, false);
    this._eventHandler.fireSelectionEvent();
  }
  
  // Gather the rowKeys for the selected objects
  var rowKeys = [];
  var selection = this._selectionHandler.getSelection();
  for(var i=0; i<selection.length; i++) {
    rowKeys.push(selection[i].getId());
  }
  
  return rowKeys;
}

/**
 * Returns the displayables to use for drag feedback for the current drag.
 * @param {DvtBaseTreeNode} node The node where the drag was initiated.
 * @return {array} The displayables for the current drag.
 */
DvtBaseTreeView.prototype.__getDragFeedback = function() {
  // This is called after __getDragTransferable, so the selection has been updated already.
  // Gather the displayables for the selected objects
  var displayables = [];
  var selection = this._selectionHandler.getSelection();
  for(var i=0; i<selection.length; i++) {
    displayables.push(selection[i].__getDisplayable());
  }
  
  return displayables;
}

/**
 * Displays drop site feedback for the specified node.
 * @param {DvtBaseTreeNode} node The node for which to show drop feedback, or null to remove drop feedback.
 * @return {DvtDisplayable} The drop site feedback, if any.
 */
DvtBaseTreeView.prototype.__showDropSiteFeedback = function(node) {
  // Remove any existing drop site feedback
  if(this._dropSiteFeedback) {
    this.removeChild(this._dropSiteFeedback);
    this._dropSiteFeedback = null;
  }

  // Create feedback for the node
  if(node) {
    this._dropSiteFeedback = node.getDropSiteFeedback();
    if(this._dropSiteFeedback) {
      this._dropSiteFeedback.setFill(this._dropSiteFill);
      this._dropSiteFeedback.setStroke(this._dropSiteStroke);
      this.addChild(this._dropSiteFeedback);
    }
  }
  
  return this._dropSiteFeedback;
}

/**
 * Processes a breadcrumb drill event.
 * @param {DvtBreadcrumbsDrillEvent} event
 */
DvtBaseTreeView.prototype.__processBreadcrumbsEvent = function(event) {
  if(event instanceof DvtBreadcrumbsDrillEvent)
    this.__drill(event.getId(), false);
  else
    this.__dispatchEvent(event); // for example, an ActiveElementChangeEvent
}

/**
 * Performs a drill on the specified node.
 * @param {string} id
 * @param {boolean} bDrillUp True if this is a drill up operation.
 */
DvtBaseTreeView.prototype.__drill = function(id, bDrillUp) {
  if(bDrillUp && this._root && id == this._root.getId() && this._ancestors && this._ancestors.length > 0) {
    // after the drill up completes, set keyboard focus on the node that was the 
    // root of the previously drilled-down view
    this.__setNavigableIdToFocus(id);
    
    // Drill up only supported on the root node
    this.__dispatchEvent(new DvtDrillReplaceEvent(this._ancestors[0].id));
  }
  else if(!bDrillUp) // Fire the event
    this.__dispatchEvent(new DvtDrillReplaceEvent(id));
    
  // Hide any tooltips being shown
  this.getCtx().getTooltipManager().hideTooltip();
}


/**
  *  @returns {DvtTreeAutomaion} the automation object DvtTreeAutomaion.
  */
DvtBaseTreeView.prototype.getAutomation = function()
{
    return this._Automation;
};

/**
 * Returns the logical object corresponding to the physical target
 * @param {Object} target
 * @return {Object}
 */
DvtBaseTreeView.prototype.getLogicalObject = function(target)
{
   return this._eventHandler.GetLogicalObject(target);   
}
 
/**
 * @return {DvtBaseTreeNode} the root tree node.
 */
DvtBaseTreeView.prototype.getRootNode = function()
{
    return this._root;
}

/**
 * Returns the id of the node that should get keyboard focus, if the default node should not receive focus.
 * Used when an event causes the view to re-render or animate and we want to set the keyboard focus
 * to a non-default node.
 * 
 * @return {String} the id of the node that should receive keyboard focus
 */
DvtBaseTreeView.prototype.__getNavigableIdToFocus = function() 
{
  return this._navigableIdToFocus;
}

/**
 * Sets the id of the node that should get keyboard focus, if the default node should not receive focus.
 * Used when an event causes the view to re-render or animate and we want to set the keyboard focus
 * to a non-default node.
 * 
 * @param {String} id The id of the node that should receive keyboard focus
 */
DvtBaseTreeView.prototype.__setNavigableIdToFocus = function(id) 
{
  this._navigableIdToFocus = id;
}

/**
 * @return {String} whether nodeSelection is multiple, single, or null.
 */
DvtBaseTreeView.prototype.__getNodeSelection = function() 
{
  return this._nodeSelection;
}
// APIs called by the ADF Faces drag source for DvtBaseTreeView

/**
 * If this object supports drag, returns the client id of the drag component.
 * Otherwise returns null.
 * @param mouseX the x coordinate of the mouse
 * @param mouseY the x coordinate of the mouse
 * @param clientIds the array of client ids of the valid drag components
 */
DvtBaseTreeView.prototype.isDragAvailable = function (mouseX, mouseY, clientIds) {
  return this._dragSource.isDragAvailable(clientIds); 
}

/**
 * Returns the transferable object for a drag initiated at these coordinates.
 */
DvtBaseTreeView.prototype.getDragTransferable = function (mouseX, mouseY) {
  return this._dragSource.getDragTransferable(mouseX, mouseY);
}

/**
 * Returns the feedback for the drag operation.
 */
DvtBaseTreeView.prototype.getDragOverFeedback = function (mouseX, mouseY) {
  return this._dragSource.getDragOverFeedback(mouseX, mouseY);
}

/**
 * Returns an Object containing the drag context info.
 */
DvtBaseTreeView.prototype.getDragContext = function (mouseX, mouseY) {
  return this._dragSource.getDragContext(mouseX, mouseY); 
}

/**
 * Returns the offset to use for the drag feedback. This positions the drag
 * feedback relative to the pointer.
 */
DvtBaseTreeView.prototype.getDragOffset = function (mouseX, mouseY) {
  return this._dragSource.getDragOffset(mouseX, mouseY); 
}

/**
 * Returns the offset from the mouse pointer where the drag is considered to be located.
 */
DvtBaseTreeView.prototype.getPointerOffset = function (xOffset, yOffset) {
  return this._dragSource.getPointerOffset(xOffset, yOffset);
}

/**
 * Notifies the component that a drag started.
 */
DvtBaseTreeView.prototype.initiateDrag = function () {
  this._dragSource.initiateDrag();
}

/**
 * Clean up after the drag is completed.
 */
DvtBaseTreeView.prototype.dragDropEnd = function () {
  this._dragSource.dragDropEnd();
}
// APIs called by the ADF Faces drop target for DvtBaseTreeView

/**
 * If a drop is possible at these mouse coordinates, returns the client id
 * of the drop component. Returns null if drop is not possible.
 */
DvtBaseTreeView.prototype.acceptDrag = function (mouseX, mouseY, clientIds) {
  return this._dropTarget.acceptDrag(mouseX, mouseY, clientIds); 
}

/**
 * Paints drop site feedback as a drag enters the drop site.
 */
DvtBaseTreeView.prototype.dragEnter = function () {
  this._dropTarget.dragEnter(); 
}

/**
 * Cleans up drop site feedback as a drag exits the drop site.
 */
DvtBaseTreeView.prototype.dragExit = function () {
  this._dropTarget.dragExit(); 
}

/**
 * Returns the object representing the drop site. This method is called when a valid
 * drop is performed.
 */
DvtBaseTreeView.prototype.getDropSite = function (mouseX, mouseY) {
  return this._dropTarget.getDropSite(mouseX, mouseY); 
}
/**
 * Animation handler for tree data objects.
 * @param {DvtContext} context The platform specific context object.
 * @param {DvtContainer} deleteContainer The container where deletes should be moved for animation.
 * @class DvtBaseTreeAnimationHandler
 * @constructor
 */
var DvtBaseTreeAnimationHandler = function(context, deleteContainer) {
  this.Init(context, deleteContainer);
};

DvtObj.createSubclass(DvtBaseTreeAnimationHandler, DvtDataAnimationHandler, "DvtBaseTreeAnimationHandler");

/**
 * Animates the tree component, with support for data changes and drilling.
 * @param {DvtBaseTreeNode} oldRoot The state of the tree before the animation.
 * @param {DvtBaseTreeNode} newRoot The state of the tree after the animation.
 * @param {array} oldAncestors The array of ancestors for the old root node.
 * @param {array} newAncestors The array of ancestors for the new root node.
 */
DvtBaseTreeAnimationHandler.prototype.animate = function(oldRoot, newRoot, oldAncestors, newAncestors) {
  this._bDrill = false; // true if this is a drilling animation
  this._oldRoot = oldRoot;
  this._oldAncestors = oldAncestors;
  
  // Determine whether this is a drill or data change animation
  if(DvtBaseTreeAnimationHandler._isAncestor(newAncestors, oldRoot) || 
     DvtBaseTreeAnimationHandler._isAncestor(oldAncestors, newRoot))
  {
    // Drilling
    this._bDrill = true;
    var oldList = oldRoot.getDescendantNodes();
    var newList = newRoot.getDescendantNodes();
    oldList.push(oldRoot);
    newList.push(newRoot);
    this.constructAnimation(oldList, newList);
  }
  else {
    // Data Change Animation
    this.constructAnimation([oldRoot], [newRoot]);
  }
}

/**
 * Returns true if the current animation is for a drill operation.  The nodes
 * will call this function and handle their animations differently.
 * @return {boolean}
 */
DvtBaseTreeAnimationHandler.prototype.isDrillAnimation = function() {
  return this._bDrill;
}

/**
 * Returns true if the specified node was previously an ancestor of the old root.  A value
 * of true indicates that an insert animation should not be performed on this node.
 * @param {DvtBaseTreeNode} node
 */
DvtBaseTreeAnimationHandler.prototype.isAncestorInsert = function(node) {
  if(this._bDrill) 
    return this._oldRoot.getId() == node.getId() ||
           DvtBaseTreeAnimationHandler._isAncestor(this._oldAncestors, node);
  else
    return false;
}

/**
 * Returns true if the specified node is contained in the array of ancestors.
 * @param {array} ancestors The array of ancestors to search.
 * @param {DvtBaseTreeNode} node The node to search for.
 * @return {boolean}
 */
DvtBaseTreeAnimationHandler._isAncestor = function(ancestors, node) {
  if(!node || !ancestors)
    return false;
  
  // Iterate through the array and search for the node
  for(var i=0; i<ancestors.length; i++) {
    if(ancestors[i].id == node.getId())
      return true;
  }
  
  // No match found
  return false;
}
/**
 * Drop Target event handler for DvtBaseTreeView
 * @param {DvtBaseTreeView} view
 * @class DvtBaseTreeDropTarget
 * @extends DvtDropTarget
 * @constructor
 */
var DvtBaseTreeDropTarget = function(view) {
  this._view = view;  
};

DvtObj.createSubclass(DvtBaseTreeDropTarget, DvtDropTarget, "DvtBaseTreeDropTarget");

/**
 * @override
 */
DvtBaseTreeDropTarget.prototype.acceptDrag = function (mouseX, mouseY, clientIds) {
  // If there is no node under the point, then don't accept the drag
  var node = this._view.__getNodeUnderPoint(mouseX, mouseY);
  if(!node) {
    this._view.__showDropSiteFeedback(null);
    return null;
  }
  else if(node != this._dropSite) {
    this._view.__showDropSiteFeedback(node); 
    this._dropSite = node;
  }
  
  // Return the first clientId, since this component has only a single drag source
  return clientIds[0];
}

/**
 * @override
 */
DvtBaseTreeDropTarget.prototype.dragExit = function () {
  // Remove drop site feedback
  this._view.__showDropSiteFeedback(null); 
  this._dropSite = null;
}

/**
 * @override
 */
DvtBaseTreeDropTarget.prototype.getDropSite = function (mouseX, mouseY) {
  var node = this._view.__getNodeUnderPoint(mouseX, mouseY);
  if(node)
    return {clientRowKey: node.getId()};
  else
    return null;
}
/**
 * @constructor
 * Event Manager for tree components.
 */
var DvtBaseTreeEventManager = function(view, context, callback, callbackObj) {
  this.Init(context, callback, callbackObj);
  this._view = view;
};

DvtObj.createSubclass(DvtBaseTreeEventManager, DvtEventManager, "DvtBaseTreeEventManager");

/**
 * Returns the owning tree component.
 * @return {DvtBaseTreeView}
 * @protected
 */
DvtBaseTreeEventManager.prototype.GetView = function() {
  return this._view;
}

/**
 * @override
 */
DvtBaseTreeEventManager.prototype.OnDblClick = function(event) {
  DvtBaseTreeEventManager.superclass.OnDblClick.call(this, event);
  
  // Done if there is no object
  var obj = this.GetLogicalObject(event.target);
  if(!obj)
    return;
    
  this._processDrill(obj, event.shiftKey);

}

/**
 * @override
 */
DvtBaseTreeEventManager.prototype.OnClick = function(event) {
  DvtBaseTreeEventManager.superclass.OnClick.call(this, event);
  
  // If the object is a DvtBaseTreePeer (for node labels), handle drilling
  var obj = this.GetLogicalObject(event.target);
  this._processNodeLabel(obj);
}

/**
 * @override
 */
DvtBaseTreeEventManager.prototype.OnMouseOver = function(event) {
  DvtBaseTreeEventManager.superclass.OnMouseOver.call(this, event);
  
  // Additional mouse over support
  var obj = this.GetLogicalObject(event.target);
  if(obj && obj.handleMouseOver) {
    obj.handleMouseOver();
  }
}

/**
 * @override
 */
DvtBaseTreeEventManager.prototype.OnMouseOut = function(event) {
  DvtBaseTreeEventManager.superclass.OnMouseOut.call(this, event);
  
  // Additional mouse out support
  var obj = this.GetLogicalObject(event.target);
  if(obj && obj.handleMouseOut) {
    // Don't hide on mouseOut to object belonging to same node (expand button for example)
    var relatedObj = this.GetLogicalObject(event.relatedTarget);
    var relatedId = relatedObj && relatedObj.getId ? relatedObj.getId() : null;
    if(relatedId != obj.getId())
      obj.handleMouseOut();
  }
}

/**
 * @override
 */
DvtBaseTreeEventManager.prototype.ProcessKeyboardEvent = function(event)
{   
  var eventConsumed = false;
  var keyCode = event.keyCode;
  var obj = this.getFocus(); // the item with current keyboard focus

  if(keyCode == DvtKeyboardEvent.ENTER && !event.ctrlKey)
  {  
    // handle drill operations
    obj = this.getFocus(); 
    if(obj.isDrillReplaceEnabled && obj.isDrillReplaceEnabled()) 
    {
      // SHIFT+ENTER means drill up from the current root, even if the node with keyboard focus is not the current root
      if(event.shiftKey)
        obj = this._view.getRootNode();
      
      // Delegate to the view to fire a drill event
      this._view.__drill(obj.getId(), event.shiftKey);
    }
    
    event.preventDefault();
    eventConsumed = true;
  }
  else
  {
    eventConsumed = DvtBaseTreeEventManager.superclass.ProcessKeyboardEvent.call(this, event);   
  }

  return eventConsumed;
}

DvtBaseTreeEventManager.prototype.HandleTouchClickInternal = function(event) {
  var targetObj = event.target;        
  var obj = this.GetLogicalObject(targetObj);
  this._processNodeLabel(obj);

  if (this._currentHoverItem) {
      if (this._currentHoverItem != obj) {
          this._currentHoverItem.handleMouseOut();
          this._currentHoverItem = null;
      }
  }
  
  if (obj && obj instanceof DvtBaseTreeNode) {
      if (this._currentHoverItem != obj) {
          this._currentHoverItem = obj;
          obj.handleMouseOver();
      }
  }
}

/**
 * @override
 */
DvtBaseTreeEventManager.prototype.OnComponentTouchDblClick = function(event) {
  var targetObj = event.target;        
  var obj = this.GetLogicalObject(targetObj);
  if(!obj)
    return;
  this._processDrill(obj, false);
}

DvtBaseTreeEventManager.prototype._processNodeLabel = function(obj) {
  if(obj && obj instanceof DvtBaseTreePeer && obj.isDrillable()) {
    // Delegate to the view to fire a drill event
    this._view.__drill(obj.getId(), false);
  }
}

DvtBaseTreeEventManager.prototype._processDrill = function(obj, shiftKey) {
  // Fire a drill event if drilling is enabled
  if(obj.isDrillReplaceEnabled && obj.isDrillReplaceEnabled()) {
    // Delegate to the view to fire a drill event
    this._view.__drill(obj.getId(), shiftKey);
  }
}
/**
 * Abstract class for parsing XML for tree components.
 * @class
 * @constructor
 */
var DvtBaseTreeParser = function() {}

DvtObj.createSubclass(DvtBaseTreeParser, DvtObj, "DvtBaseTreeParser");

// Top Level Attributes
DvtBaseTreeParser.ATTR_NODE_SELECTION = "sel";
DvtBaseTreeParser.ATTR_SORTING = "sort";
DvtBaseTreeParser.ATTR_SELECTED_IDS = "selIds";
DvtBaseTreeParser.ATTR_EMPTY_TEXT = "emptyText";

DvtBaseTreeParser.ATTR_LEGEND_SOURCE = "ls";
DvtBaseTreeParser.ATTR_LEGEND_SIZE_VALUE = "sv";
DvtBaseTreeParser.ATTR_LEGEND_COLOR_VALUE = "cv";

DvtBaseTreeParser.ATTR_ANIMATION_DURATION = "adu";
DvtBaseTreeParser.ATTR_ANIMATION_ON_DATA_CHANGE = "adc";
DvtBaseTreeParser.ATTR_ANIMATION_ON_DISPLAY = "adi";

DvtBaseTreeParser.ATTR_DROP_SITE_FILL_COLOR = "dsf";
DvtBaseTreeParser.ATTR_DROP_SITE_BORDER_COLOR = "dsb";
DvtBaseTreeParser.ATTR_DROP_SITE_OPACITY = "dso";

// Top Level Attribute Values
DvtBaseTreeParser.NODE_SELECTION_NONE = "none";
DvtBaseTreeParser.NODE_SELECTION_SINGLE = "single";
DvtBaseTreeParser.NODE_SELECTION_MULTIPLE = "multiple";
DvtBaseTreeParser.SORTING_ON = "on";

// Node Attributes
DvtBaseTreeParser.ATTR_TEMPLATE_ID = "T";
DvtBaseTreeParser.ATTR_MENU_ID = "M";
DvtBaseTreeParser.ATTR_ATTR_GROUPS_COLOR = "ag";
DvtBaseTreeParser.ATTR_ID = "id";
DvtBaseTreeParser.ATTR_SIZE = "s";
DvtBaseTreeParser.ATTR_COLOR = "c";
DvtBaseTreeParser.ATTR_PATTERN = "p";
DvtBaseTreeParser.ATTR_LABEL = "l";
DvtBaseTreeParser.ATTR_TOOLTIP = "tt";
DvtBaseTreeParser.ATTR_LABEL_STYLE = "ls";
DvtBaseTreeParser.ATTR_LABEL_DISPLAY = "ld";
DvtBaseTreeParser.ATTR_INDEX_IN_PARENT = "iip";
DvtBaseTreeParser.ATTR_TEMPLATE_NAME = "tn";
DvtBaseTreeParser.ATTR_DRILLING = "d";
DvtBaseTreeParser.ATTR_DISCLOSED = "di";
DvtBaseTreeParser.ATTR_SELECTABLE = "nsel";

// Attr Groups Attributes
DvtBaseTreeParser.ATTR_AG_GROUP = "g";
DvtBaseTreeParser.ATTR_AG_GROUP_LABEL = "l";
DvtBaseTreeParser.ATTR_AG_COLOR = "c";
DvtBaseTreeParser.ATTR_AG_PATTERN = "p";

DvtBaseTreeParser._ELEM_NODE = "n";
DvtBaseTreeParser._ELEM_F = "f";
DvtBaseTreeParser._ELEM_EL = "el";

// Style properties
DvtBaseTreeParser.ANIMATION_UPDATE_COLOR = "-tr-animation-update-color";

/**
 * @param {DvtBaseTreeView} treeView
 * @protected
 */
DvtBaseTreeParser.prototype.Init = function(treeView) {
  this._view = treeView;
  this._parser = new DvtXmlParser(treeView.getCtx());
  
  // Continuous Attribute Groups Support
  this._minAGColor = Infinity;
  this._maxAGColor = -Infinity;
} 

/**
 * Parses the specified XML String and returns the root node of the treemap.
 * @param {string} xmlString The String containing XML describing the component.
 * @return {object} An object containing the parsed properties
 */
DvtBaseTreeParser.prototype.parse = function(xmlString) 
{
  // Parse the XML string and get the root node
  var rootNode = this._parser.parse(xmlString);
  
  // Parse attributes on the top level node
  var ret = this.ParseRootAttributes(rootNode);
  
  // Parse templates if exist
  var childNodes = rootNode.getChildNodes();
  ret.templates = this._parseTemplates(childNodes);

  // Parse the child nodes  
  var i;
  this._nodeCount = 0;
  var xmlDataNodes = this._getChildNodesByName(childNodes, DvtBaseTreeParser._ELEM_NODE);
  var rootNodes = [];
  for(i=0; i<xmlDataNodes.length; i++) {
    var root = this._parseDataNode(xmlDataNodes[i], ret.templates);
    if(root)
      rootNodes.push(root);
  }
  ret.nodeCount = this._nodeCount;
  
  // Create an artificial root if needed, or assign the root
  if(rootNodes.length == 1)
    ret.root = rootNodes[0];
  else 
    ret.root = this._createArtificialRoot(this._view, rootNodes);
  
  // Parse any other nodes
  for(i=0; i<childNodes.length; i++)
    this._parseNode(childNodes[i], ret);
  
  // Apply any parsed properties to the nodes
  this._applyParsedProperties(ret.root, ret);
  
  return ret;
}

/**
 * Creates a tree node for the specified view.
 * @param {DvtBaseTreeView} treeView
 * @param {object} props The properties for the node.
 * @return {DvtBaseTreeNode} The resulting tree component node.
 * @protected
 */
DvtBaseTreeParser.prototype.CreateNode = function(treeView, props) {
  // subclasses should override
  return null;
}

/**
 * Parses the attributes on the root node.
 * @param {DvtXmlNode} xmlNode The xml node defining the root
 * @return {object} An object containing the parsed properties
 * @protected
 */
DvtBaseTreeParser.prototype.ParseRootAttributes = function(xmlNode) {
  // The object that will be populated with parsed values and returned
  var ret = new Object();
  
  var nodeSelectionStr = xmlNode.getAttr(DvtBaseTreeParser.ATTR_NODE_SELECTION);
  if(nodeSelectionStr == DvtBaseTreeParser.NODE_SELECTION_NONE)
    ret.nodeSelection = null;
  else if(nodeSelectionStr == DvtBaseTreeParser.NODE_SELECTION_SINGLE)
    ret.nodeSelection = DvtSelectionHandler.TYPE_SINGLE;
  else
    ret.nodeSelection = DvtSelectionHandler.TYPE_MULTIPLE;
    
  ret.sorting = xmlNode.getAttr(DvtBaseTreeParser.ATTR_SORTING);
  
  // The selected ids are a comma delimited list
  var selectedIdsStr = xmlNode.getAttr(DvtBaseTreeParser.ATTR_SELECTED_IDS);
  if(selectedIdsStr)
    ret.selectedIds = selectedIdsStr.split(",");
  
  ret.emptyText = xmlNode.getAttr(DvtBaseTreeParser.ATTR_EMPTY_TEXT);
  
  // Legend
  ret.legendSource = xmlNode.getAttr(DvtBaseTreeParser.ATTR_LEGEND_SOURCE);
  ret.sizeValueStr = xmlNode.getAttr(DvtBaseTreeParser.ATTR_LEGEND_SIZE_VALUE);
  ret.colorValueStr = xmlNode.getAttr(DvtBaseTreeParser.ATTR_LEGEND_COLOR_VALUE);
  
  // Animation
  var duration = xmlNode.getAttr(DvtBaseTreeParser.ATTR_ANIMATION_DURATION);
  if(duration) // convert server duration to client duration
    ret.animationDuration = duration/1000;
  
  ret.animationOnDataChange = xmlNode.getAttr(DvtBaseTreeParser.ATTR_ANIMATION_ON_DATA_CHANGE);
  ret.animationOnDisplay = xmlNode.getAttr(DvtBaseTreeParser.ATTR_ANIMATION_ON_DISPLAY);
  
  return ret;
}

/**
 * Parses the attributes on a tree node.
 * @param {DvtXmlNode} xmlNode The xml node defining the tree node
 * @return {object} An object containing the parsed properties
 * @protected
 */
DvtBaseTreeParser.prototype.ParseNodeAttributes = function(xmlNode) {
  // The object that will be populated with parsed values and returned
  var ret = new Object();
  
  // Parse this node's properties
  ret.templateId = xmlNode.getAttr(DvtBaseTreeParser.ATTR_TEMPLATE_ID);
  ret.menuId = xmlNode.getAttr(DvtBaseTreeParser.ATTR_MENU_ID);
  ret.agColor = xmlNode.getAttr(DvtBaseTreeParser.ATTR_ATTR_GROUPS_COLOR);
  ret.id = xmlNode.getAttr(DvtBaseTreeParser.ATTR_ID);
  ret.size = Number(xmlNode.getAttr(DvtBaseTreeParser.ATTR_SIZE));
  ret.color = xmlNode.getAttr(DvtBaseTreeParser.ATTR_COLOR);
  ret.pattern = xmlNode.getAttr(DvtBaseTreeParser.ATTR_PATTERN);
  ret.label = xmlNode.getAttr(DvtBaseTreeParser.ATTR_LABEL);
  ret.tooltip = xmlNode.getAttr(DvtBaseTreeParser.ATTR_TOOLTIP);
  ret.labelDisplay = xmlNode.getAttr(DvtBaseTreeParser.ATTR_LABEL_DISPLAY);
  ret.drilling = xmlNode.getAttr(DvtBaseTreeParser.ATTR_DRILLING);
  ret.indexInParent = xmlNode.getAttr(DvtBaseTreeParser.ATTR_INDEX_IN_PARENT);
  ret.disclosed = xmlNode.getAttr(DvtBaseTreeParser.ATTR_DISCLOSED) == "t" ? true : false;
  ret.selectable = xmlNode.getAttr(DvtBaseTreeParser.ATTR_SELECTABLE);

  var tn = xmlNode.getAttr(DvtBaseTreeParser.ATTR_TEMPLATE_NAME);
  if (tn) {
    ret.templateName = tn;
  }

  var labelStyle = xmlNode.getAttr(DvtBaseTreeParser.ATTR_LABEL_STYLE);
  if(labelStyle)
    ret.labelStyle = new DvtCSSStyle(labelStyle);
    
  // Keep track of the min and max attribute groups color values
  if(ret.agColor != null) {
    this._maxAGColor = Math.max(this._maxAGColor, ret.agColor);
    this._minAGColor = Math.min(this._minAGColor, ret.agColor);
  }
  
  return ret;
}

/**
 * Creates an artificial root above the given root nodes.
 * @param {DvtBaseTreeView} treeView
 * @param {array} rootNodes The array of nodes at the root level
 * @return {DvtBaseTreeNode} The resulting artificial tree component root node.
 * @private
 */
DvtBaseTreeParser.prototype._createArtificialRoot = function(treeView, rootNodes) {
  // Calculate the sum of the child sizes
  var size = 0;
  for(var i=0; i<rootNodes.length; i++) {
    size += rootNodes[i].getSize();
  }

  // Create the actual node and set the children
  var props = {size: size, bArtificialRoot: true, disclosed: true};
  var artificialRoot = this.CreateNode(treeView, props);
  artificialRoot.setChildNodes(rootNodes);
  return artificialRoot;
}

/**
 * Recursively parses the XML nodes, creating tree component nodes.
 * @param {DvtXmlNode} xmlNode The XML node to parse.
 * @return {DvtBaseTreeNode} The resulting tree component node.
 * @private
 */
DvtBaseTreeParser.prototype._parseDataNode = function(xmlNode, templates) {
  if(!xmlNode || xmlNode.getName() != DvtBaseTreeParser._ELEM_NODE)
    return null;
    
  // Increment the count
  this._nodeCount++;

  // Parse the attributes and create the node
  var props = this.ParseNodeAttributes(xmlNode);
  var treeNode = this.CreateNode(this._view, props, templates);
  
  // Parse the children if the node is disclosed
  treeNode.setChildNodes(this._parseChildren(xmlNode, treeNode, templates));
  
  return treeNode;
}

/**
 * Parses the children of the given node, returning the Array of results.
 * @param {DvtXmlNode} xmlNode the XML node whose children will be parsed
 * @return {array} the Array of resulting DvtBaseTreeNodes
 * @private
 */
DvtBaseTreeParser.prototype._parseChildren = function(xmlNode, treeNode, templates) {
  var treeNodes = new Array();
  
  //Bug 14059366 - TREEMAP ADVANCED NODE CONTENT DEMO NOT DISPLAYING PROPERLY
  // if(!treeNode.isDisclosed())
  //   return treeNodes;
  
  var childNodes = xmlNode.getChildNodes();
  for(var i=0; i<childNodes.length; i++) {
    var child = childNodes[i];
    if (child) {
      // has EL data?
      if(child.getName() == DvtBaseTreeParser._ELEM_EL) {
        if (templates) {
          this._parseELData(treeNode, child);
        }
      }
      else {
        //Bug 14059366 - TREEMAP ADVANCED NODE CONTENT DEMO NOT DISPLAYING PROPERLY
        // Return an empty array if children are not disclosed
        if (treeNode.isDisclosed())
          treeNodes.push(this._parseDataNode(child, templates));
      }
    }
  }
  
  return treeNodes;
}

/**
 * Parses the specified xml node.
 * @param {DvtXmlNode} xmlNode The xml node containing the node templates.
 * @param {object} ret The object containing the parsed state of the component.
 * @private
 */
DvtBaseTreeParser.prototype._parseNode = function(xmlNode, ret) {
  if(!xmlNode)
    return;
    
  var name = xmlNode.getName();
  if(name == "spb") {
    var showPopupBehavior = this._parseShowPopupBehavior(xmlNode, ret);
    if(!ret.showPopupBehaviors)
      ret.showPopupBehaviors = new Array();
    ret.showPopupBehaviors.push(showPopupBehavior);
  }
  else if(name == "menus") {
    // Make sure the handler is created
    if(!ret.contextMenuHandler)
      ret.contextMenuHandler = new DvtContextMenuHandler(this._view.getCtx());
    
    // Add this definition to the handler  
    ret.contextMenuHandler.add(xmlNode);
  }
  else if(name == "ag") 
    this._parseAttrGroups(xmlNode, ret);
  else if(name =="styles")
    ret.styles = this._parseStyles(xmlNode, ret);
  else if(name == "a")
    ret.ancestors = this._parseAncestors(xmlNode);
  else if(name == "resources")
    ret.resources = this._parseResources(xmlNode);
}

/**
 * Parses a showPopupBehavior element.
 * @param {DvtXmlNode} xmlNode The xml node defining the showPopupBehavior.
 * @param {object} ret The object containing the parsed state of the component.
 * @private
 */
DvtBaseTreeParser.prototype._parseShowPopupBehavior = function(xmlNode, ret) {
  // First parse the showPopupBehavior
  var showPopupBehavior = DvtShowPopupBehavior.newInstance(xmlNode);
  var templateId = xmlNode.getAttr(DvtBaseTreeParser.ATTR_TEMPLATE_ID);

  // Then store in it the ret object
  if(!ret.spb)
    ret.spb = new Object();

  if(!ret.spb[templateId])
    ret.spb[templateId] = new Array();

  ret.spb[templateId].push(showPopupBehavior);  
}

/**
 * Parses an attributeGroups element.
 * @param {DvtXmlNode} xmlNode The xml node defining the attr groups.
 * @param {object} ret The object containing the parsed state of the component.
 * @private
 */
DvtBaseTreeParser.prototype._parseAttrGroups = function(xmlNode, ret) {
  // Parse and create an entry for this attribute groups xml
  var attrGroups;
  var id = xmlNode.getAttr(DvtBaseTreeParser.ATTR_ID);
  var templateId = xmlNode.getAttr(DvtBaseTreeParser.ATTR_TEMPLATE_ID);
  var attrType = xmlNode.getAttr("t");
  
  if(attrType == "continuous") {
    // Continuous attribute groups support
    var minValue = xmlNode.getAttr("minValue");
    var maxValue = xmlNode.getAttr("maxValue");
    var minLabel = xmlNode.getAttr("minLabel");
    var maxLabel = xmlNode.getAttr("maxLabel");
    
    // The ramp is separated by semicolons
    var rampStr = xmlNode.getAttr("ramp");
    var ramp = rampStr.split(";");
    
    // Support implicit min/max values
    if(minValue == null)
      minValue = this._minAGColor;
    if(maxValue == null)
      maxValue = this._maxAGColor;
    
    // Create the attribute groups handler and pass it with the parsed properties
    attrGroups = new DvtContinuousAttrGroups(minValue, maxValue, minLabel, maxLabel, ramp);
  }
  else {
    // Discrete attribute groups support
    attrGroups = new DvtDiscreteAttrGroups();
    
    // Loop through the child nodes to find the mapping results
    var childNodes = xmlNode.getChildNodes();
    for(var i=0; i<childNodes.length; i++) {
      var child = childNodes[i];
      if(child) {
        var group = child.getAttr(DvtBaseTreeParser.ATTR_AG_GROUP);
        var groupLabel = child.getAttr(DvtBaseTreeParser.ATTR_AG_GROUP_LABEL);
        var params = {color: child.getAttr(DvtBaseTreeParser.ATTR_AG_COLOR),
                      pattern: child.getAttr(DvtBaseTreeParser.ATTR_AG_PATTERN)};
        attrGroups.add(group, groupLabel, params);
      }
    }  
  }
  
  // Make sure the attrGroups array is created
  if(!ret.attrGroups)
    ret.attrGroups = [];
  
  // Add the attr groups to the array
  ret.attrGroups.push({attrGroups: attrGroups, templateId: templateId, id: id});
}

/**
 * Recursively applies parsed properties onto the nodes.
 * @param {DvtBaseTreeNode} node The current node.
 * @param {object} ret The object containing the parsed state of the component.
 */
DvtBaseTreeParser.prototype._applyParsedProperties = function(node, ret) {
  if(!node)
    return;
    
  // Template ID is used to identify associated behaviors
  var templateId = node.getTemplateId();  
  
  // ShowPopupBehavior
  if(ret.spb) { 
    var behaviors = ret.spb[templateId];
    if(behaviors)
      node.setShowPopupBehaviors(behaviors);
  }
  
  // Attribute Groups
  if(ret.attrGroups) {
    // Iterate through and find the associated attribute groups definition
    for(var i=0; i<ret.attrGroups.length; i++) {
      var agDef = ret.attrGroups[i];
      if(agDef.templateId == templateId) {
        // Only continuous attribute groups are processed here, as discrete attribute
        // groups are processed in the server and the results baked into the xml.
        if(agDef.attrGroups instanceof DvtContinuousAttrGroups)
          node.processAttrGroups(agDef.attrGroups);
        
        break; 
      }
    }
  }

  // Recurse
  var children = node.getChildNodes();
  if(children) {
    for(var childIndex=0; childIndex<children.length; childIndex++) {
      this._applyParsedProperties(children[childIndex], ret);
    }
  }
}

/**
 * Get the child nodes with the name specified
 * @param {array} array of child nodes
 * @return {array} array of the child nodes with the name specified
 * @private
 */
DvtBaseTreeParser.prototype._getChildNodesByName = function(childNodes, name) {
  var nodes = [];
  for(var i=0; i<childNodes.length; i++) {
    var child = childNodes[i];

    if (child && child.getName() == name) {
      nodes.push(child);
    }
  }
  return nodes;
}

DvtBaseTreeParser.prototype._parseStyles = function(xmlNode, ret) {
  var styles = new Object();
  
  var topStyle = new DvtCSSStyle(xmlNode.getAttr("top"));
  styles[DvtBaseTreeView.BACKGROUND_STYLE] = topStyle;
  styles[DvtBaseTreeNode.ANIMATION_UPDATE_COLOR_STYLE] = topStyle.getStyle(DvtBaseTreeParser.ANIMATION_UPDATE_COLOR);

  var nodeStyle = new DvtCSSStyle(xmlNode.getAttr("node"));
  styles[DvtBaseTreeNode.LABEL_TEXT_DEFAULT_STYLE] = nodeStyle;
  
  var nodeHoverStyle = nodeStyle.clone().merge(new DvtCSSStyle(xmlNode.getAttr("node-hover")));
  var nodeSelectedStyle = nodeStyle.clone().merge(new DvtCSSStyle(xmlNode.getAttr("node-selected")));
  
  // Parse drop site feedback
  ret.dropSiteFillColor = xmlNode.getAttr(DvtBaseTreeParser.ATTR_DROP_SITE_FILL_COLOR);
  ret.dropSiteBorderColor = xmlNode.getAttr(DvtBaseTreeParser.ATTR_DROP_SITE_BORDER_COLOR);
  ret.dropSiteOpacity = xmlNode.getAttr(DvtBaseTreeParser.ATTR_DROP_SITE_OPACITY);
  
  // Additional support
  this.ParseAdditionalNodeStyles(nodeStyle, nodeHoverStyle, nodeSelectedStyle, styles);
  this.ParseAdditionalStyles(xmlNode, styles);

  var textStyle = new DvtCSSStyle(xmlNode.getAttr("rootText"));
  styles[DvtBaseTreeView.TEXT_STYLE] = textStyle;
  
  var attrTypeStyle = new DvtCSSStyle(xmlNode.getAttr("attrType"));
  styles[DvtBaseTreeView.ATTRIBUTE_TYPE_STYLE] = attrTypeStyle;
  
  var attrValueStyle = new DvtCSSStyle(xmlNode.getAttr("attrValue"));
  styles[DvtBaseTreeView.ATTRIBUTE_VALUE_STYLE] = attrValueStyle;

  var drillTextStyle = new DvtCSSStyle(xmlNode.getAttr("drillText"));
  styles[DvtBaseTreeView.DRILL_TEXT_STYLE] = drillTextStyle;

  var currentTextStyle = new DvtCSSStyle(xmlNode.getAttr("currentText"));
  styles[DvtBaseTreeView.CURRENT_TEXT_STYLE] = currentTextStyle;
  
  return styles;
}

DvtBaseTreeParser.prototype.ParseAdditionalNodeStyles = function(nodeStyle, nodeHoverStyle, nodeSelectedStyle, styles) {
}

DvtBaseTreeParser.prototype.ParseAdditionalStyles = function(xmlNode, styles) {
}

/**
 * Parses the template if exists
 * @param {DvtXmlNode} xmlNode The xml node containing the node template.
 * @return {Object} The object containing the parsed state of the tempaltes.
 * @private
 */
DvtBaseTreeParser.prototype._parseTemplates = function(childNodes) {

  // parse template, ex:
  // <f name="content">
  //     <ot value="Fixed Facet" id="j_id_id10"/>
  // </f>

  // <f name="content, 2">
  //     <ot id="j_id_id14" value="#{b1}"/>
  // </f>

  var template = this._getChildNodesByName(childNodes, DvtBaseTreeParser._ELEM_F);
  var count = template.length;
  if (count > 0) {
    var temp;
    var tempName;
    var templateMap = {};
    for (var i = 0; i < count; i++) {
      temp = template[i];
      tempName = temp.getAttr("name");
      templateMap[tempName] = DvtAfComponentFactory.parseXml(temp);
    }
    return templateMap;
  }
  return null;
}

/**
 * Parses the EL data if exists
 * @param {DvtXmlNode} xmlNode The xml node containing the node template.
 * @return {afComponent} The object containing the parsed state of the tempalte.
 * @private
 */
DvtBaseTreeParser.prototype._parseELData = function(treeNode, xmlNode) {
  // content facet: save EL attributes to be used in stamping afComponent
  if (treeNode.SetElAttributes) {
    treeNode.SetElAttributes(DvtPropMap.toELContext(xmlNode));
  }
}

/**
 * Parses an ancestors element.
 * @param {DvtXmlNode} xmlNode The xml node defining the ancestors.
 * @return {array} The array of ancestors.
 * @private
 */
DvtBaseTreeParser.prototype._parseAncestors = function(xmlNode) {
  // Ancestors are defined in order from direct ancestor to oldest ancestor
  var ancestors = [];
  
  // Iterate through the ancestors and retrieve their information
  var childNodes = xmlNode.getChildNodes();
  for(var i=0; i<childNodes.length; i++) {
    var id = childNodes[i].getAttr(DvtBaseTreeParser.ATTR_ID);
    var text = childNodes[i].getAttr(DvtBaseTreeParser.ATTR_LABEL);
    ancestors.push({id: id, text: text});
  }
  
  return ancestors;
}

/**
 * Parses a resources element.
 * @param {DvtXmlNode} xmlNode The xml node defining the resources.
 * @return {object} The map containing resources for this component.
 * @private
 */
DvtBaseTreeParser.prototype._parseResources = function(xmlNode) {
  var resources = {};
  
  // Iterate through the array of attributes
  var attrs = xmlNode.getAttributes();
  for(var i=0; i<attrs.length; i++) {
    var name = attrs[i].name;
    var value = attrs[i].value;
    resources[name] = value;
  }
  
  return resources;
}

/**
 * Applies the specified disclosed flag to the node with the given id to the xml string.
 * @param {string} The original xml string.
 * @param {string} The id of the node to update.
 * @param {boolean} The new disclosure state.
 * @return {string} The resulting xml string.
 */
DvtBaseTreeParser.applyDisclosure = function(xmlString, nodeId, bDisclosed) {
  // Find the substring of the xml for the node
  var startIndex = xmlString.indexOf('<n id="' + nodeId);
  var endIndex = xmlString.indexOf('>', startIndex);
  var nodeString = xmlString.substring(startIndex, endIndex);
  
  // Update the disclosed flag
  var disclosedIndex = nodeString.indexOf(DvtBaseTreeParser.ATTR_DISCLOSED + '=');
  if(disclosedIndex > -1) {
    if(bDisclosed)
      nodeString = nodeString.replace(DvtBaseTreeParser.ATTR_DISCLOSED + '="f"', DvtBaseTreeParser.ATTR_DISCLOSED + '="t"')
    else
      nodeString = nodeString.replace(DvtBaseTreeParser.ATTR_DISCLOSED + '="t"', DvtBaseTreeParser.ATTR_DISCLOSED + '="f"')
  }
  else
    nodeString += DvtBaseTreeParser.ATTR_DISCLOSED + (bDisclosed ? '="t"' : '="f"');
  
  // Reconstruct the xml string and return
  var prefix = xmlString.substring(0, startIndex);
  var suffix = xmlString.substring(endIndex);
  var ret = prefix + nodeString + suffix;
  return ret;
}
/**
 * Base class for tree component nodes.
 * @class The base class for tree component nodes.
 * @constructor
 * @implements {DvtTooltipSource}
 * @implements {DvtSelectable}
 * @implements {DvtPopupSource}
 * @implements {DvtContextMenuSource}
 * @implements {DvtKeyboardNavigable}
 * @implements {DvtDraggable}
 */
var DvtBaseTreeNode = function() {}

DvtObj.createSubclass(DvtBaseTreeNode, DvtObj, "DvtBaseTreeNode");

DvtBaseTreeNode._ANIMATION_DELETE_PRIORITY = 0;   // The order in which the delete animation occurs
DvtBaseTreeNode._ANIMATION_UPDATE_PRIORITY = 1;   // The order in which the update animation occurs
DvtBaseTreeNode._ANIMATION_INSERT_PRIORITY = 2;   // The order in which the insert animation occurs
DvtBaseTreeNode._ANIMATION_UPDATE_COLOR = null;   // The color that the node will flash on update, none by default

DvtBaseTreeNode._DEFAULT_FILL_COLOR = "#000000";
DvtBaseTreeNode._DEFAULT_TEXT_SIZE = 11;
DvtBaseTreeNode._DEFAULT_TEMPLATE_NAME = "content";
DvtBaseTreeNode._ROOT_TEMPLATE_NAME = "rootContent";


DvtBaseTreeNode.__NODE_SELECTED_SHADOW = new DvtShadow("#000000", 2, 5, 5, 45, 0.5);

// Style
DvtBaseTreeNode.ANIMATION_UPDATE_COLOR_STYLE = "ANIMATION_UPDATE_COLOR_STYLE";
DvtBaseTreeNode.LABEL_TEXT_DEFAULT_STYLE = "LABEL_TEXT_DEFAULT_STYLE";

/**
 * @param {DvtBaseTreeView} treeView The DvtBaseTreeView that owns this node.
 * @param {object} props The properties for the node.
 * @protected
 */
DvtBaseTreeNode.prototype.Init = function(treeView, props, templates) 
{
  this._view = treeView;
  this._templateId = props.templateId;
  this._menuId = props.menuId;
  this._agColor = props.agColor;
  
  this._id = props.id;
  this._size = props.size;
  this._color = props.color ? props.color : DvtBaseTreeNode._DEFAULT_FILL_COLOR;
  this._pattern = props.pattern;
  this._textStr = props.label;
  this._datatip = props.tooltip;
  this._labelStyle = props.labelStyle;
  this._drilling = props.drilling;
  this._disclosed = props.disclosed;
  this._indexInParent = props.indexInParent;
  
  // Whether this node is an artificial root
  this._bArtificialRoot = props.bArtificialRoot;
  
  // Node alpha is always 1 unless during animation
  this._alpha = 1;

  // reference to last visited child
  this._lastVisitedChild = null;  
  
  this._isShowingKeyboardFocusEffect = false;

  //save template info
  this._templates = templates;

  //if template name is specified (switcher case)
  if (props.templateName) {
    this._setTemplate(props.templateName);
  }
  else if (templates && templates[DvtBaseTreeNode._DEFAULT_TEMPLATE_NAME]) {
    this._setTemplate(DvtBaseTreeNode._DEFAULT_TEMPLATE_NAME);
  }
  else if (templates && templates[DvtBaseTreeNode._ROOT_TEMPLATE_NAME])
    this._setTemplate(DvtBaseTreeNode._ROOT_TEMPLATE_NAME);
    
  this.IsHover = false;
  
  // Whether or not this node will have the ability to be selectable
  this.Selectable = props.selectable;
}

/**
 * Sets the Array containing all children of this node.
 * @param {array} children The array of children for this node.
 */
DvtBaseTreeNode.prototype.setChildNodes = function(children) {
  // Set this node as the parent of the children
  if(children != null) {
    for(var i=0; i<children.length; i++)
      children[i]._parent = this;
  }
  
  // Store the children
  this._children = children;
}

/**
 * Returns the Array containing all children of this node.
 * @return {array} The array of children belonging to this node.
 */
DvtBaseTreeNode.prototype.getChildNodes = function() {
  return this._children;
}

/**
 * Returns an Array containing all the descendants of this node
 * @return {Array} The array of descendants of this node
 */
DvtBaseTreeNode.prototype.getDescendantNodes = function()
{
  var descendants = [];
  var childDescendants;
  var child;

  if(!this.hasChildren())
    return descendants;
    
  for(var i=0; i<this._children.length; i++)
  {
    child = this._children[i];
    childDescendants = child.getDescendantNodes();
    descendants.push(child);
    descendants = descendants.concat(childDescendants);
   }
   
  return descendants;
}

/**
 * Sets a reference to the last visited child.
 * 
 * @param {DvtBaseTreeNode} lastVisited
 * @protected
 */
DvtBaseTreeNode.prototype.SetLastVisitedChild = function(lastVisited)
{
  this._lastVisitedChild = lastVisited;
};

/**
 * Returns the last visited child
 * 
 * @return {DvtBaseTreeNode} The last visited child
 * @protected
 */
DvtBaseTreeNode.prototype.GetLastVisitedChild = function() 
{
  return this._lastVisitedChild;
};

/**
 * Updates the last visited child on the given node's parent to this node
 * @protected
 */
DvtBaseTreeNode.prototype.MarkAsLastVisitedChild = function()
{
  var parent = this.GetParent();
  if(parent)
  {
    parent.SetLastVisitedChild(this);
  }
}

/**
 * Returns true if this node is a descendant of the specified node.
 * @param {DvtBaseTreeNode} node
 */
DvtBaseTreeNode.prototype.isDescendantOf = function(node) {
  if(!node || !this.GetParent())
    return false;
  else if(this.GetParent() == node)
    return true;
  else
    return this.GetParent().isDescendantOf(node);
}

/**
 * Returns an Array containing all nodes that are at the given depth away from the current node
 * @param {DvtBaseTreeNode} root
 * @param {Number} depth
 * @return {Array} 
 */
DvtBaseTreeNode.prototype.GetNodesAtDepth = function(root, depth)
{
  var returnArray = []
  if(depth < 0)
    return returnArray;
    
  if(depth == 0)
    return [this];
  else if(root.hasChildren())
  {
    var children = root.getChildNodes();
    var child;
    for(var i=0; i<children.length; i++)
    {
      child = children[i];
      returnArray = returnArray.concat(child.GetNodesAtDepth(child, depth-1));
    }
  }

  return returnArray;
}

/**
 * Returns an Array containing all the leaves stemming from the tree rooted at this node
 * @return {Array}
 */
DvtBaseTreeNode.prototype.getLeafNodes = function()
{
  var leafNodes = [];
  var childLeafNodes;
  var child;

  if(!this.hasChildren())
    return [this];
    
  for(var i=0; i<this._children.length; i++)
  {
    child = this._children[i];
    childLeafNodes = child.getLeafNodes();
    leafNodes = leafNodes.concat(childLeafNodes);
   }
   
  return leafNodes;  
}
 
/**
 * Returns the node with the given id, if it is in the tree with the given root
 * @param {DvtBaseTreeNode} root
 * @param {String} id
 * @return {DvtBaseTreeNode} The node with the given id, or null if no node with the given id is found
 */
DvtBaseTreeNode.getNodeById = function(root, id)
{
  if(root.getId() == id)
  {
    return root;
  }
  else 
  {
    // recursively call getNodeById on each of the children
    var node = null;
    var children = root.getChildNodes();
    var length = children.length;
    var child = null;
    
    for(var i=0; i<length; i++)
    {
      child = children[i];
      node = DvtBaseTreeNode.getNodeById(child, id);
      if(node) 
      {
        // if we found the node, return it, otherwise check the next child
        return node;
      }
    }
    return null;
  }
}

/** 
 * Returns the component that owns this node.
 * @return {DvtBaseTreeView} The component that owns this node.
 */ 
DvtBaseTreeNode.prototype.getView = function() {
  return this._view;
}

/**
 * Returns the id of the template for this node.
 * @return {string} The id of the template for this node.
 */
DvtBaseTreeNode.prototype.getTemplateId = function() {
  return this._templateId;
}

/**
 * Returns the id for this node.
 * @return {string} The id for this node.
 */
DvtBaseTreeNode.prototype.getId = function() {
  return this._id;
}

/**
 * Returns the relative size of this node.
 * @return {Number} The relative size of this node.
 */
DvtBaseTreeNode.prototype.getSize = function() {
  // Note: Called by automation APIs
  return this._size;
}

/**
 * Returns the color of this node.
 * @return {String} The color of this node.
 */
DvtBaseTreeNode.prototype.getColor = function() {
  // Note: Called by automation APIs
  return this._color;
}

/**
 * @override
 */
DvtBaseTreeNode.prototype.getDatatip = function(target, x, y) {
  // Note: Called by automation APIs
  return this._datatip;
}

/**
 * @override
 */
DvtBaseTreeNode.prototype.getDatatipColor = function() {
  return this._color;
}

/**
 * Returns the alpha for this node.
 * @return {number} The alpha for this node.
 */
DvtBaseTreeNode.prototype.getAlpha = function() {
  // Note: This API is called by the fadeIn and fadeOut animations
  return this._alpha;
}

/**
 * Specifies the alpha for this node.
 * @param {number} alpha The alpha for this node.
 */
DvtBaseTreeNode.prototype.setAlpha = function(alpha) {
  // Note: This API is called by the fadeIn and fadeOut animations
  this._alpha = alpha;
  
  if(this._shape)
    this._shape.setAlpha(this._alpha);
}

/**
 * Returns true if the children of this node are disclosed.
 * @return {boolean}
 * @protected
 */
DvtBaseTreeNode.prototype.isDisclosed = function() {
  return this._disclosed;
}

/**
 * Returns true if this node is the artificial root of the tree.
 * @return {boolean}
 */
DvtBaseTreeNode.prototype.isArtificialRoot = function() {
  return this._bArtificialRoot;
}

/**
 * Returns true if drill replace is enabled for this node.
 * @return {boolean}
 */
DvtBaseTreeNode.prototype.isDrillReplaceEnabled = function() {
  return this._drilling == "r" || this._drilling == "ir";
}

/**
 * Specifies the array of showPopupBehaviors for this node.
 * @param {array} behaviors The array of showPopupBehaviors for this node.
 */
DvtBaseTreeNode.prototype.setShowPopupBehaviors = function(behaviors) {
  this._showPopupBehaviors = behaviors;  
}

/**
 * @override
 */
DvtBaseTreeNode.prototype.getShowPopupBehaviors = function() {
  return this._showPopupBehaviors;
}

/**
 * @override
 */
DvtBaseTreeNode.prototype.getContextMenuId = function() {
  return this._menuId;
}

/**
 * Renders this node.
 * @param {DvtContainer} container The container to render in.
 */
DvtBaseTreeNode.prototype.render = function(container) {
  // subclasses should override
}

/**
 * Renders the child nodes of this node.
 * @param {DvtContainer} container The container to render in.
 */
DvtBaseTreeNode.prototype.renderChildren = function(container) {
  // Render all children of this node
  var children = this.getChildNodes();
  if(children != null) {
    for(var i=0; i<children.length; i++) {
      children[i].render(container);
    }
  }
}

/**
 * Updates this node and its children with values from the attribute groups.
 * @param {DvtAttrGroups} ag
 */
DvtBaseTreeNode.prototype.processAttrGroups = function(ag) {
  var color = ag.get(this._agColor);
  if(color)
    this._color = color;
}


/**
 * Default implementation of getNextNavigable. Returns this node as the next navigable.  Subclasses should override
 * @override
 */
DvtBaseTreeNode.prototype.getNextNavigable = function(event) 
{
  // subclasses should override
  this.MarkAsLastVisitedChild();
  return this;
};


/**
 * @override
 */
DvtBaseTreeNode.prototype.getKeyboardBoundingBox = function() 
{
  // subclasses should override
  return new DvtRectangle(0,0,0,0);
};

/**
 * @override
 */
DvtBaseTreeNode.prototype.showKeyboardFocusEffect = function() 
{
  this.showHoverEffect();
  if(this.handleMouseOver)
    this.handleMouseOver();
    
  this._isShowingKeyboardFocusEffect = true;
}

/**
 * @override
 */
DvtBaseTreeNode.prototype.hideKeyboardFocusEffect = function()
{
  // Hide the hover effect if it was shown in response to keyboard focus
  if(this.isShowingKeyboardFocusEffect())
    this.hideHoverEffect();

  if(this.handleMouseOut)
    this.handleMouseOut();
  
  this._isShowingKeyboardFocusEffect = false;
}

/**
 * @override
 */
DvtBaseTreeNode.prototype.isShowingKeyboardFocusEffect = function() 
{
  return this._isShowingKeyboardFocusEffect;
}

/**
 * Handles a mouse over event on the node.
 */
DvtBaseTreeNode.prototype.handleMouseOver = function() {
  this.IsHover = true;
}

/**
 * Handles a mouse out event on the node.
 */
DvtBaseTreeNode.prototype.handleMouseOut = function() {
  this.IsHover = false;
}
 
/**
 * @override
 */
DvtBaseTreeNode.prototype.isSelectable = function() {
  return true;
}

/**
 * @override
 */
DvtBaseTreeNode.prototype.isSelected = function() {
  return this._selected;
}

/**
 * @override
 */
DvtBaseTreeNode.prototype.setSelected = function(selected) {
  // Store the selection state
  this._selected = selected;
}

/**
 * @override
 */
DvtBaseTreeNode.prototype.showHoverEffect = function() {
  // subclasses should override
}

/**
 * @override
 */
DvtBaseTreeNode.prototype.hideHoverEffect = function() {
  // subclasses should override
}

/**
 * @override
 */
DvtBaseTreeNode.prototype.isDragAvailable = function(clientIds) {
  return this.getView().__isDragAvailable(clientIds);
}

/**
 * @override
 */
DvtBaseTreeNode.prototype.getDragTransferable = function(mouseX, mouseY) {
  return this.getView().__getDragTransferable(this);
}

/**
 * @override
 */
DvtBaseTreeNode.prototype.getDragFeedback = function(mouseX, mouseY) {
  return this.getView().__getDragFeedback();
}

/**
 * Returns a displayable used for drop site feedback.
 * @return {DvtDisplayable}
 */
DvtBaseTreeNode.prototype.getDropSiteFeedback = function() {
  return null;
}

/**
 * Returns the displayable for this node.
 */
DvtBaseTreeNode.prototype.__getDisplayable = function() {
  return this._shape;
}

/**
 * Returns the bounds upon which the popup fired by the given behavior should align.
 * @param {DvtShowPopupBehavior} behavior The DvtShowPopupBehavior that is firing the popup.
 * @return {DvtRectangle} The rectangle that the popup should align to.
 */
DvtBaseTreeNode.prototype.getPopupBounds = function(behavior) {
  return null; // subclasses can override, or else default positioning will occur
}

/**
 * Returns true if this node contains the given coordinates.
 * @param {number} x
 * @param {number} y
 * @return {boolean}
 */
DvtBaseTreeNode.prototype.contains = function(x, y) {
  return false; // subclasses should override
}

/**
 * Returns the node under the given point, if it exists in the subtree of this node.
 * @param {number} x
 * @param {number} y
 * @return {DvtBaseTreeNode}
 */
DvtBaseTreeNode.prototype.getNodeUnderPoint = function(x, y) {
  return null; // subclasses should override
}

/**
 * Returns the layout parameters for the current animation frame.
 * @return {array} The array of layout parameters.
 * @protected
 */
DvtBaseTreeNode.prototype.GetAnimationParams = function() {
  return []; // subclasses should override
}

/**
 * Sets the layout parameters for the current animation frame.
 * @param {array} params The array of layout parameters.
 * @protected
 */
DvtBaseTreeNode.prototype.SetAnimationParams = function(params) {
  // subclasses should override
}

/**
 * Creates the update animation for this node.
 * @param {DvtBaseTreeAnimationHandler} handler The animation handler, which can be used to chain animations.
 * @param {DvtBaseTreeNode} oldNode The old node state to animate from.
 */
DvtBaseTreeNode.prototype.animateUpdate = function(handler, oldNode) {
  // Drilling animations are handled across all nodes up front, no recursion needed
  if(!handler.isDrillAnimation()) {
    // Recurse and animate the children
    handler.constructAnimation(oldNode.getChildNodes(), this.getChildNodes());
  }
  
  // Create the animator for this node
  var startState = oldNode.GetAnimationParams();
  var endState = this.GetAnimationParams();
  var nodePlayable;
  if(!DvtArrayUtils.equals(startState, endState)) {
    // Only create if state changed
    nodePlayable = new DvtCustomAnimation(this.getView().getCtx(), this, this.getView().__getAnimationDuration());
    nodePlayable.getAnimator().addProp(DvtAnimator.TYPE_NUMBER_ARRAY, this, this.GetAnimationParams, this.SetAnimationParams, endState);
    
    // Create the playable
    handler.add(nodePlayable, DvtBaseTreeNode._ANIMATION_UPDATE_PRIORITY);
    
    // Determine whether size and color changed.  This must be done before start state is set.
    var bSizeChanged = (this._size != oldNode._size);
    var bColorChanged = (DvtColorUtils.getRGBA(this._color) != DvtColorUtils.getRGBA(oldNode._color));
    
    // Initialize the start state
    this.SetAnimationParams(startState);
    
    var animationUpdateColor = this.getResolvedColor(DvtBaseTreeNode._ANIMATION_UPDATE_COLOR,  DvtBaseTreeNode.ANIMATION_UPDATE_COLOR_STYLE);
    // If the data changed, flash directly into the update color.
    if(animationUpdateColor && (bSizeChanged || bColorChanged)) 
      this._color = animationUpdateColor;                            
  }
}

/**
 * Creates the insert animation for this node.
 * @param {DvtBaseTreeAnimationHandler} handler The animation handler, which can be used to chain animations.
 */
DvtBaseTreeNode.prototype.animateInsert = function(handler) {
  // Animate if this is a data change animation (not drilling), or if this node is not an 
  // ancestor of the old root in a drilling animation.  The ancestors are not animated
  // so that they appear at the beginning of the animation.
  if(!handler.isDrillAnimation() || !handler.isAncestorInsert(this)) {
    // Initialize the start state
    this.setAlpha(0);
    
    var anim = new DvtAnimFadeIn(this.getView().getCtx(), this, this.getView().__getAnimationDuration());
    handler.add(anim, DvtBaseTreeNode._ANIMATION_INSERT_PRIORITY);
    
    // Recurse to children
    for(var i=0; i<this._children.length; i++) {
      this._children[i].animateInsert(handler);
    }
  }
}

/**
 * Creates the delete animation for this node.
 * @param {DvtBaseTreeAnimationHandler} handler The animation handler, which can be used to chain animations.
 * @param {DvtContainer} container The container where deletes should be moved for animation.
 */
DvtBaseTreeNode.prototype.animateDelete = function(handler, container) {
  // Move to the new container, since the old container may be removed
  container.addChild(this._shape);
  
  // Create the animation
  var anim = new DvtAnimFadeOut(this.getView().getCtx(), this, this.getView().__getAnimationDuration());
  handler.add(anim, DvtBaseTreeNode._ANIMATION_DELETE_PRIORITY);
  
  // Drilling animations are handled across all nodes up front, no recursion needed
  if(!handler.isDrillAnimation()) {
    // Recurse to children
    for(var i=0; i<this._children.length; i++) {
      this._children[i].animateDelete(handler, container);
    }
  }
}

/**
 * Returns true if this node has children.
 * @return {boolean} true if this node has children.
 */
DvtBaseTreeNode.prototype.hasChildren = function() {
  return (this._children != null && this._children.length > 0);
}

/** 
 * Returns the parent node for this node.
 * @return {DvtBaseTreeNode} The parent node.
 * @protected
 */ 
DvtBaseTreeNode.prototype.GetParent = function() {
  return this._parent;
}

/**
 * Returns the depth of the node in the tree.
 * @return {number} The depth of the node.
 * @protected
 */
DvtBaseTreeNode.prototype.GetDepth = function() {
  var depth = 0;
  var parent = this.GetParent();
  while(parent) {
    depth++;
    parent = parent.GetParent();
  }
  return depth;
}

/**
 * Returns the DvtFill to use for this node.
 * @return {DvtFill}
 */
DvtBaseTreeNode.prototype.GetFill = function() {
  if(this._pattern)  
    return new DvtPatternFill(this._pattern, this._color);
  else 
    return new DvtSolidFill(this._color);
}

/**
 * Calculates and returns a color for node text that will provide a 
 * good contrast with the given color.
 * @param {DvtBaseTreeNode} node
 * @protected
 */
DvtBaseTreeNode.GetNodeTextColor = function(node) {
  if(node._pattern) {
    // Use black for all patterned nodes against white backgrounds
    return "#000000";
  }
  else {
    var color = node._color;
    var r = DvtColorUtils.getRed(color);
    var g = DvtColorUtils.getGreen(color);
    var b = DvtColorUtils.getBlue(color);
    var yiq = (r*299 + g*587 + b*114)/1000;
    return (yiq >= 128) ? "#000000" : "#FFFFFF";
  }
}
  
DvtBaseTreeNode.prototype.ApplyLabelTextStyle = function(text) {
  var styleDef = DvtBaseTreeNode.LABEL_TEXT_DEFAULT_STYLE;
  var defaultFillColor = DvtBaseTreeNode.GetNodeTextColor(this);
  text.setSolidFill(defaultFillColor);
  var textStyle = new Array();
  textStyle.push(this._view.__getStyles()[styleDef]);
  if(this._labelStyle)
    textStyle.push(this._labelStyle);
  text.setCSSStyle(DvtCSSStyle.mergeStyles(textStyle));
}

DvtBaseTreeNode.prototype.getResolvedColor = function(defaultColor, styleColorKey) {
  var color = defaultColor;
  var colorValue = this._view.__getStyles()[styleColorKey];
  if (colorValue)
    color = colorValue;
  return color;
}

DvtBaseTreeNode.prototype.GetTextSize = function() {
  var size = DvtBaseTreeNode._DEFAULT_TEXT_SIZE;
  var textStyle = this._view.__getStyles()[DvtBaseTreeNode.LABEL_TEXT_DEFAULT_STYLE];
  var fontSize = textStyle.getFontSize();
  if (fontSize) {
    size = parseFloat(fontSize);
  }
  return size;
}

DvtBaseTreeNode.prototype.getIndexInParent = function() {
  // Note: Called by automation APIs
  return this._indexInParent;
}

DvtBaseTreeNode.prototype.getDisplayable = function() {
  // Note: Called by automation APIs
  return this._shape;
}

DvtBaseTreeNode.prototype.getLabel = function() {
  // Note: Called by automation APIs
  return this._textStr;
}


DvtBaseTreeNode.prototype.GetAfContext = function() {
  return this.getView().__getAfContext();
}

DvtBaseTreeNode.prototype.SetElAttributes = function(elAttrs) {
  //if no template name is specified(simple content facet case)
  if (elAttrs && ! this._template) {
    this._setTemplate(DvtBaseTreeNode._DEFAULT_TEMPLATE_NAME);
  }
  this._elAttributes = elAttrs;
}

DvtBaseTreeNode.prototype.GetElAttributes = function() {
  return this._elAttributes;
}

DvtBaseTreeNode.prototype._setTemplate = function(tempName) {
  if (tempName) {
    this._template = this._templates[tempName];
  }
}

DvtBaseTreeNode.prototype.GetTemplate = function() {
  return this._template;
}

/**
 * Returns whether this node can be double clicked.
 */
DvtBaseTreeNode.prototype.isDoubleClickable = function() {
  return this.isDrillReplaceEnabled();
}
/**
 * Simple logical object for drilling and tooltip support.
 * @param {DvtBaseTreeNode} node The associated node, if it has been created.
 * @param {string} id The id of the associated node.
 * @param {string} tooltip The tooltip to display.
 * @param {string} datatip The datatip to display.
 * @param {string} datatipColor The border color of the datatip.
 * @class
 * @constructor
 * @implements {DvtTooltipSource}
 */
var DvtBaseTreePeer = function(node, id, tooltip, datatip, datatipColor) {
  this.Init(tooltip, datatip, datatipColor);
  this._node = node;
  this._id = id;
  this._bDrillable = false;
}

DvtObj.createSubclass(DvtBaseTreePeer, DvtSimpleObjPeer, "DvtBaseTreePeer");

/**
 * Returns the id of the associated node.
 * @return {string}
 */
DvtBaseTreePeer.prototype.getId = function() {
  return this._id;
}

/**
 * Returns true if the associated object is drillable.
 * @return {boolean}
 */
DvtBaseTreePeer.prototype.isDrillable = function() {
  return this._bDrillable;
}

/**
 * Specifies whether the associated object is drillable.
 * @param {boolean} drillable
 */
DvtBaseTreePeer.prototype.setDrillable = function(drillable) {
  this._bDrillable = drillable;
}

/**
 * Handles a mouse out event on the associated object.
 */
DvtBaseTreePeer.prototype.handleMouseOut = function() {
  // Expand/Collapse: hide button if displayed
  if(this._node && this._node.handleMouseOut) {
    this._node.handleMouseOut();
  }
}
/**
 * Breadcrumb rendering utilities for tree components.
 * @class
 */
var DvtTreeBreadcrumbsRenderer = function() {}

DvtObj.createSubclass(DvtTreeBreadcrumbsRenderer, DvtObj, "DvtTreeBreadcrumbsRenderer");

DvtTreeBreadcrumbsRenderer._COMPONENT_GAP = 6; 
DvtTreeBreadcrumbsRenderer._ENABLED_INLINE_STYLE = "color: #003286;";

/**
 * Performs layout and rendering for the breadcrumbs in the given space.  Updates the available
 * space and returns the rendered displayable.
 * @param {DvtBaseTreeView} treeView The owning component.
 * @param {DvtRectangle} availSpace The rectangle within which to layout.
 * @param {array} ancestors
 * @param {string} rootLabel The label for the root node.
 * @return {DvtDisplayable} The rendered legend contents.
 */
DvtTreeBreadcrumbsRenderer.render = function(treeView, availSpace, ancestors, rootLabel) {  
  var context = treeView.getCtx();
  
  // Figure out the label styles
  var enabledStyleArray = new Array();
  enabledStyleArray.push(treeView.__getStyles()[DvtBaseTreeView.TEXT_STYLE]);
  enabledStyleArray.push(new DvtCSSStyle(DvtTreeBreadcrumbsRenderer._ENABLED_INLINE_STYLE));
  enabledStyleArray.push(treeView.__getStyles()[DvtBaseTreeView.DRILL_TEXT_STYLE]);
  var enabledStyle = DvtCSSStyle.mergeStyles(enabledStyleArray).toString();
  var enabledStyleOver = enabledStyle + "text-decoration: underline;"
  
  var disabledStyleArray = new Array();
  disabledStyleArray.push(treeView.__getStyles()[DvtBaseTreeView.TEXT_STYLE]);
  disabledStyleArray.push(treeView.__getStyles()[DvtBaseTreeView.CURRENT_TEXT_STYLE]);
  var disabledStyle = DvtCSSStyle.mergeStyles(disabledStyleArray).toString();
  
  // Create the breadcrumbs component and temporarily add to the component
  var options = {labelStyle: enabledStyle, labelStyleOver: enabledStyleOver, labelStyleDown: enabledStyleOver, disabledLabelStyle: disabledStyle};
  var breadcrumbs = new DvtBreadcrumbs(context, treeView.__processBreadcrumbsEvent, treeView, options);
  treeView.addChild(breadcrumbs);
  
  // Create the data object for the breadcrumbs.  Use the reverse of the ancestors array, since
  // the most distant ancestor is rendered first.
  var dataItems = ancestors.slice(0).reverse();
  dataItems.push({text: rootLabel});
  var data = {'items': dataItems};
  breadcrumbs.render(data, availSpace.w);

  // Figure out the height used and reduce availSpace
  var dims = breadcrumbs.getDimensions();
  breadcrumbs.setTranslate(availSpace.x, availSpace.y);
  var height = dims.h + DvtTreeBreadcrumbsRenderer._COMPONENT_GAP;
  availSpace.y += height;
  availSpace.h -= height;
  
  // Remove the breadcrumbs so that it can be added under the right parent.
  treeView.removeChild(breadcrumbs);
  return breadcrumbs;
}
/**
 * Legend rendering utilies for tree components.
 * @class
 */
var DvtTreeLegendRenderer = function() {}

DvtObj.createSubclass(DvtTreeLegendRenderer, DvtObj, "DvtTreeLegendRenderer");

DvtTreeLegendRenderer._LEGEND_GAP = 4; 
DvtTreeLegendRenderer._LEGEND_LABEL_GAP = 7; 
DvtTreeLegendRenderer._LEGEND_SECTION_GAP = 24; 
DvtTreeLegendRenderer._LABEL_SIZE = 11;
DvtTreeLegendRenderer._LABEL_COLOR = "#636363";

DvtTreeLegendRenderer._LABEL_INLINE_STYLE = "color:"+DvtTreeLegendRenderer._LABEL_COLOR+";";


/**
 * Performs layout and rendering for the legend in the given space.  Updates the available
 * space and returns the rendered displayable.
 * @param {DvtBaseTreeView} treeView The owning component.
 * @param {DvtRectangle} availSpace The rectangle within which to layout.
 * @param {string} sizeStr The resource for "Size".
 * @param {string} colorStr The resource for "Color".
 * @param {string} sizeValueStr A description of the size metric.
 * @param {string} colorValueStr A description of the color metric.
 * @param {DvtAttrGroups} attrGroups An attribute groups describing the colors.
 * @return {DvtDisplayable} The rendered legend contents.
 */
DvtTreeLegendRenderer.render = function(treeView, availSpace, sizeStr, colorStr, sizeValueStr, colorValueStr, attrGroups) {  
  var context = treeView.getCtx();
  var eventManager = treeView.__getEventManager();

  // Create the legend container and temporarily add to the component
  var legend = new DvtContainer(context);
  treeView.addChild(legend);
      
  // Size/Color Labels    
  var labelContainer = DvtTreeLegendRenderer._renderLabels(context, treeView, legend, availSpace.w, sizeStr, colorStr, sizeValueStr, colorValueStr, attrGroups);

  var borderColor = treeView.__getResources().alta ? null : "#000000";
  var legendStyleArray = new Array();
  legendStyleArray.push(treeView.__getStyles()[DvtBaseTreeView.TEXT_STYLE]);
  var legendStyles = {borderColor: borderColor, labelStyle: DvtCSSStyle.mergeStyles(legendStyleArray)};

  // Color Section
  var colorContainer = DvtLegendAttrGroupsRenderer.renderAttrGroups(context, eventManager, legend, availSpace.w, availSpace.h, attrGroups, legendStyles);

  // Position the sections horizontally
  var labelDims = labelContainer ? labelContainer.getDimensions() : null;
  var colorDims = colorContainer ? colorContainer.getDimensions() : null;
  if(labelContainer && !colorContainer) // Only labels, center
    labelContainer.setTranslateX(availSpace.y + (availSpace.w - labelDims.w)/2);
  else if(colorContainer && !labelContainer) // Only colors, center
    colorContainer.setTranslateX(availSpace.y + (availSpace.w - colorDims.w)/2);
  else if(colorContainer && labelContainer) {
    // Deal with overflow
    var availWidth = availSpace.w - DvtTreeLegendRenderer._LEGEND_SECTION_GAP;
    if(labelDims.w + colorDims.w > availWidth) { 
      if(labelDims.w > availWidth/2 && colorDims.w > availWidth/2) {
        // Both don't fit, recreate at half of the avail width each
        legend.removeChild(labelContainer);
        legend.removeChild(colorContainer);
        labelContainer = DvtTreeLegendRenderer._renderLabels(context, treeView, legend, availWidth/2, sizeStr, colorStr, sizeValueStr, colorValueStr, attrGroups);
        colorContainer = DvtLegendAttrGroupsRenderer.renderAttrGroups(context, eventManager, legend, availWidth/2, availSpace.h, attrGroups, legendStyles);
      }
      else if(labelDims.w > colorDims.w) {
        // Labels don't fit, give all remaining space
        var labelSpace = availWidth - colorDims.w;
        
        // Recreate the labelContainer at the available size
        legend.removeChild(labelContainer);
        labelContainer = DvtTreeLegendRenderer._renderLabels(context, treeView, legend, labelSpace, sizeStr, colorStr, sizeValueStr, colorValueStr, attrGroups);
      }
      else {
        // Colors don't fit, give all remaining space
        var colorSpace = availWidth - labelDims.w;
        
        // Recreate the labelContainer at the available size
        legend.removeChild(colorContainer);
        colorContainer = DvtLegendAttrGroupsRenderer.renderAttrGroups(context, eventManager, legend, colorSpace, availSpace.h, attrGroups, legendStyles);
      }
      
      // Size changed so recalc dimensions
      labelDims = labelContainer.getDimensions();
      colorDims = colorContainer.getDimensions();
    }
    
    // Position
    if(DvtAgent.isRightToLeft(context)) {
      colorContainer.setTranslateX(availSpace.x);
      labelContainer.setTranslateX(availSpace.x + availSpace.w - labelDims.w);
    }
    else {
      labelContainer.setTranslateX(availSpace.x);
      colorContainer.setTranslateX(availSpace.x + availSpace.w - colorDims.w);
    }
  }
  
  // Figure out the height used and reduce availSpace
  var legendDims = legend.getDimensions();
  legend.setTranslateY(availSpace.y + availSpace.h - legendDims.h);
  availSpace.h -= (legendDims.h + DvtTreeLegendRenderer._LEGEND_GAP);
  
  // Remove the legend so that it can be added under the right parent.
  treeView.removeChild(legend);
  return legend;
}

/**
 * Performs layout and rendering for the legend labels.
 * @param {DvtContext} context
 * @param {DvtBaseTreeView} treeView The owning component.
 * @param {DvtContainer} legend The legend container.
 * @param {number} availWidth The available horizontal space.
 * @param {string} sizeStr The resource for "Size".
 * @param {string} colorStr The resource for "Color".
 * @param {string} sizeValueStr A description of the size metric.
 * @param {string} colorValueStr A description of the color metric.
 * @param {DvtAttrGroups} attrGroups An attribute groups describing the colors.
 * @return {DvtDisplayable} The rendered contents.
 */
DvtTreeLegendRenderer._renderLabels = function(context, treeView, legend, availWidth, sizeStr, colorStr, sizeValueStr, colorValueStr, attrGroups) {  
  var isRTL = DvtAgent.isRightToLeft(context);
  var eventManager = treeView.__getEventManager();
  var labelContainer = null;
  if(sizeValueStr || colorValueStr) {
    // Create a container for the labels  
    labelContainer = new DvtContainer(context);
    legend.addChild(labelContainer); 

    var textStyle = new Array();
    textStyle.push(treeView.__getStyles()[DvtBaseTreeView.TEXT_STYLE]);
    textStyle.push(treeView.__getStyles()[DvtBaseTreeView.ATTRIBUTE_TYPE_STYLE]);
    var attrTypeStyle = DvtCSSStyle.mergeStyles(textStyle);

    textStyle = new Array();
    textStyle.push(treeView.__getStyles()[DvtBaseTreeView.TEXT_STYLE]);
    textStyle.push(treeView.__getStyles()[DvtBaseTreeView.ATTRIBUTE_VALUE_STYLE]);
    var attrValueStyle = DvtCSSStyle.mergeStyles(textStyle);
  
    // Size: Size Metric
    var sizeLabel;
    var sizeValueLabel;
    var sizeLabelWidth;
    var sizeValueLabelWidth;
    var sizeWidth = 0;
    if(sizeValueStr) {    
      // Size Label
      sizeLabel = new DvtOutputText(context, sizeStr, 0, 0);
      sizeLabel.setCSSStyle(attrTypeStyle);
    
      labelContainer.addChild(sizeLabel);
      sizeLabelWidth = sizeLabel.measureDimensions().w;
      
      // Size Value Label
      sizeValueLabel = new DvtOutputText(context, sizeValueStr, 0, 0);
      sizeValueLabel.setCSSStyle(attrValueStyle);

      labelContainer.addChild(sizeValueLabel); 
      sizeValueLabelWidth = sizeValueLabel.measureDimensions().w;
      
      // Size section width
      sizeWidth = sizeLabelWidth + sizeValueLabelWidth + DvtTreeLegendRenderer._LEGEND_LABEL_GAP;
    }
    
    // Color: Color Metric
    var colorLabel;
    var colorValueLabel;
    var colorLabelWidth;
    var colorValueLabelWidth;
    var colorWidth = 0;
    if(colorValueStr) {  
      // Color Label
      colorLabel = new DvtOutputText(context, colorStr, 0, 0);
      colorLabel.setCSSStyle(attrTypeStyle);

      labelContainer.addChild(colorLabel);
      colorLabelWidth = colorLabel.measureDimensions().w;
      
      // Color Value Label
      colorValueLabel = new DvtOutputText(context, colorValueStr, 0, 0);
      colorValueLabel.setCSSStyle(attrValueStyle);

      labelContainer.addChild(colorValueLabel);
      colorValueLabelWidth = colorValueLabel.measureDimensions().w;
      
      // Size section width
      colorWidth = colorLabelWidth + colorValueLabelWidth + DvtTreeLegendRenderer._LEGEND_LABEL_GAP;
    }
    
    // Reduce size to fit if needed
    availWidth -= DvtTreeLegendRenderer._LEGEND_SECTION_GAP;
    if(sizeWidth + colorWidth > availWidth) {
      var widthPerSection = availWidth/2;
      if(sizeWidth > widthPerSection && colorWidth > widthPerSection) {
        // Both don't fit, truncate and reposition
        var sizeValueSpace = widthPerSection - sizeLabelWidth - DvtTreeLegendRenderer._LEGEND_LABEL_GAP;
        if(DvtTextUtils.fitText(sizeValueLabel, sizeValueSpace, Infinity, labelContainer)) {
          sizeValueLabelWidth = sizeValueLabel.measureDimensions().w;
          eventManager.associate(sizeValueLabel, new DvtSimpleObjPeer(sizeValueStr));
        }
        else {
          labelContainer.removeChild(sizeLabel);
          labelContainer.removeChild(sizeValueLabel);
          sizeValueLabel = null;
          sizeValueLabelWidth = 0;
        }
        
        var colorValueSpace = widthPerSection - colorLabelWidth - DvtTreeLegendRenderer._LEGEND_LABEL_GAP;
        if(DvtTextUtils.fitText(colorValueLabel, colorValueSpace, Infinity, labelContainer)) {
          colorValueLabelWidth = colorValueLabel.measureDimensions().w;
          eventManager.associate(colorValueLabel, new DvtSimpleObjPeer(colorValueStr));
        }
        else {
          labelContainer.removeChild(colorLabel);
          labelContainer.removeChild(colorValueLabel);
          colorValueLabel = null;
          colorValueLabelWidth = 0;
        }
      }
      else if(sizeWidth > colorWidth) { // Reduce the size label size
        if(DvtTextUtils.fitText(sizeValueLabel, availWidth - colorWidth - sizeLabelWidth - DvtTreeLegendRenderer._LEGEND_LABEL_GAP, Infinity, labelContainer)) {
          sizeValueLabelWidth = sizeValueLabel.measureDimensions().w;
          eventManager.associate(sizeValueLabel, new DvtSimpleObjPeer(sizeValueStr));
        }
        else {
          labelContainer.removeChild(sizeLabel);
          labelContainer.removeChild(sizeValueLabel);
          sizeValueLabel = null;
          sizeValueLabelWidth = 0;
        }
      }
      else { // Reduce the color label size 
        if(DvtTextUtils.fitText(colorValueLabel, availWidth - sizeWidth - colorLabelWidth - DvtTreeLegendRenderer._LEGEND_LABEL_GAP, Infinity, labelContainer)) {
          colorValueLabelWidth = colorValueLabel.measureDimensions().w;
          eventManager.associate(colorValueLabel, new DvtSimpleObjPeer(colorValueStr));
        }
        else {
          labelContainer.removeChild(colorLabel);
          labelContainer.removeChild(colorValueLabel);
          colorValueLabel = null;
          colorValueLabelWidth = 0;
        }
      }
    }
    
    // Position the text objects
    var x = 0;
    if(isRTL) {
      if(colorValueLabel) {
        colorValueLabel.setX(x);
        x += colorValueLabelWidth + DvtTreeLegendRenderer._LEGEND_LABEL_GAP;
        colorLabel.setX(x);
        x += colorLabelWidth + DvtTreeLegendRenderer._LEGEND_SECTION_GAP;
      }
      
      if(sizeValueLabel) {
        sizeValueLabel.setX(x);
        x += sizeValueLabelWidth + DvtTreeLegendRenderer._LEGEND_LABEL_GAP;
        sizeLabel.setX(x);
      }
    }
    else {
      if(sizeValueLabel) {
        sizeLabel.setX(x);
        x += sizeLabelWidth + DvtTreeLegendRenderer._LEGEND_LABEL_GAP;
        sizeValueLabel.setX(x);
        x += sizeValueLabelWidth + DvtTreeLegendRenderer._LEGEND_SECTION_GAP;
      }
      
      if(colorValueLabel) {
        colorLabel.setX(x);
        x += colorLabelWidth + DvtTreeLegendRenderer._LEGEND_LABEL_GAP;
        colorValueLabel.setX(x);
      }
    }
  }
  return labelContainer;
}
/*---------------------------------------------------------------------------------*/
/*  DvtBaseTreeKeyboardHandler     Keyboard handler for Sunburst                   */
/*---------------------------------------------------------------------------------*/
/**
  *  @param {DvtEventManager} manager The owning DvtEventManager 
  *  @class DvtBaseTreeKeyboardHandler
  *  @extends DvtKeyboardHandler
  *  @constructor
  */
var  DvtBaseTreeKeyboardHandler = function(manager)
{
    this.Init(manager);
};

DvtObj.createSubclass(DvtBaseTreeKeyboardHandler, DvtKeyboardHandler, "DvtBaseTreeKeyboardHandler");


/**
 * @override
 */
DvtBaseTreeKeyboardHandler.prototype.isSelectionEvent = function(event)
{
  return  this.isNavigationEvent(event) && !event.ctrlKey;
}

/**
 * @override
 */ 
DvtBaseTreeKeyboardHandler.prototype.isMultiSelectEvent = function(event)
{
  return  event.keyCode == DvtKeyboardEvent.SPACE && event.ctrlKey;
}
/**
 * Default values and utility functions for component versioning.
 * @class
 * @constructor
 * @extends {DvtBaseComponentDefaults}
 */
var DvtBaseTreeDefaults = function() {}

DvtObj.createSubclass(DvtBaseTreeDefaults, DvtBaseComponentDefaults, "DvtBaseTreeDefaults");

/**
 * Defaults for version 1.
 */ 
DvtBaseTreeDefaults.VERSION_1 = {
  'skin': DvtCSSStyle.SKIN_SKYROS,
  
  // Note, only attributes that are different than the XML defaults need 
  // to be listed here, at least until the XML API is replaced.
  'emptyText': "No data to display",
  'nodeDefaults': {
    'labelStyle': new DvtCSSStyle("font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 11px;")
  },
  
  'styleDefaults': {
    '_attributeTypeTextStyle': new DvtCSSStyle("font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:12px;font-weight:bold;color:#4F4F4F"),
    '_attributeValueTextStyle': new DvtCSSStyle("font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;font-size:12px;")
  },
  
  '_resources': {}
}

/**
 * @override
 */
DvtBaseTreeDefaults.prototype.Init = function(defaultsMap) {
  // This will only be called via subclasses.  Combine with defaults from this class before passing to super.
  var ret = {
    'skyros': DvtJSONUtils.merge(defaultsMap['skyros'], DvtBaseTreeDefaults.VERSION_1),
    'alta': DvtJSONUtils.merge(defaultsMap['alta'], {})
  };

  DvtBaseTreeDefaults.superclass.Init.call(this, ret);
}
/**
 * Utility functions for converting between JSON and XML APIs.
 * @class
 */
var DvtBaseTreeJsonUtils = function() {}

DvtObj.createSubclass(DvtBaseTreeJsonUtils, DvtObj, "DvtBaseTreeJsonUtils");

/**
 * Converts the options JSON API into the XML API.
 * @param {object} options The object containing specifications and data for this component.
 * @return {string} The resulting XML string.
 */
DvtBaseTreeJsonUtils.prototype.toXml = function(options) {
  var ret = this.StartComponentElement(options);
  
  // Write out the nodes
  if(options && options['nodes']) {
    var nodes = options['nodes'];
    for(var i=0; i<nodes.length; i++)
      ret += this.WriteNodeElement(options, nodes[i]);
  }
  
  ret += this.EndComponentElement(options);
  return ret;
}

/** @protected **/
DvtBaseTreeJsonUtils.prototype.WriteAttr = function(attrName, value) {
  return value != null ? " " + attrName + "=\"" + value + "\"" : "";
}

/** @protected **/
DvtBaseTreeJsonUtils.prototype.GetComponentName = function() {
  return null;
}

/** @protected **/
DvtBaseTreeJsonUtils.prototype.StartComponentElement = function(options) {
  var ret = "<" + this.GetComponentName();
  ret += this.WriteComponentAttributes(options);
  ret += ">\n";
  return ret;
}

/** @protected **/
DvtBaseTreeJsonUtils.prototype.WriteComponentAttributes = function(options) {
  var ret = "";
  
  // Data Attrs
  ret += this.WriteAttr("sv", options['sizeLabel']);
  ret += this.WriteAttr("cv", options['colorLabel']);
  
  // Legend Source
  var attrGroups = options['attributeGroups'] ? options['attributeGroups'][0] : null;
  if(attrGroups)
    ret += this.WriteAttr("ls", attrGroups['id']);
    
  // Selected Node Ids
  var selectedNodes = options['selectedNodes'] ? options['selectedNodes'] : [];
  var selectedNodeStr = "";
  for(var i=0; i<selectedNodes.length; i++) {
    if(selectedNodeStr.length > 0)
      selectedNodeStr += ",";
  
    selectedNodeStr += selectedNodes[i];
  }
  
  if(selectedNodeStr.length > 0)
    ret += this.WriteAttr("selIds", selectedNodeStr);
  
  // Options Attrs
  ret += this.WriteAttr("adu", options['animationDuration']);
  ret += this.WriteAttr("adc", options['animationOnDataChange']);
  ret += this.WriteAttr("emptyText", options['emptyText']);
  ret += this.WriteAttr("sel", options['selection']);
  ret += this.WriteAttr("sort", options['sorting']);
  
  return ret;
}

/** @protected **/
DvtBaseTreeJsonUtils.prototype.EndComponentElement = function(options) {
  // TODO ancestors, resources, styles
  var ret = "";
  
  ret += "<a/>\n";
  ret += this.WriteResourcesElement(options);
  ret += this.WriteStyleElement(options);
  ret += this.WriteAttributeGroupsElement(options);
  ret += "<\/" + this.GetComponentName() + ">";
  return ret;
}

/** @protected **/
DvtBaseTreeJsonUtils.prototype.WriteNodeElement = function(options, nodeData) {
  var ret = "<n";
  
  // Write node attributes
  ret += this.WriteNodeAttributes(options, nodeData);
  
  // Write child nodes
  if(nodeData && nodeData['nodes'] && nodeData['nodes'].length > 0) {
    // Disclosed true  
    ret += this.WriteAttr("di", "t");
  
    // Close the current element
    ret += ">\n";
  
    var nodes = nodeData['nodes'];
    for(var i=0; i<nodes.length; i++)
      ret += this.WriteNodeElement(options, nodes[i]);
      
    // Really close the current element
    ret += "<\/n>\n";
  }
  else // No children
    ret += "/>\n";
    
  // Return the xml  
  return ret;
}

/** @protected **/
DvtBaseTreeJsonUtils.prototype.WriteNodeAttributes = function(options, nodeData) {
  var ret = "";
  
  ret += this.WriteAttr("id", nodeData['id']);
  ret += this.WriteAttr("s", nodeData['value']);
  ret += this.WriteAttr("c", nodeData['color']);
  ret += this.WriteAttr("l", nodeData['label']);
  ret += this.WriteAttr("p", nodeData['pattern']);
  
  var tooltip = nodeData['shortDesc'] ? nodeData['shortDesc'] : nodeData['tooltip'];
  ret += this.WriteAttr("tt", tooltip);
  
  var labelStyle = nodeData['labelStyle'] ? nodeData['labelStyle'] : options['nodeDefaults']['labelStyle'];
  ret += this.WriteAttr("ls", labelStyle);
  
  var drilling = nodeData['drilling'] ? nodeData['drilling'] : options['nodeDefaults']['drilling'];
  if(drilling == "insert")
    ret += this.WriteAttr("d", "i");
  else if(drilling == "replace")
    ret += this.WriteAttr("d", "r");
  else if(drilling == "insertAndReplace")
    ret += this.WriteAttr("d", "ir");
    
  var selectable = nodeData['selectable'] ? nodeData['selectable'] : "auto";
  ret += this.WriteAttr("nsel", selectable);
  
  return ret;
}

/** @protected **/
DvtBaseTreeJsonUtils.prototype.WriteAttributeGroupsElement = function(options) {
  var attrGroups = options['attributeGroups'] ? options['attributeGroups'][0] : null;
  if(!attrGroups)
    return "";

  var ret = '<ag id="' + attrGroups['id'] + '"';
  if(attrGroups['attributeType'] == 'continuous') {  
    // Write out the properties
    ret += this.WriteAttr("t", 'continuous');
    ret += this.WriteAttr("ramp", attrGroups['colors'].join(';'));
    ret += this.WriteAttr("minValue", attrGroups['min']);
    ret += this.WriteAttr("maxValue", attrGroups['max']);
    ret += this.WriteAttr("minLabel", attrGroups['minLabel']);
    ret += this.WriteAttr("maxLabel", attrGroups['maxLabel']);
    ret += '/>';
  }
  else { // discrete
    ret += '>\n';
    
    // Write out the group items
    var groups = attrGroups['groups'];
    for(var i=0; i<groups.length; i++) {
      ret += '<i';
      ret += this.WriteAttr("g", groups[i]['id']);
      ret += this.WriteAttr("l", groups[i]['label']);
      ret += this.WriteAttr("c", groups[i]['color']);
      ret += this.WriteAttr("p", groups[i]['pattern']);
      ret += '/>\n';
    }
    
    ret += '<\/ag>\n';
  }
  
  return ret;
}

/** @protected **/
DvtBaseTreeJsonUtils.prototype.WriteResourcesElement = function(options) {
  // subclasses should override
}

/** @protected **/
DvtBaseTreeJsonUtils.prototype.WriteStyleElement = function(options) {
  var ret = "<styles ";
  
  var attributeTypeTextStyle = options['styleDefaults']["_attributeTypeTextStyle"];
  ret += this.WriteAttr("attrType", attributeTypeTextStyle);
  
  var attributeValueTextStyle = options['styleDefaults']["_attributeValueTextStyle"];
  ret += this.WriteAttr("attrValue", attributeValueTextStyle);
  
  return ret;
}
// Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.
/*---------------------------------------------------------------------*/
/*  DvtTreeAutomation         Tree Automation Services         */
/*---------------------------------------------------------------------*/
/**
  *  Provides automation services for treemap/sunburst.  To obtain a
  *  @class  DvtTreeAutomation
  *  @extends DvtObj
  *  @param {DvtBaseTreeView} treeView 
  *  @constructor
  * 
  */
var  DvtTreeAutomation = function(treeView)
{
  this._Init(treeView)
};

DvtObj.createSubclass(DvtTreeAutomation, DvtObj, "DvtTreeAutomation") ;

DvtTreeAutomation.prototype._Init = function(treeView)
{
  this._treeView = treeView;
};

DvtTreeAutomation.NODE_ID_PREFIX                = "node";

DvtTreeAutomation.AUTOMATION_NO_EVENT           = -1;
DvtTreeAutomation.AUTOMATION_MOUSE_CLICK        = 0;

DvtTreeAutomation.prototype.getSubIdFromCoord = function(x, y)
{
    var target = this._treeView.getCtx().getDocumentUtils().elementFromPoint(x, y);
    if (target)
        return this.getSubIdFromObj(target);
    return null;
}
      
DvtTreeAutomation.prototype.getSubIdFromEvent = function(event)
{
    return this.getSubId(event.pageX, event.pageY, event.target);
}

DvtTreeAutomation.prototype.getSubId = function(pageX, pageY, target)
{
    return this.getSubIdFromObj(target);
}

DvtTreeAutomation.prototype.getSubIdFromObj = function(target) 
{
    var logicalObj = this._treeView.getLogicalObject(target);
    if (!logicalObj)
        return null;
    if(logicalObj instanceof DvtBaseTreeNode)
    {
      var currentNode = logicalObj;
      var nodeId = "["+currentNode.getIndexInParent()+"]";
      
      currentNode = currentNode.GetParent();
      while (currentNode) {
          nodeId = "["+currentNode.getIndexInParent()+"]" + nodeId;
          currentNode = currentNode.GetParent();
      }
      return DvtTreeAutomation.NODE_ID_PREFIX+nodeId;
    }
    return null;
}

DvtTreeAutomation.prototype.click = function(subId)
{
    this.processSubId(subId, DvtTreeAutomation.AUTOMATION_MOUSE_CLICK);
}

DvtTreeAutomation.prototype.processSubId = function(subId, event)
{
  if(event === undefined)
  {
    event = DvtTreeAutomation.AUTOMATION_NO_EVENT;
  }
  
  if (subId == null)
  {
    return null ;
  }

  var  str;              // return value
    
  var bIsEvent = (event != DvtTreeAutomation.AUTOMATION_NO_EVENT);

  if (bIsEvent) {
      if (event == DvtTreeAutomation.AUTOMATION_MOUSE_CLICK) {
          var subIdArray = DvtTreeAutomation._convertSubIdToArray(subId);
          if (subIdArray && subIdArray[0] == DvtTreeAutomation.NODE_ID_PREFIX) {
              var foundNode = DvtTreeAutomation._FindNode(this._treeView.getRootNode(), subIdArray, 1);
              if (foundNode)
                  foundNode.getDisplayable().dispatchDisplayableEvent(DvtMouseEvent.CLICK);
          }
      }
  } else {
    var subIdArray = DvtTreeAutomation._convertSubIdToArray(subId);
    if (subIdArray && subIdArray[0] == DvtTreeAutomation.NODE_ID_PREFIX) {
      var lastIndex = subIdArray.length - 1;
      var subSubId  = subIdArray[lastIndex];
      if (subSubId.indexOf("#") >= 0) {
          subIdArray[lastIndex] = null;
          var foundNode = DvtTreeAutomation._FindNode(this._treeView.getRootNode(), subIdArray, 1);
          if (foundNode) {
            if(subSubId == "#label") {
                str = foundNode.getLabel();
            } else if (subSubId == "#size") {
                str = foundNode.getSize();
            } else if (subSubId == "#color") {
                str = foundNode.getColor();
            } else if (subSubId == "#tooltip") {
                str = foundNode.getDatatip();
            }
          }
      }
    }
  }

  return str;
}

/**
    Find a node
 * @private
 */
DvtTreeAutomation._FindNode = function(node, path, pathArrayIndex) {
  var nodePath = node.getIndexInParent();
  var foundNode = null;
  if (nodePath == path[pathArrayIndex]) {
      if (path[pathArrayIndex+1] == null)
            foundNode = node;
      else {
          // Search children
          var children = node.getChildNodes();
          if(children) {
            for(var i=0; i<children.length; i++) {
              foundNode = DvtTreeAutomation._FindNode(children[i], path, pathArrayIndex + 1);
              if (foundNode)
                break;
            }
          }
      }
  }
  return foundNode;  
  
}

DvtTreeAutomation._convertSubIdToArray = function(subId)
{
  var array  = subId.split("\[");
    
  // Retrieve and remove the subSubid from the array
  var subSubId = DvtTreeAutomation._parseSubSubId(array);   

  var len =  array.length ;
  
  for (var i=1; i < len; i++)
  {
    var elem = array[i];
    var tempId = elem.substr(0, elem.length-1);   // remove trailing "]"
    tempIdAsNumber = parseFloat(tempId);
    tempId = isNaN(tempIdAsNumber) ? tempId : tempIdAsNumber ;
    array[i] = tempId;
  }

  if (subSubId)               // if a subSubId was found, add it to
  {                           // the end of the array
    array[len] = subSubId;
  }
    
  return array;
}

DvtTreeAutomation._parseSubSubId = function(array)
{
  var  sRet = null;

  if (array && array.length >= 0)
  {
    // Special case where subsubid is present

    var target  = array.length-1;
    var elem = array[target];           // get last entry in array
    var sepIdx  = elem.indexOf("#");

    if (sepIdx > 0)
    {
      array[target] = elem.substr(0, sepIdx);  // remove subSubId from array entry
    
      sRet = elem.substr(sepIdx);              // isolate the subSubId
    }
  }
    
  return sRet ;                                 // the subSubId
}

/*---------------------------------------------------------------------*/
/*  sendClickToQA()   Send the click event to the Javascript routine   */
/*                    supplied by setAutomation().                     */
/*---------------------------------------------------------------------*/

DvtTreeAutomation.prototype.sendClickToQA = function(evt)
{
 if (m_JSClickCallback != null && ExternalInterface)
     ExternalInterface.call(m_JSClickCallback, "") ;
}


/*---------------------------------------------------------------------*/
/*   setJSClickCallback()   Receives the name of a Javascript routine  */
/*                          to call on a click event/                  */
/*---------------------------------------------------------------------*/

DvtTreeAutomation.prototype.setJSClickCallback = function(JSClickCallback)
{
    m_JSClickCallback = JSClickCallback ;
}
/**
 * @constructor
 * Treemap component.
 * @param {DvtContext} context The rendering context.
 * @param {string} callback The function that should be called to dispatch component events.
 * @param {object} callbackObj The object context for the callback function
 * @class Treemap component.
 * @extends {DvtBaseTreeView}
 */
var DvtBaseTreemap = function(context, callback, callbackObj) {
  this.Init(context, callback, callbackObj);
}

// Make DvtBaseTreemap a subclass of DvtBaseTreeView
DvtObj.createSubclass(DvtBaseTreemap, DvtBaseTreeView, "DvtBaseTreemap");

// Layout and Style Constants
DvtBaseTreemap._BUFFER_SPACE = 7; // This is in addition to gap between groups
DvtBaseTreemap._MIN_BUFFER_SPACE = 2; // Minimum buffer for very small treemaps

DvtBaseTreemap._BACKGROUND_FILL_COLOR = "#EBEFF5";
DvtBaseTreemap._BACKGROUND_BORDER_COLOR = "#DBE0EA";

DvtBaseTreemap._BACKGROUND_INLINE_DEFAULT = "background-color:"+DvtBaseTreemap._BACKGROUND_FILL_COLOR+";"+
                                        "border-color:"+DvtBaseTreemap._BACKGROUND_BORDER_COLOR+";"+
                                        "border-width:2px";
                                        
/**
 * @override
 */
DvtBaseTreemap.prototype.Init = function(context, callback, callbackObj) {
  DvtBaseTreemap.superclass.Init.call(this, context, callback, callbackObj);
  
  // Create the defaults object
  this.Defaults = new DvtTreemapDefaults();
  
  // Do not antialias the treemap
  this.setPixelHinting(true);
}
                                        
/**
 * @override
 */
DvtBaseTreemap.prototype.Parse = function(xmlString) {
  var parser = new DvtTreemapParser(this);
  return parser.parse(xmlString);
}

/**
 * @override
 */
DvtBaseTreemap.prototype.ApplyParsedProperties = function(props) {
  DvtBaseTreemap.superclass.ApplyParsedProperties.call(this, props);
  
  // Layout and sorting
  this._layout = props.layout;
  this._groupGaps = props.groupGaps;
  
  if(this._layout) {
    this._layout.setSorting(this.Sorting);
  }
  
  // Isolate Support
  this._isolatedNodes = [];
  this._processInitialIsolate(props.isolateRowKey);
}

/**
 * @override
 */
DvtBaseTreemap.prototype.Layout = function(availSpace) {
  // Allocate buffer space for the container
  var bufferSpace = Math.max(Math.ceil(DvtBaseTreemap._BUFFER_SPACE * Math.min(availSpace.w, availSpace.h)/400), DvtBaseTreemap._MIN_BUFFER_SPACE);
  availSpace.x += bufferSpace;
  availSpace.y += bufferSpace;
  availSpace.w -= 2*bufferSpace;
  availSpace.h -= 2*bufferSpace;
  
  // Legend and Breadcrumbs
  // Add the additional buffer space for nodes to make the legend line up.
  var gap = this._layout.getGapSize(this, 1);
  availSpace.x += gap;
  availSpace.w -= 2*gap;
  this.LayoutBreadcrumbs(availSpace);
  this.LayoutLegend(availSpace);
  // Restore the gap for use by the nodes
  availSpace.x -= gap;
  availSpace.w += 2*gap;

  // Layout Algorithm: For a layout in response to isolate or restore, only re-layout the newly visible isolated node.  
  // Otherwise, layout the root, and then each isolated child in order.
  var numIsolated = this._isolatedNodes.length;
  if(numIsolated > 0 && this._isolateRestoreLayout) {
    // Isolate or Restore Action: Don't layout unchanged, since it would affect animation
    var lastIsolated = this._isolatedNodes[numIsolated - 1];
    this._layout.layout(this, lastIsolated, availSpace.x, availSpace.y, availSpace.w, availSpace.h, true);
  }
  else {
    // Standard Layout: Layer the isolated nodes so that they can be peeled back like a stack.
    if(this._root) 
      this._layout.layout(this, this._root, availSpace.x, availSpace.y, availSpace.w, availSpace.h, false);
    
    for(var i=0; i<numIsolated; i++) {
      var layoutRoot = this._isolatedNodes[i];
      this._layout.layout(this, layoutRoot, availSpace.x, availSpace.y, availSpace.w, availSpace.h, true);
    }
  }
}

/**
 * @override
 */
DvtBaseTreemap.prototype.Render = function(container, bounds) {
  // Background
  this.RenderBackground(container, DvtBaseTreemap._BACKGROUND_INLINE_DEFAULT);
  
  // Breadcrumbs
  this.RenderBreadcrumbs(container);
  
  // Legend
  this.RenderLegend(container);

  // Node or Empty Text
  if(this.HasValidData()) {
    // Layer for group text displayed on node.  Will be reordered after the selected layer
    this._groupTextLayer = new DvtContainer(this.getCtx());
    container.addChild(this._groupTextLayer); 
  
    // Render the nodes.  The root node is not rendered unless it's a singleton
    // This creates the shape objects, but does not render them yet.
    if(this._isolatedNode)
      this._isolatedNode.render(container);
    else if(!this._root.hasChildren())
      this._root.render(container);
    else
      this._root.renderChildren(container);
      
    // Create a group for isolated nodes
    this._isolatedLayer = new DvtContainer(this.getCtx());
    container.addChild(this._isolatedLayer);
    
    // Create a group for selected nodes
    this._selectedLayer = new DvtContainer(this.getCtx());
    container.addChild(this._selectedLayer);
    
    // Reorder group text after selected layer
    container.addChild(this._groupTextLayer); 
    
    // Prepare the hover effect
    this._hoverEffect = new DvtPolyline(this.getCtx(), new Array());
    this._hoverEffect.setVisible(false);
    this._hoverEffect.setMouseEnabled(false);
    container.addChild(this._hoverEffect);
    
    // Fix the z-order of the isolated objects
    for(var i=0; i<this._isolatedNodes.length; i++) {
      var displayable = this._isolatedNodes[i].getDisplayable();
      this._isolatedLayer.addChild(displayable);
    }
  }
  else {
    // Display the empty text message
    this.RenderEmptyText(container);
  }
}

/**
 * Hook for cleaning up animation behavior at the end of the animation.
 * @override
 */
DvtBaseTreemap.prototype.OnAnimationEnd = function() {
  // Before the animation, the treemap nodes will remove their bevels and selection
  // effects.  If the animation is complete (and not stopped), then rerender to restore.
  if(!this.AnimationStopped) {
    this._container.removeChildren();
    
    // Finally, re-layout and render the component
    var availSpace = new DvtRectangle(0, 0, this.Width, this.Height);
    this.Layout(availSpace); 
    this.Render(this._container);
    
    // Reselect the nodes using the selection handler's state
    this.ReselectNodes();
  }
  
  // Delegate to the superclass to clear common things
  DvtBaseTreemap.superclass.OnAnimationEnd.call(this);
}

/**
 * Reselects the selected nodes after a re-render.
 * @protected
 */
DvtBaseTreemap.prototype.ReselectNodes = function() {
  var selectedNodes = this._selectionHandler ? this._selectionHandler.getSelection() : new Array();
  for(var i=0; i<selectedNodes.length; i++) {
    // Don't show selection effect for obscured nodes when isolate is being used
    if(this._isolatedNodes.length > 0) {
      var lastIsolated = this._isolatedNodes[this._isolatedNodes.length - 1];
      if(selectedNodes[i] == lastIsolated || selectedNodes[i].isDescendantOf(lastIsolated))
        selectedNodes[i].setSelected(true);
    }
    else
      selectedNodes[i].setSelected(true);
  }
}

/**
 * @override
 */
DvtBaseTreemap.prototype.CreateKeyboardHandler = function (manager)
{
  return new DvtTreemapKeyboardHandler(manager);
}

/**
 * @override
 */
DvtBaseTreemap.prototype.CreateEventManager = function(view, context, callback, callbackObj)
{
  return new DvtTreemapEventManager(view, context, callback, callbackObj);
}

/**
 * @override
 */
DvtBaseTreemap.prototype.GetInitialFocusedItem = function(root)
{
  var isolatedRootNode = this.__getLastIsolatedNode();
  
  if(isolatedRootNode)
    return this.__getDefaultNavigable(isolatedRootNode.getLeafNodes());
  else if(root)
    return this.__getDefaultNavigable(root.getLeafNodes());
  else
    return null;
}

/**
 * Updates the hover effect to display the specified stroke along the specified points.
 * @param {array} points The array of points defining the polyline.
 * @param {DvtStroke} stroke The stroke definition.
 * @param {DvtTreemapNode} node The treemap node that this hover effect will belong to.
 */
DvtBaseTreemap.prototype.__showHoverEffect = function(points, stroke, node) {
  this._hoverEffect.setPoints(points);
  this._hoverEffect.setStroke(stroke);
  this._hoverEffect.setVisible(true);
}

/**
 * Hides the hover effect.
 */
DvtBaseTreemap.prototype.__hideHoverEffect = function() {
  this._hoverEffect.setVisible(false);
}

/**
 * Returns the layer for rendering group text displayed on nodes.  This layer is above the selected
 * layer, so that selected nodes will node obscure it.
 * @param {DvtContainer}
 */
DvtBaseTreemap.prototype.__getGroupTextLayer = function() {
  return this._groupTextLayer;
}

/**
 * Moves the specified object to the selected layer, above the non-selected objects.
 * @param {DvtRect} rect The object to be moved.
 */
DvtBaseTreemap.prototype.__moveToSelectedLayer = function(rect) {
  // Loop through the selected layer to find the right position
  var newIndex = 0;
  var numChildren = this._selectedLayer.getNumChildren();
  for(var i=0; i<numChildren; i++) {
    var child = this._selectedLayer.getChildAt(i);
    if(rect.zIndex > child.zIndex)
      newIndex = i+1;
  }
  
  // Add the object
  if(newIndex < numChildren)
    this._selectedLayer.addChildAt(rect, newIndex);
  else
    this._selectedLayer.addChild(rect);
}

/**
 * @override
 */
DvtBaseTreemap.prototype.__getNodeUnderPoint = function(x, y) {
  // For isolated nodes, search from the last isolated node
  if(this._isolatedNodes.length > 0) {
    var lastIsolated = this._isolatedNodes[this._isolatedNodes.length - 1];
    return lastIsolated.getNodeUnderPoint(x, y);
  }
  else
    return this._root.getNodeUnderPoint(x, y);
}

/**
 * Isolates the specified node.
 * @param {DvtBaseTreeNode} node The node to isolate.
 */
DvtBaseTreemap.prototype.__isolate = function(node) {
  var currentNavigable = this.__getEventManager().getFocus();
  if(currentNavigable)
    currentNavigable.hideKeyboardFocusEffect();

  // Keep track of the isolated node
  this._isolatedNodes.push(node);
  
  // Update state
  this.__dispatchEvent(new DvtTreemapIsolateEvent(node.getId()));
  
  // Layout the isolated node and its children
  this._isolateRestoreLayout = true;
  this.Layout(new DvtRectangle(0, 0, this.Width, this.Height));
  this._isolateRestoreLayout = false;
  
  // Update z-order
  var displayable = node.getDisplayable();
  this._isolatedLayer.addChild(displayable);
  
  // Render the changes
  this._renderIsolateRestore(node);
}

/**
 * Restores the full tree from the isolated state.
 */
DvtBaseTreemap.prototype.__restore = function() {
  var restoreNode = this._isolatedNodes.pop();
  
  var currentNavigable = this.__getEventManager().getFocus();
  if(currentNavigable)
    currentNavigable.hideKeyboardFocusEffect();
  
  // after we restore the full tree, set keyboard focus on the node that was previously isolated
  this.__setNavigableIdToFocus(restoreNode.getId());
  
  // Update state
  this.__dispatchEvent(new DvtTreemapIsolateEvent());
  
  // Layout the isolated node and its children
  this._isolateRestoreLayout = true;
  this.Layout(new DvtRectangle(0, 0, this.Width, this.Height)); 
  this._isolateRestoreLayout = false;
  
  // Render the changes
  this._renderIsolateRestore(restoreNode);
}

/**
 * Returns the currently isolated node, or null if no node is isolated
 * 
 * @return {DvtTreemapNode}
 */
DvtBaseTreemap.prototype.__getLastIsolatedNode = function()
{
  if(this._isolatedNodes && this._isolatedNodes.length > 0)
    return this._isolatedNodes[this._isolatedNodes.length-1];
  else
    return null;
}

/**
 * The node that was isolated or restored.
 * @param {DvtTreemapNode} node
 * @private
 */
DvtBaseTreemap.prototype._renderIsolateRestore = function(node) {
  // Animate or re-render to display the updated state
  if(this.AnimationOnDataChange) {
    // Deselect all nodes so that the selected layer doesn't display above the 
    // isolated node during animation.  Nodes will be reselected at the end of animation.
    var selectedNodes = this._selectionHandler ? this._selectionHandler.getSelection() : new Array();
    for(var i=0; i<selectedNodes.length; i++) {
      selectedNodes[i].setSelected(false);
    }
  
    // Animate the isolated node
    var playables = node.getIsolateAnimation();
    this.Animation = new DvtParallelPlayable(this.getCtx(), playables);
    this.Animation.setOnEnd(this.OnAnimationEnd, this); 
    
    // Disable event listeners temporarily
    this._eventHandler.removeListeners(this);
    
    // Start the animation
    this.Animation.play();
  }
  else {
    // Fix for 17562112: the true prevents the options object from being evaluated, so that the isolated node will not
    // be cleared.  This is necessary until we remove the xml layer, after which we can remove the true param.
    this.render(null, this.Width, this.Height, true); 
  }
}

/**
 * Processes the initially isolated node, if any.
 * @param {string} isolateRowKey The initially isolated node, if any.
 */
DvtBaseTreemap.prototype._processInitialIsolate = function(isolateRowKey) {
  if(isolateRowKey && this._root) {
    var allNodes = this._root.getDescendantNodes();
    allNodes.push(this._root);
    
    // Look through all the nodes for the isolated node
    for(var i=0; i<allNodes.length; i++) {
      if(allNodes[i].getId() == isolateRowKey) {
        this._isolatedNodes.push(allNodes[i]);
        return;
      }
    }
  }
}

/**
 * Returns whether gaps are displayed between groups.
 * @return {string} The types of groups for which gaps are displayed.
 */
DvtBaseTreemap.prototype.__getGroupGaps = function() {
  return this._groupGaps;
}

/**
 * Returns the default navigable item to receive keyboard focus. 
 * @param {Array} navigableItems An array of DvtNavigableItems that could receive keyboard focus
 * @return {DvtKeyboardNavigable}
 */
DvtBaseTreemap.prototype.__getDefaultNavigable = function(navigableItems)
{
  var keyboardHandler = this._eventHandler.getKeyboardHandler();
  if(keyboardHandler)
    return keyboardHandler.getDefaultNavigable(navigableItems);
  else if(navigableItems && navigableItems.length > 0)
    return navigableItems[0];
  else    
    return null;
}

DvtBaseTreemap.prototype.getShapesForViewSwitcher = function(bOld) {
  var shapes = {};
  if (this._root) {
    var arNodes = [this._root];
    while (arNodes.length > 0) {
      var node = arNodes.splice(0, 1)[0];
      var id = node.getId();
      var shape = node.getDisplayable();
      if (id && shape) {
        shapes[id] = shape;
        shapes[id + "_text"] = node._text;
        if (node._borderTL) {
          shapes[id + "_borderTL"] = node._borderTL;
        }
        if (node._borderBR) {
          shapes[id + "_borderBR"] = node._borderBR;
        }
        if (node._border) {
          shapes[id + "_border"] = node._border;
        }
        
        //flatten hierarchical structure of nodes so that they animate independently
        if (bOld) {
          var parentNode = node.GetParent();
          if (parentNode) {
            var parentShape = parentNode.getDisplayable();
            var parent = null;
            if (parentShape) {
              parent = parentShape.getParent();
            }
            else {
              parent = this._container;
            }
            if (parent) {
              //this will insert children in reverse z-order, but still after the parent node
              var childIndex = parent.getChildIndex(parentShape);
              if (node._border) {
                parent.addChildAt(node._border, childIndex + 1);
              }
              if (node._borderBR) {
                parent.addChildAt(node._borderBR, childIndex + 1);
              }
              if (node._borderTL) {
                parent.addChildAt(node._borderTL, childIndex + 1);
              }
              if (node._text) {
                parent.addChildAt(node._text, childIndex + 1);
              }
              parent.addChildAt(shape, childIndex + 1);
            }
          }
        }
      }
      
      var children = node.getChildNodes();
      if (children) {
        arNodes = arNodes.concat(children);
      }
    }
  }
  return shapes;
};
/**
 * Sunburst component.  This component should never be instantiated directly.  Use the
 * newInstance function instead.
 * @class
 * @constructor
 * @extends {DvtBaseTreemap}
 * @export
 */
var DvtTreemap = function() {}

DvtObj.createSubclass(DvtTreemap, DvtBaseTreemap, "DvtTreemap");

/**
 * Returns a new instance of DvtTreemap.
 * @param {DvtContext} context The rendering context.
 * @param {string} callback The function that should be called to dispatch component events.
 * @param {object} callbackObj The optional object instance on which the callback function is defined.
 * @return {DvtTreemap}
 * @export
 */
DvtTreemap.newInstance = function(context, callback, callbackObj) {
  var component = new DvtTreemap();
  component.Init(context, callback, callbackObj);
  return component;
}

/**
 * Returns a copy of the default options for the specified skin.
 * @param {string} skin The skin whose defaults are being returned.
 * @return {object} The object containing defaults for this component.
 * @export
 */
DvtTreemap.getDefaults = function(skin) 
{  
  return (new DvtTreemapDefaults()).getDefaults(skin);
}

/**
 * @override
 * @export
 */
DvtTreemap.prototype.render = function(options, width, height, bSkipXml) 
{  
  // Update if a new options object has been provided or initialize with defaults if needed.
  if(options) {
    this.Options = this.Defaults.calcOptions(options);
  
    // Disable animation for canvas and xml
    if (!DvtAgent.isEnvironmentBrowser()) {
      this.Options['animationOnDisplay']    = 'none';
      this.Options['animationOnDataChange'] = 'none';
    }
  }
  else if(!this.Options)
    this.Options = this.GetDefaults();
 
  // TODO: bSkipXml is needed for isolate/restore to prevent the XML from being resent to the component.  This can be
  // removed once the XML layer is removed.  See bug 17562112.
  // Convert the options object into XML
  var xmlString = bSkipXml ? null : (new DvtTreemapJsonUtils(this.getCtx())).toXml(this.Options);

  // Call superclass with the xmlString to render
  DvtTreemap.superclass.render.call(this, xmlString, width, height);
}
/**
 * Treemap XML Parser
 * @param {DvtSunburst} treemap The owning treemap component.
 * @class
 * @constructor
 * @extends {DvtBaseTreeParser}
 */
var DvtTreemapParser = function(treemap) {
  this.Init(treemap);
}

// Make DvtTreemapParser a subclass of DvtBaseTreeParser
DvtObj.createSubclass(DvtTreemapParser, DvtBaseTreeParser, "DvtTreemapParser");

// Top Level Attributes
DvtTreemapParser.ATTR_LAYOUT = "layout";
DvtTreemapParser.ATTR_GROUP_GAPS = "gg";
DvtTreemapParser.ATTR_ISOLATE_ROW_KEY = "irk";

// Top Level Attribute Values
DvtTreemapParser.LAYOUT_SQUARIFY = "s";
DvtTreemapParser.LAYOUT_SLICE_AND_DICE_HORIZ = "h";
DvtTreemapParser.LAYOUT_SLICE_AND_DICE_VERT = "v";

// Node Attributes
DvtTreemapParser.ATTR_GROUP_LABEL_DISPLAY = "gld";
DvtTreemapParser.ATTR_LABEL_H_ALIGN = "ha";
DvtTreemapParser.ATTR_LABEL_V_ALIGN = "va";
DvtTreemapParser.ATTR_HEADER_TITLE_H_ALIGN = "hha";
DvtTreemapParser.ATTR_HEADER_LABEL_STYLE = "hls";
DvtTreemapParser.ATTR_HEADER_ISOLATE = "hi";
DvtTreemapParser.ATTR_HEADER_USE_NODE_COLOR = "unc";

// Node Attribute Values
DvtTreemapParser.GROUP_GAPS_ALL = "a";
DvtTreemapParser.GROUP_GAPS_OUTER = "o";
DvtTreemapParser.GROUP_GAPS_NONE = "n";

/**
 * @override
 */
DvtTreemapParser.prototype.CreateNode = function(treeView, props, templates) {
  return new DvtTreemapNode(treeView, props, templates);
}

/**
 * @override
 */
DvtTreemapParser.prototype.ParseRootAttributes = function(xmlNode) {
  // The object that will be populated with parsed values and returned
  var ret = DvtTreemapParser.superclass.ParseRootAttributes.call(this, xmlNode);

  var layoutStr = xmlNode.getAttr(DvtTreemapParser.ATTR_LAYOUT);
  if(layoutStr == DvtTreemapParser.LAYOUT_SLICE_AND_DICE_HORIZ)
    ret.layout = new DvtSliceAndDiceLayout(true);
  else if(layoutStr == DvtTreemapParser.LAYOUT_SLICE_AND_DICE_VERT)
    ret.layout = new DvtSliceAndDiceLayout(false);
  else
    ret.layout = new DvtSquarifyingLayout();
    
  ret.groupGaps = xmlNode.getAttr(DvtTreemapParser.ATTR_GROUP_GAPS);
  if(!ret.groupGaps)
    ret.groupGaps = DvtTreemapParser.GROUP_GAPS_OUTER;
    
  // Store the isolated row key on the parser, for use when parsing nodes  
  ret.isolateRowKey = xmlNode.getAttr(DvtTreemapParser.ATTR_ISOLATE_ROW_KEY);
  this._isolateRowKey = ret.isolateRowKey;
  
  return ret;
}

/**
 * @override
 */
DvtTreemapParser.prototype.ParseNodeAttributes = function(xmlNode) {
  // The object that will be populated with parsed values and returned
  var ret = DvtTreemapParser.superclass.ParseNodeAttributes.call(this, xmlNode);
  
  // Parse this node's properties
  ret.groupLabelDisplay = xmlNode.getAttr(DvtTreemapParser.ATTR_GROUP_LABEL_DISPLAY);
  ret.labelHalign = xmlNode.getAttr(DvtTreemapParser.ATTR_LABEL_H_ALIGN);
  ret.labelValign = xmlNode.getAttr(DvtTreemapParser.ATTR_LABEL_V_ALIGN);
  ret.isolate = xmlNode.getAttr(DvtTreemapParser.ATTR_HEADER_ISOLATE);
  
  ret.headerUseNodeColor = xmlNode.getAttr(DvtTreemapParser.ATTR_HEADER_USE_NODE_COLOR);
  ret.headerHalign = xmlNode.getAttr(DvtTreemapParser.ATTR_HEADER_TITLE_H_ALIGN);
  var headerLabelStyle = xmlNode.getAttr(DvtTreemapParser.ATTR_HEADER_LABEL_STYLE);
  if(headerLabelStyle)
    ret.headerLabelStyle = new DvtCSSStyle(headerLabelStyle);
    
  // Initially isolated node support
  if(this._isolateRowKey == ret.id)
    ret.isIsolated = true;
  
  return ret;
}

/**
 * @override
 */
DvtTreemapParser.prototype.ParseAdditionalNodeStyles = function(nodeStyle, nodeHoverStyle, nodeSelectedStyle, styles) {
  styles[DvtTreemapNode.NODE_HOVER_COLOR_STYLE] = nodeHoverStyle.getStyle("border-color");
  styles[DvtTreemapNode.NODE_SELECTED_OUTER_COLOR_STYLE] = nodeSelectedStyle.getStyle(DvtCSSStyle.OUTER_COLOR);
  styles[DvtTreemapNode.NODE_SELECTED_INNER_COLOR_STYLE] = nodeSelectedStyle.getStyle(DvtCSSStyle.INNER_COLOR);
}

/**
 * @override
 */
DvtTreemapParser.prototype.ParseAdditionalStyles = function(xmlNode, styles) {
    var nodeHeaderStyle = new DvtCSSStyle(xmlNode.getAttr("nodeHeader"));
    styles[DvtTreemapNode.HEADER_TEXT_DEFAULT_STYLE] = nodeHeaderStyle;
    styles[DvtTreemapNode.HEADER_BACKGROUND_STYLE]= nodeHeaderStyle;

    var nodeHeaderHoverStyle = nodeHeaderStyle.clone().merge(new DvtCSSStyle(xmlNode.getAttr("nodeHeader-hover")));
    styles[DvtTreemapNode.HEADER_TEXT_HOVER_DEFAULT_STYLE] = nodeHeaderHoverStyle;
    styles[DvtTreemapNode.HEADER_BACKGROUND_HOVER_STYLE] = nodeHeaderHoverStyle;
    
    var nodeHeaderSelectedStyle = nodeHeaderStyle.clone().merge(new DvtCSSStyle(xmlNode.getAttr("nodeHeader-selected")));
    styles[DvtTreemapNode.HEADER_TEXT_SELECTED_DEFAULT_STYLE] = nodeHeaderSelectedStyle;
    styles[DvtTreemapNode.HEADER_BACKGROUND_SELECTED_STYLE] = nodeHeaderSelectedStyle;
    
    var nodeHeaderDrillStyle = nodeHeaderStyle.clone().merge(new DvtCSSStyle(xmlNode.getAttr("nodeHeaderDrill")));
    styles[DvtTreemapNode.HEADER_DRILL_TEXT_DEFAULT_STYLE] = nodeHeaderDrillStyle;
    styles[DvtTreemapNode.HEADER_DRILL_TEXT_HOVER_DEFAULT_STYLE] = nodeHeaderDrillStyle.clone().merge(new DvtCSSStyle(xmlNode.getAttr("nodeHeaderDrill-hover")));
    styles[DvtTreemapNode.HEADER_DRILL_TEXT_SELECTED_DEFAULT_STYLE] = nodeHeaderDrillStyle.clone().merge(new DvtCSSStyle(xmlNode.getAttr("nodeHeaderDrill-selected")));

    styles[DvtTreemapNode.HEADER_HOVER_OUTER_COLOR_STYLE] = nodeHeaderHoverStyle.getStyle(DvtCSSStyle.OUTER_COLOR);
    styles[DvtTreemapNode.HEADER_HOVER_INNER_COLOR_STYLE] = nodeHeaderHoverStyle.getStyle(DvtCSSStyle.INNER_COLOR);
    styles[DvtTreemapNode.HEADER_SELECTED_OUTER_COLOR_STYLE] = nodeHeaderSelectedStyle.getStyle(DvtCSSStyle.OUTER_COLOR);
    styles[DvtTreemapNode.HEADER_SELECTED_INNER_COLOR_STYLE] = nodeHeaderSelectedStyle.getStyle(DvtCSSStyle.INNER_COLOR);
}
/**
 * Class representing a treemap node.
 * @param {DvtTreemap} treemap The owning treemap component.
 * @param {object} props The properties for the node.
 * @class 
 * @constructor
 * @extends {DvtBaseTreeNode}
 * @implements {DvtKeyboardNavigable}
 */
var DvtTreemapNode = function (treemap, props, templates) {
  this.Init(treemap, props, templates);

  this._labelDisplay = props.labelDisplay ? props.labelDisplay : DvtTreemapNode.DEFAULT_LABEL_DISPLAY;
  this._groupLabelDisplay = props.groupLabelDisplay ? props.groupLabelDisplay : DvtTreemapNode.DEFAULT_GROUP_LABEL_DISPLAY;
  this._labelHalign = props.labelHalign ? props.labelHalign : DvtTreemapNode.DEFAULT_NODE_H_ALIGN;
  this._labelValign = props.labelValign ? props.labelValign : DvtTreemapNode.DEFAULT_NODE_V_ALIGN;
  this._headerHalign = props.headerHalign ? props.headerHalign : DvtTreemapNode.DEFAULT_HEADER_H_ALIGN;
  this._headerLabelStyle = props.headerLabelStyle;
  this._headerUseNodeColor = props.headerUseNodeColor == "on";
  
  this._isolate = props.isolate ? props.isolate : "on";
  this._isIsolated = props.isIsolated;
}

// Make DvtTreemapNode a subclass of DvtBaseTreeNode
DvtObj.createSubclass(DvtTreemapNode, DvtBaseTreeNode, "DvtTreemapNode");

// Text style options
DvtTreemapNode.TEXT_STYLE_HEADER = "h";
DvtTreemapNode.TEXT_STYLE_NODE = "n";
DvtTreemapNode.TEXT_STYLE_OFF  = "o";
DvtTreemapNode.DEFAULT_LABEL_DISPLAY = DvtTreemapNode.TEXT_STYLE_NODE;
DvtTreemapNode.DEFAULT_GROUP_LABEL_DISPLAY = DvtTreemapNode.TEXT_STYLE_HEADER;

DvtTreemapNode.LABEL_ALIGN_CENTER = "c";
DvtTreemapNode.LABEL_ALIGN_START  = "s";
DvtTreemapNode.LABEL_ALIGN_END    = "e";
DvtTreemapNode.LABEL_ALIGN_TOP    = "t";
DvtTreemapNode.LABEL_ALIGN_BOTTOM = "b";
DvtTreemapNode.DEFAULT_NODE_H_ALIGN = DvtTreemapNode.LABEL_ALIGN_CENTER;
DvtTreemapNode.DEFAULT_NODE_V_ALIGN = DvtTreemapNode.LABEL_ALIGN_CENTER;
DvtTreemapNode.DEFAULT_HEADER_H_ALIGN = DvtTreemapNode.LABEL_ALIGN_START;

// Constants for All Nodes
DvtTreemapNode._DEFAULT_HEADER_TEXT_COLOR = "#003D5B";
DvtTreemapNode._HEADER_DRILLABLE_TEXT_COLOR = "#003286";
DvtTreemapNode._HEADER_HOVER_TEXT_COLOR = "#000000";
DvtTreemapNode._HEADER_SELECTED_TEXT_COLOR = DvtTreemapNode._DEFAULT_HEADER_TEXT_COLOR;
DvtTreemapNode._HEADER_TEXT_STYLE = "font-weight:bold;";

DvtTreemapNode.TEXT_BUFFER_HORIZ = 4; // Buffer for text alignment
DvtTreemapNode.TEXT_BUFFER_VERT = 2; // Buffer for text alignment
DvtTreemapNode.MIN_TEXT_BUFFER = 2; // Minimum buffer for text (on opposite side of alignment for example)

DvtTreemapNode._LINE_FUDGE_FACTOR = 1;

DvtTreemapNode._ANIMATION_ISOLATE_DURATION = 0.3; // in seconds

// Constants for Group Headers
DvtTreemapNode._MIN_TITLE_BAR_HEIGHT = 15; 
DvtTreemapNode._MIN_TITLE_BAR_HEIGHT_ISOLATE = 15;
DvtTreemapNode.DEFAULT_HEADER_FILL_COLOR = "#FFFFFF";
DvtTreemapNode.DEFAULT_HEADER_BORDER_COLOR = "#E1E6EE";
DvtTreemapNode.DEFAULT_HEADER_BORDER_WIDTH = 1;
DvtTreemapNode.DEFAULT_HEADER_WITH_NODE_COLOR_ALPHA = 0.5;
DvtTreemapNode._ISOLATE_ICON_SIZE = 12;
DvtTreemapNode._ISOLATE_GAP_SIZE = 1;
DvtTreemapNode._ISOLATE_TOUCH_BUFFER = 2;

DvtTreemapNode.DEFAULT_HEADER_INLINE_STYLE =    "background-color:"+DvtTreemapNode.DEFAULT_HEADER_FILL_COLOR+";"+
                                                "border-color:"+DvtTreemapNode.DEFAULT_HEADER_BORDER_COLOR+";"+
                                                "border-width:"+DvtTreemapNode.DEFAULT_HEADER_BORDER_WIDTH+"px";

// Constants for Leaf Nodes
DvtTreemapNode.DEFAULT_NODE_TOP_BORDER_COLOR = "#FFFFFF";
DvtTreemapNode.DEFAULT_NODE_BOTTOM_BORDER_COLOR = "#000000";
DvtTreemapNode.DEFAULT_NODE_BORDER_WIDTH = 1;
DvtTreemapNode.DEFAULT_NODE_BORDER_OPACITY = 0.3;
DvtTreemapNode.DEFAULT_NODE_PATTERN_BORDER_OPACITY = 0.15;

DvtTreemapNode.MIN_SIZE_FOR_BORDER = 2*DvtTreemapNode.DEFAULT_NODE_BORDER_WIDTH;

// Constants for Selection Effects
DvtTreemapNode.HEADER_HOVER_FILL_COLOR = "#C4DCFF";
DvtTreemapNode.DEFAULT_HEADER_HOVER_INLINE_STYLE =    "background-color:"+DvtTreemapNode.HEADER_HOVER_FILL_COLOR+";";
DvtTreemapNode.HEADER_SELECTED_FILL_COLOR = "#9CACC9";
DvtTreemapNode.DEFAULT_HEADER_SELECTED_INLINE_STYLE =    "background-color:"+DvtTreemapNode.HEADER_SELECTED_FILL_COLOR+";";

DvtTreemapNode.GROUP_HOVER_OUTER_COLOR    = "#00AEFF";
DvtTreemapNode.GROUP_HOVER_OUTER_OPACITY  = "1";
DvtTreemapNode.GROUP_HOVER_INNER_COLOR = "#C4DCFF";
DvtTreemapNode.GROUP_HOVER_INNER_OPACITY = 0.8;
DvtTreemapNode.GROUP_HOVER_INNER_WIDTH = 3;
DvtTreemapNode.GROUP_SELECTED_OUTER_COLOR = "#000000";
DvtTreemapNode.GROUP_SELECTED_INNER_COLOR = "#FFFFFF";
DvtTreemapNode.GROUP_SELECTED_OPACITY = 1;

DvtTreemapNode.NODE_HOVER_COLOR = "#FFFFFF";
DvtTreemapNode.NODE_HOVER_OPACITY = 1.0;
DvtTreemapNode.NODE_SELECTED_OUTER_COLOR = "#000000";
DvtTreemapNode.NODE_SELECTED_OUTER_OPACITY = 1.0;
DvtTreemapNode.NODE_SELECTED_INNER_COLOR = "#FFFFFF";
DvtTreemapNode.NODE_SELECTED_INNER_OPACITY = 1.0;
DvtTreemapNode.NODE_SELECTION_WIDTH = 2;

// Style keys
DvtTreemapNode.NODE_HOVER_COLOR_STYLE = "NODE_HOVER_COLOR";
DvtTreemapNode.NODE_SELECTED_OUTER_COLOR_STYLE = "NODE_SELECTED_OUTER_COLOR";
DvtTreemapNode.NODE_SELECTED_INNER_COLOR_STYLE = "NODE_SELECTED_INNER_COLOR";

DvtTreemapNode.HEADER_TEXT_DEFAULT_STYLE = "HEADER_TEXT_DEFAULT_STYLE";
DvtTreemapNode.HEADER_TEXT_HOVER_DEFAULT_STYLE = "HEADER_TEXT_HOVER_DEFAULT_STYLE";
DvtTreemapNode.HEADER_TEXT_SELECTED_DEFAULT_STYLE = "HEADER_TEXT_SELECTED_DEFAULT_STYLE";

DvtTreemapNode.HEADER_DRILL_TEXT_DEFAULT_STYLE = "HEADER_DRILL_TEXT_DEFAULT_STYLE";
DvtTreemapNode.HEADER_DRILL_TEXT_HOVER_DEFAULT_STYLE = "HEADER_DRILL_TEXT_HOVER_DEFAULT_STYLE";
DvtTreemapNode.HEADER_DRILL_TEXT_SELECTED_DEFAULT_STYLE = "HEADER_DRILL_TEXT_SELECTED_DEFAULT_STYLE";

DvtTreemapNode.HEADER_BACKGROUND_STYLE = "HEADER_BACKGROUND_STYLE";
DvtTreemapNode.HEADER_BACKGROUND_HOVER_STYLE = "HEADER_BACKGROUND_HOVER_STYLE";
DvtTreemapNode.HEADER_BACKGROUND_SELECTED_STYLE = "HEADER_BACKGROUND_SELECTED_STYLE";

DvtTreemapNode.HEADER_HOVER_OUTER_COLOR_STYLE = "HEADER_HOVER_OUTER_COLOR_STYLE";
DvtTreemapNode.HEADER_HOVER_INNER_COLOR_STYLE = "HEADER_HOVER_INNER_COLOR_STYLE";
DvtTreemapNode.HEADER_SELECTED_OUTER_COLOR_STYLE = "HEADER_SELECTED_OUTER_COLOR_STYLE";
DvtTreemapNode.HEADER_SELECTED_INNER_COLOR_STYLE = "HEADER_SELECTED_INNER_COLOR_STYLE";

DvtTreemapNode.LEAF_NODE_TOP_BORDER_COLOR_STYLE = "LEAF_NODE_TOP_BORDER_COLOR_STYLE";
DvtTreemapNode.LEAF_NODE_BOTTOM_BORDER_COLOR_STYLE = "LEAF_NODE_BOTTOM_BORDER_COLOR_STYLE";


//**************** Begin Overridden Functions ***************//

/**
 * @override
 */
DvtTreemapNode.prototype.render = function(container) {
  // If not positioned, don't render
  if (!this._hasLayout)
    return;
    
  // Create the shape object
  this._shape = this._createShapeNode();
  container.addChild(this._shape);

  var template;

  if(this.hasChildren()) {
    // Create the container for the children and render
    this._childNodeGroup = new DvtContainer(this.getView().getCtx());
    this._shape.addChild(this._childNodeGroup);
    this.renderChildren(this._childNodeGroup);
  } 
  else {
    template = this.GetTemplate();
  }

  // if content facet exists, added the content to treeNode
  if (template) {
    var elAttrs = this.GetElAttributes();
    var afContext = this.GetAfContext();
    afContext.setELContext(elAttrs);

    //TODO fudge factor and tree node border?
    var bw = DvtTreemapNode.DEFAULT_NODE_BORDER_WIDTH + DvtTreemapNode._LINE_FUDGE_FACTOR;
    var marginx = DvtTreemapNode.TEXT_BUFFER_HORIZ;
    var marginy = DvtTreemapNode.TEXT_BUFFER_VERT;

    var aw = this._width - 2 * marginx - bw;
    var ah = this._height - 2 * marginy - bw;

    if (aw > 0 && ah > 0) {
      afContext.setAvailableWidth(aw);
      afContext.setAvailableHeight(ah);
      afContext.setFontSize(this.GetTextSize());
//     this._contentRoot = DvtAfComponentFactory.parseAndStamp(afContext, template, this._shape);

      var afRoot = DvtAfComponentFactory.parseAndLayout(afContext, template, this._shape);
      this._contentRoot = afRoot;
      
      var transX;
      if (DvtAgent.isRightToLeft(container.getCtx())) {
        var dim = afRoot.getDimensions();
        transX = this._x + this._width - marginx - .5 * bw - dim.w;
      }
      else {
        transX = this._x + marginx + .5 * bw;
      }
      afRoot.setTranslate(transX, this._y + marginy + .5 * bw);
    }
  }
  else {
    // Create the text object
    this._text = this._createTextNode(this._shape);
    if(this._text != null) {  
      // For pattern nodes, add a background to make the text readable
      if(this._pattern && this._textStyle != DvtTreemapNode.TEXT_STYLE_HEADER) {
        var dims = this._text.measureDimensions();
        this._textBackground = new DvtRect(this.getView().getCtx(), dims.x, dims.y, dims.w, dims.h);
        this._textBackground.setSolidFill("#FFFFFF");
        this._textBackground.setMouseEnabled(false);
        this._shape.addChild(this._textBackground);
        
        // Reorder the text in front of the background rect
        this._addChildText(this._text);
      }
    }
  }
  
  // WAI-ARIA
  this._shape.setAriaRole('img');
  this._shape.setAriaProperty('label', this._datatip);
}

/**
 * @override
 */
DvtTreemapNode.prototype.setSelected = function(selected) {
  if(this.Selectable == "off")
    return;
    
  // Delegate to super to store the state
  DvtTreemapNode.superclass.setSelected.call(this, selected);
  
  // If the node isn't displayed, return
  if(!this._shape)
    return;
  
  if(this.isSelected()) {    
    // Calculate the bounds for the selection effect
    var x = this._x;
    var y = this._y + DvtTreemapNode._LINE_FUDGE_FACTOR;
    var w = this._width - DvtTreemapNode._LINE_FUDGE_FACTOR;
    var h = this._height - DvtTreemapNode._LINE_FUDGE_FACTOR;
    
    // Workaround for different pixel drawing behavior between browsers
    if(DvtAgent.isPlatformWebkit()) 
     y -= DvtTreemapNode._LINE_FUDGE_FACTOR;
    
    // Clear the selection inner and outer, which may be used by hover
    this._removeChildShape(this._selectionOuter);
    this._removeChildShape(this._selectionInner);
    this._selectionOuter = null;
    this._selectionInner = null;
    
    // Create the shapes, the fill will be set based on node type
    this._selectionOuter = new DvtRect(this.getView().getCtx(), x, y, w, h);
    this._selectionOuter.setMouseEnabled(false);       
    this._selectionOuter.setFill(null);
    this._shape.addChild(this._selectionOuter); 
    
    this._selectionInner = new DvtRect(this.getView().getCtx(), x+1, y+1, w-2, h-2);
    this._selectionInner.setMouseEnabled(false);      
    this._selectionInner.setFill(null);
    this._shape.addChild(this._selectionInner); 
  
    if(this._textStyle == DvtTreemapNode.TEXT_STYLE_HEADER) 
    {
      // Apply the selection effect to the header
      if(this.IsHover || this.isShowingKeyboardFocusEffect())
        this.ApplyHeaderStyle(this._shape, DvtTreemapNode.DEFAULT_HEADER_HOVER_INLINE_STYLE, DvtTreemapNode.HEADER_BACKGROUND_HOVER_STYLE);
      else {
        this.ApplyHeaderStyle(this._shape, DvtTreemapNode.DEFAULT_HEADER_SELECTED_INLINE_STYLE, DvtTreemapNode.HEADER_BACKGROUND_SELECTED_STYLE);
        // Update the text color
        if(this._text) {
          this.ApplyHeaderTextStyle(this._text, DvtTreemapNode.HEADER_TEXT_SELECTED_DEFAULT_STYLE, DvtTreemapNode._HEADER_SELECTED_TEXT_COLOR);
        }
      }
      // Apply the right LAF
      this._selectionOuter.setSolidStroke(this.getResolvedColor(DvtTreemapNode.GROUP_SELECTED_OUTER_COLOR, DvtTreemapNode.HEADER_SELECTED_OUTER_COLOR_STYLE), DvtTreemapNode.GROUP_SELECTED_OPACITY);
      this._selectionInner.setSolidStroke(this.getResolvedColor(DvtTreemapNode.GROUP_SELECTED_INNER_COLOR, DvtTreemapNode.HEADER_SELECTED_INNER_COLOR_STYLE), DvtTreemapNode.GROUP_SELECTED_OPACITY);
    }
    else {
      // Apply the right LAF
      this._selectionOuter.setSolidStroke(this.getResolvedColor(DvtTreemapNode.NODE_SELECTED_OUTER_COLOR, DvtTreemapNode.NODE_SELECTED_OUTER_COLOR_STYLE), DvtTreemapNode.NODE_SELECTED_OUTER_OPACITY);
      this._selectionInner.setSolidStroke(this.getResolvedColor(DvtTreemapNode.NODE_SELECTED_INNER_COLOR, DvtTreemapNode.NODE_SELECTED_INNER_COLOR_STYLE), DvtTreemapNode.NODE_SELECTED_INNER_OPACITY);
      
      // Also apply the shadow.  Use a clone since the object is static and may be used elsewhere in the page.
      if(!DvtAgent.isBrowserSafari()) { //bug 15875065 -- filter is supported in Safari 6. but causes errors
        this._shape.addDrawEffect(DvtBaseTreeNode.__NODE_SELECTED_SHADOW);
      }

      // Hide the bevel effects
      if(this._borderTL)
        this._borderTL.setVisible(false);
      if(this._borderBR)
        this._borderBR.setVisible(false);
      
      // Move to the front of the z-order
      this.getView().__moveToSelectedLayer(this._shape);
    }
  }
  else { // !selected
    // Restore the regular effect to the shape    
    this._removeChildShape(this._selectionInner);
    this._selectionInner = null;
    
    if(this._textStyle == DvtTreemapNode.TEXT_STYLE_HEADER) 
    {
      // If this is a node with header, adjust it
      if(this.IsHover || this.isShowingKeyboardFocusEffect())
        this.ApplyHeaderStyle(this._shape, DvtTreemapNode.DEFAULT_HEADER_HOVER_INLINE_STYLE, DvtTreemapNode.HEADER_BACKGROUND_HOVER_STYLE);
      else {
        this.ApplyHeaderStyle(this._shape, DvtTreemapNode.DEFAULT_HEADER_INLINE_STYLE, DvtTreemapNode.HEADER_BACKGROUND_STYLE);
        // Restore the text color
        if(this._text) {
          if(this.isDrillReplaceEnabled()) 
            this.ApplyHeaderTextStyle(this._text, DvtTreemapNode.HEADER_TEXT_DEFAULT_STYLE, DvtTreemapNode._HEADER_DRILLABLE_TEXT_COLOR);
          else
            this.ApplyHeaderTextStyle(this._text, DvtTreemapNode.HEADER_TEXT_DEFAULT_STYLE, DvtTreemapNode._DEFAULT_HEADER_TEXT_COLOR);
        }
      }
      if(this._selectionOuter) {
        if(this.IsHover || this.isShowingKeyboardFocusEffect())
          this._selectionOuter.setSolidStroke(this.getResolvedColor(DvtTreemapNode.GROUP_HOVER_OUTER_COLOR, DvtTreemapNode.HEADER_HOVER_OUTER_COLOR_STYLE), DvtTreemapNode.GROUP_HOVER_OUTER_OPACITY);
        else {
          this._removeChildShape(this._selectionOuter);
          this._selectionOuter = null;
        }
      }  
    }
    else { // leaf node
      
      // Remove the selection effects on this node
      this._shape.removeAllDrawEffects();
      if(this._selectionOuter) {
        this._removeChildShape(this._selectionOuter);
        this._selectionOuter = null;
      }
      
      // Restore the element back to its original location under its parent node
      var parentNode = this.GetParent();
      if(parentNode && parentNode._childNodeGroup) {
        // The exact z-order doesn't matter, since only the selected nodes have effects
        // that overflow into surrounding nodes.
        parentNode._childNodeGroup.addChild(this._shape);
      }
    }
    
    // Restore the bevel effects
    if(this._borderTL)
      this._borderTL.setVisible(true);
    if(this._borderBR)
      this._borderBR.setVisible(true);
  }
}

/**
 * @override
 */
DvtTreemapNode.prototype.showHoverEffect = function() {
  if(!this._shape || !this._hasLayout)
    return;
    
  // Fix for 16563380: Do not show the hover effect if the node is not within the isolated subtree.  When a child of an
  // isolated node is selected, it is move to the front of the z-order.  During this move, the node behind it will
  // recieve a mouseOver event, which we should not show a hover effect for.
  var isolatedNode = this._view.__getLastIsolatedNode();
  if(isolatedNode != null && isolatedNode != this && !this.isDescendantOf(isolatedNode))
    return;
  
  // Prepare the array of points and stroke for the hover effect
  var points = new Array();
  var stroke;
  var x1, y1, x2, y2;
  if (this._textStyle == DvtTreemapNode.TEXT_STYLE_HEADER) 
  {
    // Apply the hover effect to the header
    this.ApplyHeaderStyle(this._shape, DvtTreemapNode.DEFAULT_HEADER_HOVER_INLINE_STYLE, DvtTreemapNode.HEADER_BACKGROUND_HOVER_STYLE);
    
    // Apply the outer hover effect border
    if(!this._selectionOuter) { 
      // If the outer effect doesn't exist, create it
      var x = this._x;
      var y = this._y + DvtTreemapNode._LINE_FUDGE_FACTOR;
      var w = this._width - DvtTreemapNode._LINE_FUDGE_FACTOR;
      var h = this._height - DvtTreemapNode._LINE_FUDGE_FACTOR;
      
      // Workaround for different pixel drawing behavior between browsers
      if(DvtAgent.isPlatformWebkit()) 
       y -= DvtTreemapNode._LINE_FUDGE_FACTOR;
      
      this._selectionOuter = new DvtRect(this.getView().getCtx(), x, y, w, h);
      this._selectionOuter.setMouseEnabled(false);
      this._selectionOuter.setFill(null);
      this._shape.addChild(this._selectionOuter);
    }
    
    // Apply the formatting based on selection
    if(this.isSelected())
      this._selectionOuter.setSolidStroke(this.getResolvedColor(DvtTreemapNode.GROUP_SELECTED_OUTER_COLOR, DvtTreemapNode.HEADER_SELECTED_OUTER_COLOR_STYLE), DvtTreemapNode.GROUP_SELECTED_OUTER_OPACITY);
    else
      this._selectionOuter.setSolidStroke(this.getResolvedColor(DvtTreemapNode.GROUP_HOVER_OUTER_COLOR, DvtTreemapNode.HEADER_HOVER_OUTER_COLOR_STYLE), DvtTreemapNode.GROUP_HOVER_OUTER_OPACITY);
  
    // Apply the hover effect to the group contents
    x1 = this._x + DvtTreemapNode.GROUP_HOVER_INNER_WIDTH/2 + DvtTreemapNode._LINE_FUDGE_FACTOR;
    x2 = this._x + this._width - DvtTreemapNode.GROUP_HOVER_INNER_WIDTH/2 - DvtTreemapNode._LINE_FUDGE_FACTOR; 
    y1 = this._y + this._titleBarHeight;
    y2 = this._y + this._height - DvtTreemapNode.GROUP_HOVER_INNER_WIDTH/2 - DvtTreemapNode._LINE_FUDGE_FACTOR;    
    points.push(x2, y1, x2, y2, x1, y2, x1, y1);                 
    stroke = new DvtSolidStroke(this.getResolvedColor(DvtTreemapNode.GROUP_HOVER_INNER_COLOR, DvtTreemapNode.HEADER_HOVER_INNER_COLOR_STYLE), DvtTreemapNode.GROUP_HOVER_INNER_OPACITY, DvtTreemapNode.GROUP_HOVER_INNER_WIDTH); 
    
    // Update the text color
    if(this._text) {
      if (this.isDrillReplaceEnabled())
        this.ApplyHeaderTextStyle(this._text, DvtTreemapNode.HEADER_DRILL_TEXT_HOVER_DEFAULT_STYLE, DvtTreemapNode._HEADER_HOVER_TEXT_COLOR);
      else
        this.ApplyHeaderTextStyle(this._text, DvtTreemapNode.HEADER_TEXT_HOVER_DEFAULT_STYLE, DvtTreemapNode._HEADER_HOVER_TEXT_COLOR);
    }
  }
  else 
  {
    x1 = this._x + DvtTreemapNode.NODE_SELECTION_WIDTH/2;
    x2 = this._x + this._width - DvtTreemapNode.NODE_SELECTION_WIDTH/2;
    y1 = this._y + DvtTreemapNode.NODE_SELECTION_WIDTH/2;
    y2 = this._y + this._height - DvtTreemapNode.NODE_SELECTION_WIDTH/2;
    
    // Need to start at the right coord, this._x, because of the line end miter
    points.push(this._x, y1, x2, y1, x2, y2, x1, y2, x1, y1);                        
    stroke = new DvtSolidStroke(this.getResolvedColor(DvtTreemapNode.NODE_HOVER_COLOR, DvtTreemapNode.NODE_HOVER_COLOR_STYLE), DvtTreemapNode.NODE_HOVER_OPACITY, DvtTreemapNode.NODE_SELECTION_WIDTH);
  }
 
  // Apply and show the effect
  this.getView().__showHoverEffect(points, stroke, this);
}

/**
 * @override
 */
DvtTreemapNode.prototype.hideHoverEffect = function() {
  if(!this._shape || !this._hasLayout)
    return;
    
  // Remove the hover effect from the header
  if(this._textStyle == DvtTreemapNode.TEXT_STYLE_HEADER) {
    if(this.isSelected()) {
      this.ApplyHeaderStyle(this._shape, DvtTreemapNode.DEFAULT_HEADER_SELECTED_INLINE_STYLE, DvtTreemapNode.HEADER_BACKGROUND_SELECTED_STYLE);
      this._selectionOuter.setSolidStroke(this.getResolvedColor(DvtTreemapNode.GROUP_SELECTED_OUTER_COLOR, DvtTreemapNode.HEADER_SELECTED_OUTER_COLOR_STYLE), DvtTreemapNode.GROUP_SELECTED_OUTER_OPACITY);
      // Update the text color
      if(this._text) {
        if (this.isDrillReplaceEnabled())
          this.ApplyHeaderTextStyle(this._text, DvtTreemapNode.HEADER_DRILL_TEXT_SELECTED_DEFAULT_STYLE, DvtTreemapNode._HEADER_SELECTED_TEXT_COLOR);
        else
          this.ApplyHeaderTextStyle(this._text, DvtTreemapNode.HEADER_TEXT_SELECTED_DEFAULT_STYLE, DvtTreemapNode._HEADER_SELECTED_TEXT_COLOR);
      }
    }
    else {
      this.ApplyHeaderStyle(this._shape, DvtTreemapNode.DEFAULT_HEADER_INLINE_STYLE, DvtTreemapNode.HEADER_BACKGROUND_STYLE);
      if(this._selectionOuter) {
        this._shape.removeChild(this._selectionOuter);    
        this._selectionOuter = null;
      }
      // Restore the text color
      if(this._text) {
        if (this.isDrillReplaceEnabled())
          this.ApplyHeaderTextStyle(this._text, DvtTreemapNode.HEADER_DRILL_TEXT_DEFAULT_STYLE, DvtTreemapNode._HEADER_DRILLABLE_TEXT_COLOR);
        else
          this.ApplyHeaderTextStyle(this._text, DvtTreemapNode.HEADER_TEXT_DEFAULT_STYLE, DvtTreemapNode._DEFAULT_HEADER_TEXT_COLOR);
      }
    }
  }

  this.getView().__hideHoverEffect();
}

/**
 * Returns true if isolate is enabled for this node.
 * @return {boolean}
 */
DvtTreemapNode.prototype.isIsolateEnabled = function() {
  return this._isolate == "on" && this._textStyle == DvtTreemapNode.TEXT_STYLE_HEADER;
}

/**
 * @override
 */
DvtTreemapNode.prototype.getPopupBounds = function(behavior) {
  // If not specified or if no align provided, defer to default behavior
  if(!behavior || !behavior.getAlign())
    return DvtTreemapNode.superclass.getPopupBounds.call(this, behavior);
    
  // Otherwise align to the node  
  return new DvtRectangle(this._x, this._y, this._width, this._height);
}


/**
 * @override
 */
DvtTreemapNode.prototype.getNextNavigable = function(event) 
{
  var keyCode;
  var parent;
  var lastChild;
  var next;

  if(event.type == DvtMouseEvent.CLICK)
  {
    return DvtTreemapNode.superclass.getNextNavigable.call(this, event);
  }
 
  keyCode = event.keyCode; 
  
  if(keyCode == DvtKeyboardEvent.SPACE && event.ctrlKey)
  {
    // multi-select node with current focus; so we navigate to ourself and then let the selection handler take
    // care of the selection
    return this;
  }

  // if alt held, or a bracket, move focus up or down one level in tree 
  if( (keyCode == DvtKeyboardEvent.UP_ARROW && event.altKey) || keyCode == DvtKeyboardEvent.CLOSE_BRACKET )
  {
    // move up one level in the tree
    parent = this.GetParent();
    
    // we can move up one level if the parent is not the current root
    if( parent && (parent.getId() != this.getView().getRootNode().getId()) )
    {          
      next = parent;

      // update the grandparent's last visited child to be the current node's parent
      // updating the parent's (i.e. next node's) last visited child to point to the current node is 
      // done at the end of this sequence of if, else-if statements      
      parent.MarkAsLastVisitedChild();
    }
    else
    {
      next = this;
    }
  } 
  else if( (keyCode == DvtKeyboardEvent.DOWN_ARROW && event.altKey) || keyCode == DvtKeyboardEvent.OPEN_BRACKET )
  {
    // move down one level in the tree    
    lastChild = this.GetLastVisitedChild();
    if(lastChild)
    {
      next = lastChild;
    }
    else if(this.hasChildren())
    {
      next = this.getView().__getDefaultNavigable(this.getChildNodes());
    }
    else // leaf node
    {
      next = this;
    }
  }
  else 
  {
    // otherwise, stay in the same level
    var root = this.getView().__getLastIsolatedNode();
    var depth = 0;

    if(root)
    {
      // We have isolated a treemap node, so make sure we only consider the nodes currently being displayed.
      // Isolated nodes are rendered on top of the other nodes in the treemap, so we have to exclude the
      // other non-visible nodes in the treemap when navigating through an isolated node.
    
      // Find the depth of the current node from the isolated node  
      if (this == root)
      {
        depth = 0;
      }
      else 
      {
        var parent = this.GetParent();
        depth = 1;
        while(root != parent)
        {
          depth++;
          parent = parent.GetParent();
        }
      }
    }
    else
    {
      root = this;
      while(root.GetParent())
      {
        root = root.GetParent();
      }

      depth = this.GetDepth();
    }

    var navigables = this.GetNodesAtDepth(root, depth);
    next = DvtKeyboardHandler.getNextNavigable(this, event, navigables);
  }
     
  next.MarkAsLastVisitedChild();

  return next;
};


/**
 * @override 
 */
DvtTreemapNode.prototype.getKeyboardBoundingBox = function() 
{
  return new DvtRectangle(this._x, this._y, this._width, this._height);
};


//**************** End Overridden Functions *****************//



/**
 * Specifies the relative z-order for this node.
 * @param {number} zIndex The relative z-order for this node.
 */
DvtTreemapNode.prototype.setZIndex = function(zIndex) {
  this._zIndex = zIndex;
}

/**
 * Sets the position and bounds of this treemap node.
 * @param {number} x The x coordinate of the bounds.
 * @param {number} y The y coordinate of the bounds.
 * @param {number} width The width of the bounds.
 * @param {number} height The height of the bounds.
 * @return {DvtRectangle} the rectangle indicating the area to allocate to children, if different than inputs
 */
DvtTreemapNode.prototype.setLayoutParams = function (x, y, width, height) {
  // Nothing to render if either dimension is 0px
  if(width <= 0 || height <= 0)
    return;

  // Set a flag indicating layout has been performed
  this._hasLayout = true;
  
  // Cache the previous size and position for isolate support
  this._oldState = this.GetAnimationParams();
  
  // Store the given size and position
  this._x = x;
  this._y = y;
  this._width = width ? width : 0;
  this._height = height ? height : 0;
  
  // Determine the text style for this node
  if(this.hasChildren())
    this._textStyle = this._groupLabelDisplay;
  else
    this._textStyle = this._labelDisplay;
    
  // If text not specified, same as off  
  if(!this._textStr)
    this._textStyle = DvtTreemapNode.TEXT_STYLE_OFF;

  // Return the subsection to allocate to children, ignored for leaf nodes
  if(this._textStyle == DvtTreemapNode.TEXT_STYLE_HEADER) {
    // Find the height of the header by creating and measuring the text node
    this._titleBarHeight = DvtTreemapNode._MIN_TITLE_BAR_HEIGHT;
    var text = new DvtOutputText(this.getView().getCtx(), this._textStr);
    text.setFontSize(this.GetTextSize());
    this.ApplyHeaderTextStyle(text, DvtTreemapNode.HEADER_TEXT_DEFAULT_STYLE, DvtTreemapNode._DEFAULT_HEADER_TEXT_COLOR);
    var headerLabelHeight = DvtTextUtils.guessTextDimensions(text).h;
    this._titleBarHeight = Math.max(this._titleBarHeight, headerLabelHeight);
    
    // Additional space for isolate/restore button
    if(this.isIsolateEnabled())
      this._titleBarHeight = Math.max(this._titleBarHeight, DvtTreemapNode._MIN_TITLE_BAR_HEIGHT_ISOLATE);
  
    // Headers consume some of the space
    var xx = this._x;
    var yy = this._y + this._titleBarHeight;
    var ww = this._width;
    var hh = this._height - this._titleBarHeight;

    // If there is enough space, then return the rectangle
    if (ww >= 0 && hh >= 0)
      return new DvtRectangle(xx, yy, ww, hh);
    else 
      this._textStyle = null; // Not enough space, don't show header 
  }

  return new DvtRectangle(this._x, this._y, this._width, this._height);
}

/**
 * @override
 */
DvtTreemapNode.prototype.getNodeUnderPoint = function(x, y) {
  // Check if the node contains the coords
  if(this.contains(x, y) || !this._hasLayout) {
    var childNodes = this.getChildNodes();
    for(var i=0; i<childNodes.length; i++) {
      if(childNodes[i].contains(x, y))
        return childNodes[i].getNodeUnderPoint(x, y);
    }
    
    // No child found, return the current node
    if(this._hasLayout)
        return this;
  }
  
  // No node found, return null
  return null;
}

/**
 * @override
 */
DvtTreemapNode.prototype.contains = function(x, y) {
  return x >= this._x && x <= this._x + this._width && 
         y >= this._y && y <= this._y + this._height;
}

/**
 * @override
 */
DvtTreemapNode.prototype.GetAnimationParams = function() {
  var r = DvtColorUtils.getRed(this._color);
  var g = DvtColorUtils.getGreen(this._color);
  var b = DvtColorUtils.getBlue(this._color);
  return [this._x, this._y, this._width, this._height, r, g, b];  
}

/**
 * @override
 */
DvtTreemapNode.prototype.SetAnimationParams = function(params) {  
  // Update the layout params
  this.setLayoutParams(params[0], params[1], params[2], params[3]);  
  
  // Update the color.  Round them since color parts must be ints
  var r = Math.round(params[4]);
  var g = Math.round(params[5]);
  var b = Math.round(params[6]);
  this._color = DvtColorUtils.makeRGB(r, g, b);
  
  // Update the shapes
  this._updateShapes();
}

/**
 * After a relayout due to isolate or restore, returns the animation to render this node and
 * all of its descendants to the new state.
 * @return {array}
 */
DvtTreemapNode.prototype.getIsolateAnimation = function() {
  var playables = [this._getIsolateAnimation()];
  var descendants = this.getDescendantNodes();
  for(var i=0; i<descendants.length; i++) {
    playables.push(descendants[i]._getIsolateAnimation());
  }
  
  return playables;
}

/**
 * Returns the isolate or restore animation for this node.
 * @return {DvtPlayable}
 */
DvtTreemapNode.prototype._getIsolateAnimation = function() {
  if(this._oldState) {
    // Create the playable to animate to the new layout state
    var playable = new DvtCustomAnimation(this.getView().getCtx(), this, DvtTreemapNode._ANIMATION_ISOLATE_DURATION);
    playable.getAnimator().addProp(DvtAnimator.TYPE_NUMBER_ARRAY, this, this.GetAnimationParams, this.SetAnimationParams, this.GetAnimationParams());
      
    // Initialize the old state
    this.SetAnimationParams(this._oldState);
      
    return playable;  
  }
  else
    return null;
}

/**
 * @override
 */
DvtTreemapNode.prototype.animateUpdate = function(handler, oldNode) {
  if(this.GetDepth() == 0 || (oldNode._hasLayout && oldNode._width > 0 && oldNode._height > 0)) {
    // Old node existed and was visible, show the update animation
    // this.GetDepth() check since root will not have a size
    return DvtTreemapNode.superclass.animateUpdate.call(this, handler, oldNode);
  }
  else {
    // Old node did not exist or was not visible, treat as insert
    return this.animateInsert(handler);
  }
}

/**
 * Creates and return the shape object for this node.
 * @return {DvtShape} The shape object for this node
 * @private
 */
DvtTreemapNode.prototype._createShapeNode = function () {
  // Initialize helper vars for geometry calc
  var x1 = this._x;
  var x2 = this._x + this._width - DvtTreemapNode._LINE_FUDGE_FACTOR;
  var y1 = this._y + DvtTreemapNode._LINE_FUDGE_FACTOR;
  var y2 = this._y + this._height;
  
  // Workaround for different pixel drawing behavior between browsers
  if(DvtAgent.isPlatformWebkit()) {
   y1 -= DvtTreemapNode._LINE_FUDGE_FACTOR;
   y2 -= DvtTreemapNode._LINE_FUDGE_FACTOR;
  }
  
  // Create the basic shape with geometry
  var shape;
  var headerPoints;
  if(this._textStyle == DvtTreemapNode.TEXT_STYLE_HEADER) {
    // Create the header shape and border
    if(this.getView().__getGroupGaps() == DvtTreemapParser.GROUP_GAPS_ALL) {
      // Header extends around the children when there are gaps between nested groups
      shape = new DvtRect(this.getView().getCtx(), this._x, this._y, this._width, this._height);
      headerPoints = new Array(x1, y2, x1, y1, x2, y1, x2, y2, x1, y2);
    }
    else {
      shape = new DvtRect(this.getView().getCtx(), this._x, this._y, this._width, this._titleBarHeight);
      y2 = this._y + this._titleBarHeight;
      headerPoints = new Array(x1, y2, x1, y1, x2, y1, x2, y2);
    }
    
    this._border = new DvtPolyline(this.getView().getCtx(), headerPoints);
    this.ApplyHeaderStyle(shape, DvtTreemapNode.DEFAULT_HEADER_INLINE_STYLE, DvtTreemapNode.HEADER_BACKGROUND_STYLE);
    this._border.setMouseEnabled(false);
    shape.addChild(this._border);
    
    // Isolate Support
    if(this._isIsolated)    
      this._isolateButton = this._createIsolateRestoreButton(shape);
  }
  else {
    // Create the node shape
    shape = new DvtRect(this.getView().getCtx(), this._x, this._y, this._width, this._height);
    shape.setFill(this.GetFill());
    
    // Create the bevel effect for the node: Disabled on phones/tablets for 1000+ nodes for performance reasons.
    var bVisualEffects = this.getView().__getNodeCount() < 1000 || !DvtAgent.isTouchDevice();
    if(bVisualEffects && this._width >= DvtTreemapNode.MIN_SIZE_FOR_BORDER && this._height >= DvtTreemapNode.MIN_SIZE_FOR_BORDER) {
      // Figure out the stroke colors
      var topLeft = new DvtSolidStroke(this.getResolvedColor(DvtTreemapNode.DEFAULT_NODE_TOP_BORDER_COLOR, DvtTreemapNode.LEAF_NODE_TOP_BORDER_COLOR_STYLE), DvtTreemapNode.DEFAULT_NODE_BORDER_OPACITY);
      var bottomRight = new DvtSolidStroke(this.getResolvedColor(DvtTreemapNode.DEFAULT_NODE_BOTTOM_BORDER_COLOR, DvtTreemapNode.LEAF_NODE_BOTTOM_BORDER_COLOR_STYLE), DvtTreemapNode.DEFAULT_NODE_BORDER_OPACITY);
      if(this._pattern) {
        topLeft = new DvtSolidStroke(this._color, DvtTreemapNode.DEFAULT_NODE_PATTERN_BORDER_OPACITY);
        bottomRight = topLeft;
      }
      
      // Creation of bevels varies based on the minimum of the width and height of the node:
      // 0: Won't reach this code
      // 1: No bevels
      // 2: Bottom right bevel only
      // 4+: All bevels
      var minDim = Math.min(this._width, this._height);
      
      // Top Left Bevel
      if(minDim >= 4) {
        var pointsTL = new Array(x1, y2, x1, y1, x2, y1);
        this._borderTL = new DvtPolyline(this.getView().getCtx(), pointsTL);
        this._borderTL.setStroke(topLeft);  
        this._borderTL.setMouseEnabled(false);
        shape.addChild(this._borderTL);
      }
      
      // Bottom Right Bevel
      if(minDim >= 2) {
        var pointsBR = new Array(x2, y1, x2, y2, x1, y2);
        this._borderBR = new DvtPolyline(this.getView().getCtx(), pointsBR);
        this._borderBR.setStroke(bottomRight); 
        this._borderBR.setMouseEnabled(false);
        shape.addChild(this._borderBR);
      }
    }
  }

  // Add pointers between this node and the shape
  this.getView().__getEventManager().associate(shape, this);
  
  // Allows selection cursor to be shown over nodes if nodeSelection is enabled and node is selectable
  // Unselectable nodes explicitly set as default so correct pointer appears if un-selectable node is drawn inside selectable node
  if(this.getView().__getNodeSelection() != null && this.Selectable != "off")
    shape.setSelectable(true);
  else
    shape.setCursor("default");
  
  shape.zIndex = this._zIndex; 
  shape.setAlpha(this.getAlpha());
  return shape;
}

/**
 * Creates and positions the isolate or restore button for this node.
 * @param {DvtContainer} container The container for the button.
 * @return {DvtButton}
 * @private
 */
DvtTreemapNode.prototype._createIsolateRestoreButton = function(container) {
  if(this._textStyle != DvtTreemapNode.TEXT_STYLE_HEADER || !this.isIsolateEnabled())
    return null;

  var button = null;
  var x1 = this._x;
  var x2 = this._x + this._width - DvtTreemapNode._LINE_FUDGE_FACTOR;
  var y1 = this._y + DvtTreemapNode._LINE_FUDGE_FACTOR;
  var y2 = this._y + this._titleBarHeight;
  var availIconWidth = x2 - x1 - DvtTreemapNode._ISOLATE_GAP_SIZE * 2;
  if(availIconWidth > DvtTreemapNode._ISOLATE_ICON_SIZE) {
    // Create the button and add to the container
    button = this._isIsolated ? this._getRestoreButton() : this._getIsolateButton();
    var transX;
    if(DvtAgent.isRightToLeft(container.getCtx()))
      transX = x1 + DvtTreemapNode._ISOLATE_GAP_SIZE;
    else
      transX = x2 - DvtTreemapNode._ISOLATE_ICON_SIZE - DvtTreemapNode._ISOLATE_GAP_SIZE;
    button.setTranslate(transX, (y2 + y1 - DvtTreemapNode._ISOLATE_ICON_SIZE)/2);
    container.addChild(button);
    
    // Add a buffer to make the objects easier to interact with on touch devices
    if(DvtAgent.isTouchDevice()) {
      var rect = new DvtRect(container.getCtx(), 
                             -DvtTreemapNode._ISOLATE_TOUCH_BUFFER, -DvtTreemapNode._ISOLATE_TOUCH_BUFFER, 
                             DvtTreemapNode._ISOLATE_ICON_SIZE + 2*DvtTreemapNode._ISOLATE_TOUCH_BUFFER, 
                             DvtTreemapNode._ISOLATE_ICON_SIZE + 2*DvtTreemapNode._ISOLATE_TOUCH_BUFFER);
      rect.setInvisibleFill();
      button.addChild(rect);
    }
    
    // For Alta, associate the node so the hover effect doesn't get removed.
    if(this.getView().__getResources().alta == "true") 
      this.getView().__getEventManager().associate(button, this);
    else { // Associate a blank peer so the button is not treated as part of the node
      var tooltip = this._isIsolated ? this.getView().__getResources().restore : this.getView().__getResources().isolate;
      this.getView().__getEventManager().associate(button, new DvtBaseTreePeer(this, this.getId(), tooltip));    
    }
  }
  
  return button;
}

/**
 * Removes the isolate/restore button, if displayed.
 * @private
 */
DvtTreemapNode.prototype._removeIsolateRestoreButton = function() {
  if(this._isolateButton) {
    this._removeChildShape(this._isolateButton);
    this._isolateButton = null;
  }
}

/**
 * Creates and return the text object for this node. Adds the text to the container if it's not empty.
 * @param {DvtContainer} container The container to render in.
 * @return {DvtText} The text object for this node.
 * @private
 */
DvtTreemapNode.prototype._createTextNode = function(container) {
  var isRTL = DvtAgent.isRightToLeft(container.getCtx());

  // If no text or no container to place the text, return
  if(!this._textStr || !container || !this._textStyle || this._textStyle == DvtTreemapNode.TEXT_STYLE_OFF)
    return null;

  // Approximate whether the text could fit vertically
  var availHeight = this._height;
  if (this.GetTextSize() > availHeight)
    return null;
  
  // Figure out the horizontal alignment
  var hAlign = (this._textStyle == DvtTreemapNode.TEXT_STYLE_NODE) ? this._labelHalign : this._headerHalign;
  if(isRTL) {
    if(hAlign == DvtTreemapNode.LABEL_ALIGN_START)
      hAlign = DvtTreemapNode.LABEL_ALIGN_END;
    else if(hAlign == DvtTreemapNode.LABEL_ALIGN_END)
      hAlign = DvtTreemapNode.LABEL_ALIGN_START;
  }

  // Approximate whether the text could fit horizontally (conservative)  
  var availWidth = this._width - (DvtTreemapNode.TEXT_BUFFER_HORIZ + DvtTreemapNode.MIN_TEXT_BUFFER);
  var isolateWidth = 0;
  if(this.isIsolateEnabled()) {
    isolateWidth = DvtTreemapNode._ISOLATE_ICON_SIZE + DvtTreemapNode._ISOLATE_GAP_SIZE;
    if(hAlign == DvtTreemapNode.LABEL_ALIGN_CENTER)
      availWidth -= 2*isolateWidth; // center aligned text should always be centered, meaning space is reserved on either size for the button
    else 
      availWidth -= isolateWidth;
  }
  
  if (availWidth <= 0)
    return null;

  // Create the text object
  var text = new DvtOutputText(this.getView().getCtx(), this._textStr);
  text.setFontSize(this.GetTextSize());
  
  // Calculate the horizontal text position
  if(hAlign == DvtTreemapNode.LABEL_ALIGN_START) {
    if(isRTL)
      text.setX(this._x + DvtTreemapNode.TEXT_BUFFER_HORIZ + isolateWidth);
    else
      text.setX(this._x + DvtTreemapNode.TEXT_BUFFER_HORIZ);
    text.alignLeft();
  }
  else if(hAlign == DvtTreemapNode.LABEL_ALIGN_CENTER) {
    text.setX(this._x + (this._width/2));
    text.alignCenter();
  }
  else if(hAlign == DvtTreemapNode.LABEL_ALIGN_END) {
    if(isRTL)
      text.setX(this._x + this._width - DvtTreemapNode.TEXT_BUFFER_HORIZ);
    else
      text.setX(this._x + this._width - DvtTreemapNode.TEXT_BUFFER_HORIZ - isolateWidth);
    text.alignRight();
  }
  
  // Calculate the vertical text position and style
  if (this._textStyle == DvtTreemapNode.TEXT_STYLE_NODE) {
    // Set the correct available height
    availHeight = this._height - DvtTreemapNode.TEXT_BUFFER_VERT * 2;
    
    // Vertical Alignment
    if(this._labelValign == DvtTreemapNode.LABEL_ALIGN_TOP) {
      text.setY(this._y + DvtTreemapNode.TEXT_BUFFER_VERT);
      text.alignTop();
    }
    else if(this._labelValign == DvtTreemapNode.LABEL_ALIGN_CENTER) {
      text.setY(this._y + (this._height/2));
      text.alignMiddle();
    }
    else if(this._labelValign == DvtTreemapNode.LABEL_ALIGN_BOTTOM) {
      text.setY(this._y + this._height - DvtTreemapNode.TEXT_BUFFER_VERT);
      text.alignBottom();
    } else {
        text.alignBaseline();
    }
    
    // Update it with the correct style
    this.ApplyLabelTextStyle(text);
  }
  else if (this._textStyle == DvtTreemapNode.TEXT_STYLE_HEADER) {
    // Note: No need to worry about available height here.  Headers are sized based on the text size.
    var chromeAdjustment = DvtAgent.isPlatformWebkit() ? DvtTreemapNode._LINE_FUDGE_FACTOR : 0;
    text.setY(this._y + DvtTreemapNode.DEFAULT_HEADER_BORDER_WIDTH + this._titleBarHeight/2 + chromeAdjustment);  
    text.alignMiddle();
    this.ApplyHeaderTextStyle(text, DvtTreemapNode.HEADER_TEXT_DEFAULT_STYLE, DvtTreemapNode._DEFAULT_HEADER_TEXT_COLOR);
  }

  if (text != null) {
    if(this._textStyle == DvtTreemapNode.TEXT_STYLE_HEADER && this.isDrillReplaceEnabled()) {
      // Drillable text link
      this.ApplyHeaderTextStyle(text, DvtTreemapNode.HEADER_DRILL_TEXT_DEFAULT_STYLE, DvtTreemapNode._HEADER_DRILLABLE_TEXT_COLOR);
      text.setCursor("pointer");
    
      // Associate with a DvtBaseTreePeer to handle drilling
      var peer = new DvtBaseTreePeer(this, this.getId(), null, this.getDatatip(), this.getDatatipColor());
      peer.setDrillable(true);
      this.getView().__getEventManager().associate(text, peer);
    }
    else // Parent node will handle all events
      text.setMouseEnabled(false); 
    
    // Truncate the text if necessary
    return DvtTextUtils.fitText(text, availWidth, availHeight, container) ? text : null;
  }
}

DvtTreemapNode.prototype.ApplyHeaderStyle = function(shape, defaultStyle, styleDef) {
    var style = new DvtCSSStyle(defaultStyle);
    style.merge(this._view.__getStyles()[styleDef]);
    var backgroundColor = style.getStyle(DvtCSSStyle.BACKGROUND_COLOR);
    
    // Fill the header with a color
    var borderAlpha = 1;
    if(this._headerUseNodeColor && styleDef == DvtTreemapNode.HEADER_BACKGROUND_STYLE) {
      shape.setSolidFill(this._color);
      borderAlpha = DvtTreemapNode.DEFAULT_HEADER_WITH_NODE_COLOR_ALPHA;
    }
    else 
      shape.setSolidFill(backgroundColor);
    
    // There's a bug in CSSStyle so hex is not allowed.  For now don't allow skinning
    //borderColor = DvtTreemapNode.DEFAULT_HEADER_BORDER_COLOR;
    
    //var borderWidth = style.getStyle(DvtCSSStyle.BORDER_WIDTH);
    
    var borderColor = style.getStyle(DvtCSSStyle.BORDER_COLOR);
    if (this._border)
        this._border.setSolidStroke(borderColor, borderAlpha, DvtTreemapNode.DEFAULT_HEADER_BORDER_WIDTH);
}

DvtTreemapNode.prototype.ApplyHeaderTextStyle = function(text, styleDef, defaultFillColor) {
  // Set the text color.  The default color is overridden if headers display node colors.
  if(this._headerUseNodeColor && styleDef == DvtTreemapNode.HEADER_TEXT_DEFAULT_STYLE)
    text.setSolidFill(DvtBaseTreeNode.GetNodeTextColor(this));
  else 
    text.setSolidFill(defaultFillColor);

  var textStyle = new Array();
  if(this.GetDepth() <= 1 && this.hasChildren()) {
    textStyle.push(new DvtCSSStyle(DvtTreemapNode._HEADER_TEXT_STYLE));
  }
  
  textStyle.push(this._view.__getStyles()[styleDef]);
  
  // Update it with the correct style
  if(this._headerLabelStyle)
    textStyle.push(this._headerLabelStyle);

  text.setCSSStyle(DvtCSSStyle.mergeStyles(textStyle));
}

/**
 * Handles a mouse out event on the node.
 */
DvtTreemapNode.prototype.handleMouseOver = function() {
  // Isolate: draw button if needed
  if(!this._isolateButton)
    this._isolateButton = this._createIsolateRestoreButton(this._shape);
    
  DvtTreemapNode.superclass.handleMouseOver.call(this);    
}

/**
 * Handles a mouse out event on the node.
 */
DvtTreemapNode.prototype.handleMouseOut = function() {
  // Isolate: hide button if displayed
  if(this._isIsolated !== true)    
    this._removeIsolateRestoreButton();
    
  DvtTreemapNode.superclass.handleMouseOut.call(this);        
}

/**
 * Updates the shapes for the current layout params.
 * @private
 */
DvtTreemapNode.prototype._updateShapes = function() {
  if(!this._shape)
    return;

  // Update the shape and color
  this._shape.setRect(this._x, this._y, this._width, this._height);
  
  // Also update the color
  if(this._textStyle != DvtTreemapNode.TEXT_STYLE_HEADER || this._headerUseNodeColor) {
    this._shape.setFill(this.GetFill());
  }
  
  if(this.isSelected())
    this.setSelected(false);
 
  // Clear all border effects.  They will be restored in the animationEnd listener.
  this._removeChildShape(this._border);
  this._removeChildShape(this._borderTL);
  this._removeChildShape(this._borderBR);
  this._border = null;
  this._borderTL = null;
  this._borderBR = null;
  
  // Remove isolate/restore if displayed
  this._removeIsolateRestoreButton()
  
  // Handle the node content
  var template = this.GetTemplate();
  if(template) {
    // Hide the content for now, it will be added back after the animation completes.
    this._removeChildShape(this._contentRoot);
    this._contentRoot = null;
  }
  else { // No template, update the text
    // Remove the text background
    this._removeChildShape(this._textBackground);
    this._textBackground = null;
    
    // Update the text.  This implementation simply removes and repaints it.
    if(this._text)
      this._text.getParent().removeChild(this._text); // necessary because the parent may not be the shape
    
    this._text = this._createTextNode(this._shape);
  }
}

/**
 * @override
 */
DvtTreemapNode.prototype.getDropSiteFeedback = function() {
  if(this._shape) {
    return new DvtRect(this.getView().getCtx(), 
                       this._shape.getX(), this._shape.getY(), 
                       this._shape.getWidth(), this._shape.getHeight());
  }
  else
    return null;
}

/**
 * Adds the specified DvtText as a child.
 * @param {DvtText} text
 */
DvtTreemapNode.prototype._addChildText = function(text) {
  if(this._textStyle == DvtTreemapNode.TEXT_STYLE_NODE && this.hasChildren()) 
    this.getView().__getGroupTextLayer().addChild(text);
  else
    this._shape.addChild(text);
}

/**
 * Helper function to remove child shapes from this node.
 * @param {DvtShape} childShape The child shape to remove.
 * @private
 */
DvtTreemapNode.prototype._removeChildShape = function(childShape) {
  if(childShape)
    this._shape.removeChild(childShape);
}

/**
 * Returns the isolate button for use on the node header.
 * @return {DvtDisplayable}
 * @private
 */
DvtTreemapNode.prototype._getIsolateButton = function() {
  var context = this.getView().getCtx();
  
  // Get the resources from the view
  var resources = this.getView().__getResources();
  
  // Initialize the button states
  var upState = new DvtImage(context, resources.maximizeUp, 0, 0, DvtTreemapNode._ISOLATE_ICON_SIZE, DvtTreemapNode._ISOLATE_ICON_SIZE);
  var overState = new DvtImage(context, resources.maximizeOver, 0, 0, DvtTreemapNode._ISOLATE_ICON_SIZE, DvtTreemapNode._ISOLATE_ICON_SIZE);
  var downState = new DvtImage(context, resources.maximizeDown, 0, 0, DvtTreemapNode._ISOLATE_ICON_SIZE, DvtTreemapNode._ISOLATE_ICON_SIZE);
  
  // Have to add a transparent fill so that IE9 can capture the mouse events (Bug 14653059)
  upState.setInvisibleFill();
  overState.setInvisibleFill();
  downState.setInvisibleFill();
  
  // Create button and hook up click listener
  var button = new DvtButton(context, upState, overState, downState);
  button.addEvtListener(DvtMouseEvent.CLICK, this.__isolateNode, false, this);
  return button;
}

/**
 * Returns the restore button for use on the node header.
 * @return {DvtDisplayable}
 * @private
 */
DvtTreemapNode.prototype._getRestoreButton = function() {
  var context = this.getView().getCtx();
  
  // Get the resources from the view
  var resources = this.getView().__getResources();
  
  // Initialize the button states
  var upState = new DvtImage(context, resources.restoreUp, 0, 0, DvtTreemapNode._ISOLATE_ICON_SIZE, DvtTreemapNode._ISOLATE_ICON_SIZE);
  var overState = new DvtImage(context, resources.restoreOver, 0, 0, DvtTreemapNode._ISOLATE_ICON_SIZE, DvtTreemapNode._ISOLATE_ICON_SIZE);
  var downState = new DvtImage(context, resources.restoreDown, 0, 0, DvtTreemapNode._ISOLATE_ICON_SIZE, DvtTreemapNode._ISOLATE_ICON_SIZE);
  
  // Have to add a transparent fill so that IE9 can capture the mouse events (Bug 14653059) 
  var transparentFill = DvtSolidFill.invisibleFill();
  upState.setFill(transparentFill);
  overState.setFill(transparentFill);
  downState.setFill(transparentFill);
  
  // Create button and hook up click listener
  var button = new DvtButton(context, upState, overState, downState);
  button.addEvtListener(DvtMouseEvent.CLICK, this.__restoreNode, false, this);
  return button;
}

/**
 * Returns true if this node is isolated
 * @return {Boolean} true if this node is isolated, false otherwise
 */
DvtTreemapNode.prototype.__isIsolated = function()
{
  return this._isIsolated;
}

/**
 * Isolates this node and maximizes it.
 */
DvtTreemapNode.prototype.__isolateNode = function() {
  this._isIsolated = true;
  this.hideHoverEffect();
  this.getView().__isolate(this);
  
  // Remove the isolate button, to be redrawn after isolate is complete
  this._removeIsolateRestoreButton()
}

/**
 * Restores this node to its normal size.
 */
DvtTreemapNode.prototype.__restoreNode = function() {
  this._isIsolated = false;
  this.hideHoverEffect();
  this.getView().__restore();
  
  // Remove the restore button, to be redrawn after isolate is complete
  this._removeIsolateRestoreButton()
}

/**
 * @override
 */
DvtTreemapNode.prototype.getDatatip = function(target, x, y) {
  if(target && target instanceof DvtButton)
    return null; // tooltip is displayed for isolate button
  else
    return DvtTreemapNode.superclass.getDatatip.call(this, target, x, y);
}

/**
 * @override
 */
DvtTreemapNode.prototype.getDatatipColor = function(target) {
  if(target && target instanceof DvtButton)
    return null; // tooltip is displayed for isolate button
  else
    return DvtTreemapNode.superclass.getDatatipColor.call(this, target);
}

/**
 * @override
 */
DvtTreemapNode.prototype.getTooltip = function(target) {
  if(target && target instanceof DvtButton)
    return this._isIsolated ? this.getView().__getResources().restore : this.getView().__getResources().isolate;
  else
    return null;
}
/**
 * Base layout class for treemaps.
 * @class
 * @constructor
 */
var DvtBaseTreemapLayout = function() {
  this.Init();
}

DvtObj.createSubclass(DvtBaseTreemapLayout, DvtObj, "DvtBaseTreemapLayout");

DvtBaseTreemapLayout._GROUP_GAP = 3;

/**
 * @protected
 */
DvtBaseTreemapLayout.prototype.Init = function() {
  this._zIndex = 0; // counter to help keep track of the zIndex of the nodes
}

/**
 * Performs layout for the tree.  The specific algorithm varies by subclass.
 * @param {DvtTreemap} view The treemap component.
 * @param {DvtBaseTreeNode} root The root of the tree.
 * @param {number} x The x coordinate for this node.
 * @param {number} y The y coordinate for this node.
 * @param {number} width The width of this node.
 * @param {number} height The height of this node.
 * @param {boolean} bShowRoot True if the root node should be displayed.
 */
DvtBaseTreemapLayout.prototype.layout = function(view, root, x, y, width, height, bShowRoot) 
{
  // subclasses should override
}

/**
 * Specifies whether this layout will sort the nodes.  This will be respected only for layouts where
 * ordering is maintained.
 * @param {string} sorting "on" if sorting by size is enabled.
 */
DvtBaseTreemapLayout.prototype.setSorting = function(sorting) {
  this.Sorting = sorting;
}

/**
 * Applies the specified bounds to the node and returns the space available to the node's children.
 * @param {DvtBaseTreeNode} root The root of the tree.
 * @param {number} x The x coordinate for this node.
 * @param {number} y The y coordinate for this node.
 * @param {number} width The width of this node.
 * @param {number} height The height of this node.
 * @param {boolean} isRoot true if this node is the root of the tree.
 * @return {DvtRectangle} The rectangle indicating the area to allocate to the children of this node.
 */
DvtBaseTreemapLayout.prototype.setNodeBounds = function(node, x, y, width, height, isRoot) 
{
  // Set the relative zIndex of the node and increment
  node.setZIndex(this._zIndex);
  this._zIndex++;

  // The root node is not rendered, unless it's a singleton
  if(!isRoot || !node.hasChildren()) { 
    // Support for gaps between nodes
    var gap = this.getGapSize(node.getView(), node.GetDepth());
  
    // Round the values to pixel locations and add gaps
    var xx = Math.round(x + gap);
    var yy = Math.round(y + gap);
    var ww = Math.round(x + width - gap) - xx;
    var hh = Math.round(y + height - gap) - yy;
    
    // Set the rectangle on the node and get the bounds available to its children
    var availBounds = node.setLayoutParams(xx, yy, ww, hh);
    if(availBounds)
      return availBounds;
  }
  
  // If no explicit bounds returned, use the entire space
  return new DvtRectangle(x, y, width, height);
}

/**
 * Returns the gap size for a node at the specified depth.
 * @param {DvtTreemap} view
 * @param {number} depth The depth of the node for which the gap should be replied.
 * @return {number} The size of the gaps around this node.
 */
DvtBaseTreemapLayout.prototype.getGapSize = function(view, depth) {
  var groupGaps = view.__getGroupGaps();
  if(groupGaps == DvtTreemapParser.GROUP_GAPS_OUTER) 
    return (depth == 1 && view.__getMaxDepth() >= 2) ? DvtBaseTreemapLayout._GROUP_GAP : 0;
  else if(groupGaps == DvtTreemapParser.GROUP_GAPS_ALL)
    return (depth < view.__getMaxDepth()) ? DvtBaseTreemapLayout._GROUP_GAP : 0;
  else // none
    return 0;
}
/**
 * Layout class for treemaps.  This layout optimizes the aspect ratios, making the nodes as square as
 * possible for improved comparisons between nodes.  This layout does not maintain the ordering of
 * the nodes.
 * @class
 * @constructor
 * @extends {DvtBaseTreemapLayout}
 */
var DvtSquarifyingLayout = function() {
  this.Init();
}

DvtObj.createSubclass(DvtSquarifyingLayout, DvtBaseTreemapLayout, "DvtSquarifyingLayout");

/**
 * @override
 */
DvtSquarifyingLayout.prototype.layout = function(view, root, x, y, width, height, bShowRoot) {
  var isRoot = bShowRoot ? false : true;
  this._layout(root, x, y, width, height, isRoot);
}

/**
 * Performs layout for the specified node in the tree.
 * @param {DvtTreemapNode} node the root of the tree
 * @param {number} x The x coordinate for this node.
 * @param {number} y The y coordinate for this node.
 * @param {number} width The width of this node.
 * @param {number} height The height of this node.
 * @param {boolean} isRoot true if this node is the root of the tree.
 */
DvtSquarifyingLayout.prototype._layout = function(node, x, y, width, height, isRoot) 
{
  // Set the bounds on the current node and get the space available for its children
  var availBounds = this.setNodeBounds(node, x, y, width, height, isRoot);
  
  // Layout the children
  var children = node.getChildNodes();
  if(children != null && children.length > 0) {
    // Calculate the pixel size for each node and store in a temp field
    this._calcPixelSize(children, availBounds.w*availBounds.h);
    
    // Make a copy of the children array and sort ascending by size.
    // The ascending sort is used because squarify will move from back to front
    children = children.slice(0).sort(function(a,b) {return a.getSize() - b.getSize()});
    
    var w = Math.min(availBounds.w, availBounds.h);
    var r = new DvtRectangle(availBounds.x, availBounds.y, availBounds.w, availBounds.h);
    this._squarify(children, new Array(), w, r, Infinity);
  }
}

/**
 * Calculates and sets the pixel size for each child node.
 * @param {array} children The array of treemap node children.
 * @param {number} area The pixel area available for these children.
 * @private
 */
DvtSquarifyingLayout.prototype._calcPixelSize = function(children, area) {
  // First calculate the total.
  var total = 0;
  var i = 0;
  for(i=0; i<children.length; i++) 
    total += children[i].getSize() > 0 ? children[i].getSize() : 0; // ignore negatives, which skew child size calc
  
  // Then set the size
  var factor = (area == 0) ? 0 : area/total;
  for(i=0; i<children.length; i++) {
    var child = children[i];
    child.__pxSize = child.getSize()*factor;
  }
}

/**
 * Recursively arranges the rectangles to perform layout with lowest aspect ratio.
 * @param {array} children The array of treemap nodes that still need layout, in ascending order by size.
 * @param {array} row The array of treemap nodes arranged in the current row.
 * @param {number} w The length along which the rectangles will be laid out.
 * @param {DvtRectangle} r The rectangle available for layout.
 * @param {number} worst The worst aspect ratio in the current row.
 * @private
 */
DvtSquarifyingLayout.prototype._squarify = function(children, row, w, r, worst) {
  // Note: This algorithm was modified from recursive to iterative to avoid the maximum
  //       recursive stack size in javascript.  This new implementation is much better
  //       at dealing with 0 size nodes and with large breadth size.

  // If there are no more children, assign the row and return
  if(children == null || children.length == 0) {
    this._layoutRow(row, w, r);
    return;
  }
  
  while(children.length > 0) {
    var c = children.pop();
    
    // If c has no visible size, we are done, since children are sorted in ascending size.
    if(c.__pxSize < 0) {
      // Assign the layout and finish
      this._layoutRow(row, w, r);
      return;
    }
    
    // Otherwise assign it to the row
    row.push(c);
    
    var newWorst = this._getWorst(row, w);
    if(newWorst > worst) {
      // Adding child does not improve layout. Reset arrays, assign the layout and recurse.
      children.push(c); // add c back to the children
      row.pop(); // remove c from the row
      r = this._layoutRow(row, w, r);
      this._squarify(children, new Array(), Math.min(r.w, r.h), r, Infinity);
      return;
    }
    else if(children.length == 0) {
      // No more children to allocate.  Assign layout and finish
      this._layoutRow(row, w, r);
      return;
    }
    else // update the worst field
      worst = newWorst;
  }
}

/**
 * Returns the highest aspect ratio of a list of rectangles.
 * @param {array} areas The array of treemap nodes
 * @param {number} w The length along which the rectangles will be laid out
 * @return {number} The greatest aspect ratio of the list of rectangles.
 * @private
 */
DvtSquarifyingLayout.prototype._getWorst = function(areas, w) {
  var total = 0;
  var min = Infinity;
  var max = -Infinity;
  
  for(var i=0; i<areas.length; i++) {
    total += areas[i].__pxSize;
    min = Math.min(min, areas[i].__pxSize);
    max = Math.max(max, areas[i].__pxSize);
  }
  
  var s2 = total*total;
  var w2 = w*w;
  return Math.max((w2*max)/s2, s2/(w2*min));
}

/**
 * Assigns the layout for the current row.
 * @param {array} row The array of treemap nodes arranged in the current row.
 * @param {number} w The length along which the rectangles will be laid out.
 * @param {DvtRectangle} r The rectangle available for layout.
 * @return {DvtRectangle} A rectangle containing the unallocated space.
 * @private
 */
DvtSquarifyingLayout.prototype._layoutRow = function(row, w, r) 
{
  // Calculate the sum of the row areas
  var total = 0;
  var i;
  for(i=0; i<row.length; i++)
    total += row[i].__pxSize;
    
  // Assign positions to the row nodes  
  var x = r.x;
  var y = r.y;
  var width, height;
  if(w == r.w) {
    // Horizontal Layout
    height = (w == 0) ? 0 : total/w;
    for(i=0; i<row.length; i++) {
      width = row[i].__pxSize/height;  // equivalent to w*size/total
      this._layout(row[i], x, y, width, height, false); // Set and recurse
      x += width;
    }
    
    // Return the remaining space
    return new DvtRectangle(r.x, r.y+height, r.w, r.h-height);
  }
  else {
    // Vertical Layout
    width = (w == 0) ? 0 : total/w;
    for(i=0; i<row.length; i++) {
      height = row[i].__pxSize/width;  // equivalent to w*size/total
      this._layout(row[i], x, y, width, height, false); // Set and recurse
      y += height;
    }
    
    // Return the remaining space
    return new DvtRectangle(r.x+width, r.y, r.w-width, r.h);
  }
}
/**
 * Layout class for treemaps.  This layout allocates space across a single dimension for each layer,
 * alternating between horizontal and vertical allocation.  This layout maintains the ordering of
 * the nodes while sacrificing aspect ratio.
 * @param {boolean} isHoriz true if the first layer is laid out horizontally.
 * @class
 * @constructor
 * @extends {DvtBaseTreemapLayout}
 */
var DvtSliceAndDiceLayout = function(isHoriz) {
  this.Init();
  this._isHoriz = isHoriz;
}

DvtObj.createSubclass(DvtSliceAndDiceLayout, DvtBaseTreemapLayout, "DvtSliceAndDiceLayout");

/**
 * @override
 */
DvtSliceAndDiceLayout.prototype.layout = function(view, root, x, y, width, height, bShowRoot) {
  var isRoot = bShowRoot ? false : true;
  this._layout(this._isHoriz, view, root, x, y, width, height, isRoot);
}

/**
 * Performs layout for the specified node in the tree.
 * @param {boolean} isHoriz true if this layer is laid out horizontally.
 * @param {DvtTreemap} view The treemap component.
 * @param {DvtTreemapNode} node The root of the tree.
 * @param {number} x The x coordinate for this node.
 * @param {number} y The y coordinate for this node.
 * @param {number} width The width of this node.
 * @param {number} height The height of this node.
 * @param {boolean} isRoot true if this node is the root of the tree.
 * @private
 */
DvtSliceAndDiceLayout.prototype._layout = function(isHoriz, view, node, x, y, width, height, isRoot) 
{
  // Set the bounds on the current node and get the space available for its children
  var availBounds = this.setNodeBounds(node, x, y, width, height, isRoot);
  
  // Layout the children
  var children = node.getChildNodes();
  if(children != null) {
    var childX = availBounds.x;
    var childY = availBounds.y;
    // Width and height will be overwritten based on isHoriz
    var childWidth = availBounds.w;
    var childHeight = availBounds.h;
    
    // Find the total size of the children.  This may not match node.getSize() for
    // hierarchies that vary based on depth.
    var total = 0;
    var i;
    for(i=0; i<children.length; i++)
      total += children[i].getSize() > 0 ? children[i].getSize() : 0; // ignore negatives, which skew child size calc
      
    // Sorting
    if(this.Sorting == DvtBaseTreeParser.SORTING_ON) {
      // Copy and sort by decreasing size
      children = children.slice(0);
      children.sort(function(a, b) { return b.getSize() - a.getSize(); });
    }
  
    // BIDI Support: For horizontal layout, reverse the order of the nodes
    if(isHoriz && DvtAgent.isRightToLeft(view.getCtx()))
      children = children.slice(0).reverse(); 
    
    for(i=0; i<children.length; i++) {
      var child = children[i];
      
      // Ignore negative and zero sized nodes
      if(child.getSize() <= 0) 
        continue;
    
      // Calculate the bounds of the child
      var sizeRatio = child.getSize()/total;
      if(isHoriz)
        childWidth = availBounds.w * sizeRatio;
      else
        childHeight = availBounds.h * sizeRatio;
        
      // Recursively layout the child
      this._layout(!isHoriz, view, child, childX, childY, childWidth, childHeight, false);
      
      // Update the x and y
      if(isHoriz)
        childX += childWidth;
      else
        childY += childHeight;
    }    
  }
}
/**
 * @constructor
 * A component level treemap isolate event.
 * @type {string} id The id of the node that is the target of the event.
 * @class
 * @extends DvtBaseComponentEvent
 */
var DvtTreemapIsolateEvent = function(id) {
  this.Init(DvtTreemapIsolateEvent.TYPE);
  this._id = id ? id : null;
}

DvtObj.createSubclass(DvtTreemapIsolateEvent, DvtBaseComponentEvent, "DvtTreemapIsolateEvent");

// Event Types
DvtTreemapIsolateEvent.TYPE = "treemapIsolate";

/**
 * Returns the id of the isolated node, if any.
 * @return {string}
 */
DvtTreemapIsolateEvent.prototype.getId = function() {
  return this._id;
}
/*---------------------------------------------------------------------------------*/
/*  DvtTreemapKeyboardHandler     Keyboard handler for Treemap                     */
/*---------------------------------------------------------------------------------*/
/**
  *  @param {DvtEventManager} manager The owning DvtEventManager 
  *  @class DvtTreemapKeyboardHandler
  *  @extends DvtKeyboardHandler
  *  @constructor
  */
var  DvtTreemapKeyboardHandler = function(manager)
{
    this.Init(manager);
};

DvtObj.createSubclass(DvtTreemapKeyboardHandler, DvtBaseTreeKeyboardHandler, "DvtTreemapKeyboardHandler");


/**
 * @override 
 */
DvtTreemapKeyboardHandler.prototype.isNavigationEvent = function(event)
{
  var isNavigable = DvtTreemapKeyboardHandler.superclass.isNavigationEvent.call(this, event);
  
  if(!isNavigable)
  {
    var keyCode = event.keyCode;
    if( keyCode == DvtKeyboardEvent.OPEN_BRACKET || 
        keyCode == DvtKeyboardEvent.CLOSE_BRACKET )
      isNavigable = true;
  }
  
  return isNavigable;
}
/**
 * Event Manager for Treemap.
 * @param {DvtTreemap} view The treemap to associate with this event manager
 * @param {DvtContext} context The platform specific context object.
 * @param {function} callback A function that responds to component events.
 * @param {object} callbackObj The optional object instance that the callback function is defined on.
 * @class
 * @constructor
 */
var DvtTreemapEventManager = function(view, context, callback, callbackObj) {
  DvtBaseTreeEventManager.call(this, view, context, callback, callbackObj);
};

DvtObj.createSubclass(DvtTreemapEventManager, DvtBaseTreeEventManager, "DvtTreemapEventManager");


/**
 * @override
 */
DvtTreemapEventManager.prototype.ProcessKeyboardEvent = function(event)
{
  var eventConsumed = true; 
  var keyCode = event.keyCode;
  
  if(keyCode == DvtKeyboardEvent.ENTER && event.ctrlKey)
  {  
    // isolate or restore
    var node = this.getFocus(); 
    if(node.isIsolateEnabled())
    {
      if(node.__isIsolated())      
        node.__restoreNode();      
      else
        node.__isolateNode();      
    }
    event.preventDefault();
  }
  else
  {
    eventConsumed = DvtTreemapEventManager.superclass.ProcessKeyboardEvent.call(this, event);
  }
  
  return eventConsumed;
}

DvtTreemapEventManager.prototype.isClearMenuAllowed = function()
{
    return false;
}
/**
 * Resource bundle for DvtTreemap.
 * @class
 * @constructor
 * @extends {DvtBundle}
 */
var DvtTreemapBundle = function() {}

DvtObj.createSubclass(DvtTreemapBundle, DvtBundle, "DvtTreemapBundle");

DvtTreemapBundle["_defaults"] = {
  'COLOR': 'Color',
  'SIZE': 'Size'
}

/**
 * @override
 */
DvtTreemapBundle.prototype.GetDefaultStringForKey = function(key) {
  return DvtTreemapBundle["_defaults"][key];
}

/**
 * @override
 */
DvtTreemapBundle.prototype.GetBundlePrefix = function() {
  return "DvtTreemapBundle";
}
/**
 * Default values and utility functions for component versioning.
 * @class
 * @constructor
 * @extends {DvtBaseTreeDefaults}
 */
var DvtTreemapDefaults = function() {
  this.Init({'skyros': DvtTreemapDefaults.VERSION_1, 'alta': {}});
}

DvtObj.createSubclass(DvtTreemapDefaults, DvtBaseTreeDefaults, "DvtTreemapDefaults");

/**
 * Defaults for version 1.
 */ 
DvtTreemapDefaults.VERSION_1 = {
  // Note, only attributes that are different than the XML defaults need 
  // to be listed here, at least until the XML API is replaced.
  'nodeDefaults': {
    'header': {'labelStyle': new DvtCSSStyle("font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; font-size: 12px;")}
  }
}
/**
 * Utility functions for converting between JSON and XML APIs.
 * @param {DvtContext} context
 * @class
 */
var DvtTreemapJsonUtils = function(context) {
  this._context = context;
}

DvtObj.createSubclass(DvtTreemapJsonUtils, DvtBaseTreeJsonUtils, "DvtTreemapJsonUtils");

/** @override **/
DvtTreemapJsonUtils.prototype.GetComponentName = function() {
  return "treemap";
}

/** @override **/
DvtTreemapJsonUtils.prototype.WriteComponentAttributes = function(options) {
  var ret = DvtTreemapJsonUtils.superclass.WriteComponentAttributes.call(this, options);
  ret += this.WriteAttr("irk", options['isolatedNode']);
  
  var groupGaps = options['groupGaps'];
  if(groupGaps == "all")
    ret += this.WriteAttr("gg", "a");
  else if(groupGaps == "none")
    ret += this.WriteAttr("gg", "n");
  
  var layout = options['layout'];
  if(layout == "sliceAndDiceHorizontal")
    ret += this.WriteAttr("layout", "h");
  else if(layout == "sliceAndDiceVertical")
    ret += this.WriteAttr("layout", "v");
    
  var animationOnDisplay = options['animationOnDisplay'];
  if(animationOnDisplay == "auto")
    ret += this.WriteAttr("adi", "alphaFade"); 
  else
    ret += this.WriteAttr("adi", animationOnDisplay); 
  
  return ret;
}

/** @override **/
DvtTreemapJsonUtils.prototype.WriteNodeAttributes = function(options, nodeData) {
  var ret = DvtTreemapJsonUtils.superclass.WriteNodeAttributes.call(this, options, nodeData);
  
  var labelDisplay = nodeData['labelDisplay'] ? nodeData['labelDisplay'] : options['nodeDefaults']['labelDisplay'];
  if(labelDisplay == "off")
    ret += this.WriteAttr("ld", "o");
  
  var groupLabelDisplay = nodeData['groupLabelDisplay'] ? nodeData['groupLabelDisplay'] : options['nodeDefaults']['groupLabelDisplay'];
  if(groupLabelDisplay == "node")
    ret += this.WriteAttr("gld", "n");
  else if(groupLabelDisplay == "off")
    ret += this.WriteAttr("gld", "o");
  
  var labelHalign = nodeData['labelHalign'] ? nodeData['labelHalign'] : options['nodeDefaults']['labelHalign'];
  if(labelHalign == "start")
    ret += this.WriteAttr("ha", "s");
  else if(labelHalign == "end")
    ret += this.WriteAttr("ha", "e");
    
  var labelValign = nodeData['labelValign'] ? nodeData['labelValign'] : options['nodeDefaults']['labelValign'];
  if(labelValign == "top")
    ret += this.WriteAttr("va", "t");
  else if(labelValign == "bottom")
    ret += this.WriteAttr("va", "b");
    
  // Header Properties  
  var header = nodeData['header'];
  
  var labelStyle = header && header['labelStyle'] ? header['labelStyle'] : options['nodeDefaults']['header']['labelStyle'];
  ret += this.WriteAttr("hls", labelStyle);
  
  var headerHalign = header && header['labelHalign'] ? header['labelHalign'] : options['nodeDefaults']['header']['labelHalign'];
  if(headerHalign == "center")
    ret += this.WriteAttr("hha", "c");
  else if(headerHalign == "end")
    ret += this.WriteAttr("hha", "e");
  
  var isolate = header && header['isolate'] ? header['isolate'] : options['nodeDefaults']['header']['isolate'];
  if(isolate == "off")
    ret += this.WriteAttr("hi", "off"); 
  
  var useNodeColor = header && header['useNodeColor'] ? header['useNodeColor'] : options['nodeDefaults']['header']['useNodeColor'];
  if(useNodeColor == "on")
    ret += this.WriteAttr("unc", "on"); 
  
  return ret;
}

/** @override **/
DvtTreemapJsonUtils.prototype.WriteResourcesElement = function(options) {
  var ret = '<resources';
  
  // Translations
  var bundle = new DvtTreemapBundle();
  ret += this.WriteAttr("legendSize", bundle.getTranslatedString('SIZE'));
  ret += this.WriteAttr("legendColor", bundle.getTranslatedString('COLOR'));
  
  // Image Resources  
  var resources = options['_resources'];
  var bRtl = DvtAgent.isRightToLeft(this._context);
  var bImageSuffix = bRtl ? "Rtl" : "";
  ret += this.WriteAttr("maximizeUp", resources['isolate' + bImageSuffix]);
  ret += this.WriteAttr("maximizeDown", resources['isolateDown' + bImageSuffix]);
  ret += this.WriteAttr("maximizeOver", resources['isolateOver' + bImageSuffix]);
  ret += this.WriteAttr("restoreUp", resources['restore' + bImageSuffix]);
  ret += this.WriteAttr("restoreDown", resources['restoreDown' + bImageSuffix]);
  ret += this.WriteAttr("restoreOver", resources['restoreOver' + bImageSuffix]);
  
  // Alta Behavior
  ret += this.WriteAttr("alta", "true");
  
  ret += '/>\n';
  return ret;
}

/** @override **/
DvtTreemapJsonUtils.prototype.WriteStyleElement = function(options) {
  var ret = DvtTreemapJsonUtils.superclass.WriteStyleElement.call(this, options);
  
  var animationColor = options["animationUpdateColor"];
  if(animationColor)
    ret += this.WriteAttr("top", "-tr-animation-update-color: " + animationColor);
  
  var nodeHoverColor = options['nodeDefaults']["hoverColor"];
  if(nodeHoverColor) 
    ret += this.WriteAttr("node-hover", "border-color: " + nodeHoverColor);
    
  var nodeSelectedInnerColor = options['nodeDefaults']["selectedInnerColor"];
  var nodeSelectedOuterColor = options['nodeDefaults']["selectedOuterColor"];
  var nodeSelectedStr = nodeSelectedInnerColor ? DvtCSSStyle.INNER_COLOR + ':' + nodeSelectedInnerColor + ";": "";
  nodeSelectedStr += nodeSelectedOuterColor ? DvtCSSStyle.OUTER_COLOR + ':' + nodeSelectedOuterColor : "";
  if(nodeSelectedStr)
    ret += this.WriteAttr("node-selected", nodeSelectedStr);
  
  var nodeHeaderBackgroundColor = options['nodeDefaults']["header"]["backgroundColor"];
  var nodeHeaderBorderColor = options['nodeDefaults']["header"]["borderColor"];
  var nodeHeaderStr = nodeHeaderBackgroundColor ? "background-color:" + nodeHeaderBackgroundColor + ";": "";
  nodeHeaderStr += nodeHeaderBorderColor ? "border-color:" + nodeHeaderBorderColor : "";
  if(nodeHeaderStr)
    ret += this.WriteAttr("nodeHeader", nodeHeaderStr);
  
  var nodeHeaderHoverInnerColor = options['nodeDefaults']["header"]["hoverInnerColor"];
  var nodeHeaderHoverOuterColor = options['nodeDefaults']["header"]["hoverOuterColor"];
  var nodeHeaderHoverStr = nodeHeaderHoverInnerColor ? DvtCSSStyle.INNER_COLOR + ':' + nodeHeaderHoverInnerColor + ";": "";
  nodeHeaderHoverStr += nodeHeaderHoverOuterColor ? DvtCSSStyle.OUTER_COLOR + ':' + nodeHeaderHoverOuterColor : "";
  if(nodeHeaderHoverStr)
    ret += this.WriteAttr("nodeHeader-hover", nodeHeaderHoverStr);
  
  var nodeHeaderSelectedInnerColor = options['nodeDefaults']["header"]["selectedInnerColor"];
  var nodeHeaderSelectedOuterColor = options['nodeDefaults']["header"]["selectedOuterColor"];
  var nodeHeaderSelectedStr = nodeHeaderSelectedInnerColor ? DvtCSSStyle.INNER_COLOR + ':' + nodeHeaderSelectedInnerColor + ";": "";
  nodeHeaderSelectedStr += nodeHeaderSelectedOuterColor ? DvtCSSStyle.OUTER_COLOR + ':' + nodeHeaderSelectedOuterColor : "";
  if(nodeHeaderSelectedStr)
    ret += this.WriteAttr("nodeHeader-selected", nodeHeaderSelectedStr);
  
  ret += "/>\n";
  return ret;
}
/**
 * A component level sunburst rotation event.
 * @param {number} startAngle The start angle of the sunburst, in degrees.
 * @param {boolean} bComplete True if the value change interaction is complete.
 * @class
 * @constructor
 * @export
 */
var DvtSunburstRotationEvent = function(startAngle, bComplete) {
  var type = (bComplete === false) ? DvtSunburstRotationEvent.TYPE_INPUT : DvtSunburstRotationEvent.TYPE;
  this.Init(type);
  this._startAngle = startAngle;
}

DvtObj.createSubclass(DvtSunburstRotationEvent, DvtBaseComponentEvent, "DvtSunburstRotationEvent");

/**
 * @export
 */
DvtSunburstRotationEvent.TYPE = "sunburstRotation";

/**
 * @export
 */
DvtSunburstRotationEvent.TYPE_INPUT = "sunburstRotationInput";


/**
 * Returns the start angle of the sunburst, in degrees.
 * @return {number} The start angle of the sunburst, in degrees.
 * @export
 */
DvtSunburstRotationEvent.prototype.getStartAngle = function() {
  return this._startAngle;
}
/**
 * @constructor
 * Sunburst component.
 * @param {DvtContext} context The rendering context.
 * @param {object} callback The function that should be called to dispatch component events.
 * @param {object} callbackObj The object context for the callback function
 * @class Sunburst component.
 * @extends {DvtBaseTreeView}
 */
var DvtBaseSunburst = function(context, callback, callbackObj) {
  this.Init(context, callback, callbackObj);
}

// Make DvtBaseSunburst a subclass of DvtBaseTreeView
DvtObj.createSubclass(DvtBaseSunburst, DvtBaseTreeView, "DvtBaseSunburst");

DvtBaseSunburst._ROTATION_SHAPE_RADIUS = 15; // size of additional radius for mouse rotation detection
DvtBaseSunburst._ROTATION_SHAPE_RADIUS_TOUCH = 60; // size of additional radius for mouse rotation detection
DvtBaseSunburst._ANIMATION_TYPE_FAN = "fan";
DvtBaseSunburst._BACKGROUND_INLINE_DEFAULT = "";

// Layout Constants
DvtBaseSunburst._BUFFER_SPACE = 3;
DvtBaseSunburst._MIN_BUFFER_SPACE = 2; // Minimum buffer for very small sunbursts

/**
 * @override
 */
DvtBaseSunburst.prototype.Init = function(context, callback, callbackObj) {
  DvtBaseSunburst.superclass.Init.call(this, context, callback, callbackObj);
  
  // Create the defaults object
  this.Defaults = new DvtSunburstDefaults();
  
  // Initialize the angle extent, which may be changed during animation
  this._angleExtent = 2*Math.PI;
}

/**
 * @override
 */
DvtBaseSunburst.prototype.Parse = function(xmlString) {
  var parser = new DvtSunburstParser(this);
  return parser.parse(xmlString);
}

/**
 * @override
 */
DvtBaseSunburst.prototype.ApplyParsedProperties = function(props) {
  DvtBaseSunburst.superclass.ApplyParsedProperties.call(this, props);
  
  this._rotation = props.rotation;
  if (DvtAgent.isPlatformIE()) { 
    //bug fix 14768708 -- ie doesn't support cursor image positioning
    this._rotateCursor = "url(" + this.__getResources().cursorRotate + "), auto";
  } else {
    this._rotateCursor = "url(" + this.__getResources().cursorRotate + ") 8 8, auto";  
  }
  
  // Calculate the start angle.  Use a value from -PI to PI
  this._startAngle = ((360-props.startAngle) * DvtSunburstNode.TWO_PI/360);
  if(this._startAngle > Math.PI)
    this._startAngle -= DvtSunburstNode.TWO_PI;
}

/**
 * @override
 */
DvtBaseSunburst.prototype.Layout = function(availSpace) {
  // Update available space
  var bufferSpace = Math.max(Math.ceil(DvtBaseSunburst._BUFFER_SPACE * Math.min(availSpace.w, availSpace.h)/400), DvtBaseSunburst._MIN_BUFFER_SPACE);
  availSpace.x += bufferSpace;
  availSpace.y += bufferSpace;
  availSpace.w -= 2*bufferSpace;
  availSpace.h -= 2*bufferSpace;
  
  // Layout legend and breadcrumbs
  this.LayoutBreadcrumbs(availSpace);
  this.LayoutLegend(availSpace);

  // Calculate the radius and total depth first
  this._totalRadius = Math.floor(Math.min(availSpace.w, availSpace.h)/2);
  
  // Layout the nodes
  if(this._root)
    DvtSunburstLayout.layout(this._totalRadius, this._root, this._startAngle, this._angleExtent, this.Sorting);
}

/**
 * @override
 */
DvtBaseSunburst.prototype.Render = function(container, bounds) {
  // Background
  this.RenderBackground(container, DvtBaseSunburst._BACKGROUND_INLINE_DEFAULT);

  // Breadcrumbs
  this.RenderBreadcrumbs(container);
  
  // Legend
  this.RenderLegend(container);
  
  // Calculate the center of the sunburst
  this._translatePt = new DvtPoint(bounds.x + bounds.w/2, bounds.y + bounds.h/2);
  
  // Rotation Support
  if(this.__isRotationEnabled() && this.HasValidData()) {
    var buffer = (DvtAgent.isTouchDevice()) ? DvtBaseSunburst._ROTATION_SHAPE_RADIUS_TOUCH : DvtBaseSunburst._ROTATION_SHAPE_RADIUS;
    var rotationShape = new DvtCircle(this.getCtx(), bounds.x + bounds.w/2, bounds.y + bounds.h/2, this._totalRadius + buffer);
    rotationShape.setInvisibleFill();
    rotationShape.setCursor(this._rotateCursor);
    container.addChild(rotationShape);
    
    // Associate for event handling
    this.__getEventManager().associate(rotationShape, new DvtBaseTreePeer(null, DvtSunburstEventManager.ROTATION_ID));
  }
  
  // Create a node container, which will contain all nodes.
  var nodeContainer = new DvtContainer(this.getCtx());
  // Translate to center, since all nodes are drawn at (0,0)
  nodeContainer.setTranslate(this._translatePt.x, this._translatePt.y);
  container.addChild(nodeContainer);
  
  if(this.HasValidData()) {
    // Render the nodes. This creates the shape objects, but does not render them yet.
    var nodeLayer = new DvtContainer(this.getCtx());
    nodeContainer.addChild(nodeLayer);
    this._root.render(nodeLayer);
    
    // Create a group for selected nodes
    this._selectedLayer = new DvtContainer(this.getCtx());
    nodeContainer.addChild(this._selectedLayer);
    
    // Prepare the hover effect
    this._hoverLayer = new DvtContainer(this.getCtx());
    nodeContainer.addChild(this._hoverLayer);
  }
  else {
    // Display the empty text message
    this.RenderEmptyText(container);   
  }
}

/**
 * @override
 */
DvtBaseSunburst.prototype.CreateEventManager = function(view, context, callback, callbackObj)
{
  return new DvtSunburstEventManager(view, context, callback, callbackObj);
}

/**
 * @override
 */
DvtBaseSunburst.prototype.GetDisplayAnimation = function(container, bounds) {
  if(this.AnimationOnDisplay === DvtBaseSunburst._ANIMATION_TYPE_FAN && this.HasValidData()) { 
    // Set up the initial state
    this._animateAngleExtent(0);
    
    // Create and return the animation
    var anim = new DvtCustomAnimation(this.getCtx(), this, this.AnimationDuration);
    anim.getAnimator().addProp(DvtAnimator.TYPE_NUMBER, this, this._getAngleExtent, this._animateAngleExtent, 2*Math.PI);
    return anim;
  }
  else
    return DvtBaseSunburst.superclass.GetDisplayAnimation.call(this, container, bounds);
}

/**
 * @override
 */
DvtBaseSunburst.prototype.GetDeleteContainer = function() {
  var ret = DvtBaseSunburst.superclass.GetDeleteContainer.call(this);
  if(ret) {
    ret.setTranslate(this._translatePt.x, this._translatePt.y);
  }
  return ret;
}

/**
 * Hook for cleaning up animation behavior at the end of the animation.
 * @override
 */
DvtBaseSunburst.prototype.OnAnimationEnd = function() {
  // Before the animation, the treemap nodes will remove their bevels and selection
  // effects.  If the animation is complete (and not stopped), then rerender to restore.
  if(!this.AnimationStopped) {
    this._container.removeChildren();
    
    // Finally, re-layout and render the component
    var availSpace = new DvtRectangle(0, 0, this.Width, this.Height);
    this.Layout(availSpace); 
    this.Render(this._container, availSpace);
    
    // Reselect the nodes using the selection handler's state
    var selectedNodes = this._selectionHandler ? this._selectionHandler.getSelection() : new Array();
    for(var i=0; i<selectedNodes.length; i++)
      selectedNodes[i].setSelected(true);
  }
  
  // Delegate to the superclass to clear common things
  DvtBaseSunburst.superclass.OnAnimationEnd.call(this);
}

/**
 * Moves the specified object to the selected layer, above the non-selected objects.
 * @param {DvtDisplayable} displayable The object to be moved.
 */
DvtBaseSunburst.prototype.__moveToHoverLayer = function(displayable) {
  // Move the object to the hover layer
  this._hoverLayer.addChild(displayable);
}

/**
 * Moves the specified object to the selected layer, above the non-selected objects.
 * @param {DvtDisplayable} displayable The object to be moved.
 */
DvtBaseSunburst.prototype.__moveToSelectedLayer = function(displayable) {
  // Move the object to the selected layer
  this._selectedLayer.addChild(displayable);
  
  // Also reapply the shadow.  Use a clone since the object is static and may be used elsewhere in the page.
  if(!DvtAgent.isBrowserSafari()) { //bug 15893527 -- filter is supported in Safari 6. but causes errors
    this._selectedLayer.removeAllDrawEffects();
    this._selectedLayer.addDrawEffect(DvtBaseTreeNode.__NODE_SELECTED_SHADOW);
  }
}

/**
 * Returns the angle extent of the entire sunburst, for use in animating the sunburst.
 * @return {number} angleExtent The angle extent of the entire sunburst.
 * @private
 */
DvtBaseSunburst.prototype._getAngleExtent = function() {
  return this._angleExtent;
}

/**
 * Animates the angle extent of the sunburst to the specified value.
 * @param {number} extent The new angle extent.
 * @private
 */
DvtBaseSunburst.prototype._animateAngleExtent = function(extent) {
  // Steps: Update the field, relayout the sunburst, update the shapes.
  this._angleExtent = extent;
  
  var bounds = new DvtRectangle(0, 0, this.Width, this.Height);
  this.Layout(bounds);
  if(this._root)
    this._root.updateShapes(true);
}

/**
 * Initiates the rotation from the specified coordinates.  This call establishes a rotation
 * anchor which determines the amount of rotation performed.
 * @param {number} mouseX The x coordinate of the rotation anchor.
 * @param {number} mouseY The y coordinate of the rotation anchor.
 */
DvtBaseSunburst.prototype.__startRotation = function(mouseX, mouseY) {
  this.__setRotationAnchor(this._calcAngle(mouseX, mouseY));
}

/**
 * Sets the rotation anchor for the Sunburst.
 * @param {number} angle The rotation anchor, in radians
 */
DvtBaseSunburst.prototype.__setRotationAnchor = function(angle) {
  // Store the angle at which the rotation started
  this._currentAngle = angle;

  // Apply a mask to show cursor and prevent interaction on nodes
  this._rotationMask = new DvtRect(this.getCtx(), 0, 0, this.Width, this.Height);
  this._rotationMask.setInvisibleFill();
  this._rotationMask.setCursor(this._rotateCursor);
  this.addChild(this._rotationMask);
  
  // Associate for event handling
  this.__getEventManager().associate(this._rotationMask, new DvtBaseTreePeer(null, DvtSunburstEventManager.ROTATION_ID));
}

/**
 * Continues the rotation at the specified coordinates.
 * @param {number} mouseX The new x coordinate of the rotation anchor.
 * @param {number} mouseY The new y coordinate of the rotation anchor.
 */
DvtBaseSunburst.prototype.__continueRotation = function(mouseX, mouseY) {
  this.__rotate(this._calcAngle(mouseX, mouseY));
}

/**
 * Continues the rotation at the specified angle
 * @param {number} newAngle The new value of the rotation anchor, in radians
 */
DvtBaseSunburst.prototype.__rotate = function(newAngle) {
  // Calculate and update the angle of the component
  var change = newAngle - this._currentAngle;
  this._currentAngle = newAngle;
  this._updateStartAngle(change);
    
  // Fire the intermediate rotation event
  var degrees = 360 - Math.round(this._startAngle * 180/Math.PI);
  this.__dispatchEvent(new DvtSunburstRotationEvent(degrees, false));
}

/**
 * Completes the rotation.
 */
DvtBaseSunburst.prototype.__endRotation = function() {
  // Clear flags
  this._currentAngle = null;

  // Remove the rotation mask
  this.removeChild(this._rotationMask);
  this._rotationMask = null;
  
  // Fire events to update ADF state, convert to degrees API (reversed from SVG)
  var degrees = 360 - Math.round(this._startAngle * 180/Math.PI);
  this.__dispatchEvent(new DvtSunburstRotationEvent(degrees, false));
  this.__dispatchEvent(new DvtSunburstRotationEvent(degrees, true));
}

/**
 * Applies the updated disclosure to the node and re-renders.
 * @param {DvtSunburstNode} node The node to expand or collapse.
 * @param {boolean} bDisclosed The new disclosure state of the node's children.
 */
DvtBaseSunburst.prototype.__expandCollapseNode = function(node, bDisclosed) {
  // after the expand/collapse completes, set keyboard focus on the node on which 
  // the expand or collapse was applied to
  this.__setNavigableIdToFocus(node.getId());

  if(bDisclosed) // Expand
    this.__dispatchEvent(new DvtSunburstExpandCollapseEvent(DvtSunburstExpandCollapseEvent.TYPE_EXPAND, node.getId()));
  else { 
    // Collapse: Collapse is handled within the component by updating the xml and
    // re-rendering.  The event is fired to the peer, which will keep track of the
    // state and send a server event if a listener is registered.
    var xml = DvtBaseTreeParser.applyDisclosure(this.LastXml, node.getId(), false);
    this.render(xml, this.Width, this.Height);
    this.__dispatchEvent(new DvtSunburstExpandCollapseEvent(DvtSunburstExpandCollapseEvent.TYPE_COLLAPSE, node.getId()));
  }
}

/**
 * Calculates the angle for the specified coordinates.
 * @param {number} x
 * @param {number} y
 * @return {number} The angle in radians.
 */
DvtBaseSunburst.prototype._calcAngle = function(x, y) {
  return Math.atan2(y - this._translatePt.y, x - this._translatePt.x); 
}

/**
 * Updates the start angle by the specified amount.
 * @param {number} change The change in start angle, in radians.
 * @private
 */
DvtBaseSunburst.prototype._updateStartAngle = function(change) {
  // Update start angle and constrain to -PI to PI
  this._startAngle += change;
  if(this._startAngle < -Math.PI)
    this._startAngle += 2*Math.PI;
  else if(this._startAngle > Math.PI)
    this._startAngle -= 2*Math.PI;
  
  // Relayout and update shapes
  var bounds = new DvtRectangle(0, 0, this.Width, this.Height);
  this.Layout(bounds);
  if(this._root)
    this._root.updateShapes(true);
}

/**
 * @override
 */
DvtBaseSunburst.prototype.__getNodeUnderPoint = function(x, y) {
  return this._root.getNodeUnderPoint(x - this._translatePt.x, y - this._translatePt.y);
}

/**
 * @override
 */
DvtBaseSunburst.prototype.__showDropSiteFeedback = function(node) {
  var feedback = DvtBaseSunburst.superclass.__showDropSiteFeedback.call(this, node);
  if(feedback) {
    feedback.setTranslate(this._translatePt.x, this._translatePt.y);
  }
  
  return feedback;
}

/**
 * Returns true if Sunburst rotation is enabled
 * @return {Boolean} true if rotation is enabled, false otherwise
 */
DvtBaseSunburst.prototype.__isRotationEnabled = function() 
{
  return this._rotation == "on";
}

DvtBaseSunburst.prototype.getShapesForViewSwitcher = function(bOld) {
  var shapes = {};
  if (this._root) {
    var arNodes = [this._root];
    while (arNodes.length > 0) {
      var node = arNodes.splice(0, 1)[0];
      var id = node.getId();
      var shape = node.getDisplayable();
      if (id && shape) {
        shapes[id] = shape;
        shapes[id + "_text"] = node._text;
        
        //flatten hierarchical structure of nodes so that they animate independently
        if (bOld) {
          var parent = shape.getParent();
          if (parent) {
            var childIndex = parent.getChildIndex(shape);
            parent.addChildAt(node._text, childIndex + 1);
          }
        }
      }
      
      var children = node.getChildNodes();
      if (children) {
        arNodes = arNodes.concat(children);
      }
    }
  }
  return shapes;
};
/**
 * Sunburst component.  This component should never be instantiated directly.  Use the
 * newInstance function instead.
 * @class
 * @constructor
 * @extends {DvtBaseSunburst}
 * @export
 */
var DvtSunburst = function() {}

DvtObj.createSubclass(DvtSunburst, DvtBaseSunburst, "DvtSunburst");

/**
 * Returns a new instance of DvtSunburst.
 * @param {DvtContext} context The rendering context.
 * @param {string} callback The function that should be called to dispatch component events.
 * @param {object} callbackObj The optional object instance on which the callback function is defined.
 * @return {DvtSunburst}
 * @export
 */
DvtSunburst.newInstance = function(context, callback, callbackObj) {
  var component = new DvtSunburst();
  component.Init(context, callback, callbackObj);
  return component;
}

/**
 * Returns a copy of the default options for the specified skin.
 * @param {string} skin The skin whose defaults are being returned.
 * @return {object} The object containing defaults for this component.
 * @export
 */
DvtSunburst.getDefaults = function(skin) 
{  
  return (new DvtSunburstDefaults()).getDefaults(skin);
}

/**
 * @override
 * @export
 */
DvtSunburst.prototype.render = function(options, width, height) 
{  
  // Update if a new options object has been provided or initialize with defaults if needed.
  if(options) {
    this.Options = this.Defaults.calcOptions(options);
  
    // Disable animation for canvas and xml
    if (!DvtAgent.isEnvironmentBrowser()) {
      this.Options['animationOnDisplay']    = 'none';
      this.Options['animationOnDataChange'] = 'none';
    }
  }
  else if(!this.Options)
    this.Options = this.GetDefaults();
 
  // Convert the options object into XML
  var xmlString = (new DvtSunburstJsonUtils()).toXml(this.Options);

  // Call superclass with the xmlString to render
  DvtSunburst.superclass.render.call(this, xmlString, width, height);
}
/**
 * Sunburst XML Parser
 * @param {DvtSunburst} sunburst The owning sunburst component.
 * @class
 * @constructor
 * @extends {DvtBaseTreeParser}
 */
var DvtSunburstParser = function(sunburst) {
  this.Init(sunburst);
}

// Make DvtSunburstParser a subclass of DvtBaseTreeParser
DvtObj.createSubclass(DvtSunburstParser, DvtBaseTreeParser, "DvtSunburstParser");

// Top Level Attributes
DvtSunburstParser.ATTR_ROTATION = "r";
DvtSunburstParser.ATTR_START_ANGLE = "sa";

// Node Attributes
DvtSunburstParser.ATTR_LABEL_H_ALIGN = "ha";
DvtSunburstParser.ATTR_RADIUS = "r";

/**
 * @override
 */
DvtSunburstParser.prototype.CreateNode = function(treeView, props, templates) {
  return new DvtSunburstNode(treeView, props, templates);
}

/**
 * @override
 */
DvtSunburstParser.prototype.ParseRootAttributes = function(xmlNode) {
  // The object that will be populated with parsed values and returned
  var ret = DvtSunburstParser.superclass.ParseRootAttributes.call(this, xmlNode);
  ret.rotation = xmlNode.getAttr(DvtSunburstParser.ATTR_ROTATION);
  
  // Start angle defaults to 90
  ret.startAngle = xmlNode.getAttr(DvtSunburstParser.ATTR_START_ANGLE);
  if(ret.startAngle === null || isNaN(ret.startAngle))
    ret.startAngle = 90;
  
  return ret;
}

/**
 * @override
 */
DvtSunburstParser.prototype.ParseNodeAttributes = function(xmlNode) {
  // The object that will be populated with parsed values and returned
  var ret = DvtSunburstParser.superclass.ParseNodeAttributes.call(this, xmlNode);
  
  // Parse this node's properties
  ret.labelHalign = xmlNode.getAttr(DvtSunburstParser.ATTR_LABEL_H_ALIGN);
  ret.radius = xmlNode.getAttr(DvtSunburstParser.ATTR_RADIUS);
  
  return ret;
}

/**
 * @override
 */
DvtSunburstParser.prototype.ParseAdditionalNodeStyles = function(nodeStyle, nodeHoverStyle, nodeSelectedStyle, styles) {
  styles[DvtSunburstNode.NODE_DEFAULT_COLOR_STYLE] = nodeStyle.getStyle("border-color");
  styles[DvtSunburstNode.NODE_HOVER_COLOR_STYLE] = nodeHoverStyle.getStyle("border-color");
  styles[DvtSunburstNode.NODE_SELECTED_INNER_COLOR_STYLE] = nodeSelectedStyle.getStyle("-tr-inner-color");
  styles[DvtSunburstNode.NODE_SELECTED_OUTER_COLOR_STYLE] = nodeSelectedStyle.getStyle("-tr-outer-color");
}
/**
 * Class representing a sunburst node.
 * @param {DvtSunburst} sunburst The owning sunburst component.
 * @param {object} props The properties for the node.
 * @class 
 * @constructor
 * @extends {DvtBaseTreeNode}
 * @implements {DvtKeyboardNavigable}
 */
var DvtSunburstNode = function(sunburst, props, templates) 
{
  this.Init(sunburst, props, templates);
  this._labelDisplay = props.labelDisplay ? props.labelDisplay : 'auto';
  this._labelHalign = props.labelHalign;
  this._radius = props.radius;
}

// Make DvtSunburstNode a subclass of DvtBaseTreeNode
DvtObj.createSubclass(DvtSunburstNode, DvtBaseTreeNode, "DvtSunburstNode");

// Text style options
DvtSunburstNode.LABEL_ALIGN_START  = "s";
DvtSunburstNode.LABEL_ALIGN_END    = "e";

// LAF Constants
DvtSunburstNode._DEFAULT_NODE_STROKE_COLOR = "#FFFFFF";
DvtSunburstNode._NODE_SELECTED_INNER_STROKE_COLOR = "#FFFFFF";
DvtSunburstNode._NODE_SELECTED_OUTER_STROKE_COLOR = "#000000";
DvtSunburstNode._NODE_HOVER_STROKE_COLOR = "#FFFFFF";

DvtSunburstNode.TEXT_BUFFER_HORIZ = 6; // Total buffer for both sides
DvtSunburstNode._EXPAND_ICON_SIZE = 16;
DvtSunburstNode.ROOT_NODE_MARGIN = 2;

// Constant for efficiency
DvtSunburstNode.TWO_PI = (Math.PI*2);

// Styles
DvtSunburstNode.NODE_DEFAULT_COLOR_STYLE = "NODE_DEFAULT_COLOR_STYLE";
DvtSunburstNode.NODE_HOVER_COLOR_STYLE = "NODE_HOVER_COLOR_STYLE";
DvtSunburstNode.NODE_SELECTED_INNER_COLOR_STYLE = "NODE_SELECTED_INNER_COLOR_STYLE";
DvtSunburstNode.NODE_SELECTED_OUTER_COLOR_STYLE = "NODE_SELECTED_OUTER_COLOR_STYLE";

// Relative radius of the center node compared to the other layers
DvtSunburstNode._CENTER_ARTIFICIAL_ROOT_RADIUS = 0.25;
DvtSunburstNode._CENTER_NODE_RADIUS = 0.5;
DvtSunburstNode._CENTER_WITH_CONTENT_RADIUS = 1.0;

//**************** Begin Overridden Functions ***************//

/**
 * @override
 */
DvtSunburstNode.prototype.render = function(container) {
  // If not positioned, don't render
  if(!this._hasLayout)
    return;

  // Keep a reference to the container, for use after z-order changes
  this._nodeContainer = container;
  
  // Create the shape object
  this._shape = this._createShapeNode();
  container.addChild(this._shape);

  var template = this.GetTemplate();

  // render root content facet??
  if (this._showRootContent() && template) {

    var sqrt2 = Math.sqrt(2);
    var aw = this._outerRadius * sqrt2 - 2 * DvtSunburstNode.ROOT_NODE_MARGIN;
    var ah = aw;

    this._x = - this._outerRadius / sqrt2 + DvtSunburstNode.ROOT_NODE_MARGIN;
    this._y = - this._outerRadius / sqrt2 + DvtSunburstNode.ROOT_NODE_MARGIN;

    var elAttrs = this.GetElAttributes();
    var afContext = this.GetAfContext();
    afContext.setELContext(elAttrs);

    if (aw > 0 && ah > 0) {
      afContext.setAvailableWidth(aw);
      afContext.setAvailableHeight(ah);
      afContext.setFontSize(this.GetTextSize());
//     this._contentRoot = DvtAfComponentFactory.parseAndStamp(afContext, template, this._shape);
      var afRoot = DvtAfComponentFactory.parseAndLayout(afContext, template, this._shape);
      this._contentRoot = afRoot;

      var dims = afRoot.getDimensions();
      afRoot.setTranslate(this._x + (aw - dims.w)/2, this._y + (ah - dims.h)/2);
    }
  }
  else {
    // Create the text object
    this._text = this._createTextNode(this._shape); 
    if(this._text != null) {
      this._shape.addChild(this._text);
    
      // For pattern nodes, add a background to make the text readable
      if(this._pattern) {
        var dims = this._text.measureDimensions();
        this._textBackground = new DvtRect(this.getView().getCtx(), dims.x, dims.y, dims.w, dims.h);
        this._textBackground.setSolidFill("#FFFFFF");
        this._textBackground.setMouseEnabled(false);
        this._shape.addChild(this._textBackground);
        
        // Add the transform for rotated text
        var matrix = this._text.getMatrix();
        if(!matrix.isIdentity())
          this._textBackground.setMatrix(matrix);
      
        // Reorder the text in front of the background rect
        this._shape.addChild(this._text);
      }
    }
  }
  
  // WAI-ARIA
  this._shape.setAriaRole('img');
  this._shape.setAriaProperty('label', this._datatip);
  
  // Create the container for the children and render
  this.renderChildren(container);
}

/**
 * @override
 */
DvtSunburstNode.prototype.setSelected = function(selected) {
  if(this.Selectable == "off")
    return;
    
  // Delegate to super to store the state
  DvtSunburstNode.superclass.setSelected.call(this, selected);  
  
  // Update the visual feedback
  if(this.isSelected()) {
    // Apply the selection effect to the shape
    this._shape.setSelected(true);
  
    // Move to the front of the z-order
    this.getView().__moveToSelectedLayer(this._shape);
  }
  else {
    // Restore the regular effect to the shape
    this._shape.setSelected(false);
  
    // Restore the z-order
    if(this._nodeContainer)
      this._nodeContainer.addChild(this._shape);
  }
}

/**
 * @override
 */
DvtSunburstNode.prototype.showHoverEffect = function() {
  if(!this._shape || !this._hasLayout)
    return;
  
  // Apply the hover effect
  this._shape.showHoverEffect();
  
  // Show the hover effect as an overlay
  if(this.isSelected()) {
    // Move to the front of the selected layer 
    this.getView().__moveToSelectedLayer(this._shape);
  }
  else {
    // Unselected nodes get moved to the hover layer
    this.getView().__moveToHoverLayer(this._shape);
  }
}

/**
 * @override
 */
DvtSunburstNode.prototype.hideHoverEffect = function() {
  // Don't continue if the shape isn't defined or if the node is currently focused by the keyboard.
  if(!this._shape || !this._hasLayout || this.isShowingKeyboardFocusEffect())
    return;
  
  // Hide the hover effect
  this._shape.hideHoverEffect();
  
  // Restore the z-order
  if(!this.isSelected() && this._nodeContainer)
    this._nodeContainer.addChild(this._shape);
}

/**
 * Returns true if expand/collapse is enabled for this node.
 * @return {boolean}
 */
DvtSunburstNode.prototype.isExpandCollapseEnabled = function() {
  return this._drilling == "i" || this._drilling == "ir";
}

/**
 * @override
 */
DvtSunburstNode.prototype.getNextNavigable = function(event) 
{
  var keyCode;
  var next;
  var navigables;
  var idx;
  var root;
 
  if(event.type == DvtMouseEvent.CLICK)
  {
    return DvtSunburstNode.superclass.getNextNavigable.call(this, event);
  }

  keyCode = event.keyCode;
 
  if(keyCode == DvtKeyboardEvent.SPACE && event.ctrlKey)
  {
    // multi-select node with current focus; so we navigate to ourself and then let the selection handler take
    // care of the selection
    return this;
  }

  root = this;
  while(root.GetParent())
  {
    root = root.GetParent();
  }

  navigables = this.GetNodesAtDepth(root, this.GetDepth());
  idx = DvtSunburstNode._findNodeIndex(this, navigables);
  
  var midAngle = this._startAngle + this._angleExtent/2;
  midAngle = DvtSunburstNode._normalizedRadToDeg(midAngle);

  var lastVisitedChild;
  var lastVisitedMidAngle;
  
  switch(keyCode)
  {
    case DvtKeyboardEvent.UP_ARROW:

      // if at root or upper half of sunburst, go to the last visited child if it is in the upper half of the sunburst
      // otherwise use free-form navigation to select the next child in the "up" direction
      if(this === root || midAngle > 180)
      {
        lastVisitedChild = this.GetLastVisitedChild();
        if(lastVisitedChild)
        {
          lastVisitedMidAngle = lastVisitedChild._startAngle + lastVisitedChild._angleExtent/2;
          lastVisitedMidAngle = DvtSunburstNode._normalizedRadToDeg(lastVisitedMidAngle);
          if(lastVisitedMidAngle > 180)
          {
            return lastVisitedChild;
          }
        }
        next = DvtKeyboardHandler.getNextAdjacentNavigable(this, event, this.getDescendantNodes());
      }        
      // lower half of sunburst
      else 
        next = this._navigateToParent();
      
      break;
      
    case DvtKeyboardEvent.DOWN_ARROW:
    
      // if at root or lower half of sunburst, go to the last visited child if it is in the lower half of the sunburst
      // otherwise use free-form navigation to select the next child in the "down" direction
      if(this === root ||  (midAngle >= 0 && midAngle <= 180))
      {
        lastVisitedChild = this.GetLastVisitedChild();
        if(lastVisitedChild)
        {
          lastVisitedMidAngle = lastVisitedChild._startAngle + lastVisitedChild._angleExtent/2;
          lastVisitedMidAngle = DvtSunburstNode._normalizedRadToDeg(lastVisitedMidAngle);
          if(lastVisitedMidAngle >= 0 && lastVisitedMidAngle <= 180)
          {
            return lastVisitedChild;
          }
        }
        next = DvtKeyboardHandler.getNextAdjacentNavigable(this, event, this.getDescendantNodes());
      }
      // upper half of sunburst
      else 
        next = this._navigateToParent();
        
      break;
      
    case DvtKeyboardEvent.LEFT_ARROW:
      if(navigables.length == 1)
      {
        next = this;
      }
      else 
      {
        if(idx == 0)
          next = navigables[navigables.length-1];
        else
          next = navigables[idx - 1];
      }
      break;
      
    case DvtKeyboardEvent.RIGHT_ARROW:
      if(navigables.length == 1)
      {
        next = this;
      }
      else
      {
        if(idx == navigables.length-1)
          next = navigables[0];
        else
          next = navigables[idx + 1];
      }
      break;
      
    default:
      next = this;
      break;        
  }

  next.MarkAsLastVisitedChild();
  
  return next;
}


/**
 * Returns the parent node and updates last visited child state.
 * 
 * @return {DvtSunburstNode} This node's parent, if it is not the root.  Root otherwise
 */
DvtSunburstNode.prototype._navigateToParent = function() 
{
  // move to the parent, if not the root node
  var parent = this.GetParent();
  var next;
  if(parent)
  {
    next = parent;
    // update the grandparent's last visited child to be the current node's parent
    parent.MarkAsLastVisitedChild();
  }
  else
    next = this;     
  
  next.MarkAsLastVisitedChild();
  return next;
}

/**
 * Normalizes an angle to fall between 0 and 360.  0 is the usual 0 degree mark in trigonometry, but angles are
 * measured CLOCKWISE
 * 
 * @param {Number} rad
 * @return {Number} The equivalent angle in degrees
 * @private
 */
DvtSunburstNode._normalizedRadToDeg = function(rad)
{
  var deg = DvtMath.radsToDegrees(rad);
  if(deg<0)
    deg += 360;
  else if(deg>360)
    deg -= 360;
  return deg;
}

/**
 * @override 
 */
DvtSunburstNode.prototype.getKeyboardBoundingBox = function() 
{
  if(this._shape) 
  {
    var bounds = this._shape.getDimensions();
    var point = new DvtPoint(bounds.x, bounds.y);
    point = this._shape.localToStage(point);
    bounds.x = point.x;
    bounds.y = point.y;
    return bounds;
  }  
  else
  {
    return new DvtRectangle(0, 0, 0, 0);
  }
};

/**
 * @override
 */
DvtSunburstNode.prototype.getContextMenuLocation = function()
{
  // returns the coordinate of the midpoint of the arc, along a radius that is the average of the inner and outer radii
  var point = DvtSunburstNode._calcPointOnArc(0.5*(this._outerRadius+this._innerRadius), this._startAngle+this._angleExtent/2); 
  return this._shape.localToStage(point);
}
 
//**************** End Overridden Functions *****************//


/**
 * Sets the result of the layout.
 * @param {number} innerRadius The inner radius of the node.
 * @param {number} outerRadius The outer radius of the node.
 * @param {number} startAngle The starting angle for this node in radians.
 * @param {number} angleExtent The extent of this node in radians.
 */
DvtSunburstNode.prototype.setLayoutParams = function(innerRadius, outerRadius, startAngle, angleExtent) {
  this._innerRadius = innerRadius;  
  this._outerRadius = outerRadius;
  this._startAngle = startAngle;
  this._angleExtent = angleExtent;
  
  // Set a flag indicating layout is done
  this._hasLayout = true;
}

/**
 * @override
 */
DvtSunburstNode.prototype.GetFill = function() {
  if(this.isArtificialRoot())
    return DvtSolidFill.invisibleFill(); // make it as close to invisible as possible
  else
    return DvtSunburstNode.superclass.GetFill.call(this);
}

/**
 * @override
 */
DvtSunburstNode.prototype.GetAnimationParams = function() {
  var r = DvtColorUtils.getRed(this._color);
  var g = DvtColorUtils.getGreen(this._color);
  var b = DvtColorUtils.getBlue(this._color);
  return [this._innerRadius, this._outerRadius, this._startAngle, this._angleExtent, r, g, b];  
}

/**
 * @override
 */
DvtSunburstNode.prototype.SetAnimationParams = function(params) {
  // Update the layout params
  this.setLayoutParams(params[0], params[1], params[2], params[3]);  
  
  // Update the color.  Round them since color parts must be ints
  var r = Math.round(params[4]);
  var g = Math.round(params[5]);
  var b = Math.round(params[6]);
  this._color = DvtColorUtils.makeRGB(r, g, b);
    
  // Update the shapes
  this.updateShapes(false);
}

/**
 * @override
 */
DvtSunburstNode.prototype.animateUpdate = function(handler, oldNode) {
  if(oldNode._hasLayout && oldNode._angleExtent > 0) {
    // Old node existed and was visible, show the update animation
    DvtSunburstNode.superclass.animateUpdate.call(this, handler, oldNode);
  }
  else {
    // Old node did not exist or was not visible, treat as insert
    this.animateInsert(handler);
  }
}

/**
 * @override
 */
DvtSunburstNode.prototype.getNodeUnderPoint = function(x, y) {
  // Check if the node contains the coords
  if(this.contains(x, y)) 
    return this;
  else {
    var childNodes = this.getChildNodes();
    for(var i=0; i<childNodes.length; i++) {
      var ret = childNodes[i].getNodeUnderPoint(x, y);
      if(ret)
        return ret;
    }
  }
  
  // No node found, return null
  return null;
}

/**
 * @override
 */
DvtSunburstNode.prototype.contains = function(x, y) {
  var radius = DvtSunburstNode._calcRadius(x, y);  
  var angle = DvtSunburstNode._calcAngle(x, y);
  return this.ContainsRadius(radius) && this.ContainsAngle(angle);
}


/**
 * Returns true if this node contains the given angle.
 * @param {number} angle An angle in radius between 0 and 2pi.
 * @protected
 */
DvtSunburstNode.prototype.ContainsAngle = function(angle) {
  // The start and end angles may be from -2pi to 2pi. Adjust angle to check.  
  // First adjust angle to be greater than the start angle.
  while(angle < this._startAngle) {
    angle += DvtSunburstNode.TWO_PI;
  }
  // Then adjust to be within 2*PI of it  
  while(angle - this._startAngle > DvtSunburstNode.TWO_PI) {
    angle -= DvtSunburstNode.TWO_PI;
  }

  return (angle >= this._startAngle) && (angle <= this._startAngle + this._angleExtent);
}

/**
 * Returns true if this node contains the given radius.
 * @protected
 */
DvtSunburstNode.prototype.ContainsRadius = function(radius) {
  return (radius >= this._innerRadius) && (radius <= this._outerRadius);
}

/**
 * Returns the location of the point on the arc with the specified radius 
 * at the specified angle.
 * @private
 */
DvtSunburstNode._calcPointOnArc = function(radius, angle) {
  var x = Math.cos(angle) * radius;
  var y = Math.sin(angle) * radius;
  return {x:x, y:y};
}

/**
 * Returns true if this node contains the given bounding box, used for labels.
 * @param {object} bbox The bounding box to check containment for.
 * @param {DvtSunburstNode} node The sunburst node on which to check containment.
 * @private
 */
DvtSunburstNode._containsRect = function(bbox, node) {
  return (node.contains(bbox.x, bbox.y) && node.contains(bbox.x + bbox.w, bbox.y) && 
          node.contains(bbox.x + bbox.w, bbox.y + bbox.h) && node.contains(bbox.x, bbox.y + bbox.h));
}


/**
 * Returns the angle for a point with the specified coordinates 
 * relative to the origin.
 * @param {number} x The x coordinate.
 * @param {number} y The y coordinate.
 * @return {number} The angle for the point with the specified coordinates, in radians.
 * @private
 */
DvtSunburstNode._calcAngle = function(x, y) {
  var angle = Math.atan2(y, x);
  
  // Adjust, since all node angles are between 0 and 2pi
  if(angle < 0)
    angle += DvtSunburstNode.TWO_PI;
  else if(angle > DvtSunburstNode.TWO_PI)
    angle -= DvtSunburstNode.TWO_PI;

  return angle;
}

/**
 * Returns the radius for a point with the specified coordinates 
 * relative to the origin.
 * @param {number} x The x coordinate.
 * @param {number} y The y coordinate.
 * @return {number} The radius for the point with the specified coordinates.
 * @private
 */
DvtSunburstNode._calcRadius = function(x, y) {
  return Math.sqrt((x*x) + (y*y))
}

/**
 * Creates and return the shape element for this node.
 * @return {DvtShape} The shape element for this node.
 * @private
 */
DvtSunburstNode.prototype._createShapeNode = function() {
  // Skip if no angle extent
  if(!this._angleExtent || this._angleExtent <= 0)
    return null;

  // Finally create the shape
  var cmd = this._createPathCmd();
  var shape = new DvtPath(this.getView().getCtx(), cmd);
  
  // Add pointers between this node and the shape
  this.getView().__getEventManager().associate(shape, this);
 
  // Apply style properties
  shape.setAlpha(this.getAlpha());
  shape.setFill(this.GetFill());
  
  // Apply the default, selected, and hover strokes
  var defaultStrokeColor = this.getResolvedColor(DvtSunburstNode._DEFAULT_NODE_STROKE_COLOR, DvtSunburstNode.NODE_DEFAULT_COLOR_STYLE);
  var selectedInnerColor = this.getResolvedColor(DvtSunburstNode._NODE_SELECTED_INNER_STROKE_COLOR, DvtSunburstNode.NODE_SELECTED_INNER_COLOR_STYLE);
  var selectedOuterColor = this.getResolvedColor(DvtSunburstNode._NODE_SELECTED_OUTER_STROKE_COLOR, DvtSunburstNode.NODE_SELECTED_OUTER_COLOR_STYLE);
  var hoverColor = this.getResolvedColor(DvtSunburstNode._NODE_HOVER_STROKE_COLOR, DvtSunburstNode.NODE_HOVER_COLOR_STYLE);
  
  shape.setStroke(new DvtSolidStroke(defaultStrokeColor, 0.3));
  shape.setHoverStroke(new DvtSolidStroke(hoverColor, 1, 3));
  shape.setSelectedStroke(new DvtSolidStroke(selectedInnerColor, 1, 1.5), new DvtSolidStroke(selectedOuterColor, 1, 3.5));
  shape.setSelectedHoverStroke(new DvtSolidStroke(hoverColor, 1, 3));
  
  // Allows selection cursor to be shown over nodes if nodeSelection is enabled and node is selectable
  shape.setSelectable(this.getView().__getNodeSelection() != null && this.Selectable !="off");
  
  // Artificial Root Support: The artificial root is hollow and mouse transparent
  if(this.isArtificialRoot()) {
    shape.setAlpha(0.001);
    shape.setMouseEnabled(false);
  }
    
  return shape;
}

/**
 * Calculates and returns the path command for the current node.
 * @return {string} The path command for the current node.
 * @private
 */
DvtSunburstNode.prototype._createPathCmd = function() {
  var cmd;
  var p1, p2, p3, p4;
  
  if(this._angleExtent < DvtSunburstNode.TWO_PI) 
  {
    // Calc the 4 points.  We will draw:
    // 1. Arc from p1 to p2
    // 2. Line/Move from p2 to p3
    // 3. Arc from p3 to p4
    // 4. Line from p4 to p1    
    p1 = DvtSunburstNode._calcPointOnArc(this._outerRadius, this._startAngle);
    p2 = DvtSunburstNode._calcPointOnArc(this._outerRadius, this._startAngle + this._angleExtent);
    p3 = DvtSunburstNode._calcPointOnArc(this._innerRadius, this._startAngle + this._angleExtent);
    p4 = DvtSunburstNode._calcPointOnArc(this._innerRadius, this._startAngle);
    
    // Create the command and feed it into the path
    cmd = DvtPathUtils.moveTo(p1.x,p1.y) + 
          DvtPathUtils.arcTo(this._outerRadius,this._outerRadius,this._angleExtent,1,p2.x,p2.y) +
          DvtPathUtils.lineTo(p3.x,p3.y) + 
          DvtPathUtils.arcTo(this._innerRadius,this._innerRadius,this._angleExtent,0,p4.x,p4.y) + 
          DvtPathUtils.closePath();
  }
  else 
  {
    // To work around a chrome/safari bug, we draw two segments around each of the outer and inner arcs 
    p1 = DvtSunburstNode._calcPointOnArc(this._outerRadius, this._startAngle);
    p2 = DvtSunburstNode._calcPointOnArc(this._outerRadius, this._startAngle + this._angleExtent/2);
    p3 = DvtSunburstNode._calcPointOnArc(this._innerRadius, this._startAngle);
    p4 = DvtSunburstNode._calcPointOnArc(this._innerRadius, this._startAngle + this._angleExtent/2);
    
    // Create the command and return it
    cmd = DvtPathUtils.moveTo(p1.x,p1.y) + 
          DvtPathUtils.arcTo(this._outerRadius,this._outerRadius,this._angleExtent/2,1,p2.x,p2.y) + 
          DvtPathUtils.arcTo(this._outerRadius,this._outerRadius,this._angleExtent/2,1,p1.x,p1.y);
    
    // Add the inner segment for a hollow center        
    if(this._innerRadius > 0)
      cmd += DvtPathUtils.moveTo(p4.x,p4.y) + 
             DvtPathUtils.arcTo(this._innerRadius,this._innerRadius,this._angleExtent/2,0,p3.x,p3.y) + 
             DvtPathUtils.arcTo(this._innerRadius,this._innerRadius,this._angleExtent/2,0,p4.x,p4.y);
             
    cmd += DvtPathUtils.closePath();
  }
  
  return cmd;
}


/**
 * Creates and positions the expand or collapse button button for this node.
 * @param {DvtContainer} container The container for the button.
 * @return {DvtButton}
 * @private
 */
DvtSunburstNode.prototype._createExpandCollapseButton = function(container) {
  if(!container || !this.isExpandCollapseEnabled())
    return null;

  // Create the button and add to the container
  var button = this._disclosed ? this._getCollapseButton() : this._getExpandButton();
  var center = DvtSunburstNode._calcPointOnArc(this._outerRadius, this._startAngle + this._angleExtent/2);
  button.setTranslate(center.x - DvtSunburstNode._EXPAND_ICON_SIZE/2, center.y - DvtSunburstNode._EXPAND_ICON_SIZE/2);
  container.addChild(button);
    
  // Associate a blank peer so the button is not treated as part of the node
  var tooltip = this._disclosed ? this.getView().__getResources().collapse : this.getView().__getResources().expand;
  this.getView().__getEventManager().associate(button, new DvtBaseTreePeer(this, this.getId(), tooltip));
  
  return button;
}

/**
 * Creates and return the text element for this node.
 * @param {DvtContainer} container The container element.
 * @return {DvtText} The text element for this node. // TODO HZHANG: Why is the text object returned?
 * @private
 */
DvtSunburstNode.prototype._createTextNode = function(container) {
  // If no text or no container to place the text, return
  if(!this._textStr || !container || !this._labelDisplay || this._labelDisplay == 'off')
    return null;
  
  // Determine whether the label is rotated. Rotation is only supported for SVG and XML for now
  var bRotated = false;
  if(this._labelDisplay == 'auto') {
    // If labelDisplay is auto, don't use rotated labels for non-IE on windows, since rotated text does not look good
    // in those browsers.
    if(!DvtAgent.isPlatformIE() && DvtAgent.getOS() == DvtAgent.WINDOWS_OS)
      bRotated = false;
    else
      bRotated = true; 
  }
  else if(this._labelDisplay == 'rotated')
    bRotated = true;
    
  if(bRotated && this._angleExtent < 2*Math.PI)
    return this._createTextRotated(container);
  else
    return this._createTextHoriz(container);
}

/**
 * Creates and returns a horizontal text element for this node.
 * @param {DvtContainer} container The container element.
 * @return {DvtText} The text element for this node.
 * @private
 */
DvtSunburstNode.prototype._createTextHoriz = function(container) {
  var textAnchor;
  if(this._innerRadius == 0) 
    textAnchor = {x:0, y:0};
  else {
    // Calculate the anchor point for the text
    textAnchor = DvtSunburstNode._calcPointOnArc((this._innerRadius + this._outerRadius)/2, this._startAngle + this._angleExtent/2);
    
    // Using the approx width of the text, decide whether the text won't fit
    var approxWidth = 3 * this.GetTextSize()/2;
    var leftAngle = DvtSunburstNode._calcAngle(textAnchor.x - approxWidth/2, textAnchor.y);
    var rightAngle = DvtSunburstNode._calcAngle(textAnchor.x + approxWidth/2, textAnchor.y);
    if(!(this.ContainsAngle(leftAngle) && this.ContainsAngle(rightAngle)))
      textAnchor = null;
  }
  
   // Now create the text
  if(textAnchor) {
    var text = new DvtOutputText(this.getView().getCtx(), this._textStr, textAnchor.x, textAnchor.y, null);
    text.setFontSize(this.GetTextSize());
    this.ApplyLabelTextStyle(text);
    text.alignCenter();
    text.alignMiddle();
    text.setMouseEnabled(false);
    
    // Find the estimated dimensions of the label
    var estimatedDims = DvtTextUtils.guessTextDimensions(text);
    
    // Find the largest rectangle that will fit.  The height is accurate, so we only need to check the width.
    var x1 = textAnchor.x;
    var x2 = textAnchor.x;
    var y1 = textAnchor.y - estimatedDims.h/2;
    var y2 = textAnchor.y + estimatedDims.h/2;
    
    // Calculate the left-most x1 that will fit
    while(this.contains(x1, y1) && this.contains(x1, y2)) {
      x1--;
    }
    
    // Calculate the right-most x2 that will fit
    while(this.contains(x2, y1) && this.contains(x2, y2)) {
      x2++;
    }
    
    // Add a 3-pixel buffer on each side (accounts for the potential extra pixel in the while loop on failed check)
    x1 += 3;
    x2 -= 3;
    
    // Adjust the anchor point to the midpoint of available space if truncation would occur centered at current anchor
    var usableSpace = 2 * Math.min(textAnchor.x-x1, x2-textAnchor.x);
    if(usableSpace < estimatedDims.w) {
      text.setX((x1 + x2)/2);
      usableSpace = x2 - x1; 
    }
    
    // Truncate and return the text if it fits in the available space   
    return DvtTextUtils.fitText(text, usableSpace, estimatedDims.h, container) ? text : null;
  }
}

/**
 * Creates and returns a rotated text element for this node. Adds the text to the container if it's not empty.
 * @param {DvtContainer} container The container element.
 * @return {DvtText} The text element for this node.
 * @private
 */
DvtSunburstNode.prototype._createTextRotated = function(container) {
  // Note: This function will never get called for 360 degree nodes, so it does not handle them.  
  
  // Calculate the available space for placing text. For text height, we estimate using the inner circumference divided 
  // by angle proportion and multiplied by a fudge factor to account for the difference between an arc and straight 
  // line. The innerStartCoord is used to provide a buffer for very small inner radii.
  var innerStartCoord = Math.max(this._innerRadius, 10);
  var availWidth = this._outerRadius - innerStartCoord - DvtSunburstNode.TEXT_BUFFER_HORIZ;
  var availHeight = this._angleExtent * (innerStartCoord + DvtSunburstNode.TEXT_BUFFER_HORIZ) * 1.10; 
  
  // Skip remaining calculations if availHeight is too small to reasonably fit text
  if(availHeight <= 6)
    return null;
  
  // Create the text
  var text = new DvtOutputText(this.getView().getCtx(), this._textStr, 0, 0);
  text.setFontSize(this.GetTextSize());
  
  // Set Style Properties
  this.ApplyLabelTextStyle(text);
  
  // Truncate the text if necessary
  if (!DvtTextUtils.fitText(text, availWidth, availHeight, container))
    return null;
    
  // Calculate the anchor point and alignment for the text
  var anchorRadius = (innerStartCoord + this._outerRadius)/2;
  if(this._labelHalign == DvtSunburstNode.LABEL_ALIGN_START || this._labelHalign == DvtSunburstNode.LABEL_ALIGN_END) {
    container.addChild(text);
    var actualTextWidth = text.getDimensions().w;
    var textBuffer = DvtSunburstNode.TEXT_BUFFER_HORIZ*0.75; // Use a slightly greater proportion of the buffer for padding
    
    if(this._labelHalign == DvtSunburstNode.LABEL_ALIGN_START) 
      anchorRadius = innerStartCoord + textBuffer + actualTextWidth/2;
    else if(this._labelHalign == DvtSunburstNode.LABEL_ALIGN_END)
      anchorRadius = innerStartCoord - textBuffer - actualTextWidth/2;
  }
  
  var textAnchor = DvtSunburstNode._calcPointOnArc(anchorRadius, this._startAngle + this._angleExtent/2);
  text.alignCenter();
  text.alignMiddle();
  
  // Calc the angle, adjusted to between 0 and 2pi
  var angle = this._startAngle + this._angleExtent/2;
  angle = (angle >= DvtSunburstNode.TWO_PI) ? angle - DvtSunburstNode.TWO_PI : angle;
  angle = (angle < 0) ? angle + DvtSunburstNode.TWO_PI : angle;
  
  // If the anchor is on the left half, adjust the rotation for readability
  if(angle > 0.5*Math.PI && angle < 1.5*Math.PI)
    angle += Math.PI;
    
  // Finally rotate and position  
  text.setRotation(angle);
  text.setTranslate(textAnchor.x, textAnchor.y);
  text.setMouseEnabled(false);
  return text;
}

/**
 * Returns the index at which the given node can be found in the input array
 * @param {DvtSunburstNode} node
 * @param {Array} nodes
 * @return {Number} The index at which this node is found, or -1 if not found
 * @private
 */
DvtSunburstNode._findNodeIndex = function(node, nodes)
{
  for(var i=0; i<nodes.length; i++)
  {
    if(node === nodes[i])
      return i;
  }
  
  return -1;
}

/**
 * Handles a mouse over event on the node.
 */
DvtSunburstNode.prototype.handleMouseOver = function() {
  // Expand/Collapse: draw button if needed
  if(!this._expandButton)
    this._expandButton = this._createExpandCollapseButton(this._shape);
    
  DvtSunburstNode.superclass.handleMouseOver.call(this);
}

/**
 * Handles a mouse out event on the node.
 */
DvtSunburstNode.prototype.handleMouseOut = function() {
  // Expand/Collapse: hide button if displayed
  if(this._expandButton && this._shape) {
    this._shape.removeChild(this._expandButton);
    this._expandButton = null;
  }
  
  DvtSunburstNode.superclass.handleMouseOut.call(this);
  
}

/**
 * Updates the shapes of this node for the current layout params.
 * @param {boolean} bRecurse True if the subtree of this node should also be updated.
 */
DvtSunburstNode.prototype.updateShapes = function(bRecurse) {
  if(!this._shape)
    return;

  // Update Shape
  var cmd = this._createPathCmd();
  this._shape.setCmds(cmd);
  
  // Update the text.  The current impl just destroys and recreates the text element.
  if(!this._showRootContent()) { 
    // Update the text.  The current impl just destroys and recreates the text element.
    if(this._text)
      this._shape.removeChild(this._text);
  
    this._text = this._createTextNode(this._shape);
  
    // Remove the text background
    if(this._textBackground) {
      this._shape.removeChild(this._textBackground);
      this._textBackground = null;
    }
  }

  // Update the color
  this._shape.setFill(this.GetFill());
  
  // Recurse to the children
  if(bRecurse) {
    var children = this.getChildNodes();
    for(var i=0; i<children.length; i++) 
      children[i].updateShapes(true);
  }
}

/**
 * @override
 */
DvtSunburstNode.prototype.getDropSiteFeedback = function() {
  if(this._shape instanceof DvtCircle) 
    return new DvtCircle(this.getView().getCtx(), this._shape.getCx(), this._shape.getCy(), this._shape.getRadius());
  else if(this._shape instanceof DvtPath) 
    return new DvtPath(this.getView().getCtx(), this._shape.getCmds());
  else 
    return null;
}

/**
 * Returns the expand button.
 * @return {DvtDisplayable}
 * @private
 */
DvtSunburstNode.prototype._getExpandButton = function() {
  var context = this.getView().getCtx();
  
  // Get the resources from the view
  var resources = this.getView().__getResources();
  
  // Initialize the button states
  var upState = new DvtImage(context, resources.expandUp, 0, 0, DvtSunburstNode._EXPAND_ICON_SIZE, DvtSunburstNode._EXPAND_ICON_SIZE);
  var overState = new DvtImage(context, resources.expandOver, 0, 0, DvtSunburstNode._EXPAND_ICON_SIZE, DvtSunburstNode._EXPAND_ICON_SIZE);
  var downState = new DvtImage(context, resources.expandDown, 0, 0, DvtSunburstNode._EXPAND_ICON_SIZE, DvtSunburstNode._EXPAND_ICON_SIZE);
  
  // Have to add a transparent fill so that IE9 can capture the mouse events (Bug 14698260)
  upState.setInvisibleFill();
  overState.setInvisibleFill();
  downState.setInvisibleFill();
  
  // Create button and hook up click listener
  var button = new DvtButton(context, upState, overState, downState);
  button.addEvtListener(DvtMouseEvent.CLICK, this.expandCollapseNode, false, this);
  return button;
}

/**
 * Returns the collapse button.
 * @return {DvtDisplayable}
 * @private
 */
DvtSunburstNode.prototype._getCollapseButton = function() {
  var context = this.getView().getCtx();
  
  // Get the resources from the view
  var resources = this.getView().__getResources();
  
  // Initialize the button states
  var upState = new DvtImage(context, resources.collapseUp, 0, 0, DvtSunburstNode._EXPAND_ICON_SIZE, DvtSunburstNode._EXPAND_ICON_SIZE);
  var overState = new DvtImage(context, resources.collapseOver, 0, 0, DvtSunburstNode._EXPAND_ICON_SIZE, DvtSunburstNode._EXPAND_ICON_SIZE);
  var downState = new DvtImage(context, resources.collapseDown, 0, 0, DvtSunburstNode._EXPAND_ICON_SIZE, DvtSunburstNode._EXPAND_ICON_SIZE);
  
  // Have to add a transparent fill so that IE9 can capture the mouse events (Bug 14698260) 
  var transparentFill = DvtSolidFill.invisibleFill();
  upState.setFill(transparentFill);
  overState.setFill(transparentFill);
  downState.setFill(transparentFill);
  
  // Create button and hook up click listener
  var button = new DvtButton(context, upState, overState, downState);
  button.addEvtListener(DvtMouseEvent.CLICK, this.expandCollapseNode, false, this);
  return button;
}

/**
 * Isolates this node and maximizes it.
 */
DvtSunburstNode.prototype.expandCollapseNode = function() {
  // Flip the disclosure
  this._disclosed = !this._disclosed;

  // Delegate to the view to handle the event
  this.getView().__expandCollapseNode(this, this._disclosed);
}

/**
 * Returns true if this sunburst node is disclosed
 * @return {Boolean} true if this sunburst node is disclosed
 */
DvtSunburstNode.prototype.isDisclosed = function() {
  return this._disclosed; 
}

DvtSunburstNode.prototype._showRootContent = function() {
  return (! this._parent) && this._innerRadius == 0 && this._angleExtent == DvtSunburstNode.TWO_PI;
}

/**
 * Returns true if this sunburst node has root content defined.  Note that this does not take into
 * account whether this node is the root or not.
 */
DvtSunburstNode.prototype.hasRootContent = function() {
  return (this.GetTemplate() ? true : false);
}

/**
 * Returns the relative radius of this node.
 * @return {number}
 */
DvtSunburstNode.prototype.__getRadius = function() {
  if(this._radius != null) // radius explicitly specified
    return Number(this._radius);
  else if(!this.GetParent()) {
    // Root Node
    if(this.isArtificialRoot())
      return DvtSunburstNode._CENTER_ARTIFICIAL_ROOT_RADIUS;
    else if(this.hasRootContent())
      return DvtSunburstNode._CENTER_WITH_CONTENT_RADIUS;
    else
      return DvtSunburstNode._CENTER_NODE_RADIUS;
  }
  else
    return 1;
}
/**
 * Layout class for sunbursts.
 * @class
 */
var DvtSunburstLayout = new Object();

DvtObj.createSubclass(DvtSunburstLayout, DvtObj, "DvtSunburstLayout");

/**
 * Performs layout for the sunburst.
 * @param {number} totalRadius The total radius of the sunburst.
 * @param {DvtSunburstNode} root The root of the tree.
 * @param {number} startAngle The starting angle for the sunburst in radians.
 * @param {number} angleExtent The extent of this node in radians.
 * @param {string} sorting "on" if sorting by size is enabled.
 */
DvtSunburstLayout.layout = function(totalRadius, root, startAngle, angleExtent, sorting)
{
  // Calculate the longest branch radius and radius per unit of depth
  var longestRadius = DvtSunburstLayout._calcLargestRadius(root);
  var radiusPerDepth = totalRadius/longestRadius;
  
  // Layout the nodes  
  DvtSunburstLayout._layout(radiusPerDepth, root, startAngle, angleExtent, sorting, 0);
}

/**
 * Performs layout for the specified node in the sunburst.
 * @param {number} radiusPerDepth The radius per depth unit.
 * @param {DvtSunburstNode} node The root of the subtree.
 * @param {number} startAngle The starting angle for this node in radians.
 * @param {number} angleExtent The extent of this node in radians.
 * @param {string} sorting "on" if sorting by size is enabled.
 * @param {number} innerRadius The inner radius of the node to layout.
 */
DvtSunburstLayout._layout = function(radiusPerDepth, node, startAngle, angleExtent, sorting, innerRadius) 
{
  // First layout the node itself
  var outerRadius = innerRadius + node.__getRadius() * radiusPerDepth;
  node.setLayoutParams(innerRadius, outerRadius, startAngle, angleExtent);
  
  // Layout the children
  var children = node.getChildNodes();
  if(children != null && node.isDisclosed()) {
    var childStartAngle = startAngle;
    
    // Sorting
    if(sorting == DvtBaseTreeParser.SORTING_ON) {
      // Copy and sort by decreasing size
      children = children.slice(0);
      children.sort(function(a, b) { return b.getSize() - a.getSize(); });
    }
    
    // BIDI Support: For horizontal layout, reverse the order of the nodes
    if(DvtAgent.isRightToLeft(node.getView().getCtx()))
      children = children.slice(0).reverse();
    
    // Find the total of the children  
    var i;
    var total = 0;
    for(i=0; i<children.length; i++)
      total += children[i].getSize() > 0 ? children[i].getSize() : 0; // ignore negatives, which skew child size calc
    
    // Find the size of each child
    for(i=0; i<children.length; i++) {
      var child = children[i];
    
      // Ignore negative and zero sized nodes
      if(child.getSize() <= 0) 
        continue;
    
      // Calculate the bounds of the child
      var sizeRatio = child.getSize()/total;
      var childAngleExtent = sizeRatio * angleExtent;
   
      // Recursively layout the child
      DvtSunburstLayout._layout(radiusPerDepth, child, childStartAngle, childAngleExtent, sorting, outerRadius);
      
      // Update the start angle
      childStartAngle += childAngleExtent;
    }    
  }
}

/**
 * Returns the radius of the tree rooted at the specified node.
 * @param {DvtSunburstNode} node The subtree to find the radius for.
 * @return {number} The maximum radius of the tree.
 * @private
 */
DvtSunburstLayout._calcLargestRadius = function(node) {
  var maxRadius = 0;
  
  // Search children
  var children = node.getChildNodes();
  if(children && children.length > 0) {
    for(var i=0; i<children.length; i++) {
      var childRadius = DvtSunburstLayout._calcLargestRadius(children[i]);
      maxRadius = Math.max(maxRadius, childRadius);
    }
    return maxRadius + node.__getRadius();
  }
  else {
    // Use 1 for default if not specified
    return node.__getRadius();
  }
}
/**
 * @constructor
 * A component level sunburst node expand or collapse event.
 * @type {string} type The type of the event
 * @type {string} id The id of the node that is the target of the event.
 * @class
 * @constructor
 * @extends DvtBaseComponentEvent
 */
var DvtSunburstExpandCollapseEvent = function(type, id) {
  this.Init(type);
  this._id = id ? id : null;
}

DvtObj.createSubclass(DvtSunburstExpandCollapseEvent, DvtBaseComponentEvent, "DvtSunburstExpandCollapseEvent");

// Event Types
DvtSunburstExpandCollapseEvent.TYPE_EXPAND = "sunburstExpand";
DvtSunburstExpandCollapseEvent.TYPE_COLLAPSE = "sunburstCollapse";

/**
 * Returns the id of the isolated node, if any.
 * @return {string}
 */
DvtSunburstExpandCollapseEvent.prototype.getId = function() {
  return this._id;
}
/**
 * Event Manager for Sunburst.
 * 
 * @param {DvtSunburst} view The Sunburst to associate with this event manager
 * @param {DvtContext} context The platform specific context object.
 * @param {function} callback A function that responds to component events.
 * @param {object} callbackObj The optional object instance that the callback function is defined on.
 * @class
 * @constructor
 */
var DvtSunburstEventManager = function(view, context, callback, callbackObj) {
  DvtBaseTreeEventManager.call(this, view, context, callback, callbackObj);
};

DvtObj.createSubclass(DvtSunburstEventManager, DvtBaseTreeEventManager, "DvtSunburstEventManager");

DvtSunburstEventManager.ROTATION_ID = "_rotationShape"; // id used to identify the shape used for rotation

/**
 * @override
 */
DvtSunburstEventManager.prototype.OnMouseDown = function(event) {
  // Rotation Support
  var obj = this.GetLogicalObject(event.target);
  if(obj && obj.getId && obj.getId() == DvtSunburstEventManager.ROTATION_ID && !this._bRotating) {
    this._bRotating = true;
    
    var relPos = this._context.pageToStageCoords(event.pageX, event.pageY);
    this.GetView().__startRotation(relPos.x, relPos.y);
  }
  else 
    DvtSunburstEventManager.superclass.OnMouseDown.call(this, event); 
}

/**
 * @override
 */
DvtSunburstEventManager.prototype.OnMouseMove = function(event) {
  if(this._bRotating) {
    var relPos = this._context.pageToStageCoords(event.pageX, event.pageY);
    this.GetView().__continueRotation(relPos.x, relPos.y);
  }
  else
    DvtSunburstEventManager.superclass.OnMouseMove.call(this, event);
}

/**
 * @override
 */
DvtSunburstEventManager.prototype.OnMouseUp = function(event) {
  if(this._bRotating) {
    this._bRotating = false;
    this.GetView().__endRotation(); 
  }
  else 
    DvtSunburstEventManager.superclass.OnMouseUp.call(this, event);
}

/**
 * @override
 */
DvtSunburstEventManager.prototype.ProcessKeyboardEvent = function(event)
{
  var eventConsumed = true;

  var keyCode = event.keyCode;
  var node = this.getFocus(); // the item with current keyboard focus
  var sunburst = this.GetView();

  // expand/collapse
  if( node.isExpandCollapseEnabled() &&
      ( (DvtKeyboardEvent.isPlus(event) && !node.isDisclosed()) ||
        (DvtKeyboardEvent.isMinus(event) && node.isDisclosed()) ||
        (event.ctrlKey && keyCode == DvtKeyboardEvent.ENTER) ))
        
  {
      node.expandCollapseNode();
      event.preventDefault();
  }
  // rotation
  else if(sunburst && sunburst.__isRotationEnabled() &&
          (keyCode == DvtKeyboardEvent.LEFT_ARROW || keyCode == DvtKeyboardEvent.RIGHT_ARROW) &&
          !event.ctrlKey && event.altKey && event.shiftKey)
  {
    var newAngle;
    if(keyCode == DvtKeyboardEvent.LEFT_ARROW)
      newAngle = -5 * (Math.PI/180); 
    else
      newAngle = 5 * (Math.PI/180); 
    
    sunburst.__setRotationAnchor(0);
    sunburst.__rotate(newAngle);
    sunburst.__endRotation();
    event.preventDefault();
  }
  else
  {
    eventConsumed = DvtSunburstEventManager.superclass.ProcessKeyboardEvent.call(this, event);  
  }
  
  return eventConsumed;
}

DvtSunburstEventManager.ROTATE_KEY = "rotateKey";

DvtSunburstEventManager.prototype.HandleImmediateTouchStartInternal = function(event) {
  var obj = this.GetLogicalObject(event.target);
  if(obj && obj.getId && obj.getId() == DvtSunburstEventManager.ROTATION_ID) {
   this.TouchManager.processAssociatedTouchAttempt(event, DvtSunburstEventManager.ROTATE_KEY, this.RotateStartTouch, this);
  }
}

DvtSunburstEventManager.prototype.HandleImmediateTouchMoveInternal = function(event) {
   this.TouchManager.processAssociatedTouchMove(event, DvtSunburstEventManager.ROTATE_KEY);
}

DvtSunburstEventManager.prototype.HandleImmediateTouchEndInternal = function(event) {
    this.TouchManager.processAssociatedTouchEnd(event, DvtSunburstEventManager.ROTATE_KEY);
}


DvtSunburstEventManager.prototype.RotateStartTouch = function(event, touch) {
    var touchIds = this.TouchManager.getTouchIdsForObj(DvtSunburstEventManager.ROTATE_KEY);
    if (touchIds.length <= 1) {
        this.TouchManager.saveProcessedTouch(touch.identifier, DvtSunburstEventManager.ROTATE_KEY, null, DvtSunburstEventManager.ROTATE_KEY, DvtSunburstEventManager.ROTATE_KEY, this.RotateMoveTouch, this.RotateEndTouch, this);
        this.TouchManager.setTooltipEnabled(touch.identifier, false);
        var pos = this._context.pageToStageCoords(touch.pageX, touch.pageY);
        this.GetView().__startRotation(pos.x, pos.y);
        event.blockTouchHold();
    }
}

DvtSunburstEventManager.prototype.RotateMoveTouch = function(event, touch) {
    var pos = this._context.pageToStageCoords(touch.pageX, touch.pageY);
    this.GetView().__continueRotation(pos.x, pos.y);
    event.preventDefault();
}

DvtSunburstEventManager.prototype.RotateEndTouch = function(event, touch) {
  this.GetView().__endRotation();
}
/**
 * Resource bundle for DvtSunburst.
 * @class
 * @constructor
 * @extends {DvtBundle}
 */
var DvtSunburstBundle = function() {}

DvtObj.createSubclass(DvtSunburstBundle, DvtBundle, "DvtSunburstBundle");

DvtSunburstBundle["_defaults"] = {
  'COLOR': 'Color',
  'SIZE': 'Size'
}

/**
 * @override
 */
DvtSunburstBundle.prototype.GetDefaultStringForKey = function(key) {
  return DvtSunburstBundle["_defaults"][key];
}

/**
 * @override
 */
DvtSunburstBundle.prototype.GetBundlePrefix = function() {
  return "DvtSunburstBundle";
}
/**
 * Default values and utility functions for component versioning.
 * @class
 * @constructor
 * @extends {DvtBaseTreeDefaults}
 */
var DvtSunburstDefaults = function() {
  this.Init({'skyros': DvtSunburstDefaults.VERSION_1, 'alta': {}});
}

DvtObj.createSubclass(DvtSunburstDefaults, DvtBaseTreeDefaults, "DvtSunburstDefaults");

/**
 * Defaults for version 1.
 */ 
DvtSunburstDefaults.VERSION_1 = {
  // Note, only attributes that are different than the XML defaults need 
  // to be listed here, at least until the XML API is replaced.
  "rotation": "on"
}
/**
 * Utility functions for converting between JSON and XML APIs.
 * @class
 */
var DvtSunburstJsonUtils = function() {}

DvtObj.createSubclass(DvtSunburstJsonUtils, DvtBaseTreeJsonUtils, "DvtSunburstJsonUtils");

/** @override **/
DvtSunburstJsonUtils.prototype.GetComponentName = function() {
  return "sunburst";
}

/** @override **/
DvtSunburstJsonUtils.prototype.WriteComponentAttributes = function(options) {
  var ret = DvtSunburstJsonUtils.superclass.WriteComponentAttributes.call(this, options);
  ret += this.WriteAttr("r", options['rotation']);
  
  var startAngle = (options['startAngle']+360) % 360;
  ret += this.WriteAttr("sa", startAngle);
    
  var animationOnDisplay = options['animationOnDisplay'];
  if(animationOnDisplay == "auto")
    ret += this.WriteAttr("adi", "fan"); 
  else
    ret += this.WriteAttr("adi", animationOnDisplay); 
  
  return ret;
}

/** @override **/
DvtSunburstJsonUtils.prototype.WriteNodeAttributes = function(options, nodeData) {
  var ret = DvtSunburstJsonUtils.superclass.WriteNodeAttributes.call(this, options, nodeData);
  
  var labelDisplay = nodeData['labelDisplay'] ? nodeData['labelDisplay'] : options['nodeDefaults']['labelDisplay'];
  ret += this.WriteAttr("ld", labelDisplay);
  
  var labelHalign = nodeData['labelHalign'] ? nodeData['labelHalign'] : options['nodeDefaults']['labelHalign'];
  if(labelHalign == "inner")
    ret += this.WriteAttr("ha", "s");
  else if(labelHalign == "outer")
    ret += this.WriteAttr("ha", "e");
    
  var radius = nodeData['radius'];
  if(radius != null && !isNaN(radius))
    ret += this.WriteAttr(DvtSunburstParser.ATTR_RADIUS, radius);
  
  return ret;
}

/** @override **/
DvtSunburstJsonUtils.prototype.WriteResourcesElement = function(options) {
  var ret = '<resources';
  
  var bundle = new DvtSunburstBundle();
  ret += this.WriteAttr("legendSize", bundle.getTranslatedString('SIZE'));
  ret += this.WriteAttr("legendColor", bundle.getTranslatedString('COLOR'));
  
  // Image Resources  
  var resources = options['_resources'];
  ret += this.WriteAttr("cursorRotate", resources['rotateCursor']);
  
  // Alta Behavior
  ret += this.WriteAttr("alta", "true");
  
  ret += '/>\n';
  return ret;
}

/** @override **/
DvtSunburstJsonUtils.prototype.WriteStyleElement = function(options) {
  var ret = DvtSunburstJsonUtils.superclass.WriteStyleElement.call(this, options);
  
  var animationColor = options["animationUpdateColor"];
  if(animationColor)
    ret += this.WriteAttr("top", "-tr-animation-update-color: " + animationColor);
  
  var borderColor = options['nodeDefaults']["borderColor"];
  if(borderColor) 
    ret += this.WriteAttr("node", "border-color: " + borderColor);
  
  var hoverColor = options['nodeDefaults']["hoverColor"];
  if(hoverColor) 
    ret += this.WriteAttr("node-hover", "border-color: " + hoverColor);
  
  var selectedColor = options['nodeDefaults']["selectedColor"];
  if(selectedColor) 
    ret += this.WriteAttr("node-selected", "border-color: " + selectedColor);
  
  ret += "/>\n";
  return ret;
}
/**
 * @export
 */
var DvtAmxThematicMap = function (context, callback, callbackObj) {
  this.Init(context, callback, callbackObj);
}

DvtObj.createSubclass(DvtAmxThematicMap, DvtContainer, "DvtAmxThematicMap");

DvtAmxThematicMap._LEGEND_COMPONET_GAP = 10;

DvtAmxThematicMap.prototype.Init = function (context, callback, callbackObj) {
  DvtAmxThematicMap.superclass.Init.call(this, context);
  this._tmap = new DvtThematicMap(context, callback, callbackObj);
  this._tmapContainer = new DvtContainer(context);
  this._tmapContainer.addChild(this._tmap);
  this.addChild(this._tmapContainer);
  this.Defaults = new DvtThematicMapDefaults();
}

/**
 * Returns a new instance of DvtAmxThematicMap.
 * @param {DvtContext} context The rendering context.
 * @param {string} callback The function that should be called to dispatch component events.
 * @param {object} callbackObj The optional object instance on which the callback function is defined.
 * @return {DvtAmxThematicMap}
 * @export
 */
DvtAmxThematicMap.newInstance = function (context, callback, callbackObj) {
  return new DvtAmxThematicMap(context, callback, callbackObj);
}

/**
 * Renders the component with the specified data.  If no data is supplied to a component
 * that has already been rendered, the component will be rerendered to the specified size.
 * @param {object} options The object containing options for this component.
 * @param {number} width The width of the component.
 * @param {number} height The height of the component.
 * @export
 */
DvtAmxThematicMap.prototype.render = function (options, width, height) {
  this.Options = this.Defaults.calcOptions(options);
  this._width = width;
  this._height = height;
  
  // render legend
  var availSpace = new DvtRectangle(0, 0, width, height);
  this._renderLegend(this, availSpace);
  // render thematic map
  this._tmap.render(options, availSpace.w, availSpace.h);
}

/**
 * Renders legend and updates the available space.
 * @param {DvtChartImpl} chart The chart being rendered.
 * @param {DvtContainer} container The container to render into.
 * @param {DvtRectangle} availSpace The available space.
 */
DvtAmxThematicMap.prototype._renderLegend = function(container, availSpace) {
  //remove old legend
  if (this._legend) {
    container.removeChild(this._legend);
    this._legend = null;
  }

  var availLegendSpace = new DvtRectangle(DvtAmxThematicMap._LEGEND_COMPONET_GAP, DvtAmxThematicMap._LEGEND_COMPONET_GAP, 
                                    availSpace.w-2*DvtAmxThematicMap._LEGEND_COMPONET_GAP, availSpace.h-2*DvtAmxThematicMap._LEGEND_COMPONET_GAP);

  var options = this.Options;
  
  var rendered = options['legend']['rendered'];
  var scrolling = options['legend']['scrolling'];
	
  // Create the options object for the legend
  var legendOptions = DvtJSONUtils.clone(options['legend']);
  this._addLegendData(this.Options, legendOptions);
  
  // Done not rendered or nothing to render
  if(!rendered || (legendOptions.sections && legendOptions.sections.length == 0))
    return;

  var position = options['legend']['position'];
  delete legendOptions["position"];
  legendOptions['layout']['gapRatio'] = this.getGapRatio();
  legendOptions['hideAndShowBehavior'] = 'none';
  legendOptions['rolloverBehavior'] = 'none';
  legendOptions['scrolling'] = options['legend']['scrolling'];
  
  // Create and add the legend to the display list for calc and rendering
  // TODO handle chart event procissing i.e. hide show/ rollover
  var legend = DvtLegend.newInstance(this._tmap.getCtx(), null, null);
  if(this._tmap.getId() != null){
    //create and set legend id based on parent id
    legend.setId(this._tmap.getId()+"legend");
  }
  container.addChild(legend);
	
  var maxWidth;
  var maxHeight;
  
  // Evaluate the automatic position
  // If scrolling is off, default legend position to bottom
  if(position == "auto" && scrolling !== "asNeeded") {
    position = "bottom";
  }
  // If scrolling is on, auto will always render vertical legend
  else if(position == "auto" && scrolling == "asNeeded") {
    position = "end";
  }
  
  // Convert "start" and "end" to absolute position
  var isRTL = DvtAgent.isRightToLeft(container.getCtx());
  if(position == "start")
    position = isRTL ? "right" : "left";
  else if(position == "end")
    position = isRTL ? "left" : "right";
	
  // Add legend orientation
  legendOptions['orientation'] = (position == "left" || position == "right" ? "vertical" : "horizontal");
	
  // Evaluate non-auto position
  var isHoriz = (position == "top" || position == "bottom");
  maxWidth = isHoriz ? availLegendSpace.w : options['layout']['legendMaxSize'] * availLegendSpace.w;
  maxHeight = isHoriz ? options['layout']['legendMaxSize'] * availLegendSpace.h : availLegendSpace.h;
  var actualSize = legend.getPreferredSize(legendOptions, maxWidth, maxHeight);
  
  if (actualSize.w > 0 && actualSize.h > 0) {
    legend.render(legendOptions, actualSize.w, actualSize.h);
    this._legend = legend;
    var gap = DvtThematicMapDefaults.getGapSize(this, options['layout']['legendGap']);
    DvtLayoutUtils.position(availLegendSpace, position, legend, actualSize.w, actualSize.h, gap);

    // update availSpace
    switch(position) {
      case 'top':
        this._tmapContainer.setTranslateY(actualSize.h + DvtAmxThematicMap._LEGEND_COMPONET_GAP);
      case 'bottom':
        availSpace.h = availSpace.h - (actualSize.h + DvtAmxThematicMap._LEGEND_COMPONET_GAP);
        break;
      case 'left':
        this._tmapContainer.setTranslateX(actualSize.w + DvtAmxThematicMap._LEGEND_COMPONET_GAP);
      case 'right':
        availSpace.w = availSpace.w - (actualSize.w + DvtAmxThematicMap._LEGEND_COMPONET_GAP);
        break;
      default:
        break;
    }
  }
}

DvtAmxThematicMap.prototype.getGapRatio = function() {
  // If defined in the options, use that instead
  if(this.Options['layout']['gapRatio'] !== null && !isNaN(this.Options['layout']['gapRatio']))
    return this.Options['layout']['gapRatio'];
  else {
    var wRatio = Math.min(this._width/400, 1);
    var hRatio = Math.min(this._height/300, 1);
    return Math.min(wRatio, hRatio);
  }
}

/**
 * Added data into the options object to be passed to the legend.
 * @param {DvtChartImpl} chart The chart whose data will be passed to the legend.
 * @param {object} legendOptions The legend options object into which data will be added.
 * @return {object} The data object for the chart's legend.
 */
DvtAmxThematicMap.prototype._addLegendData = function(data, legendOptions) {
  legendOptions['title'] = data['legend'] ? data['legend']['title'] : null;
  legendOptions['sections'] = [];

  if(data && data['legend'] && data['legend']['sections']) {
    // Iterate through any sections defined with attribute groups
    for(var i=0; i<data['legend']['sections'].length; i++) {
      var dataSection = data['legend']['sections'][i];
      if(dataSection) 
        legendOptions['sections'].push({'title': dataSection['title'], 'items': dataSection['items'], 'sections': dataSection['sections']});
    }
  }
    
  return legendOptions;
}
/**
 * DVT Toolkit based thematic map component
 * @extends DvtContainer
 * @class DVT Toolkit based thematic map component
 * @constructor
 * @export
 */
var DvtThematicMap = function (context, callback, callbackObj) {
  this.Init(context, callback, callbackObj);
}

DvtObj.createSubclass(DvtThematicMap, DvtAbstractPanZoomComponent, "DvtThematicMap");

DvtThematicMap._FEATURES_OFF_PAN = 1;
DvtThematicMap._FEATURES_OFF_ZOOM = 2;
DvtThematicMap._FEATURES_OFF_PAN_ZOOM = 3;
DvtThematicMap._FEATURES_OFF_ZOOMTOFIT = 4;
DvtThematicMap._FEATURES_OFF_PAN_ZOOMTOFIT = 5;
DvtThematicMap._FEATURES_OFF_ZOOM_ZOOMTOFIT = 6;
DvtThematicMap._FEATURES_OFF_ALL = 7;

DvtThematicMap._COLLAPSIBLE_PANEL_OFFSET = 5;

DvtThematicMap._ELEM_RESOURCES_CONTROLPANEL = "controlPanelResources";
DvtThematicMap._ELEM_RESOURCES_LEGEND = "legendResources";
DvtThematicMap._ELEM_RESOURCES_PANEL_DRAWER = "panelDrawerResources";

DvtThematicMap.DEFAULT_MAX_ZOOM_FACTOR = 6;

/**
 * Initializes the thematicMap
 * @param {DvtContext} context The rendering context.
 * @param {function} callback The function that should be called to dispatch component events.
 * @param {AdfDhtmlThematicMapPeer} callbackObj The object to dispatch component events to
 * @protected
 */
DvtThematicMap.prototype.Init = function (context, callback, callbackObj) {
  DvtThematicMap.superclass.Init.call(this, context);
  this._callback = callback;
  this._callbackObj = callbackObj;

  this._createHandlers();

  this._layers = [];
  this._drillAnimFadeOutObjs = [];

  this._legend = null;
  this._legendPanel = null;
  this._legendXml = null;
  this._legendButtonImages = null;

  this._bBaseMapChanged = false;
  this._drilledRowKeys = [];
  this._initDrilled = new Object();
  this._processingInitDrilled = false;
  this._drillDataLayer = new Object();

  this._childToParent = new Object();
  this._drilled = [];
  
  this._areaLayers = new DvtContainer(this.getCtx());
  this._dataAreaLayers = new DvtContainer(this.getCtx());
  this._dataPointLayers = new DvtContainer(this.getCtx());
  this._labelLayers = new DvtContainer(this.getCtx());
  
  this._initialZooming = false;
  this._zooming = true;
  this._panning = true;
  this._maxZoomFactor = DvtThematicMap.DEFAULT_MAX_ZOOM_FACTOR;
  this._isMarkerZoomBehaviorFixed = true;
  this._selectedAreas = {};
  
  this.setDisplayedControls(DvtPanZoomControlPanel.CONTROLS_ALL);
  
  this.Defaults = new DvtThematicMapDefaults();
}

/**
 * Returns a new instance of DvtJsonThematicMap. Currently only called by json supported platforms.
 * @param {DvtContext} context The rendering context.
 * @param {string} callback The function that should be called to dispatch component events.
 * @param {object} callbackObj The optional object instance on which the callback function is defined.
 * @return {DvtThematicMap}
 * @export
 */
DvtThematicMap.newInstance = function (context, callback, callbackObj) {
  return new DvtThematicMap(context, callback, callbackObj);
}

/**
 * Specifies the non-data options for this component. Currently only called by json supported platforms.
 * @param {object} options The object containing options specifications for this component.
 * @protected
 */
DvtThematicMap.prototype.SetOptions = function (options) {
  this.Options = this.Defaults.calcOptions(options);
  
  if (!DvtAgent.isEnvironmentBrowser()) {
    this.Options['animationOnDisplay'] = 'none';
    this.Options['animationOnMapChange'] = 'none';
    this.Options['animationOnDrill'] = 'none';
  }
  
  if (!this.Options['skin'])
    this.Options['skin'] = 'alta';
}

/**
 * Sets the style defaults for this component.
 * @param {Object} defaults The json object containing style defaults 
 */
DvtThematicMap.prototype.setStyleDefaults = function (defaults) {
  this._styleDefaults = defaults;
}

/**
 * Returns the style defaults for this component.
 * @return {Object} The json object containing style defaults 
 */
DvtThematicMap.prototype.getStyleDefaults = function () {
  return this._styleDefaults;
}

/**
 * @override
 * @export
 */
DvtThematicMap.prototype.render = function (options, width, height) {
  if (options && typeof options == 'object')
    this.SetOptions(options);
    
  DvtThematicMap.superclass.render.call(this, options, width, height);
}

DvtThematicMap.prototype.getMaxZoomFactor = function () {
  return (this._zooming ? this._maxZoomFactor : 1);
}

DvtThematicMap.prototype.setMaxZoomFactor = function (maxZoomFactor) {
  this._maxZoomFactor = maxZoomFactor;
}

/**
 * Returns whether the marker zoom behavior is 'fixed'. Valid values are fixed (default) and zoom.
 * @return {boolean} True if the marker zoom behavior is fixed
 */
DvtThematicMap.prototype.isMarkerZoomBehaviorFixed = function () {
  return this._isMarkerZoomBehaviorFixed;
}

/**
 * Sets the marker behavior when zooming. Valid values are fixed (default) and zoom.
 * @param {string} behavior The marker behavior on zoom
 */
DvtThematicMap.prototype.setMarkerZoomBehavior = function (behavior) {
  this._isMarkerZoomBehaviorFixed = (behavior == 'fixed');
}

/**
 * Returns the default css style properties to apply to all map markers and text.
 * @return {DvtCSSStyle} The css marker style properties
 */
DvtThematicMap.prototype.getMarkerStyle = function () {
  return this._markerStyle;
}

/**
 * Sets the default css style properties to apply to all map markers and text.
 * @param {DvtCSSStyle} style The css marker style properties
 */
DvtThematicMap.prototype.setMarkerStyle = function (style) {
  this._markerStyle = style;
}

DvtThematicMap.prototype.getEventHandler = function () {
  return this._eventHandler;
}

DvtThematicMap.prototype.addPointLayer = function (layer) {
  this._layers.push(layer);
}

DvtThematicMap.prototype.addLayer = function (layer) {
  this._layers.push(layer);
}

DvtThematicMap.prototype.getLayer = function (layerName) {
  for (var i = 0;i < this._layers.length;i++) {
    if (this._layers[i].getLayerName() == layerName)
      return this._layers[i];
  }
}

DvtThematicMap.prototype.getAreaLayerContainer = function () {
  return this._areaLayers;
}

DvtThematicMap.prototype.getDataAreaContainer = function () {
  return this._dataAreaLayers;
}

DvtThematicMap.prototype.getDataPointContainer = function () {
  return this._dataPointLayers;
}

DvtThematicMap.prototype.getLabelContainer = function () {
  return this._labelLayers;
}

DvtThematicMap.prototype.setMapName = function (attr) {
  this._bBaseMapChanged = (this._mapName && this._mapName != attr);
  this._mapName = attr;
}

DvtThematicMap.prototype.setAnimationOnDisplay = function (attr) {
  this._animationOnDisplay = attr;
}

DvtThematicMap.prototype.setAnimationOnMapChange = function (attr) {
  this._animationOnMapChange = attr;
}

DvtThematicMap.prototype.setAnimationDuration = function (attr) {
  this._animationDuration = parseFloat(attr);
}

/**
 * Returns the animation duration for this component
 * @return {Number} The animation duration in milliseconds
 */
DvtThematicMap.prototype.getAnimationDuration = function () {
  return this._animationDuration;
}

DvtThematicMap.prototype.setDisplayTooltips = function (attr) {
  this._displayTooltips = attr;
}

DvtThematicMap.prototype.getDisplayTooltips = function () {
  return this._displayTooltips;
}

DvtThematicMap.prototype.setFeaturesOff = function (attr) {
  this._featuresOff = parseInt(attr);
  DvtThematicMap.superclass.setFeaturesOff.call(this, this._featuresOff);
  
  var controls = this.getDisplayedControls();
  if (this._featuresOff ==  DvtThematicMap._FEATURES_OFF_PAN || this._featuresOff == DvtThematicMap._FEATURES_OFF_PAN_ZOOM ||
      this._featuresOff == DvtThematicMap._FEATURES_OFF_PAN_ZOOMTOFIT || this._featuresOff == DvtThematicMap._FEATURES_OFF_ALL) {
    controls = controls & ~DvtPanZoomControlPanel.CONTROLS_CENTER_BUTTON;
    this.setPanning(false);
  }
  if (this._featuresOff == DvtThematicMap._FEATURES_OFF_ZOOM || this._featuresOff == DvtThematicMap._FEATURES_OFF_PAN_ZOOM ||
      this._featuresOff == DvtThematicMap._FEATURES_OFF_ZOOM_ZOOMTOFIT || this._featuresOff == DvtThematicMap._FEATURES_OFF_ALL) {
    controls = controls & ~DvtPanZoomControlPanel.CONTROLS_ZOOM;
    this.setZooming(false);
  }
  if (this._featuresOff == DvtThematicMap._FEATURES_OFF_ZOOMTOFIT || this._featuresOff == DvtThematicMap._FEATURES_OFF_PAN_ZOOMTOFIT ||
      this._featuresOff == DvtThematicMap._FEATURES_OFF_ZOOM_ZOOMTOFIT || this._featuresOff == DvtThematicMap._FEATURES_OFF_ALL) {
    controls = controls & ~DvtPanZoomControlPanel.CONTROLS_ZOOM_TO_FIT_BUTTON;
  }
    
  this.setDisplayedControls(controls);
}

DvtThematicMap.prototype.setInitialCenterX = function (attr) {
  this._initialCenterX = parseFloat(attr);
}

DvtThematicMap.prototype.setInitialCenterY = function (attr) {
  this._initialCenterY = parseFloat(attr);
}

DvtThematicMap.prototype.setInitialZoom = function (attr) {
  this._initialZoom = parseFloat(attr);
}

DvtThematicMap.prototype.setAnimationOnDrill = function (attr) {
  if (attr == 'alphaFade')
    this._animationOnDrill = attr;
}

DvtThematicMap.prototype.setDrillMode = function (attr) {
    this._drillMode = attr;
    this._eventHandler.setDrillMode(attr);
}

DvtThematicMap.prototype.setInitialZooming = function (attr) {
    this._initialZooming = attr;
}

DvtThematicMap.prototype.setDrillZoomToFit = function (attr) {
  this._drillZoomToFit = (attr == 'true');
}

DvtThematicMap.prototype.getLegendPanel = function (node) {
  return this._legendPanel;
}

/**
 * @override
 */
DvtThematicMap.prototype.loadXml = function (xmlString, eventType, paramKeys, paramValues) {
  //TODO remove once DvtAbstractComponent supports json
  if (this.Options) {
    var parser = new DvtThematicMapJsonParser(this);
    parser.parse(this.Options);
    return;
  }
  // Don't parse null/empty xml coming from resize notify
  if (xmlString == null || xmlString.length == 0)
    return;
  DvtThematicMap.superclass.loadXml.call(this, xmlString, eventType, paramKeys, paramValues);
}

/**
 * @override
 */
DvtThematicMap.prototype.LoadXmlInitial = function (eventType, rootXmlNode, paramKeys, paramValues) {
  // 3 cases we need to handle
  // 1. Initial render
  // 2. New area layer
  // 3. New base map
  this._bRendered = false;
  // For cases 2 & 3 we will need to clear the old stored information
  if (this._pzcContainer) {
    this._layers = [];
    this._drilledRowKeys = [];
    this._initDrilled = new Object();
    this._drillDataLayer = new Object();
    this._childToParent = new Object();
    this._drilled = [];
    
    this.removeChild(this._legendPanel);
    this._legendPanel = null;
    this._legend = null;
    this._legendXml = null;
    this._legendButtonImages = null;
    this.setFeaturesOff(0);
    this.setDisplayedControls(DvtPanZoomControlPanel.CONTROLS_ALL);
    this._zooming = true;
    this._panning = true;
    
    // save a copy of the old pzc for animation
    this._oldPzc = this._pzc;

    this._areaLayers = new DvtContainer(this.getCtx());
    this._dataAreaLayers = new DvtContainer(this.getCtx());
    this._dataPointLayers = new DvtContainer(this.getCtx());
    this._labelLayers = new DvtContainer(this.getCtx());
    
    this._createHandlers();
  }
  
  // clear data tips from previous event handlers
  this._eventHandler.hideTooltip();
  this.GetXmlDomParser().loadXmlInitial(rootXmlNode);
}

/**
 * Creates all the event handlers that this component needs
 * @private
 */
DvtThematicMap.prototype._createHandlers = function () {
  // Each Tmap has only one keyboard handler. Each layer has its own event manager
  // because selection modes can differ between layers.
  this._eventHandler = new DvtThematicMapEventManager(this.getCtx(), this.__dispatchEvent, this);
  this._eventHandler.addListeners(this);
  if (!DvtAgent.isTouchDevice()) {
    this._keyboardHandler = new DvtThematicMapKeyboardHandler(this, this._eventHandler);
    this._eventHandler.setKeyboardHandler(this._keyboardHandler);
  } else {
    this._keyboardHandler = null;
  }
}

DvtThematicMap.prototype.HandleLegendResize = function (event) {
  if (!DvtAgent.isRightToLeft(this.getCtx())) {
    var x = this.GetWidth() - 5 - event.getWidth();
    this._legendPanel.setTranslateX(x);
  }
}

/**
 * Creates, renders, and positions a DvtCommonLegend and its parent container within this component.
 * @private
 */
DvtThematicMap.prototype._renderLegend = function () {
  if (this._legendXml) {
    // Cleanup previoius legend
    if (this._legendPanel) {
      this._legendPanel.destroy();
      this.removeChild(this._legendPanel);
    }
  
    var disclosed = this._legendXml.getAttr('disclosed') == 'true';
    var isFixed = this._legendXml.getAttr('display') == 'fixed' || DvtAgent.isEnvironmentBatik();
    if ((isFixed && !disclosed))
      return;
    
    // determine the max width of the legend container
    var maxWidth = this._legendXml.getAttr('maxWidth');
    // check if max legend width is given as a % or px
    var percentIndex = maxWidth.indexOf('%');
    var isPercent = (percentIndex != -1);
    if (isPercent)
      maxWidth = parseFloat(maxWidth.substring(0,percentIndex))/100 * this.GetWidth();
    else
      maxWidth = parseFloat(maxWidth);
    var maxHeight = this.GetHeight() - 2*DvtThematicMap._COLLAPSIBLE_PANEL_OFFSET;
    
    // create the legend container based on the skin
    if (this.getSkinName() == DvtCSSStyle.SKIN_ALTA) {
      this._legendPanel = new DvtPanelDrawer(this.getCtx(), null, this, 'pd');
      this._legendPanel.addEvtListener(DvtPanelDrawerEvent.TYPE, this.HandleLegendEvent, false, this);
      this._legendPanel.setMaxWidth(maxWidth);
      this._legendPanel.setMaxHeight(maxHeight);
      this._legendPanel.setFixed(isFixed);
      // position the container
      if (!DvtAgent.isRightToLeft(this.getCtx())) {
        this._legendPanel.setTranslateX(this.GetWidth());
      }
      else {
        this._legendPanel.setDiscloseDirection(DvtPanelDrawer.DIR_RIGHT);
        this._legendPanel.setTranslateX(0);
      }
    } else {
      this._legendPanel = new DvtCollapsiblePanel(this.getCtx(), maxWidth, maxHeight, legendCollapseDir, 
                                                this.getLegendButtonImages(), this.getControlPanelStyleMap(), disclosed, isFixed);
      this._legendPanel.addEvtListener(DvtCollapsiblePanelEvent.TYPE, this.HandleLegendEvent, false, this);
      this._legendPanel.addEvtListener(DvtResizeEvent.RESIZE_EVENT, this.HandleLegendResize, false, this);
      var expandTooltip = this._legendXml.getAttr('expandTooltip');
      var collapseTooltip = this._legendXml.getAttr('collapseTooltip');
      var legendCollapseDir = DvtAgent.isRightToLeft(this.getCtx()) ? DvtCollapsiblePanel.COLLAPSE_NORTHWEST : DvtCollapsiblePanel.COLLAPSE_NORTHEAST;
      this._legendPanel.setButtonTooltips(expandTooltip, collapseTooltip);
    }
    
    // create and render the legend
    this._legend = new DvtCommonLegend(this.getCtx(), this._legendPanel.getMaxContentWidth(), 
                                        this._legendPanel.getMaxContentHeight(), this.getLegendButtonImages(), this.getLegendStyleMap());
    this._legend.setXML(this._legendXml);
    this.addChild(this._legendPanel);
    this.addChild(this._legend); // temp add for rendering
    this._legend.render();
    
    // add the legend to its container
    var legendPanelDim;
    if (this.getSkinName() == DvtCSSStyle.SKIN_ALTA) {
      var dim = this._legend.getDimensions();
      this._legendPanel.setMaxContainerHeight(dim.h);
      this.removeChild(this._legend);
      
      var upState = new DvtImage(this.getCtx(), this.getResourcesMap()[DvtPanelDrawer.PANEL_LEGEND_ICON_ENA], 0, 0, DvtPanelDrawer.IMAGE_SIZE, DvtPanelDrawer.IMAGE_SIZE);
      var overState = new DvtImage(this.getCtx(), this.getResourcesMap()[DvtPanelDrawer.PANEL_LEGEND_ICON_OVR], 0, 0, DvtPanelDrawer.IMAGE_SIZE, DvtPanelDrawer.IMAGE_SIZE);
      var downState = new DvtImage(this.getCtx(), this.getResourcesMap()[DvtPanelDrawer.PANEL_LEGEND_ICON_DWN], 0, 0, DvtPanelDrawer.IMAGE_SIZE, DvtPanelDrawer.IMAGE_SIZE);
      var tip = this.getResourcesMap()[DvtPanelDrawer.PANEL_LEGEND_TIP];
      this._legendPanel.addPanel(this._legend, upState, overState, downState, tip, DvtPanelDrawer.PANEL_LEGEND);
      this._legendPanel.renderComponent();
      if (disclosed)
        this._legendPanel.setDisclosed(true, true);
    } else {
      this._legendPanel.addContent(this._legend);
      // position the container
      legendPanelDim = this._legendPanel.getDimensions();
      var x = DvtAgent.isRightToLeft(this.getCtx()) ? 5 : this.GetWidth() - 5 - legendPanelDim.w - legendPanelDim.x;
      this._legendPanel.setTranslate(x, 5);
      // add on the 5 px border gap to account for legend size when resetting pzc size for fixed legend
      legendPanelDim.w += 5; 
    }
    
    this._isFixedLegend = isFixed;
    if (isFixed) {
      if (!legendPanelDim)
        legendPanelDim = this._legendPanel.getDimensions();
      this._legendWidth = legendPanelDim.w;
    }
    
  }
}

DvtThematicMap.prototype.InitComponentInternal = function () {
  DvtThematicMap.superclass.InitComponentInternal.call(this);
}

/**
 * @override
 */
DvtThematicMap.prototype.RenderComponentInternal = function () {
  DvtThematicMap.superclass.RenderComponentInternal.call(this);
  
  // Create a new container and render the component into it
  var pzcContainer = new DvtContainer(this.getCtx());
  var cpContainer = new DvtContainer(this.getCtx());
  this._pzc.addChild(pzcContainer);
  this._pzc.getContentPane().addChild(cpContainer);
  this._render(pzcContainer, cpContainer);  
  
  if (!this._topLayer)
    return;
  
  // Re-add the control panel on top of any rendered layers
  this._controlPanel = this._pzc.getControlPanel();
  if (this._controlPanel)
    this._pzc.addChild(this._controlPanel);
  
  // Animation Support
  // Stop any animation in progress
  this._stopAnimation();
  var bBlackBoxUpdate = false
  var bounds = new DvtRectangle(0, 0, this.GetWidth(), this.GetHeight());
  // 3 types of animations can occur
  // 1) animation on display
  // 2) animation on base map change
  // 3) animation on area layer change
  
  if (!this._bRendered && !this._oldPzc) { // Case 1
    // animation on display
    if (DvtBlackBoxAnimationHandler.isSupported(this._animationOnDisplay)) {
      this._animation = DvtBlackBoxAnimationHandler.getInAnimation(this.getCtx(), this._animationOnDisplay, 
                                                                  this._pzc, bounds, 
                                                                  this._animationDuration);
    }
  }
  else { 
    // Trying to match Flash. If the layer changes for example from country to states then we should display the data 
    // layer's animationOnDataChange. However an area layer can have multiple data layers (area and points). We will 
    // just use the animation of the first data layer. 
    var anim = null;
    if (this._bBaseMapChanged && !this._bRenderNullXml) { // Case 2
      anim = this._animationOnMapChange;
    } else if (this._topLayer && this._topLayer.getLayerName() != this._oldTopLayerName) {
      anim = this._topLayer.getAnimation();
      if (!anim) { // Case 3
        var dataLayers = this._topLayer.getDataLayers();
        for (var i in dataLayers) {
          if (dataLayers[i].getAnimation()) {
            anim = dataLayers[i].getAnimation();
            break;
          }
        }
      }
    }    
    if (anim && DvtBlackBoxAnimationHandler.isSupported(anim)) {
      this._animation = DvtBlackBoxAnimationHandler.getCombinedAnimation(this.getCtx(), anim, 
                                                                        this._oldPzc, 
                                                                        this._pzc, bounds, 
                                                                        this._animationDuration);        
      if (this._animation)
        this.addChild(this._oldPzc);
      bBlackBoxUpdate = true;
    }
    else {
      this._pzc.getContentPane().removeChild(this._cpContainer);
    }
  }

  // If an animation was created, play it
  if (this._animation) {
    if (this._controlPanel)
      this.addChild(this._controlPanel);
    this._eventHandler.hideTooltip();
    // Disable event listeners temporarily
    this._eventHandler.removeListeners(this);
    // Start the animation
    this._animation.setOnEnd(this.OnAnimationEnd, this);
    this._animation.play();
  }

  // Update the pointers
  this._pzcContainer = pzcContainer;
  this._cpContainer = cpContainer;
  
  if(this._topLayer){
    this._oldTopLayerName = this._topLayer.getLayerName();
  }
  
  this._bRendered = true;
}

/**
 * Calculate the minimum zoom for this basemap taking into account the pan zoom canvas size
 * @return {number} The minimum zoom for this basemap
 * @private
 */
DvtThematicMap.prototype._calcMinZoom = function () {
    var zoomPadding = this._pzc.getZoomToFitPadding();
    var mapDim = this._topLayer.getLayerDim();
    var pzcDim = this._pzc.getSize();
    pzcDim.w = this._isFixedLegend ? pzcDim.w - this._legendWidth : pzcDim.w;
    var dzx = (pzcDim.w - 2 * zoomPadding) / mapDim.w;
    var dzy = (pzcDim.h - 2 * zoomPadding) / mapDim.h;
    var dz = Math.min(dzx, dzy);
    return dz;
}

/**
 * Renders all layers and subcomponents for this component
 * @param {DvtContainer} pzcContainer A child container of the pan zoom canvas
 * @param {DvtContainer} cpContainer A child container of the pan zoom canvas content pane
 * @private
 */
DvtThematicMap.prototype._render = function (pzcContainer, cpContainer) {
  // render legend first since a fixed legend will affect the canvas size
  this._renderLegend();
    
  // Add all containers
  cpContainer.addChild(this._areaLayers);
  cpContainer.addChild(this._dataAreaLayers);
  if (this.isMarkerZoomBehaviorFixed())
    pzcContainer.addChild(this._dataPointLayers);
  else
    cpContainer.addChild(this._dataPointLayers);
  pzcContainer.addChild(this._labelLayers);
  
  // Render all point layers and the first area layer
  var pzcMatrix = this._pzc.getContentPane().getMatrix();
  this._topLayerRendered = false;
  for (var i = 0;i < this._layers.length;i++) {
    var layer = this._layers[i];
    if ((!this._topLayerRendered && layer instanceof DvtMapAreaLayer) || !(layer instanceof DvtMapAreaLayer)) {
      layer.render(pzcMatrix);
      if (!this._topLayerRendered && layer instanceof DvtMapAreaLayer) {
        this._topLayerRendered = true;
        this._topLayer = layer;
      }
    }
  }
  
  if (!this._topLayer)
    return;
  
  // Set initially focused area
  var navigables = this.getNavigableAreas();
  if (navigables.length == 0)
    navigables = this.getNavigableObjects();
  
  // just use the first object as the focus
  if (this._keyboardHandler)
    this._eventHandler.setInitialFocus(navigables[0]);
  
  // do not set min and max zoom before calling zoom to fit on map
  this._pzc.setMinZoom(null);
  this._pzc.setMaxZoom(null);  
  this._pzc.setZoomingEnabled(true);
  this._pzc.setPanningEnabled(true);
  
  //Check to see if zoom and pan was intitially set, otherwise fit and center to area 
  // On resize and basemap change we want to refit the map to the viewport so ignore any saved zoom state
  if (!this._bBaseMapChanged && !this._bRenderNullXml && this._initialZoom != null) {
    this._pzc.zoomTo(this._initialZoom);
    this._pzc.panTo(this._initialCenterX, this._initialCenterY);
  } else if (this._initialZooming) {
    this._zoomData();
  } else {
    // Only zoom to fit on initial render
    this._pzc.zoomToFit(null, this._topLayer.getLayerDim()); 
  }
  
  // Set initially drilled regions
  this._processInitialDrilled();
  
  // Get the current zoom of the canvas to set min canvas zoom to fit component in viewport
  this._updateZoomLimits();
  
  this._pzc.setZoomingEnabled(this._zooming);
  this._pzc.setPanningEnabled(this._panning);
}

/**
 * Called on data layer ppr to render a data layer with new data.
 * @param {String} xmlString The xml string containing data layer information.
 */
DvtThematicMap.prototype.updateLayer = function (xmlString) {
  // Stop any animations before starting layer animations
  this._bRendered = false;
  this._stopAnimation();
  
  // Parse new data layer
  var parser = this.GetXmlStringParser();
  if (parser) {
    var rootXmlNode = parser.parse(xmlString);
    if (rootXmlNode) {
      this.GetXmlDomParser().ParseDataLayers(rootXmlNode, this._pzc.getContentPane().getMatrix(), this._topLayer.getLayerName());
      this._renderLegend();
      this._bRendered = true;
    }
  }
  
  // reset zoom limits since we could now have an isolated area after data layer update
  this._updateZoomLimits();
}

/**
 * Determines and sets the min and max zoom for the component.
 * @private
 */
DvtThematicMap.prototype._updateZoomLimits = function () {
  var fittedZoom = this._calcMinZoom();
  this._pzc.setMinZoom(fittedZoom);
  this._pzc.setMaxZoom(fittedZoom * this.getMaxZoomFactor());
}

DvtThematicMap.prototype.OnUpdateLayerEnd = function () {
  this._processInitialDrilled();
  
  if (this._initialZooming)
    this._zoomData();
  else if (this._initialZoom == null)
    this._pzc.zoomToFit(null, this._topLayer.getLayerDim()); 
}

DvtThematicMap.prototype.getMapName = function () {
  return this._mapName;
}

DvtThematicMap.prototype.getDrillMode = function () {
  return this._drillMode;
}

/**
 * @override
 * @param {DvtXmlNode} resources The xml node containing component resources
 */
DvtThematicMap.prototype.setResources = function (resources) {
  var childNodes = resources.getChildNodes();
  for (var i = 0;i < childNodes.length;i++) {
    var node = childNodes[i];
    var nodeName = node.getName();
    if (nodeName == DvtThematicMap._ELEM_RESOURCES_CONTROLPANEL)
      DvtThematicMap.superclass.setButtonImages.call(this, node);
    else if (nodeName == DvtThematicMap._ELEM_RESOURCES_LEGEND)
      this._legendButtonImages = node;
    else if (nodeName == DvtThematicMap._ELEM_RESOURCES_PANEL_DRAWER) {
      var arAttrs = node.getAttributes();
      for (var j = 0; j < arAttrs.length; j++) {
        var pair = arAttrs[j];
        this.getResourcesMap()[pair.name] = pair.value;
      }
    }
  }
}

DvtThematicMap.prototype.getLegendButtonImages = function () {
  return this._legendButtonImages;
}

DvtThematicMap.prototype.setLegendXml = function (legendXml) {
  this._legendXml = legendXml;
}

DvtThematicMap.prototype.setRolloverBehavior = function (rolloverBehavior) {
  //  if (this._legend) {
  //    if ("dim" == rolloverBehavior && "dim" != this._rolloverBehavior) {
  //      this._legend.getDisplayObj().addEvtListener('legendItemRollOver', this._rolloverCallback, false, this);      
  //    }
  //    if ("dim" != rolloverBehavior && "dim" == this._rolloverBehavior) {
  //      this._legend.getDisplayObj().removeEvtListener('legendItemRollOver', this._rolloverCallback, false, this);
  //    }
  //  }
  this._rolloverBehavior = rolloverBehavior;
}

DvtThematicMap.prototype.getRolloverBehavior = function () {
  return this._rolloverBehavior;
}

DvtThematicMap.prototype.GetXmlDomParser = function () {
  return new DvtThematicMapParser(this);
}

/**
 * Handles transforms for containers that aren't updated by the pan zoom canvas
 * @param {DvtMatrix} pzcMatrix The pan zoom canvas transform
 * @private
 */
DvtThematicMap.prototype._transformContainers = function (pzcMatrix) {
  // this._areaLayers, and this._dataAreaLayers transforms handled by pzc
  
  // update point and label layers with new panX/panY
  var mat = new DvtMatrix();
  mat.translate(pzcMatrix.getTx(), pzcMatrix.getTy());
  
  // this._dataPointLayers zoom transforms handled by markers to avoid scaling marker filter effects
  // tx/ty transforms are handled by tmap for better interactivity
  if (this.isMarkerZoomBehaviorFixed())
    this._dataPointLayers.setMatrix(mat);
  this._labelLayers.setMatrix(mat);
}

/**
 * Creates and sends a DvtSetPropertyEvent to the peer for control panel state saving
 * @param {DvtPanZoomControlPanelEvent) event The event fired by the control panel on collapse/expand
 * @protected
 */
DvtThematicMap.prototype.HandleControlPanelEvent = function (event) {
  DvtThematicMap.superclass.HandleControlPanelEvent.call(this, event);
  var spEvent = new DvtSetPropertyEvent();
  spEvent.addParam(DvtPanZoomControlPanel.CONTROL_PANEL_BEHAVIOR_KEY, 
                  event.getSubType() == DvtPanZoomControlPanelEvent.SUBTYPE_SHOW ?
                  DvtAbstractPanZoomComponent.CONTROL_PANEL_BEHAVIOR_INIT_EXPANDED :
                  DvtAbstractPanZoomComponent.CONTROL_PANEL_BEHAVIOR_INIT_COLLAPSED);
  this.__dispatchEvent(spEvent);
}

/**
 * Creates and sends a DvtSetPropertyEvent to the peer for legend state saving
 * @param {DvtBaseComponentEvent) event The event fired by the legend container panel on collapse/expand
 * @protected
 */
DvtThematicMap.prototype.HandleLegendEvent = function (event) {
  // Currently only one collapsible container which contains a legend
  var spEvent = new DvtSetPropertyEvent();
  spEvent.addParam(DvtCommonLegend.LEGEND_DISCLOSED_KEY, event.getSubType() == DvtCollapsiblePanelEvent.SUBTYPE_SHOW);
  this.__dispatchEvent(spEvent);
}

/**
 * Constrain the component panning so that we only allow panning when zoomed beyond the current viewport and we don't
 * allow the map to be panned completely outside of the viewport.
 * @param {number} zoom The current component zoom
 * @private
 */
DvtThematicMap.prototype._constrainPanning = function (zoom) {
  var padding = this._pzc.getZoomToFitPadding();
  var pzcDim = this._pzc.getSize();
  var viewportDim = new DvtRectangle(padding, padding, pzcDim.w-2*padding, pzcDim.h-2*padding);
  var mapDim = this._topLayer.getLayerDim();
  var zoomedMapX = mapDim.x*zoom;
  var zoomedMapY = mapDim.y*zoom;
  var zoomedMapW = mapDim.w*zoom;
  var zoomedMapH = mapDim.h*zoom;
  
  if (zoomedMapW>viewportDim.w) {
    this._pzc.setMinPanX((viewportDim.x+viewportDim.w) - (zoomedMapX+zoomedMapW));
    this._pzc.setMaxPanX(viewportDim.x-zoomedMapX);
  } else {
    // if smaller, center it in the viewport
    var legendAdjust = 0;
    if (this._isFixedLegend) {
      if (DvtAgent.isRightToLeft(this.getCtx())) {
        if (this._isZoomingToFit)
          legendAdjust = -this._legendWidth * 2;
        else 
          legendAdjust = -this._legendWidth;
      } else {
        if (!this._isZoomingToFit)
          legendAdjust = this._legendWidth;
      }
    }
    var minMaxX = (viewportDim.x+viewportDim.w-legendAdjust)/2 - (zoomedMapX+zoomedMapW/2);
    this._pzc.setMinPanX(minMaxX);
    this._pzc.setMaxPanX(minMaxX);
  }

  if (zoomedMapH>viewportDim.h) {
    this._pzc.setMinPanY((viewportDim.y+viewportDim.h) - (zoomedMapY+zoomedMapH));
    this._pzc.setMaxPanY(viewportDim.y-zoomedMapY);
  } else {
    var minMaxY = (viewportDim.y+viewportDim.h)/2 - (zoomedMapY+zoomedMapH/2);
    this._pzc.setMinPanY(minMaxY);
    this._pzc.setMaxPanY(minMaxY);
  }
}

/**
 * Updates the DvtAnimator associated with a pan or zoom event with additional properties for containers not added to the content pane.
 * @param {DvtBaseComponentEvent} event The pan or zoom event
 * @param {boolean} bRecenterObjs Whether to recenter map objects that are pinned to a particular long/lat or x/y coordinate
 * @private
 */
DvtThematicMap.prototype._updateAnimator = function(event, bRecenterObjs) {
  var animator = event.getAnimator();
  if (animator) {
    var contentPane = this._pzc.getContentPane();
    var mat = animator.getDestVal(contentPane, contentPane.getMatrix);
    if (bRecenterObjs) {
      this._currentAnimMatrix = contentPane.getMatrix();
      animator.addProp(DvtAnimator.TYPE_MATRIX, this, this._getCenteredObjsMatrix, this._setCenteredObjsMatrix, mat);
    }
    var transMat = new DvtMatrix(1,0,0,1,mat.getTx(),mat.getTy());
    if (this.isMarkerZoomBehaviorFixed())
      animator.addProp(DvtAnimator.TYPE_MATRIX, this._dataPointLayers, this._dataPointLayers.getMatrix, this._dataPointLayers.setMatrix, transMat);
    animator.addProp(DvtAnimator.TYPE_MATRIX, this._labelLayers, this._labelLayers.getMatrix, this._labelLayers.setMatrix, transMat);
  }
}

/**
 * Processes a zoom event for this component and subcomponents.
 * @param {DvtZoomEvent} event The event to process
 * @protected
 */
DvtThematicMap.prototype.HandleZoomEvent = function (event) {
  var type = event.getSubType();
  switch(type) {
    case DvtZoomEvent.SUBTYPE_ADJUST_PAN_CONSTRAINTS:
      // Calculate the new content dimensions based on the new zoom
      if (this._panning)
        this._constrainPanning(event.getNewZoom());    
      break;
    case DvtZoomEvent.SUBTYPE_ZOOMING:
    case DvtZoomEvent.SUBTYPE_ELASTIC_ANIM_BEGIN:
      this._updateAnimator(event, true);
      break;
    case DvtZoomEvent.SUBTYPE_ZOOMED:
      var zoom = event.getNewZoom();
      if (zoom != null) {
        var pzcMatrix = this._pzc.getContentPane().getMatrix();
        event.addParam('panX', pzcMatrix.getTx());
        event.addParam('panY', pzcMatrix.getTy());
        // null out animator for Flash. Temp fix until bug 17080391 is done.
        event._animator = null;
        DvtEventDispatcher.dispatchEvent(this._callback, this._callbackObj, this, event);
  
        this._transformContainers(pzcMatrix);
        
        for (var i = 0;i < this._layers.length;i++)
          this._layers[i].HandleZoomEvent(event, pzcMatrix);
      }
      break;
    case DvtZoomEvent.SUBTYPE_ZOOM_AND_CENTER:
      // zoom and center on the current selection from the last clicked data layer
      // this can include both points and areas
      this.fitSelectedRegions();
      break;
    case DvtZoomEvent.SUBTYPE_ZOOM_TO_FIT_BEGIN:
      this._isZoomingToFit = true;
      if (this._isFixedLegend)
        this._pzc.setSize(this.GetWidth() - this._legendWidth, this.GetHeight(), true);
      break;
    case DvtZoomEvent.SUBTYPE_ZOOM_TO_FIT_END:
      this._isZoomingToFit = false;
      if (this._isFixedLegend)
        this._pzc.setSize(this.GetWidth(), this.GetHeight(), true);
        
      DvtEventDispatcher.dispatchEvent(this._callback, this._callbackObj, this,  new DvtZoomEvent());
      break;
    case DvtZoomEvent.SUBTYPE_ZOOM_TO_FIT_CALC_BOUNDS:
      if (DvtAgent.isPlatformIE()) {
        var contentDim = this._topLayer.getLayerDim();
        event.setZoomToFitBounds(contentDim);
      }
      break;
    default:
      break;
  }
}

/**
 * @override
 */
DvtThematicMap.prototype.HandlePanEvent = function (event) {
  var subType = event.getSubType();
  if (subType == DvtPanEvent.SUBTYPE_ELASTIC_ANIM_BEGIN) {   
    this._updateAnimator(event, false);
  }
  else if (subType == DvtPanEvent.SUBTYPE_PANNED) {
    if (event.getNewX() != null) {
      var pzcMatrix = this._pzc.getContentPane().getMatrix();
      event.addParam('zoom', this._pzc.getZoom());
      event.addParam('panX', pzcMatrix.getTx());
      event.addParam('panY', pzcMatrix.getTy());
      // null out animator for Flash. Temp fix until bug 17080391 is done.
      event._animator = null;
      DvtEventDispatcher.dispatchEvent(this._callback, this._callbackObj, this, event);
      
      this._transformContainers(pzcMatrix);
      
      for (var i = 0;i < this._layers.length;i++)
        this._layers[i].HandlePanEvent(pzcMatrix);
    }
  }
  
  if (this._legendPanel) {
    // Handle DvtPanelDrawer fade
    if (this.getSkinName() == DvtCSSStyle.SKIN_ALTA) {
      if (subType === DvtPanEvent.SUBTYPE_DRAG_PAN_BEGIN) {
        this._legendPanel.setMouseEnabled(false);
      }
      else if (subType === DvtPanEvent.SUBTYPE_DRAG_PAN_END) {
        this._legendPanel.setMouseEnabled(true);
      }
    } else {
      var styleMap = this.getControlPanelStyleMap();
      var stroke = this._legendPanel._background.getStroke().clone();
      // Handle DvtCollapsiblePanel fade
      if (subType === DvtPanEvent.SUBTYPE_DRAG_PAN_BEGIN) {
        this._legend.setAlpha(styleMap[DvtPanZoomControlPanel.BG_DRAG_ALPHA]);
        stroke.setAlpha(styleMap[DvtPanZoomControlPanel.FRAME_DRAG_ALPHA]);
        this._legendPanel._background.setStroke(stroke);
        if (this._legendPanel._buttonFrame)
          this._legendPanel._buttonFrame.setAlpha(styleMap[DvtPanZoomControlPanel.FRAME_DRAG_ALPHA]);
        this._legendPanel.setMouseEnabled(false);
      }
      else if (subType === DvtPanEvent.SUBTYPE_DRAG_PAN_END){
        this._legend.setAlpha(1);
        stroke.setAlpha(styleMap[DvtPanZoomControlPanel.FRAME_ROLLOUT_ALPHA]);
        this._legendPanel._background.setStroke(stroke);
        if (this._legendPanel._buttonFrame)
          this._legendPanel._buttonFrame.setAlpha(styleMap[DvtPanZoomControlPanel.FRAME_ROLLOUT_ALPHA]);
        this._legendPanel.setMouseEnabled(true);
      }
    }
  }
}

DvtThematicMap.prototype.CreatePanZoomCanvas = function (ww, hh) {
  if (this._drillMode == 'none' && 
     (this._featuresOff == DvtThematicMap._FEATURES_OFF_ALL || (!this._zooming && this.getSkinName() == DvtCSSStyle.SKIN_ALTA)))
    this.setControlPanelBehavior(DvtAbstractPanZoomComponent.CONTROL_PANEL_BEHAVIOR_HIDDEN);
    
  this._pzc = DvtThematicMap.superclass.CreatePanZoomCanvas.call(this, ww, hh);
  // Create control panel with drilling buttons if drilling is on
  if (this.getControlPanelBehavior() != DvtAbstractPanZoomComponent.CONTROL_PANEL_BEHAVIOR_HIDDEN && this._drillMode != 'none') {
    var callbacks = [DvtObj.createCallback(this, this.drillUp), DvtObj.createCallback(this, this.drillDown), DvtObj.createCallback(this, this.resetMap)]
    var controlPanel = new DvtThematicMapControlPanel(this.getCtx(), this._drillMode, this._buttonImages, 
                                                        callbacks, this._pzc, this.getPanZoomResources(), 
                                                        this.getDisplayedControls(), this);
    this._pzc.setControlPanel(controlPanel);  
  }
  
  this._eventHandler.setPanZoomCanvas(this._pzc);
  return this._pzc;
}

DvtThematicMap.prototype.setZooming = function (attr) {
  this._zooming = attr;
}

DvtThematicMap.prototype.setPanning = function (attr) {
  this._panning = attr;
}

DvtThematicMap.prototype.addDisclosedRowKey = function (drilled) {
  this._drilledRowKeys.push(drilled);
}

DvtThematicMap.prototype.addDrilledLayer = function (layerName, drilled) {
  this._initDrilled[layerName] = drilled;
}

DvtThematicMap.prototype._processInitialDrilled = function () {
  this._processingInitDrilled = true;
  for (var i=0; i< this._layers.length; i++) {
    var layerName = this._layers[i].getLayerName();
    if (layerName in this._initDrilled) {
      this._selectedAreas[layerName] = this._initDrilled[layerName][1];
      this._clickedLayerName = layerName;
      this._clickedDataLayerId = this._initDrilled[layerName][0];
      this.drillDown();
    }
  }
  this._processingInitDrilled = false;
}

DvtThematicMap.prototype.resetMap = function () {
  // stop previous animation
  this._stopAnimation();
  
  //Clear selection and drilled starting from the lowest layer
  var removeObjs = [];
  var addObjs = [];
  for (var i = this._layers.length-1; i > -1; i--) {
    if (this._layers[i].getLayerName() == this._topLayer.getLayerName())
      this._layers[i].reset(addObjs);
    else
      this._layers[i].reset(removeObjs);
  }
  for (var j=0; j<removeObjs.length; j++) {
    if (removeObjs[j]) {
      var parent = removeObjs[j].getParent();
      if (parent)
        parent.removeChild(removeObjs[j]);
    }
  }
  // addObjs have opacity set to 0
  for (var j=0; j<addObjs.length; j++) {
    if (addObjs[j]) {
      addObjs[j].setAlpha(1);
    }
  }
  this._drilledRowKeys = [];
  this.fitMap();
  this._drilled = [];

  if (this._controlPanel && this._drillMode != 'none') {
    this._controlPanel.setEnabledDrillDownButton(false);
    this._controlPanel.setEnabledDrillUpButton(false);
  }

}

/**
 * Zooms map to fit the current rendered data
 * @private
 */
DvtThematicMap.prototype._zoomData = function () {
  var areaBounds = this._dataAreaLayers.getDimensions();
  var pointBounds = this._dataPointLayers.getDimensions();
  if (this.isMarkerZoomBehaviorFixed()) {
    var mat = this._pzc.getContentPane().getMatrix();
    pointBounds.w /= mat.getA();
    pointBounds.h /= mat.getD();
    pointBounds.x /= mat.getA();
    pointBounds.y /= mat.getD();
  }
  
  var bounds = areaBounds.getUnion(pointBounds);
  var animator = null;
  if (DvtAgent.isEnvironmentBrowser())
    animator = new DvtAnimator(this.getCtx(), .3);
  if (bounds.w > 0 && bounds.h > 0)
    this._pzc.zoomToFit(animator, bounds);
  else
    this._pzc.zoomToFit(animator, this._topLayer.getLayerDim());
  if (animator)
    animator.play();
}

/**
 * Zooms the component to fit the passed in bounds
 * @param {DvtRectangle} bounds The bounds to zoom 
 * @private
 */
DvtThematicMap.prototype._zoomToFitBounds = function (bounds) {
  var animator = new DvtAnimator(this.getCtx(), .3);
  this._pzc.zoomToFit(animator, bounds);
  animator.play();
}

/**
 * Zooms the component to fit a passed in or last clicked area
 * @param {DvtMapDataArea} toFit The area to zoom to fit to
 */
DvtThematicMap.prototype.fitRegion = function (toFit) {
  if (!toFit)
    toFit = this._zoomToFitObject;
  if (!toFit)
    toFit = this._clickedObject;
  this._zoomToFitBounds(toFit.getDimensions());
}

/**
 * Zooms the component to fit the currently selected areas
 */
DvtThematicMap.prototype.fitSelectedRegions = function() {
  if (this._clickedDataLayerId) {
    var dataLayer = this.getLayer(this._clickedLayerName).getDataLayer(this._clickedDataLayerId);
    if (dataLayer) {
      var selectionHandler = dataLayer._selectionHandler;
      if (selectionHandler) {
        var selection = selectionHandler.getSelection();
        for (var i=0; i<selection.length; i++) {
          selection[i] = selection[i].getDisplayable();
        }
        if (selection.length > 0) {
          var bounds = selection[0].getDimensions();
          for (var i=1; i< selection.length; i++)
            bounds = bounds.getUnion(selection[i].getDimensions());
          this._zoomToFitBounds(bounds);
        }
      }
    }
  }
}

DvtThematicMap.prototype.fitMap = function () {
  var animator = new DvtAnimator(this.getCtx(), .3);
  this._pzc.zoomToFit(animator);
  animator.play();
}

DvtThematicMap.prototype.getDrillParentLayer = function (layerName) {
  var parentLayerName = DvtBaseMapManager.getParentLayerName(this._mapName, layerName);
  return this.getLayer(parentLayerName);
}

DvtThematicMap.prototype.getDrillChildLayer = function (layerName) {
  var childLayerName = DvtBaseMapManager.getChildLayerName(this._mapName, layerName);
  return this.getLayer(childLayerName);
}

DvtThematicMap.prototype.getNavigableAreas = function () {
  var disclosed = [];
  if (this._topLayer){
    for (var i = 0;i < this._layers.length;i++) {
      var dataLayers = this._layers[i].getDataLayers();
      for (var id in dataLayers) {
        if (this._topLayer.getLayerName() == this._layers[i].getLayerName())
          disclosed = disclosed.concat(dataLayers[id].getNavigableAreaObjects());
        else 
          disclosed = disclosed.concat(dataLayers[id].getNavigableDisclosedAreaObjects());
      }
    }
  }
  return disclosed;
}

DvtThematicMap.prototype.getNavigableObjects = function () {
  var navigable = [];
  if (this._topLayer) {
    for (var i = 0;i < this._layers.length;i++) {
      var dataLayers = this._layers[i].getDataLayers();
      if (this._topLayer.getLayerName() == this._layers[i].getLayerName() || !(this._layers[i] instanceof DvtMapAreaLayer)) {
        for (var id in dataLayers)
          navigable = navigable.concat(dataLayers[id].getDataObjects());
      }
    }
  }
  return navigable;
}

/**
 * Used for updating the positions of centered objects like markers, images, and labels during animation.
 * @param {DvtMatrix} matrix The current animation matrix to use for updating the centered objects
 * @private
 */
DvtThematicMap.prototype._setCenteredObjsMatrix = function (matrix) {
  this._currentAnimMatrix = matrix;
  // update centered markers and images
  if (this.isMarkerZoomBehaviorFixed()) {
    var objs = this.getNavigableObjects();
    for (var i=0; i<objs.length; i++) 
      objs[i].HandleZoomEvent(matrix);
    // update centered labels for area and area data layers
    var numLabelLayers = this._labelLayers.getNumChildren();
    for (var j=0; j<numLabelLayers; j++) {
      var labelLayer = this._labelLayers.getChildAt(j);
      var numLabels = labelLayer.getNumChildren();
      for (var k=0; k<numLabels; k++) {
        var label = labelLayer.getChildAt(k);
        if (label instanceof DvtMapLabel)
          label.update(matrix);
      }
    }
  }
}

/**
 * Returns the current animation matrix used for updating centered objects
 * @return {DvtMatrix} The current animation matrix
 * @private
 */
DvtThematicMap.prototype._getCenteredObjsMatrix = function() {
  return this._currentAnimMatrix;
}

DvtThematicMap.prototype.drillDown = function () {
  // stop previous animation
  this._stopAnimation();

  var childLayer = this.getDrillChildLayer(this._clickedLayerName);
  var parentLayer = this.getLayer(this._clickedLayerName);
  var fadeInObjs = [];

  if (childLayer) {
    this._drillDataLayer[this._clickedLayerName] = this._clickedDataLayerId;
    
    //Reset other disclosed regions in this layer
    var selectedAreas = this._selectedAreas[this._clickedLayerName];
    // do not reset if just processing initiallly drilled row keys
    if (!this._processingInitDrilled && this._drillMode == 'single') {
      this._drilled.pop();
      parentLayer.reset(fadeInObjs, selectedAreas);
      childLayer.reset(this._drillAnimFadeOutObjs);
    }

    var newSelectedAreas = [];
    for (var i = 0;i < selectedAreas.length;i++) {
      var parentArea = selectedAreas[i];
      var childrenToDisclose = parentLayer.getChildrenForArea(parentArea);
      newSelectedAreas.push(childrenToDisclose[0]);
      
      //Update child to parent mapping 
      for (var j = 0;j < childrenToDisclose.length;j++)
        this._childToParent[childrenToDisclose[j]] = selectedAreas[i];

      //Add disclosed child areas of drilled region
      childLayer.discloseAreas(childrenToDisclose, fadeInObjs);
      //Set the parent area border from selected to drilled
      var drillLayer = parentLayer.getDataLayer(this._clickedDataLayerId);
      if (drillLayer)
        drillLayer.drill(parentArea, this._drillAnimFadeOutObjs);
      //Update list of disclosed areas
      this._drilled.push(parentArea);
    }

    this._handleDrillAnimations(this._drillAnimFadeOutObjs, fadeInObjs, false);
    this._updateDrillButton(childLayer.getLayerName());
    //Update so that drill up will work right after a drill down with no additional selection
    this._clickedLayerName = childLayer.getLayerName();
    this._selectedAreas[this._clickedLayerName] = newSelectedAreas;
  }
}

DvtThematicMap.prototype.drillUp = function () {
  // stop previous animation
  this._stopAnimation();
  
  var childLayer = this.getLayer(this._clickedLayerName);
  var parentLayer = this.getDrillParentLayer(this._clickedLayerName);
  //For fade in/out animation
  var fadeInObjs = [];
  var newSelectedAreas = [];
  var selectedAreas = this._selectedAreas[this._clickedLayerName];
  for (var i = 0;i < selectedAreas.length;i++) {
    var parentArea = this._childToParent[selectedAreas[i]];
    newSelectedAreas.push(parentArea);
    //Don't add a parent area multiple times if many children are selected
    if (DvtArrayUtils.getIndex(this._drilled, parentArea) !=  - 1) {
      var childrenToUndisclose = parentLayer.getChildrenForArea(parentArea);

      //Remove disclosed child areas of drilled region
      childLayer.undiscloseAreas(childrenToUndisclose, this._drillAnimFadeOutObjs);
      //Set the parent area border from drilled to selected
      parentLayer.getDataLayer(this._drillDataLayer[parentLayer.getLayerName()]).undrill(parentArea, fadeInObjs);
      //Update list of disclosed areas
      var index = DvtArrayUtils.getIndex(this._drilled, parentArea);
      if (index !=  - 1)
        this._drilled.splice(index, 1);
    }
  }

  this._handleDrillAnimations(this._drillAnimFadeOutObjs, fadeInObjs, true);

  this._clickedLayerName = parentLayer.getLayerName();
  this._clickedDataLayerId = this._drillDataLayer[this._clickedLayerName];
  this._selectedAreas[this._clickedLayerName] = newSelectedAreas;
  this._updateDrillButton(this._clickedLayerName);
}


DvtThematicMap.prototype._stopAnimation = function () {
  if (this._animation) {
    this._animation.stop(true);
    this._animation = null;
  }
}

/**
 * Handles drilling animations
 * @param {Array} oldObjs The array of displayables that will be removed once drilling is complete
 * @param {Array} newObjs The array of displayables that will be added once drilling is complete
 * @param {boolean} isDrillUp True if this is a drill up animation
 * @private
 */
DvtThematicMap.prototype._handleDrillAnimations = function (oldObjs, newObjs, isDrillUp) {
  var pzcMatrix = this._pzc.getContentPane().getMatrix();
  //Zoom to fit selection only if not proccessing initially drilled on initial render
  if (this._drillZoomToFit && !this._processingInitDrilled) {
    var animator = new DvtAnimator(this.getCtx(), .3);
    if (!DvtAgent.isEnvironmentBrowser())
      animator = null;
    if (isDrillUp)
      this._pzc.zoomToFit(animator);
    else
      this.fitSelectedRegions();
    if (animator)
        animator.play();
  }

  //Stop previous animation
  this._stopAnimation();
  this._animation = DvtBlackBoxAnimationHandler.getCombinedAnimation(this.getCtx(), this._animationOnDrill, oldObjs, newObjs, null, 0.5);
  if (!DvtAgent.isEnvironmentBrowser())
    this._animation = null;
  // If an animation was created, play it
  if (this._animation) {
    this._eventHandler.hideTooltip();
    // Disable event listeners temporarily
    this._eventHandler.removeListeners(this);
    // Start the animation
    this._animation.setOnEnd(this.OnDrillAnimationEnd, this);
    this._animation.play();
  } else {
    this._cleanUpDrilledObjects();
  }
}

DvtThematicMap.prototype.setClickInfo = function (clientId, layerName, obj) {
  this._clickedLayerName = layerName;
  this._clickedDataLayerId = clientId;
  this._clickedObject = obj;
}

DvtThematicMap.prototype.setEventClientId = function (clientId) {
  this._eventClientId = clientId;
}

/**
 * Dispatches the event to the callback function.
 * @param {object} event The event to be dispatched.
 * @protected
 */
DvtThematicMap.prototype.__dispatchEvent = function (event) {
  var type = event.getType();
  if (type == DvtSelectionEvent.TYPE) {
    this._handleSelectionEvent(event);
  }
  else if (type == DvtMapDrillEvent.TYPE) {
    this._handleDrillEvent(event);
  }
  else if (type == DvtShowPopupEvent.TYPE || type == DvtHidePopupEvent.TYPE) {
    event.addParam('clientId', this._eventClientId);
  }
  DvtEventDispatcher.dispatchEvent(this._callback, this._callbackObj, this, event);
}

/**
 * Process a selection event before sending it to the peer
 * @param {DvtSelectionEvent} event The selection event to process
 * @private
 */
DvtThematicMap.prototype._handleSelectionEvent = function (event) {
  if (this._clickedDataLayerId) {
    this._selectedRowKeys = event.getSelection();
    var dataLayer = this.getLayer(this._clickedLayerName).getDataLayer(this._clickedDataLayerId);
    this._selectedAreas[this._clickedLayerName] = dataLayer.getSelectedAreas(this._selectedRowKeys);
    this._updateDrillButton(this._clickedLayerName);
    event.addParam('clientId', this._clickedDataLayerId);
    
    // Save fit to region object
    if (this._clickedObject && !(this._clickedObject instanceof DvtMarker))
      this._zoomToFitObject = this._clickedObject;    
  } else {
    this._updateDrillButton(null);
    this._zoomToFitObject = null;
  }
}

DvtThematicMap.prototype._hideSelectionMenu = function() {
  if (this._selectionText) {
    this.removeChild(this._selectionText);
    this._selectionText = null;
  }
}

DvtThematicMap.prototype._updateDrillButton = function (layerName) {
  if (this._controlPanel && this._drillMode && this._drillMode != 'none') {
    var childLayer = this.getDrillChildLayer(layerName);
    var parentLayer = this.getDrillParentLayer(layerName);
    if (childLayer)
      this._controlPanel.setEnabledDrillDownButton(true);
    else 
      this._controlPanel.setEnabledDrillDownButton(false);

    if (parentLayer)
      this._controlPanel.setEnabledDrillUpButton(true);
    else 
      this._controlPanel.setEnabledDrillUpButton(false);
  }
}

DvtThematicMap.prototype._handleDrillEvent = function (event) {
  event.addParam('clientId', this._eventClientId);
  if (this._drillMode == 'multiple')
    this._drilledRowKeys = this._drilledRowKeys.concat(this._selectedRowKeys);
  else 
    this._drilledRowKeys = this._selectedRowKeys;

  var drillType = event.getDrillType();
  if (drillType == DvtMapDrillEvent.DRILL_UP)
    this.drillUp();
  if (drillType == DvtMapDrillEvent.DRILL_DOWN)
    this.drillDown();
  else if (drillType == DvtMapDrillEvent.RESET)
    this.resetMap();

  event.setDisclosed(this._drilledRowKeys);
}

DvtThematicMap.prototype.destroy = function () {
  DvtThematicMap.superclass.destroy.call(this);
  if (this._eventHandler) {
    this._eventHandler.destroy();
    this._eventHandler = null;
  }
}

/**
 * Hook for cleaning up animation behavior at the end of the animation.
 * @protected
 */
DvtThematicMap.prototype.OnAnimationEnd = function () {
  // Add control panel back to pzc
  if (this._controlPanel)
    this._pzc.addChild(this._controlPanel);
  
  if (this._oldPzc) {
    this.removeChild(this._oldPzc);
    this._oldPzc = null;
  }

  // Remove the animation reference
  this._animation = null;

  // Restore event listeners
  this._eventHandler.addListeners(this);
}

DvtThematicMap.prototype.OnDrillAnimationEnd = function () {
  this._cleanUpDrilledObjects();
  // Remove the animation reference
  this._animation = null;
  // Restore event listeners
  this._eventHandler.addListeners(this);
}

/**
 * Removes the drilled objects from the map
 * @private
 */
DvtThematicMap.prototype._cleanUpDrilledObjects = function () {
  if (this._drillAnimFadeOutObjs.length > 0) {
    for (var i=0; i<this._drillAnimFadeOutObjs.length; i++) {
      var obj = this._drillAnimFadeOutObjs[i];
      if (obj) {
        if (obj instanceof DvtMapLabel) {
          obj.reset();
        } else {
          if (obj.isDrilled && obj.isDrilled()) {
            obj.setAlpha(0);
            continue;
          }
          var parent = obj.getParent();
          if (parent)
            parent.removeChild(obj);
        }
      }
    }
    this._drillAnimFadeOutObjs = [];
  }
}

DvtThematicMap.prototype._rolloverCallback = function (event) {
  var category = event.getHideAttributes();
  //  var hiddenAttrGroups = this.getHiddenAttributeGroups();
  //  if (!hiddenAttrGroups) {
  //    hiddenAttrGroups = [];
  //  }
  //  var index = DvtArrayUtils.getIndex(hiddenAttrGroups, category);
  //  if (index != -1) {
  //    return; // ignore rollover on hidden attribute groups
  //  }
  var type = DvtLegendItemRollOverEvent.MOUSEOVER == event.getMouseState() ? DvtCategoryRolloverEvent.TYPE_OVER : DvtCategoryRolloverEvent.TYPE_OUT;
  this._fireRolloverEvent(type, category);
}

DvtThematicMap.prototype._fireRolloverEvent = function (type, category) {
  var rolloverEvent = new DvtCategoryRolloverEvent(type, category);
  // Build object list
  var objects = new Array();

  // Loop through areas
  for (var layerId in this._areas) {
    for (var key in this._areas[layerId]) {
      objects.push(this._areas[layerId][key]);
    }
  }

  // Loop through markers
  for (var layerId in this._markers) {
    for (var key in this._markers[layerId]) {
      objects.push(this._markers[layerId][key]);
    }
  }

  var legendItems = this._legend._hideAttrsLookUp;
  for (var legendCategory in legendItems) {
    var wrapper = new DvtThematicMapCategoryWrapper(legendItems[legendCategory].getContentShape(), legendCategory);
    objects.push(wrapper);
  }
  DvtCategoryRolloverHandler.processEvent(rolloverEvent, objects, 0.1);
}

/*
 * Prototype for view switcher. Currently gets the only the area data objects from the top layer 
 */
DvtThematicMap.prototype.getShapesForViewSwitcher = function(bOld) {
  var shapes = {};
  var dataLayers = this._topLayer.getDataLayers();
  for (var id in dataLayers) {
    var areaObjs = dataLayers[id].getAreaObjects();
    for (var i=0; i<areaObjs.length; i++) {
      var areaObj = areaObjs[i];
      var disp = areaObj.getDisplayable();
      shapes[areaObj.getId()] = disp; //path
    }
    break;
  }
  return shapes;
}
/**
 * Default values and utility functions for thematic map component versioning.
 * @class
 * @constructor
 * @extends {DvtBaseComponentDefaults}
 */
var DvtThematicMapDefaults = function () {
  this.Init({'fusion':DvtThematicMapDefaults.DEFAULT, 
              'skyros':DvtThematicMapDefaults.SKIN_SKYROS, 
              'alta':DvtThematicMapDefaults.SKIN_ALTA});
}

DvtObj.createSubclass(DvtThematicMapDefaults, DvtBaseComponentDefaults, "DvtThematicMapDefaults");

DvtThematicMapDefaults.DEFAULT = {
  'skin' : null, 
  'animationDuration' : 500, 
  'animationOnDisplay' : 'none', 
  'animationOnDrill' : 'none',
  'animationOnMapChange' : 'none',
  'controlPanelBehavior' : 'hidden',
  'drilling' : 'off',
  'initialZooming' : 'none',
  'maintainDrill' : 'off',
  'markerZoomBehavior' : 'fixed',
  'panning' : 'none', 
  'tooltipDisplay' : 'auto', 
  'zooming' : 'none',
  'styleDefaults' : {
    'areaStyle' : 'background-color:#B8CDEC;border-color:#FFFFFF;',
    'dataAreaDefaults' : {
      'borderColor' : '#FFFFFF',
      'drilledInnerColor' : '#FFFFFF',
      'drilledOuterColor' : '#000000',
      'hoverColor' : '#FFFFFF',
      'opacity' : 1,
      'selectedInnerColor' : '#FFFFFF',
      'selectedOuterColor' : '#000000'
    },
    'dataMarkerDefaults' : {
      'borderColor' : '#FFFFFF',
      'borderStyle' : 'solid',
      'borderWidth' : '0.5px',
      'color' : '#000000', 
      'height' : 8,
      'labelStyle' : 'font-family:Tahoma;font-size:13pt;color:#000000',
      'opacity' : 0.4,
      'scaleX' : 1,
      'scaleY' : 1,
      'shape' : 'circle',
      'width' : 8
    },
    'labelStyle' : 'font-family:Tahoma;font-size:11pt;'
  },
  // for amx only
  'legend' :  {
    'position' : "auto", 'rendered' : true, 'layout' :  {
      'gapRatio' : 1.0
    }
  },
  'layout' :  {
    'gapRatio' : null, // gapRatio is dynamic based on the component size
    // TODO, the following are internal and should be moved to a _layout object
  'legendMaxSize' : 0.3, 'legendGap' : 10
  }
};

DvtThematicMapDefaults.SKIN_SKYROS = {
  'styleDefaults' : {
    'backgroundColor' : '#FFFFFF'
  }
}

DvtThematicMapDefaults.SKIN_ALTA = {
  'skin' : DvtCSSStyle.SKIN_ALTA, 
  'styleDefaults' : {
    'areaStyle' : 'background-color:#DDDDDD;border-color:#FFFFFF;',
    'backgroundColor' : '#FFFFFF',
    'dataAreaDefaults' : {
      'drilledOuterColor' : '#0572CE'
    },
    'dataMarkerDefaults' : {
      'borderStyle' : 'none',
      'color' : 'rgb(51,51,51)', 
      'labelStyle' : 'font-family:"Helvetica Neue",Helvetica,Arial,sans-serif;font-size:12px;color:#333333',
      'opacity' : 1
    },
    'labelStyle' : 'font-family:"Helvetica Neue",Helvetica,Arial,sans-serif;font-size:12px;'
  }
};

DvtThematicMapDefaults.DEFAULT_AREA_LAYER = {
  'animationOnLayerChange' : 'none', 
  'labelDisplay' : 'auto',
  'labelType' : 'short'
};

DvtThematicMapDefaults.DEFAULT_DATA_LAYER = {
  'animationOnDataChange' : 'none', 
  'selection' : 'none'
}

/**
 * Combines the user options with the defaults for the specified version for an area layer.  
 * Returns the combined options object.  This object will contain internal attribute values and should be 
 * accessed in internal code only.
 * @param {object} userOptions The object containing options specifications for this component.
 * @return {object} The combined options object.
 */
DvtThematicMapDefaults.prototype.calcAreaLayerOptions = function(userOptions) {
  return DvtJSONUtils.merge(userOptions, DvtThematicMapDefaults.DEFAULT_AREA_LAYER);
}

/**
 * Combines the user options with the defaults for the specified version for a data layer.  
 * Returns the combined options object.  This object will contain internal attribute values and should be 
 * accessed in internal code only.
 * @param {object} userOptions The object containing options specifications for this component.
 * @return {object} The combined options object.
 */
DvtThematicMapDefaults.prototype.calcDataLayerOptions = function(userOptions) {
  return DvtJSONUtils.merge(userOptions, DvtThematicMapDefaults.DEFAULT_DATA_LAYER);
}

/**
 * Scales down gap sizes based on the size of the component.
 * @param {DvtThematicMap} map The thematic map that is being rendered.
 * @param {Number} defaultSize The default gap size.
 * @return {Number}
 */
DvtThematicMapDefaults.getGapSize = function (tmap, defaultSize) {
  return Math.ceil(defaultSize * tmap.getGapRatio());
}
// APIs called by the ADF Faces drag source for DvtThematicMap

DvtThematicMap.prototype._getCurrentDragSource = function () {
  for (var i = 0;i < this._layers.length;i++) {
    var dataLayers = this._layers[i].getDataLayers();
    for (var id in dataLayers) {
      var dataLayer = dataLayers[id];
      var dragSource = dataLayer.getDragSource();
      if (dragSource && dragSource.getDragCandidate())
        return dragSource;
    }
  }
  return null;
}

/**
 * If this object supports drag, returns the client id of the drag component.
 * Otherwise returns null.
 * @param mouseX the x coordinate of the mouse
 * @param mouseY the x coordinate of the mouse
 * @param clientIds the array of client ids of the valid drag components
 */
DvtThematicMap.prototype.isDragAvailable = function (mouseX, mouseY, clientIds) {
  this._dragAllowed = false;
  var dragSource = this._getCurrentDragSource();
  return dragSource ? dragSource.isDragAvailable(clientIds) : false;
}

/**
 * Returns the transferable object for a drag initiated at these coordinates.
 */
DvtThematicMap.prototype.getDragTransferable = function (mouseX, mouseY) {
  var dragSource = this._getCurrentDragSource();
  return dragSource ? dragSource.getDragTransferable(mouseX, mouseY) : null;
}

/**
 * Returns the feedback for the drag operation.
 */
DvtThematicMap.prototype.getDragOverFeedback = function (mouseX, mouseY) {
  var dragSource = this._getCurrentDragSource();
  return dragSource ? dragSource.getDragOverFeedback(mouseX, mouseY) : null;
}

/**
 * Returns an Object containing the drag context info.
 */
DvtThematicMap.prototype.getDragContext = function (mouseX, mouseY) {
  var dragSource = this._getCurrentDragSource();
  return dragSource ? dragSource.getDragContext(mouseX, mouseY) : null; 
}

/**
 * Returns the offset to use for the drag feedback. This positions the drag
 * feedback relative to the pointer.
 */
DvtThematicMap.prototype.getDragOffset = function (mouseX, mouseY) {
  var dragSource = this._getCurrentDragSource();
  return dragSource ? dragSource.getDragOffset(mouseX, mouseY) : null; 
}

/**
 * Returns the offset from the mouse pointer where the drag is considered to be located.
 */
DvtThematicMap.prototype.getPointerOffset = function (xOffset, yOffset) {
  var dragSource = this._getCurrentDragSource();
  return dragSource ? dragSource.getPointerOffset(xOffset, yOffset) : null;
}

/**
 * Notifies the component that a drag started.
 */
DvtThematicMap.prototype.initiateDrag = function () {
  var dragSource = this._getCurrentDragSource();
  if (dragSource)
    dragSource.initiateDrag();
}

/**
 * Clean up after the drag is completed.
 */
DvtThematicMap.prototype.dragDropEnd = function () {
  var dragSource = this._getCurrentDragSource();
  if (dragSource)
    dragSource.dragDropEnd();
}

/**
 * Implemented for DvtDragRecognizer
 * @override
 */
DvtThematicMap.prototype.prepDrag = function () {
  if (this._panning)
    this._startDragDropTimer(1000);
  else
    this._dragAllowed = true;
}

/**
 * Implemented for DvtDragRecognizer
 * @override
 */
DvtThematicMap.prototype.abortPrep = function () {
  this._stopDragDropTimer();
}

/**
 * Implemented for DvtDragRecognizer
 * @override
 */
DvtThematicMap.prototype.recognizeDrag = function () {
  this._stopDragDropTimer();	
  return this._dragAllowed;	
}

/**
 * Starts the drag timer to prevent immediately initiating a drag action when panning is available
 * @param {number} time The time in milliseconds to set the timer for
 * @private
 */
DvtThematicMap.prototype._startDragDropTimer = function(time) {
  this._dragDropTimer = new DvtTimer(this.getCtx(), time, this._handleDragDropTimer, this, 1);
  this._dragDropTimer.start();
}

/**
 * Stops the drag timer and allows a drag action to initiate
 * @private
 */
DvtThematicMap.prototype._handleDragDropTimer = function() {
  this._stopDragDropTimer();
  this._dragAllowed = true;
}

/**
 * Stops the drag timer
 * @private
 */
DvtThematicMap.prototype._stopDragDropTimer = function() {
  if (this._dragDropTimer) {
    this._dragDropTimer.stop();
    this._dragDropTimer = null;
  }
}
// APIs called by the ADF Faces drop target for DvtThematicMap

DvtThematicMap.prototype._getCurrentDropTarget = function (mouseX, mouseY) {
  for (var i = 0;i < this._layers.length;i++) {
    if (this._layers[i].getDropTarget) {
      var dropTarget = this._layers[i].getDropTarget();
      if (dropTarget && dropTarget.getDropSite(mouseX, mouseY))
        return dropTarget;
    }
  }
  return null;
}

/**
 * If a drop is possible at these mouse coordinates, returns the client id
 * of the drop component. Returns null if drop is not possible.
 */
DvtThematicMap.prototype.acceptDrag = function (mouseX, mouseY, clientIds) {
  var zoom = this._pzc.getZoom();
  mouseX = (mouseX-this._pzc.getPanX())/zoom;
  mouseY = (mouseY-this._pzc.getPanY())/zoom;
  this._dropTarget = this._getCurrentDropTarget(mouseX, mouseY);
  if (this._dropTarget)
    return this._dropTarget.acceptDrag(mouseX, mouseY, clientIds);
  else
    return null;
}

/**
 * Paints drop site feedback as a drag enters the drop site.
 */
DvtThematicMap.prototype.dragEnter = function () {
  if (this._dropTarget)
    return this._dropTarget.dragEnter();
  else
    return null;
}

/**
 * Cleans up drop site feedback as a drag exits the drop site.
 */
DvtThematicMap.prototype.dragExit = function () {
  if (this._dropTarget)
    return this._dropTarget.dragExit();
  else
    return null;
}

/**
 * Returns the object representing the drop site. This method is called when a valid
 * drop is performed.
 */
DvtThematicMap.prototype.getDropSite = function (mouseX, mouseY) {
  var zoom = this._pzc.getZoom();
  mouseX = (mouseX-this._pzc.getPanX())/zoom;
  mouseY = (mouseY-this._pzc.getPanY())/zoom;
  if (this._dropTarget)
    return this._dropTarget.getDropSite(mouseX, mouseY);
  else
    return null;
}
/**
 * Drop Target event handler for DvtThematicMap
 * @param {DvtMapAreaLayer} areaLayer The area layer this drop target belongs to
 * @param {String} basemap The basemap name 
 * @extends DvtDropTarget
 * @constructor
 */
var DvtThematicMapDropTarget = function(areaLayer, basemap) {
  this._areaLayer = areaLayer;  
  this._basemap = basemap;
};

DvtObj.createSubclass(DvtThematicMapDropTarget, DvtDropTarget, "DvtThematicMapDropTarget");

/**
 * @override
 */
DvtThematicMapDropTarget.prototype.acceptDrag = function (mouseX, mouseY, clientIds) {
  // If there is no obj under the point, then don't accept the drag
  var obj = this._areaLayer.__getObjectUnderPoint(mouseX, mouseY);
  if(!obj) {
    this._areaLayer.__showDropSiteFeedback(null);
    return null;
  }
  else if(obj != this._dropSite) {
    this._areaLayer.__showDropSiteFeedback(obj); 
    this._dropSite = obj;
  }
  
  // Return the first clientId, since this component has only a single drag source
  return this._areaLayer.getClientId();
}

/**
 * @override
 */
DvtThematicMapDropTarget.prototype.dragExit = function () {
  // Remove drop site feedback
  this._areaLayer.__showDropSiteFeedback(null); 
  this._dropSite = null;
}

/**
 * @override
 */
DvtThematicMapDropTarget.prototype.getDropSite = function (mouseX, mouseY) {
  var obj = this._areaLayer.__getObjectUnderPoint(mouseX, mouseY);
  if(obj) {
    var projPoint = DvtThematicMapProjections.inverseProject(mouseX, mouseY, this._basemap);
    return {regionId: obj.getAreaName(), localX: projPoint.x, localY: projPoint.y};
  } else {
    return null;
  }
}
// Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved.
/**
  *  Creates a map selectable shape that also supports drilling.
  *  @extends DvtDrillablePath
  *  @constructor
  */
var DvtDrillablePath = function (context, bSupportsVectorEffects) {
  this.Init(context, bSupportsVectorEffects)
}

DvtObj.createSubclass(DvtDrillablePath, DvtPath, "DvtDrillablePath");

// if not defined, stroke width is 1 for border effects
DvtDrillablePath.HOVER_STROKE_WIDTH = 2;
DvtDrillablePath.SELECTED_INNER_STROKE_WIDTH = 1;
DvtDrillablePath.SELECTED_OUTER_STROKE_WIDTH = 4;
DvtDrillablePath.SELECTED_HOVER_OUTER_STROKE_WIDTH = 6;
DvtDrillablePath.DISCLOSED_INNER_STROKE_WIDTH = 2;
DvtDrillablePath.DISCLOSED_OUTER_STROKE_WIDTH = 4;

/**
 *  Object initializer.
 *  @protected
 */
DvtDrillablePath.prototype.Init = function (context, bSupportsVectorEffects) {
  DvtDrillablePath.superclass.Init.call(this, context);
  this._disclosedInnerStroke = null;
  this._disclosedOuterStroke = null;
  this._disclosedInnerShape = null;
  this._disclosedOuterShape = null;
  this._isDrilled = false;
  this.Zoom =  1;
  //IE10, Flash/XML toolkit do not support vector-effects=non-scaling-stroke so we still need to set stroke width based on zoom
  this._bSupportsVectorEffects = bSupportsVectorEffects;
}

DvtDrillablePath.prototype.isDrilled = function () {
  return this._isDrilled;
}

DvtDrillablePath.prototype.setDrilled = function (drilled) {
  if (this._isDrilled == drilled)
    return;
    
  this._isDrilled = drilled;
  
  if (this.isDrilled()) {
    this._disclosedInnerShape = this.copyShape();
    this._disclosedInnerShape.setFill(null);
    this._disclosedInnerShape.setMouseEnabled(false);
    this._disclosedOuterShape = this.copyShape();
    this._disclosedOuterShape.setFill(null);
    this._disclosedOuterShape.setMouseEnabled(false);
    // because we remove the shape from the DOM, set the drill inner border on the parent directly
    var parent = this.getParent();
    parent.addChild(this._disclosedOuterShape);
    parent.addChild(this._disclosedInnerShape);
    this._disclosedInnerShape.setStroke(this._adjustStrokeZoomWidth(this._disclosedInnerStroke, DvtDrillablePath.DISCLOSED_INNER_STROKE_WIDTH));
    this._disclosedOuterShape.setStroke(this._adjustStrokeZoomWidth(this._disclosedOuterStroke, DvtDrillablePath.DISCLOSED_OUTER_STROKE_WIDTH));
    this.setMouseEnabled(false);
  }
  else {
    if (this.isHoverEffectShown()) {
      this.UpdateSelectionEffect();
      this.InnerShape.setStroke(this._adjustStrokeZoomWidth(this.HoverInnerStroke, 1), DvtDrillablePath.HOVER_STROKE_WIDTH);
    }
    this._disclosedOuterShape.getParent().removeChild(this._disclosedOuterShape);
    this._disclosedInnerShape.getParent().removeChild(this._disclosedInnerShape);
    this.setMouseEnabled(true);
    this.setAlpha(1);
  }
}

/**
 * @override
 */
DvtDrillablePath.prototype.setSelected = function (selected) {
  if (this.IsSelected == selected)
    return;
  if (selected) {
    if (this.isHoverEffectShown()) {
      this.CreateSelectedHoverStrokes();
      this.SelectedHoverInnerStroke = this._adjustStrokeZoomWidth(this.SelectedHoverInnerStroke, DvtDrillablePath.HOVER_STROKE_WIDTH);
      this.SelectedHoverOuterStroke = this._adjustStrokeZoomWidth(this.SelectedHoverOuterStroke, DvtDrillablePath.SELECTED_HOVER_OUTER_STROKE_WIDTH);
    } else {
      this.SelectedInnerStroke = this._adjustStrokeZoomWidth(this.SelectedInnerStroke, DvtDrillablePath.SELECTED_INNER_STROKE_WIDTH);
      this.SelectedOuterStroke = this._adjustStrokeZoomWidth(this.SelectedOuterStroke, DvtDrillablePath.SELECTED_OUTER_STROKE_WIDTH);
    }
  }
  DvtDrillablePath.superclass.setSelected.call(this, selected);
}

/**
 * @override
 */
DvtDrillablePath.prototype.showHoverEffect = function () {
  if (this.isSelected()) {
    this.CreateSelectedHoverStrokes();
    this.SelectedHoverInnerStroke = this._adjustStrokeZoomWidth(this.SelectedHoverInnerStroke, DvtDrillablePath.HOVER_STROKE_WIDTH);
    this.SelectedHoverOuterStroke = this._adjustStrokeZoomWidth(this.SelectedHoverOuterStroke, DvtDrillablePath.SELECTED_HOVER_OUTER_STROKE_WIDTH);
  } else {
    this.HoverInnerStroke = this._adjustStrokeZoomWidth(this.HoverInnerStroke, DvtDrillablePath.HOVER_STROKE_WIDTH);
  }
  DvtDrillablePath.superclass.showHoverEffect.call(this);
}

/**
 * @override
 */
DvtDrillablePath.prototype.CreateSelectedHoverStrokes = function() {
  if (!this.SelectedHoverInnerStroke) {
    this.SelectedHoverInnerStroke = this.HoverInnerStroke.clone();
    this.SelectedHoverInnerStroke.setWidth(DvtDrillablePath.HOVER_STROKE_WIDTH);
    if (this._bSupportsVectorEffects)
      this.SelectedHoverInnerStroke.setFixedWidth(true);
  }
  if (!this.SelectedHoverOuterStroke) {
    this.SelectedHoverOuterStroke = this.SelectedOuterStroke.clone();
    this.SelectedHoverOuterStroke.setWidth(DvtDrillablePath.SELECTED_HOVER_OUTER_STROKE_WIDTH);
    if (this._bSupportsVectorEffects)
      this.SelectedHoverOuterStroke.setFixedWidth(true);
  }
}

/**
 * @override
 */
DvtDrillablePath.prototype.hideHoverEffect = function () {
  if (this.isSelected()) {
    this.SelectedInnerStroke = this._adjustStrokeZoomWidth(this.SelectedInnerStroke, DvtDrillablePath.SELECTED_INNER_STROKE_WIDTH);
    this.SelectedOuterStroke = this._adjustStrokeZoomWidth(this.SelectedOuterStroke, DvtDrillablePath.SELECTED_OUTER_STROKE_WIDTH);
  }
  DvtDrillablePath.superclass.hideHoverEffect.call(this);
}

/**
 * @override
 */
DvtDrillablePath.prototype.setHoverStroke = function (innerStroke, outerStroke) {
  DvtDrillablePath.superclass.setHoverStroke.call(this, innerStroke, outerStroke);
  if (this._bSupportsVectorEffects) {
    if (this.HoverInnerStroke)
      this.HoverInnerStroke.setFixedWidth(true);
    if (this.HoverOuterStroke)
      this.HoverOuterStroke.setFixedWidth(true);
  }
  return this;
}

/**
 * @override
 */
DvtDrillablePath.prototype.setSelectedStroke = function (innerStroke, outerStroke) {
  DvtDrillablePath.superclass.setSelectedStroke.call(this, innerStroke, outerStroke);
  if (this._bSupportsVectorEffects) {
    if (this.SelectedInnerStroke)
      this.SelectedInnerStroke.setFixedWidth(true);
    if (this.SelectedOuterStroke)
      this.SelectedOuterStroke.setFixedWidth(true);
  }
  return this;
}

/**
 * @override
 */
DvtDrillablePath.prototype.setSelectedHoverStroke = function (innerStroke, outerStroke) {
  DvtDrillablePath.superclass.setSelectedHoverStroke.call(this, innerStroke, outerStroke);
  if (this._bSupportsVectorEffects) {
    if (this.SelectedHoverInnerStroke)
      this.SelectedHoverInnerStroke.setFixedWidth(true);
    if (this.SelectedHoverOuterStroke)
      this.SelectedHoverOuterStroke.setFixedWidth(true);
  }
  return this;
}

/**
 * Sets the disclosed stroke for this shape.
 * @return DvtDrillablePath To be used for chaining
 */
DvtDrillablePath.prototype.setDisclosedStroke = function (innerStroke, outerStroke) {
  this._disclosedInnerStroke = innerStroke;
  if (this._disclosedInnerStroke && this._bSupportsVectorEffects)
    this._disclosedInnerStroke.setFixedWidth(true);
  this._disclosedOuterStroke = outerStroke;
  if (this._disclosedOuterStroke && this._bSupportsVectorEffects)
    this._disclosedOuterStroke.setFixedWidth(true);
  return this;
}

DvtDrillablePath.prototype.savePatternFill = function (fill) {
  this._ptFill = fill;
}

DvtDrillablePath.prototype.getSavedPatternFill = function () {
  return this._ptFill;
}

DvtDrillablePath.prototype._updateStrokeZoomWidth = function (shape, fixedWidth) {
  if (!this._bSupportsVectorEffects) {
    var stroke = shape.getStroke();
    if (stroke) {
      stroke = stroke.clone();
      stroke.setWidth(fixedWidth/this.Zoom);
      shape.setStroke(stroke);
    }
  }
}

DvtDrillablePath.prototype._adjustStrokeZoomWidth = function (stroke, fixedWidth) {
  if (!this._bSupportsVectorEffects) {
    var adjustedStroke = stroke.clone();
    adjustedStroke.setWidth(fixedWidth/this.Zoom);
    return adjustedStroke;
  }
  return stroke;
}

DvtDrillablePath.prototype.handleZoomEvent = function (pzcMatrix) {
  this.Zoom = pzcMatrix.getA();
  if (this.isDrilled()) {
    this._updateStrokeZoomWidth(this._disclosedInnerShape, DvtDrillablePath.DISCLOSED_INNER_STROKE_WIDTH);
    this._updateStrokeZoomWidth(this._disclosedOuterShape, DvtDrillablePath.DISCLOSED_OUTER_STROKE_WIDTH);
  }
  else if (this.isSelected()) {
    if (this.isHoverEffectShown()) {
      this._updateStrokeZoomWidth(this.InnerShape, DvtDrillablePath.HOVER_STROKE_WIDTH);
      this._updateStrokeZoomWidth(this, DvtDrillablePath.SELECTED_HOVER_OUTER_STROKE_WIDTH);
    } else {
      this._updateStrokeZoomWidth(this.InnerShape, DvtDrillablePath.SELECTED_INNER_STROKE_WIDTH);
      this._updateStrokeZoomWidth(this, DvtDrillablePath.SELECTED_OUTER_STROKE_WIDTH);
    }
  }
  else if (this.isHoverEffectShown()) {
    this._updateStrokeZoomWidth(this.InnerShape, DvtDrillablePath.HOVER_STROKE_WIDTH);
  }
  else {
    this._updateStrokeZoomWidth(this, 1);
  }
}
var DvtBaseMapManager = this['DvtBaseMapManager'];
if (!DvtBaseMapManager) {
  DvtBaseMapManager = {};
  DvtBaseMapManager._UNPROCESSED_MAPS = [[],[],[]];
  DvtBaseMapManager._UNPROCESSED_PARENT_UPDATES = [[],[],[]];
} else {
  DvtBaseMapManager._UNPROCESSED_MAPS = DvtBaseMapManager['_UNPROCESSED_MAPS'];
  DvtBaseMapManager._UNPROCESSED_PARENT_UPDATES = DvtBaseMapManager['_UNPROCESSED_PARENT_UPDATES'];
}


if(typeof(DVT_ADVANCED_CLOSURE) != 'undefined') {
  goog.exportSymbol('DvtBaseMapManager', DvtBaseMapManager);
  goog.exportProperty(DvtBaseMapManager, '_UNPROCESSED_MAPS', DvtBaseMapManager._UNPROCESSED_MAPS);
  goog.exportProperty(DvtBaseMapManager, '_UNPROCESSED_PARENT_UPDATES', DvtBaseMapManager._UNPROCESSED_PARENT_UPDATES);
}

DvtObj.createSubclass(DvtBaseMapManager, DvtObj, "DvtBaseMapManager");

DvtBaseMapManager.TYPE_LABELS = 0;// contain region labels
DvtBaseMapManager.TYPE_PATH = 1;// contain region paths
DvtBaseMapManager.TYPE_PARENTREGION_CHILDREN = 2;// contains parent region id to current region id mappings.  Stored this way since mapping is only needed if child layer is present. 
DvtBaseMapManager.TYPE_LABELINFO = 3;// contains leaderline info
DvtBaseMapManager.TYPE_DIM = 4; //basemap dimensions
DvtBaseMapManager._INDEX = '__index';
DvtBaseMapManager._GLOBAL_MAPS = new Object();

DvtBaseMapManager.getBaseMapDim = function (baseMapName, layerName) {
  DvtBaseMapManager._processUnprocessedMaps();
  var layer = DvtBaseMapManager._GLOBAL_MAPS[baseMapName][layerName];
  if (layer) {
    var dimAr = layer[DvtBaseMapManager.TYPE_DIM];
    if (dimAr)
      return new DvtRectangle(dimAr[0], dimAr[1], dimAr[2], dimAr[3]);
  }
  return null;
}

DvtBaseMapManager.getAreaLabelInfo = function (baseMapName, layerName) {
  DvtBaseMapManager._processUnprocessedMaps();
  var layer = DvtBaseMapManager._GLOBAL_MAPS[baseMapName][layerName];
  if (layer)
    return layer[DvtBaseMapManager.TYPE_LABELINFO];
  else
    return null;
}

DvtBaseMapManager.getAreaNames = function (baseMapName, layerName) {
  DvtBaseMapManager._processUnprocessedMaps();
  var layer = DvtBaseMapManager._GLOBAL_MAPS[baseMapName][layerName];
  if (layer)
    return layer[DvtBaseMapManager.TYPE_LABELS];
  else
    return null;
}

DvtBaseMapManager.getLongAreaLabel = function (baseMapName, layerName, areaId) {
  DvtBaseMapManager._processUnprocessedMaps();
  var layer = DvtBaseMapManager._GLOBAL_MAPS[baseMapName][layerName];
  var labels;
  if (layer)
    labels = layer[DvtBaseMapManager.TYPE_LABELS];
  if (labels && labels[areaId])
    return labels[areaId][1];
  else
    return null;
}

DvtBaseMapManager.getCityCoordinates = function (baseMapName, city) {
  DvtBaseMapManager._processUnprocessedMaps();
  var basemap = DvtBaseMapManager._GLOBAL_MAPS[baseMapName];
  if (basemap) {
    var cityLayer = basemap['cities'];
    if (cityLayer) {
      var coords =  cityLayer[DvtBaseMapManager.TYPE_PATH][city];
      if (coords)
          return new DvtPoint(coords[0], coords[1]);
    }
  }
  return null;
}

DvtBaseMapManager.getCityLabel = function (baseMapName, city) {
  DvtBaseMapManager._processUnprocessedMaps();
  var basemap = DvtBaseMapManager._GLOBAL_MAPS[baseMapName];
  if (basemap) {
    var cityLayer = basemap['cities'];
    if (cityLayer) {
      var cityLabel = cityLayer[DvtBaseMapManager.TYPE_LABELS][city];
      if (cityLabel)
        return cityLabel[1];
    }
  }
  return null;
}

DvtBaseMapManager.getAreaCenter = function (baseMapName, layerName, areaId) {
  DvtBaseMapManager._processUnprocessedMaps();
  var basemap = DvtBaseMapManager._GLOBAL_MAPS[baseMapName];
  if (basemap) {
    var layer = basemap[layerName];
    if (layer) {
      var labelInfo = layer[DvtBaseMapManager.TYPE_LABELINFO];
      if (labelInfo && labelInfo[areaId]) {
        var ar = labelInfo[areaId][0];
        var bounds = DvtRectangle.create(ar);
        return bounds.getCenter();
      } else {
        // manually calculate the area path center
        var path = DvtBaseMapManager._GLOBAL_MAPS[baseMapName][layerName][DvtBaseMapManager.TYPE_PATH][areaId];
        if (!path)
          return null;
        var arPath = DvtPathUtils.createPathArray(path);
        var dim = DvtPathUtils.getDimensions(arPath);
        return dim.getCenter();
      }
    }
  }
  return null;
}

DvtBaseMapManager.getChildLayerName = function (baseMapName, layerName) {
  DvtBaseMapManager._processUnprocessedMaps();
  var layer =  DvtBaseMapManager._GLOBAL_MAPS[baseMapName][layerName];
  if (layer)
    return DvtBaseMapManager._GLOBAL_MAPS[baseMapName][DvtBaseMapManager._INDEX][layer['__index'] + 1];
  else
    return null;
}

/**
 * Returns the parent layer name of the passed in layer or null if none exists
 * @param {String} baseMapName The basemap name
 * @param {String} layerName The layer name
 * @return {String} The parent layer name of the passed in layer
 */
DvtBaseMapManager.getParentLayerName = function (baseMapName, layerName) {
  DvtBaseMapManager._processUnprocessedMaps();
  var layer =  DvtBaseMapManager._GLOBAL_MAPS[baseMapName][layerName];
  if (layer)
    return DvtBaseMapManager._GLOBAL_MAPS[baseMapName][DvtBaseMapManager._INDEX][DvtBaseMapManager._GLOBAL_MAPS[baseMapName][layerName]['__index'] - 1];
  else
    return null;
}

DvtBaseMapManager.getAreaPaths = function (baseMapName, layerName) {
  DvtBaseMapManager._processUnprocessedMaps();
  return DvtBaseMapManager._GLOBAL_MAPS[baseMapName][layerName][DvtBaseMapManager.TYPE_PATH];
}

DvtBaseMapManager.getPathForArea = function (baseMapName, layerName, area) {
  DvtBaseMapManager._processUnprocessedMaps();
  return DvtBaseMapManager._GLOBAL_MAPS[baseMapName][layerName][DvtBaseMapManager.TYPE_PATH][area];
}

DvtBaseMapManager.getChildrenForLayerAreas = function (baseMapName, layerName) {
  DvtBaseMapManager._processUnprocessedMaps();
  var childLayerName = DvtBaseMapManager.getChildLayerName(baseMapName, layerName);
  if (childLayerName) {
    var children = DvtBaseMapManager._GLOBAL_MAPS[baseMapName][childLayerName][DvtBaseMapManager.TYPE_PARENTREGION_CHILDREN];
    if (children)
      return children;
    else
      return [];
  } 
  return [];
}

DvtBaseMapManager.getMapLayerName = function (baseMapName, index) {
  DvtBaseMapManager._processUnprocessedMaps();
  return DvtBaseMapManager._GLOBAL_MAPS[baseMapName][DvtBaseMapManager._INDEX][index];
}

/**
 * @export
 * called at the end of the base map JS metadata files to register new base map layer metadata
 */
DvtBaseMapManager.registerBaseMapLayer = function (baseMapName, layerName, labelMetadata, pathMetadata, parentsRegionMetadata, labelInfoMetadata, index, dim) {
  // bootstrap global base map metadata  
  // find or create basemap metadata
  var basemapMetadata = DvtBaseMapManager._GLOBAL_MAPS[baseMapName];
  if (!basemapMetadata) {
    basemapMetadata = new Object();
    basemapMetadata[DvtBaseMapManager._INDEX] = new Array();
    DvtBaseMapManager._GLOBAL_MAPS[baseMapName] = basemapMetadata;
  }

  // find or create layer metadata
  var layerMetadata = basemapMetadata[layerName];
  if (!layerMetadata) {
    layerMetadata = new Object();
    basemapMetadata[layerName] = layerMetadata;
    // custom area layers don't have indicies when registered
    if (index != null)
    basemapMetadata[DvtBaseMapManager._INDEX][index] = layerName;
  }

  // register layer metadata base on type
  layerMetadata[DvtBaseMapManager.TYPE_LABELS] = labelMetadata;
  layerMetadata[DvtBaseMapManager.TYPE_PATH] = pathMetadata;
  layerMetadata[DvtBaseMapManager.TYPE_PARENTREGION_CHILDREN] = parentsRegionMetadata;
  layerMetadata[DvtBaseMapManager.TYPE_LABELINFO] = labelInfoMetadata;
  layerMetadata[DvtBaseMapManager.TYPE_DIM] = dim;
  layerMetadata[DvtBaseMapManager._INDEX] = index;
}

/**
 * @export
 */
DvtBaseMapManager.registerResourceBundle = function (baseMapName, layerName, labelMetadata) {
  var basemapMetadata = DvtBaseMapManager._GLOBAL_MAPS[baseMapName];
  if (!basemapMetadata) {
    basemapMetadata = new Object();
    DvtBaseMapManager._GLOBAL_MAPS[baseMapName] = basemapMetadata;
  }

  // find or create layer metadata
  var layerMetadata = basemapMetadata[layerName];
  if (!layerMetadata) {
    layerMetadata = new Object();
    basemapMetadata[layerName] = layerMetadata;
  }
  
  var layerMetadata = basemapMetadata[layerName];
  // Overwrite english labels with resource bundle language
  if (layerMetadata)
    layerMetadata[DvtBaseMapManager.TYPE_LABELS] = labelMetadata;
}

/**
 * @export
 */
DvtBaseMapManager.updateResourceBundle = function (baseMapName, layerName, labelMetadata) {
  var basemapMetadata = DvtBaseMapManager._GLOBAL_MAPS[baseMapName];
  if (basemapMetadata) {
      var layerMetadata = basemapMetadata[layerName];
      // Overwrite english labels with resource bundle language
      if (layerMetadata) {
          for(var prop in labelMetadata){
              layerMetadata[DvtBaseMapManager.TYPE_LABELS][prop] = labelMetadata[prop];
          }
      }
  }
}

/**
 * Called only by Flash thematic map to load basemaps
 * @export
 */
DvtBaseMapManager.loadUnprocessedMaps = function(unprocessedMaps, hierarchyUpdates) {
  DvtBaseMapManager._UNPROCESSED_MAPS = unprocessedMaps;  
  DvtBaseMapManager._UNPROCESSED_PARENT_UPDATES = hierarchyUpdates;
  DvtBaseMapManager._processUnprocessedMaps();
}

DvtBaseMapManager._processUnprocessedMaps = function() {
  var i;
  var args;
  if (DvtBaseMapManager._UNPROCESSED_MAPS) {
    for (i = 0; i < DvtBaseMapManager._UNPROCESSED_MAPS[0].length; i++) { // registerBaseMapLayer
      args = DvtBaseMapManager._UNPROCESSED_MAPS[0][i];
      DvtBaseMapManager.registerBaseMapLayer(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7]);
    }
    for (i = 0; i < DvtBaseMapManager._UNPROCESSED_MAPS[1].length; i++) { // registerResourceBundle
      args = DvtBaseMapManager._UNPROCESSED_MAPS[1][i];
      DvtBaseMapManager.registerResourceBundle(args[0], args[1], args[2]);
    }
    for (i = 0; i < DvtBaseMapManager._UNPROCESSED_MAPS[2].length; i++) { // updateResourceBundle
      args = DvtBaseMapManager._UNPROCESSED_MAPS[2][i];
      DvtBaseMapManager.updateResourceBundle(args[0], args[1], args[2]);
    }
    DvtBaseMapManager._UNPROCESSED_MAPS = null;
  }
  
  // update custom area layers and update hierarchy indicies
  if (DvtBaseMapManager._UNPROCESSED_PARENT_UPDATES) {
    for (i = 0; i < DvtBaseMapManager._UNPROCESSED_PARENT_UPDATES[0].length; i++) {
      args = DvtBaseMapManager._UNPROCESSED_PARENT_UPDATES[0][i];
      // update extending layer parent mapping
      var basemapName = args[0];
      var extendedLayer = args[1];
      var layerName = args[2];
      var basemapMetadata = DvtBaseMapManager._GLOBAL_MAPS[basemapName];
      var basemapDim;
      var layerMetadata;
      if (basemapMetadata) {
        layerMetadata = basemapMetadata[extendedLayer];
        if (layerMetadata) {
          layerMetadata[DvtBaseMapManager.TYPE_PARENTREGION_CHILDREN] = args[3];
          basemapDim = layerMetadata[DvtBaseMapManager.TYPE_DIM];
          // get the index of the extended layer and update indicies for layers
          var index = layerMetadata[DvtBaseMapManager._INDEX];
          var indicies = basemapMetadata[DvtBaseMapManager._INDEX];
          indicies.splice(index, 0, layerName);
          basemapMetadata[layerName][DvtBaseMapManager._INDEX] = index;
          for (var i=(index+1); i<indicies.length; i++) {
            var lowerLayer = basemapMetadata[indicies[i]];
            if (lowerLayer)
              lowerLayer[DvtBaseMapManager._INDEX]++;
          }
        }
        
        // update custom layer dimensions from extending layer
        layerMetadata = basemapMetadata[args[2]];
        if (layerMetadata) {
          layerMetadata[DvtBaseMapManager.TYPE_DIM] = basemapDim;
        }
      }
    }
  }
}

DvtBaseMapManager.simplifyAreaPaths = function(paths, basemapW, basemapH, viewportW, viewportH, zoomFactor) {
  // determine the scale factor for the map given the viewport
  if (zoomFactor > 0) {
    var dzx = viewportW/basemapW;
    var dzy = viewportH/basemapH;
    var dz = Math.min(dzx, dzy);
    var scale = 1/(dz*zoomFactor); // 6 is the current max zoom
    if (scale <= 1)
      return paths;
    // If scale = 10 that means 10 pixels in the map coordinate space = 1 pixel in the current viewport
    // and any draw commands less than 10 pixels in the map coordinate space won't even show up in the viewport
    var simplifiedPaths = [];
    if (paths) {
      for (var path in paths) {
        var pathAr = paths[path];
        if (isNaN(pathAr))
          pathAr = DvtPathUtils.createPathArray(paths[path]);
        simplifiedPaths[path] = DvtPathUtils.simplifyPath(pathAr, scale);
      }
    }
    return simplifiedPaths;
  } else {
    return paths;
  }
}
/**
 * @constructor
 */
var DvtThematicMapCategoryWrapper = function(displayable, category)
{
  this.Init(displayable, category);
};

DvtObj.createSubclass(DvtThematicMapCategoryWrapper, DvtObj, "DvtThematicMapCategoryWrapper");

DvtThematicMapCategoryWrapper.prototype.Init = function(displayable, category) {
  this._displayable = displayable;
  this._category = category;
}

DvtThematicMapCategoryWrapper.prototype.getCategories = function() {
  return this._category;
}

DvtThematicMapCategoryWrapper.prototype.getDisplayables = function() {
  return [this._displayable];
}
var DvtMapDrillEvent = function(drillType) {
  this.Init(DvtMapDrillEvent.TYPE);
  this._drillType = drillType;
}

DvtObj.createSubclass(DvtMapDrillEvent, DvtBaseComponentEvent, "DvtMapDrillEvent");

DvtMapDrillEvent.TYPE = "drill";
DvtMapDrillEvent.DRILL_UP = 0;
DvtMapDrillEvent.DRILL_DOWN = 1;
DvtMapDrillEvent.RESET = 2;

/**
 * Returns the array of currently drilled ids for the component.
 * @return {array} The array of currently drilled ids for the component.
 */
DvtMapDrillEvent.prototype.getDisclosed = function() {
  return this._disclosed;
}

DvtMapDrillEvent.prototype.setDisclosed = function(disclosed) {
  this._disclosed = disclosed;
}

DvtMapDrillEvent.prototype.getDrillType = function() {
  return this._drillType;
}
/**
 * Map action event.
 * @param {string} [clientId] The client id associated with this action event.
 * @param {string} [rowKey] The rowKey for the object associated with this event.
 * @param {string} [action] The action name.
 * @class
 * @constructor
 * @export
 */
var DvtMapActionEvent = function(clientId, rowKey, action) {
  this.Init(DvtMapActionEvent.TYPE);
  this._clientId = clientId;
  this._rowKey = rowKey;
  this._action = action;
}

DvtObj.createSubclass(DvtMapActionEvent, DvtBaseComponentEvent, "DvtMapActionEvent");

/**
 * @export
 */
DvtMapActionEvent.TYPE = "action";

/**
 * Returns the clientId associated with this event.
 * @return {string} clientId.
 * @export
 */
DvtMapActionEvent.prototype.getClientId = function() {
  return this._clientId;
}

/**
 * Returns the rowKey of the object associated with this event.
 * @return {string} rowKey.
 * @export
 */
DvtMapActionEvent.prototype.getRowKey = function() {
  return this._rowKey;
}

/**
 * Returns the action name.
 * @return {string} action.
 * @export
 */
DvtMapActionEvent.prototype.getAction = function() {
  return this._action;
}
/**
 * Base map layer metadata
 * @extends DvtObj
 * @class base map layer metadata
 * @constructor
 * 
 * @param {DvtContext} context The rendering context
 * @param {String} label Text for label
 * @param {Array} labelInfo Contains the label bounding box at different zoom levels and leader line info
 * @param {String} labelDisplay Specifies whether to display labels. "off", "on", or "auto"
 * @param {DvtContainer} parentContainer The container to add the label to
 * @param {boolean} bSupportsVectorEffects Whether the rendering platform supports vector effects
 */
var DvtMapLabel = function (context, label, labelInfo, labelDisplay, parentContainer, bSupportsVectorEffects) {
  this.Init(context, label, labelInfo, labelDisplay, parentContainer, bSupportsVectorEffects);
}

DvtObj.createSubclass(DvtMapLabel, DvtOutputText, "DvtMapLabel");

/**
 * Initializes label.  Sets bounding rectangle for label and draws leaderlines if present.
 * 
 * @param {DvtContext} context The rendering context
 * @param {String} label Text for label
 * @param {Array} labelInfo Contains the label bounding box at different zoom levels and leader line info
 * @param {String} labelDisplay Specifies whether to display labels. "off", "on", or "auto"
 * @param {DvtContainer} parentContainer The container to add the label to
 * @param {boolean} bSupportsVectorEffects Whether the rendering platform supports vector effects
 * @protected
 */
DvtMapLabel.prototype.Init = function (context, label, labelInfo, labelDisplay, parentContainer, bSupportsVectorEffects) {
  DvtMapLabel.superclass.Init.call(this, context, label, 0, 0);
  //IE10, Flash/XML toolkit do not support vector-effects=non-scaling-stroke so we still need to set stroke width based on zoom
  this._bSupportsVectorEffects = bSupportsVectorEffects;
  this._boundRectangle = new Array();
  this.setMouseEnabled(false);
  this.alignCenter();
  this.alignMiddle();
  this._center = null;
  this._labelDisplay = labelDisplay;
  this._parentContainer = parentContainer;
  
  if (labelInfo) {
    this._boundRectangle.push(DvtRectangle.create(labelInfo[0]));
    if (labelInfo.length > 1) {
      this._leaderLines = new Array();
  
      for (var i = 1;i < labelInfo.length;i++) {
        var line = labelInfo[i];
        this._boundRectangle.push(DvtRectangle.create(line[0]));
  
        var polyline = new DvtPolyline(context, line[1]);
        polyline.setPixelHinting(true);
        var stroke = new DvtSolidStroke('#000000');
        if (this._bSupportsVectorEffects)
          stroke.setFixedWidth(true);
        polyline.setStroke(stroke);
        this._leaderLines.push(polyline);
      }
    }
  }
}

DvtMapLabel.prototype.addBounds = function (boundsRect) {
  this._boundRectangle.push(boundsRect);
}

DvtMapLabel.prototype.hasBounds = function () {
  return this._boundRectangle.length > 0;
}

/**
 * Updates this label's position, adding and 
 * removing it as needed.
 * @param {DvtMatrix} pzcMatrix zoom matrix
 */
DvtMapLabel.prototype.update = function (pzcMatrix) {
  var zoom = pzcMatrix.getA();
  var state = -1;
  var estimatedDims = DvtTextUtils.guessTextDimensions(this);
  var remove = false;
  for (var i = 0;i < this._boundRectangle.length;i++) {
    var zoomW = this._boundRectangle[i].w * zoom;
    if (estimatedDims.w <= zoomW ) {
      state = i;
      break;
    } else {
      // estimatedDims is a conservative guess so if it doesn't fit we need to check the real dimensions
      if (!this.getParent()) {
        remove = true;
        this._parentContainer.addChild(this);
      }
      if (this.getDimensions().w <= zoomW) {
        state = i
        break;
      }
    }
  }
  
  // if labels are always displayed, use the last available bounding box
  if (state == -1 && this._labelDisplay == 'on')
    state = this._boundRectangle.length-1;
    
  if (this._currentState != state) {
    if (state == -1) {
      this.reset();
    } else {
      if (!this.getParent()) 
        this._parentContainer.addChild(this);
      var center = this._boundRectangle[state].getCenter();
      this.setCenter(center);
      if (this._leaderLines) {
        this._parentContainer.removeChild(this._leaderLine);
        this._leaderLine = null;
        if (state > 0) {
          this._leaderLine = this._leaderLines[state - 1];
          this._parentContainer.addChild(this._leaderLine);
          // when using leaderliners, change text to black
          var style = this.getCSSStyle();
          style.setStyle(DvtCSSStyle.COLOR, '#000000');
          this.setCSSStyle(style);
          var labelBox = this._boundRectangle[state];
          var leaderLinePoints = this._leaderLine.getPoints();
          var numPoints = leaderLinePoints.length;
          if (labelBox.x > leaderLinePoints[numPoints-2]) {
            // leaderline position: left
            this.alignLeft();
            this.alignMiddle();
            this.setCenter(new DvtPoint(labelBox.x, center.y));
          }
          else if (labelBox.y > leaderLinePoints[numPoints-1]) {
            // leaderline position: top
            this.alignTop();
            this.alignCenter();
            this.setCenter(new DvtPoint(center.x, labelBox.y));
          }
          else if ((labelBox.x+labelBox.w) < leaderLinePoints[numPoints-2]) {
            // leaderline position: right
            this.alignRight();
            this.alignMiddle();
            this.setCenter(new DvtPoint(labelBox.x+labelBox.w, center.y));
          }
          else if ((labelBox.y+labelBox.h) < leaderLinePoints[numPoints-1]) {
            // leaderline position: bottom
            this.alignBottom();
            this.alignCenter();
            this.setCenter(new DvtPoint(center.x, labelBox.y+labelBox.h));
          }
        } else {
          // reset label alignment if label now fits without leader line
          this.alignCenter();
          this.alignMiddle();
          // reset label color
          var style = this.getCSSStyle();
          style.setStyle(DvtCSSStyle.COLOR, this._labelColor);
          this.setCSSStyle(style);
        }
      }
    }
    this._currentState = state;
  }
  else if (state == -1 && remove) { // remove label if we added it to call getDimensions and it wasn't already removed
    this._parentContainer.removeChild(this);
  }
    
  if (this._currentState != -1) {
    var mat = new DvtMatrix();
    mat.translate(zoom*this._center.x-this._center.x, zoom*this._center.y-this._center.y);
    this.setMatrix(mat);
    if (this._leaderLine) {
      this._leaderLine.setMatrix(new DvtMatrix(zoom, 0, 0, zoom));
      if (!this._bSupportsVectorEffects) {
        var stroke = this._leaderLine.getStroke().clone();
        stroke.setWidth(1/zoom);
        this._leaderLine.setStroke(stroke);
      }
    }
  }
  
}

DvtMapLabel.prototype.setCenter = function (p) {
  this._center = p;
  this.setX(p.x);
  this.setY(p.y);
}

DvtMapLabel.prototype.getLeaderLine = function () {
  return this._leaderLine;
}

DvtMapLabel.prototype.getCenter = function () {
  return this._center;
}
DvtMapLabel.prototype.setCSSStyle = function (cssStyle) {
  DvtMapLabel.superclass.setCSSStyle.call(this, cssStyle);
  if (!this._labelColor) // save the label color for leader lines
    this._labelColor = cssStyle.getStyle(DvtCSSStyle.COLOR);
}

/**
 * Removes the label from the map and resets it current state
 */
DvtMapLabel.prototype.reset = function () { 
  this._parentContainer.removeChild(this);
  this._currentState = -1;
  if (this._leaderLine) {
    this._parentContainer.removeChild(this._leaderLine);
    this._leaderLine = null;
  }
}

/**
 * Base map layer metadata
 * @extends DvtObj
 * @class base map layer metadata
 * @constructor
 */
var DvtMapDataObject = function (context, dataLayer, rowKey, clientId, regionId) {
  this.Init(context, dataLayer, rowKey, clientId, regionId);
}

DvtObj.createSubclass(DvtMapDataObject, DvtContainer, "DvtMapDataObject");

DvtMapDataObject.prototype.Init = function (context, dataLayer, rowKey, clientId, regionId) {
  DvtMapDataObject.superclass.Init.call(this, context, null, clientId);
  this._categories = [];
  this.Shape = null;
  this._id = rowKey;
  this._clientId = clientId;
  this.AreaId = regionId;
  // Keep reference of the data layer and selection layer obj belongs to
  this._selectionLayer = null;
  this._datatipColor = '#000000';
  this.Zoom = 1;
  this._hasAction = false;
  this._dataLayer = dataLayer;
}

DvtMapDataObject.prototype.getId = function () {
  return this._id;
}

DvtMapDataObject.prototype.getClientId = function () {
  return this._clientId;
}

DvtMapDataObject.prototype.getAreaId = function () {
  return this.AreaId;
}

DvtMapDataObject.prototype.setDisplayable = function (disp) {
  this.Shape = disp;
  
  // WAI-ARIA
  if (this.Shape)
    this.Shape.setAriaRole('img');
}

DvtMapDataObject.prototype.setCenter = function (center) {
  this.Center = center;
}

/**
 * Returns the center of the map data object in relation to the actual size of the base map
 * @return {DvtPoint} The center of the map data object
 */
DvtMapDataObject.prototype.getCenter = function () {
  return this.Center;
}

DvtMapDataObject.prototype.getDisplayable = function () {
  return this.Shape;
}

DvtMapDataObject.prototype.setLabel = function (label) {
  this.Label = label;
}

DvtMapDataObject.prototype.getLabel = function () {
  return this.Label;
}

DvtMapDataObject.prototype.setLabelPosition = function (labelPos) {
  this.LabelPos = labelPos;
}

DvtMapDataObject.prototype.setHasAction = function (bool) {
  this._hasAction = bool;
}

DvtMapDataObject.prototype.hasAction = function () {
  return this._hasAction;
}

DvtMapDataObject.prototype.setAction = function (action) {
  this._action = action;
}

DvtMapDataObject.prototype.getAction = function () {
  return this._action;
}

/**
 * @override
 */
DvtMapDataObject.prototype.setVisible = function (bVisible) {
  DvtMapDataObject.superclass.setVisible.call(this, bVisible);
  if (this.Label)
    this.Label.setVisible(bVisible);
}

/**
 * Implemented for DvtLogicalObject
 * @override
 */
DvtMapDataObject.prototype.getDisplayables = function () {
  return [this.Shape];
}

/**
 * Implemented for DvtLogicalODvtCategoricalObject
 * @override
 */
DvtMapDataObject.prototype.getCategories = function () {
  return this._categories;
}

DvtMapDataObject.prototype.addCategory = function (cat) {
  this._categories.push(cat);
}

/**
 * Implemented for DvtTooltipSource
 * @override
 */
DvtMapDataObject.prototype.getDatatip = function () {
  return this._datatip;
}

/**
 * Implemented for DvtTooltipSource
 * @override
 */
DvtMapDataObject.prototype.getDatatipColor = function () {
  return this._datatipColor;
}

DvtMapDataObject.prototype.setDatatipColor = function (color) {
  this._datatipColor = color;
  if (this.Shape && this.Shape.setDataColor)
    this.Shape.setDataColor(color);
}

DvtMapDataObject.prototype.setDatatip = function (datatip) {
  this._datatip = datatip;
  
  // WAI-ARIA
  if (this.Shape)
    this.Shape.setAriaProperty('label', datatip);
}

/**
 * Implemented for DvtSelectable
 * @override
 */
DvtMapDataObject.prototype.isSelectable = function () {
  return this.Shape.isSelectable();
}

/**
 * Implemented for DvtSelectable
 * @override
 */
DvtMapDataObject.prototype.isSelected = function () {
  return this.Shape.isSelected();
}

/**
 * Implemented for DvtSelectable
 * @override
 */
DvtMapDataObject.prototype.showHoverEffect = function () {
  //subclasses should override
}

/**
 * Implemented for DvtSelectable
 * @override
 */
DvtMapDataObject.prototype.hideHoverEffect = function () {
  if (!this._isShowingKeyboardFocusEffect)
    this.HideHoverEffect();
} 

DvtMapDataObject.prototype.HideHoverEffect = function () {
  //subclasses should override
}

/**
 * Implemented for DvtPopupSource.
 * Specifies the array of showPopupBehaviors for this node.
 * @param {array} behaviors The array of showPopupBehaviors for this node.
 */
DvtMapDataObject.prototype.setShowPopupBehaviors = function (behaviors) {
  this._showPopupBehaviors = behaviors;
}

/**
 * Implemented for DvtPopupSource.
 * @override
 */
DvtMapDataObject.prototype.getShowPopupBehaviors = function () {
  return this._showPopupBehaviors;
}

/**
 * Implemented for DvtDraggable.
 * @override
 */
DvtMapDataObject.prototype.isDragAvailable = function (clientIds) {
  var parentId = this._dataLayer.getClientId();
  for (var i = 0;i < clientIds.length;i++) {
    if (clientIds[i] == parentId)
      return parentId;
  }
  return parentId;
}

DvtMapDataObject.prototype.getDataLayer = function () {
  return this._dataLayer;
}

/**
 * Implemented for DvtDraggable.
 * @override
 */
DvtMapDataObject.prototype.getDragTransferable = function (mouseX, mouseY) {
  return this._dataLayer.__getDragTransferable(this);
}

/**
 * Implemented for DvtDraggable.
 * @override
 */
DvtMapDataObject.prototype.getDragFeedback = function (mouseX, mouseY) {
  return this._dataLayer.__getDragFeedback();
}

/**
 * Implemented for DvtKeyboardNavigable.
 * @override
 */
DvtMapDataObject.prototype.getNextNavigable = function (event) {
  if (event.type == DvtMouseEvent.CLICK) {
    return this;
  } else if (event.keyCode == DvtKeyboardEvent.SPACE && event.ctrlKey) {
    // multi-select node with current focus; so we navigate to ourself and then let the selection handler take
    // care of the selection
    return this;
  } else {
    return DvtKeyboardHandler.getNextAdjacentNavigable(this, event, this.GetNavigables());
  }
}

/**
 * Returns the possible keyboard navigables
 * @return {array} The array of DvtMapDataObjects that are possible candidates for keyboard navigation
 */
DvtMapDataObject.prototype.GetNavigables = function () {
  // subclasses should override
  return null;
}

/**
 * Implemented for DvtKeyboardNavigable.
 * @override
 */
DvtMapDataObject.prototype.getKeyboardBoundingBox = function () {
  if (this.Shape && this.Shape.getParent())
    return this.Shape.getDimensions();
  else 
    return new DvtRectangle(0, 0, 0, 0);
}

/**
 * Implemented for DvtKeyboardNavigable.
 * @override
 */
DvtMapDataObject.prototype.showKeyboardFocusEffect = function () {
  this._isShowingKeyboardFocusEffect = true;
  this.showHoverEffect();
}

/**
 * Implemented for DvtKeyboardNavigable.
 * @override
 */
DvtMapDataObject.prototype.hideKeyboardFocusEffect = function () {
  if (this._isShowingKeyboardFocusEffect) {
    this._isShowingKeyboardFocusEffect = false;
    this.hideHoverEffect();
  }
}

/**
 * Implemented for DvtKeyboardNavigable.
 * @override
 */
DvtMapDataObject.prototype.isShowingKeyboardFocusEffect = function () {
  return this._isShowingKeyboardFocusEffect;
}

/**
 * Rescale and translate
 */
DvtMapDataObject.prototype.HandleZoomEvent = function (pzcMatrix) {
  if (!this.Shape.getParent())
    return;
  this.Zoom = pzcMatrix.getA();
  this.recenter();
}

DvtMapDataObject.prototype.PositionLabel = function (pzcMatrix) {
  //subclasses should override if needed
}

DvtMapDataObject.prototype.recenter = function () {
  //subclasses should override if needed
}
/**
 * Thematic Map custom area layer
 * @param {DvtContext} tmap The rendering context
 * @param {DvtMapDataLyaer} The data layer this data object belongs to
 * @param {String} rowKey The row key for this data object
 * @param {String} clientId The client id for data object
 * @param {String} regionId The area id for this data object
 * @constructor
 */
var DvtMapDataArea = function (context, dataLayer, rowKey, clientId, regionId) {
  this.Init(context, dataLayer, rowKey, clientId, regionId);
}

DvtObj.createSubclass(DvtMapDataArea, DvtMapDataObject, "DvtMapDataArea");

/**
 * Helper method to initialize this DvtMapDataArea object
 * @param {DvtContext} tmap The rendering context
 * @param {DvtMapDataLyaer} The data layer this data object belongs to
 * @param {String} rowKey The row key for this data object
 * @param {String} clientId The client id for data object
 * @param {String} regionId The area id for this data object
 * @protected
 */
DvtMapDataArea.prototype.Init = function (context, dataLayer, rowKey, clientId, regionId) {
  DvtMapDataArea.superclass.Init.call(this, context, dataLayer, rowKey, clientId, regionId);
  this._isHoverEffectShowing = false;
}

DvtMapDataArea.prototype.setDisplayable = function (disp) {
  DvtMapDataArea.superclass.setDisplayable.call(this, disp);
}

DvtMapDataArea.prototype.setAreaLayer = function (layer) {
  this._dataAreaLayer = layer;
}

/**
 * Implemented for DvtSelectable
 * @override
 */
DvtMapDataArea.prototype.setSelected = function (selected) {
  // for initial selection where hover effect isn't shown on selection
  if (!this._isHoverEffectShowing)
    this._dataAreaLayer.addChild(this.Shape);
  this.Shape.setSelected(selected);
}

/**
 * Implemented for DvtSelectable
 * @override
 */
DvtMapDataArea.prototype.showHoverEffect = function () {
  this._dataAreaLayer.addChild(this.Shape);
  this.Shape.showHoverEffect();
  this._isHoverEffectShowing = true;
}

/**
 * Implemented for DvtSelectable
 * @override
 */
DvtMapDataArea.prototype.HideHoverEffect = function () {
  if (this.isSelected())
    this._dataAreaLayer.addChild(this.Shape);
  else
    this._dataAreaLayer.addChildAt(this.Shape, 0);
  this.Shape.hideHoverEffect();
  this._isHoverEffectShowing = false;
}

DvtMapDataArea.prototype.isDrilled = function () {
  return this.Shape.isDrilled();
}

DvtMapDataArea.prototype.setDrilled = function (drilled) {
  this._isDrilled = drilled;
  if (drilled)
    this._dataAreaLayer.addChild(this.Shape);
  else
    this._dataAreaLayer.addChildAt(this.Shape, 0);
  this.Shape.setDrilled(drilled);
}

/**
 * @override
 */
DvtMapDataArea.prototype.HandleZoomEvent = function (pzcMatrix) {
  if (!this.Shape.getParent())
    return;
  DvtMapDataArea.superclass.HandleZoomEvent.call(this, pzcMatrix);
  this.Shape.handleZoomEvent(pzcMatrix);
  if (!this.isDrilled())
    this.PositionLabel(pzcMatrix);
}

/**
 * @override
 */
DvtMapDataArea.prototype.PositionLabel = function (pzcMatrix) {
  if (this.Label)
    this.Label.update(pzcMatrix);
}

/**
 * @override
 */
DvtMapDataArea.prototype.GetNavigables = function () {
  return this.getDataLayer().getMap().getNavigableAreas();
}
/**
 * Base map layer metadata
 * @extends DvtObj
 * @class base map layer metadata
 * @constructor
 */
var DvtMapDataMarker = function (context, dataLayer, rowKey, clientId, regionId) {
  this.Init(context, dataLayer, rowKey, clientId, regionId);
}
DvtMapDataMarker.DEFAULT_MARKER_ALPHA = 1;
DvtMapDataMarker.DEFAULT_MARKER_SIZE = 8.0;
DvtMapDataMarker.DEFAULT_MARKER_SHAPE = 'c';
DvtMapDataMarker.DEFAULT_MARKER_SCALE = 1.0;

DvtObj.createSubclass(DvtMapDataMarker, DvtMapDataObject, "DvtMapDataMarker");

DvtMapDataMarker.prototype.Init = function (context, dataLayer, rowKey, clientId, regionId) {
  DvtMapDataMarker.superclass.Init.call(this, context, dataLayer, rowKey, clientId, regionId);
  this.InitCanvasZoom = 1.0;
  this._size = 0;
}

/**
 * Implemented for DvtSelectable
 * @override
 */
DvtMapDataMarker.prototype.setSelected = function (selected) {
  this.Shape.setSelected(selected);
}

/**
 * Implemented for DvtSelectable
 * @override
 */
DvtMapDataMarker.prototype.showHoverEffect = function () {
  this.Shape.showHoverEffect();
}

/**
 * Implemented for DvtSelectable
 * @override
 */
DvtMapDataMarker.prototype.HideHoverEffect = function () {
  this.Shape.hideHoverEffect();
}

/**
 * @override
 */
DvtMapDataMarker.prototype.PositionLabel = function (pzcMatrix) {
  if (this.Label) {
    this.Label.alignCenter();
    var x = (this.Shape.getX() + this.Shape.getScaledWidth()/2)*this.Zoom;
    var markerY = this.Shape.getY()*this.Zoom;
    var markerH = this.Shape.getScaledHeight();
    var markerType = this.Shape.getType();
    
    var y;
    if (this.LabelPos == 'top') {
      y = markerY - 2;
      this.Label.alignBaseline();
    } else if (this.LabelPos == 'bottom') {
      y = markerY + markerH;
      this.Label.alignTop();
    } else if (markerType == DvtMarker.TRIANGLE_UP) {
      // we need to move center of the label to the center of gravity, it looks much better
      y = markerY + 2 * markerH/3;
      // in this special case we need special alignment since standard baseline has to be higher than 
      // in other cases to be preciesly in the center of gravity
      this.Label.alignMiddle();
    } else if (markerType == DvtMarker.TRIANGLE_DOWN) {
      // we need to move center of the label to the center of gravity, it looks much better
      y = markerY + markerH/3;
      this.Label.alignMiddle();
    } else {
      y = markerY + markerH/2;
      this.Label.alignMiddle();
    }
    
    this.Label.setX(x);
    this.Label.setY(y);
  }
}

/**
 * @override
 */
DvtMapDataMarker.prototype.recenter = function () {
  var parent = this.Shape.getParent();
  var width = this.Shape.getScaledWidth();
  var height = this.Shape.getScaledHeight();
  if (width != null && height != null && parent) {
    var rotation = this.Shape.getRotation();
    if (this.Label && this.Shape.getRotation()) {
      parent.setTranslate(this.Center.x*this.Zoom-this.Center.x, this.Center.y*this.Zoom-this.Center.y);
      DvtAgent.workaroundFirefoxRepaint(parent);
    } else {
      var rotatedCenterX = this.Center.x*Math.cos(rotation)-this.Center.y*Math.sin(rotation);
      var rotatedCenterY = this.Center.x*Math.sin(rotation)+this.Center.y*Math.cos(rotation);
      this.Shape.setTranslate(this.Center.x*this.Zoom-rotatedCenterX, this.Center.y*this.Zoom-rotatedCenterY);
      DvtAgent.workaroundFirefoxRepaint(this.Shape);
    }
  }
}

/**
 * @override
 */
DvtMapDataMarker.prototype.GetNavigables = function () {
  return this.getDataLayer().getMap().getNavigableObjects();
}

/**
 * Sets the size of this marker. Marker size is used for marker sorting.
 * @param {Number} size The marker size which is its width * height.
 */
DvtMapDataMarker.prototype.setSize = function (size) {
  this._size = size;
}

/**
 * Returns the size of this marker. Marker size is used for marker sorting.
 * @return {Number} The marker size which is its width * height.
 */
DvtMapDataMarker.prototype.getSize = function () {
  return this._size;
}
var DvtMapDataImage = function (context, dataLayer, rowKey, clientId, regionId) {
  this.Init(context, dataLayer, rowKey, clientId, regionId);
}

DvtObj.createSubclass(DvtMapDataImage, DvtMapDataObject, "DvtMapDataImage");

DvtMapDataImage.prototype.Init = function (context, dataLayer, rowKey, clientId, regionId) {
  DvtMapDataImage.superclass.Init.call(this, context, dataLayer, rowKey, clientId, regionId);
}

/**
 * For DvtImage loading only
 */
DvtMapDataImage.prototype.onImageLoaded = function (image) {
  if (image && image.width && image.height) {
    if (!this.Shape.getWidth())
      this.Shape.setWidth(image.width);
    if (!this.Shape.getHeight())
      this.Shape.setHeight(image.height);
    this.setSize(image.width*image.height);
    this.Shape.setX(this.Center.x-image.width/2);
    this.Shape.setY(this.Center.y-image.height/2);
    this.recenter();
  }
}

/**
 * @override
 */
DvtMapDataImage.prototype.recenter = function () {
  var width = this.Shape.getWidth();
  var height = this.Shape.getHeight();
  if (width != null && height != null && this.Shape.getParent()) {
    // Calculate the current (transformed) center point
    var curCenterX = this.Shape.getX() + width/2;
    var curCenterY = this.Shape.getY() + height/2;
    this.Shape.setTranslate(curCenterX*this.Zoom-this.Center.x, curCenterY*this.Zoom-this.Center.y);
  }
}

/**
 * Sets the size of this marker. Marker size is used for marker sorting.
 * @param {Number} size The marker size which is its width * height.
 */
DvtMapDataImage.prototype.setSize = function (size) {
  this._size = size;
}

/**
 * Returns the size of this marker. Marker size is used for marker sorting.
 * @return {Number} The marker size which is its width * height.
 */
DvtMapDataImage.prototype.getSize = function () {
  return this._size;
}
/**
 * Base map layer metadata
 * @extends DvtObj
 * @class base map layer metadata
 * @constructor
 */
var DvtMapArea = function (context, dvtShape, areaName, bSupportsVectorEffects) {
  this.Init(context, dvtShape, areaName, bSupportsVectorEffects);
}

DvtObj.createSubclass(DvtMapArea, DvtContainer, "DvtMapArea");

DvtMapArea._DEFAULT_STROKE_WIDTH = 1;

DvtMapArea.prototype.Init = function (context, dvtShape, areaName, bSupportsVectorEffects) {
  DvtMapArea.superclass.Init.call(this, context);
  this._bSelectable = false;
  this._isSelected = false;
  this._areaName = areaName;
  this._shape = dvtShape;
  this.addChild(this._shape);
  
  //IE10, Flash/XML toolkit do not support vector-effects=non-scaling-stroke so we still need to set stroke width based on zoom
  this._bSupportsVectorEffects = bSupportsVectorEffects;
  var stroke = dvtShape.getStroke();
  if (stroke)
    this._areaStrokeWidth = stroke.getWidth();
  
  // WAI-ARIA
  if (this._shape)
    this._shape.setAriaRole('img');
}

DvtMapArea.prototype.getAreaName = function () {
  return this._areaName;
}

/**
 * Implemented for DvtTooltipSource
 * @override
 */
DvtMapArea.prototype.getTooltip = function () {
  return this._tooltip;
}

/**
 * Implemented for DvtTooltipSource
 */
DvtMapArea.prototype.setTooltip = function (tooltip) {
  this._tooltip = tooltip;
  
  // WAI-ARIA
  if (this._shape)
    this._shape.setAriaProperty('label', tooltip);
}

DvtMapArea.prototype.getStroke = function () {
  if (this._shape instanceof DvtShape)
    return this._shape.getStroke();
  return null;
}

DvtMapArea.prototype.setStroke = function (stroke) {
  if (this._shape instanceof DvtShape)
    this._shape.setStroke(stroke);
}

DvtMapArea.prototype.setFill = function (fill) {
  if (this._shape instanceof DvtShape) {
    this._shape.setFill(fill);
  }
}

DvtMapArea.prototype.getFill = function () {
  if (this._shape instanceof DvtShape) {
    return this._shape.getFill();
  }
  return null;
}

DvtMapArea.prototype.getCmds = function () {
  if (this._shape instanceof DvtPath) {
    return this._shape.getCmds();
  }
  return null;
}

DvtMapArea.prototype.setCmds = function (cmds) {
  if (this._shape instanceof DvtPath) {
    this._shape.setCmds(cmds);
  }
}

DvtMapArea.prototype.setSrc = function (src) {
  if (this._shape instanceof DvtImage) {
    this._shape.setSrc(src);
  }
}

/**
 * @override
 */
DvtMapArea.prototype.getDropSiteFeedback = function() {
  return this._shape.copyShape();
}

/**
 * @override
 */
DvtMapArea.prototype.contains = function(x, y) {
  var dims = this.getDimensions();
  return x >= dims.x && x <= dims.x + dims.w && 
         y >= dims.y && y <= dims.y + dims.h;
}

DvtMapArea.prototype.HandleZoomEvent = function (pzcMatrix) {
  if (!this._bSupportsVectorEffects && this._shape && this._areaStrokeWidth) {
    var zoomStroke = this._shape.getStroke().clone();
    zoomStroke.setWidth(this._areaStrokeWidth/pzcMatrix.getA());
    this._shape.setStroke(zoomStroke);
  }
}
/**
 * Thematic Map map layer
 * @param {DvtThematicMap} tmap The thematic map this map layer belongs to
 * @param {DvtEventManager} eventHandler The thematic map event manager
 * @constructor
 */
var DvtMapLayer = function (tmap, eventHandler) {
  this.Init(tmap, eventHandler);
}

DvtObj.createSubclass(DvtMapLayer, DvtObj, "DvtMapLayer");

/**
 * Initializes this map layera
 * @param {DvtThematicMap} tmap The thematic map this map layer belongs to
 * @param {DvtEventManager} eventHandler The thematic map event manager
 * @protected
 */
DvtMapLayer.prototype.Init = function (tmap, eventHandler) {
  this._tmap = tmap;
  this.LayerName = 'cities';
  this.ClientId = null;
  this.EventHandler = eventHandler;
  this.DataLayers = {};
  this.PzcMatrix = new DvtMatrix();
}

/**
 * Registers a data layer to this map layer
 * @param {DvtMapDataLayer} dataLayer The data layer to add to this map layer
 */
DvtMapLayer.prototype.addDataLayer = function (dataLayer) {
  this.DataLayers[dataLayer.getClientId()] = dataLayer;
}

DvtMapLayer.prototype.PreDataLayerUpdate = function () {
  //subclasses to override
}

DvtMapLayer.prototype.PostDataLayerUpdate = function () {
  //subclasses to override
}

/**
 * Renders a data layer on ppr with new data if currently visible.
 * @param {DvtMapDataLayer} dataLayer The data layer to add and render for this DvtMapLayer
 * @param {DvtMatrix} pzcMatrix The current map transform
 * @param {String} topLayerName The layer name of the current top layer
 */
DvtMapLayer.prototype.updateDataLayer = function (dataLayer, pzcMatrix, topLayerName) { 
  // stop previous animation
  if (this._animation) {
    this._animationStopped = true;
    this._animation.stop(true);
  }
    
  this.PzcMatrix = pzcMatrix;
  // Get old data layer
  this._oldDataLayer = this.getDataLayer(dataLayer.getClientId());
  this.addDataLayer(dataLayer);
  dataLayer.render(this.PzcMatrix);
  // create a zoom event so we can update the data objects with the current zoom
  dataLayer.HandleZoomEvent(new DvtZoomEvent(DvtZoomEvent.SUBTYPE_ZOOMED), this.PzcMatrix);
  
  if (this._oldDataLayer) {
    var anim = dataLayer.getAnimation();
    var animDur = dataLayer.getAnimationDuration();
    if (DvtBlackBoxAnimationHandler.isSupported(anim)) {
      // since certain animations like zoom and cubeToLeft/Right will use the bounding box of the object we need to 
      // ensure all animated objects are the same dimensions by adding an invisible rect to all of them during animation
      var bounds1 = new DvtRectangle(0,0,this._tmap.GetWidth(),this._tmap.GetHeight());
      var oldNonScaledContainers = this._oldDataLayer.getNonScaledContainers();
      for (var i=0; i<oldNonScaledContainers.length; i++) {
        var rect = new DvtRect(this._tmap.getCtx(),0,0,this._tmap.GetWidth(),this._tmap.GetHeight());
        rect.setFill(null);
        oldNonScaledContainers[i].addChild(rect);
      }
      var newNonScaledContainers = dataLayer.getNonScaledContainers();
      for (var i=0; i<newNonScaledContainers.length; i++) {
        var rect = new DvtRect(this._tmap.getCtx(),0,0,this._tmap.GetWidth(),this._tmap.GetHeight());
        rect.setFill(null);
        newNonScaledContainers[i].addChild(rect);
      }
      var anim1 = DvtBlackBoxAnimationHandler.getCombinedAnimation(this._tmap.getCtx(), anim, 
                                                                        oldNonScaledContainers, 
                                                                        newNonScaledContainers, bounds1, animDur);
      
      var bounds2 = new DvtRectangle(0,0,this._tmap.GetWidth()/this.PzcMatrix.getA(),this._tmap.GetHeight()/this.PzcMatrix.getA());
      var oldScaledContainers = this._oldDataLayer.getScaledContainers();
      for (var i=0; i<oldScaledContainers.length; i++) {
        var rect = new DvtRect(this._tmap.getCtx(),0,0,this._tmap.GetWidth()/this.PzcMatrix.getA(),this._tmap.GetHeight()/this.PzcMatrix.getA());
        rect.setFill(null);
        oldScaledContainers[i].addChild(rect);
      }
      var newScaledContainers = dataLayer.getScaledContainers();
      for (var i=0; i<newScaledContainers.length; i++) {
        var rect = new DvtRect(this._tmap.getCtx(),0,0,this._tmap.GetWidth()/this.PzcMatrix.getA(),this._tmap.GetHeight()/this.PzcMatrix.getA());
        rect.setFill(null);
        newScaledContainers[i].addChild(rect);
      }
      
      var anim2 = DvtBlackBoxAnimationHandler.getCombinedAnimation(this._tmap.getCtx(), anim, 
                                                                        oldScaledContainers, 
                                                                        newScaledContainers, bounds2, animDur);
      this._animation = new DvtParallelPlayable(this._tmap.getCtx(), [anim1, anim2]);                                                                        
    } else {
      var oldContainers = this._oldDataLayer.getContainers();
      for (var i=0; i<oldContainers.length; i++) {
        var parent = oldContainers[i].getParent(); 
        parent.removeChild(oldContainers[i]);
      }
      this.PostDataLayerUpdate();
    }
  
    // If an animation was created, play it
    if (this._animation) {
      // Disable event listeners temporarily
      this.EventHandler.removeListeners(this._callbackObj);
  
      // Start the animation
      var thisRef = this;
      this._animation.setOnEnd(function() {thisRef.OnAnimationEnd(dataLayer)}, this);
      this.PreDataLayerUpdate();
      this._animation.play();
    }
  } else {
    this.PostDataLayerUpdate();
    this._tmap.OnUpdateLayerEnd();
  }
}

DvtMapLayer.prototype.getDataLayers = function () {
  return this.DataLayers;
}

DvtMapLayer.prototype.getDataLayer = function (clientId) {
  return this.DataLayers ? this.DataLayers[clientId] : null;
}

DvtMapLayer.prototype.getClientId = function () {
  return this.ClientId;
}

/**
 * Returns the name of this map layer i.e. continents, countries, states for built-in basemaps
 * @return {String} The name of this map layer
 */
DvtMapLayer.prototype.getLayerName = function () {
  return this.LayerName;
}

DvtMapLayer.prototype.render = function (pzcMatrix) {
  this.PzcMatrix = pzcMatrix;
  for (var id in this.DataLayers)
    this.DataLayers[id].render(pzcMatrix);
}

DvtMapLayer.prototype.reset = function(fadeOutContainer, doNotResetAreas) {
  for (var id in this.DataLayers)
    this.DataLayers[id].reset(fadeOutContainer, doNotResetAreas);
}

DvtMapLayer.prototype.HandleZoomEvent = function (event, pzcMatrix) {
  this.PzcMatrix = pzcMatrix;
  for (var id in this.DataLayers)
    this.DataLayers[id].HandleZoomEvent(event, pzcMatrix);
}

DvtMapLayer.prototype.HandlePanEvent = function (pzcMatrix) {
  this.PzcMatrix = pzcMatrix;
  for (var id in this.DataLayers)
    this.DataLayers[id].HandlePanEvent(pzcMatrix);
}

/**
 * Cleans up animated objects after animation finishes
 * @param {DvtMapDataLayer} dataLayer The animated data layere
 * @protected
 */
DvtMapLayer.prototype.OnAnimationEnd = function (dataLayer) {
  // Clean up the old container used by black box updates
  if (this._oldDataLayer) {
    var oldContainers = this._oldDataLayer.getContainers();
    for (var i=0; i<oldContainers.length; i++) {
      var parent = oldContainers[i].getParent();
      if (parent)
        parent.removeChild(oldContainers[i]);
    }
  }
  
  // remove invisible rect added for animation
  var newNonScaledContainers = dataLayer.getNonScaledContainers();
  for (var i=0; i<newNonScaledContainers.length; i++)
    newNonScaledContainers[i].removeChildAt(newNonScaledContainers[i].getNumChildren() - 1);
  var newScaledContainers = dataLayer.getScaledContainers();
  for (var i=0; i<newScaledContainers.length; i++)
    newScaledContainers[i].removeChildAt(newScaledContainers[i].getNumChildren() - 1);
        
  this.PostDataLayerUpdate();
  
  this._tmap.OnUpdateLayerEnd();
  // Reset the animation stopped flag
  this._animationStopped = false;
  // Remove the animation reference
  this._animation = null;
  // Restore event listeners
  this.EventHandler.addListeners(this._callbackObj);
}
/**
 * Thematic Map area layer
 * @param {DvtThematicMap} tmap The thematic map this map layer belongs to
 * @param {String} layerName The name of map area layer
 * @param {String} clientId The client id for this map layer
 * @param {String} labelDisplay Whether to display the labels for this map layer
 * @param {String} labelType The type of labels to display for this map layer (short or long)
 * @param {DvtEventManager} eventHandler The thematic map event manager
 * @constructor
 */
var DvtMapAreaLayer = function (tmap, layerName, clientId, labelDisplay, labelType, eventHandler) {
  this.Init(tmap, layerName, clientId, labelDisplay, labelType, eventHandler);
}

DvtObj.createSubclass(DvtMapAreaLayer, DvtMapLayer, "DvtMapAreaLayer");

DvtMapAreaLayer._SHORT_NAME = 0;
DvtMapAreaLayer._LONG_NAME = 1;

/**
 * Helper method to initialize this DvtMapAreaLayer object
 * @param {DvtThematicMap} tmap The thematic map this map layer belongs to
 * @param {String} layerName The name of map area layer
 * @param {String} clientId The client id for this map layer
 * @param {String} labelDisplay Whether to display the labels for this map layer
 * @param {String} labelType The type of labels to display for this map layer (short or long)
 * @param {DvtEventManager} eventHandler The thematic map event manager
 * @protected
 */
DvtMapAreaLayer.prototype.Init = function (tmap, layerName, clientId, labelDisplay, labelType, eventHandler) {
  DvtMapAreaLayer.superclass.Init.call(this, tmap, eventHandler);
  this._labelDisplay = labelDisplay;  
  this.LayerName = layerName;
  this.ClientId = clientId;
  this._labelType = labelType;
  this._areaLabels = new Object();
  this.Areas = new Object();
  this.AreaShapes = {};
  this.AreaNames = null;
  this._labelInfo = null;
  this._disclosed = [];
  this._renderArea = {}; // keep track of whether or not to render an area
  this._renderLabel = {}; // keep track of whether or not to render a label
  this._renderedLabels = {} // keep track of the labels that are actually added to the DOM
  
  this.AreaContainer = new DvtContainer(this._tmap.getCtx());
  this.LabelContainer = new DvtContainer(this._tmap.getCtx());
  this._tmap.getAreaLayerContainer().addChildAt(this.AreaContainer, 0);
  this._tmap.getLabelContainer().addChildAt(this.LabelContainer, 0);
  
  this._dropTarget = new DvtThematicMapDropTarget(this, this._tmap.getMapName()); 
}

DvtMapAreaLayer.prototype.setAnimation = function (animType) {
  this._animType = animType;
}

DvtMapAreaLayer.prototype.getAnimation = function () {
  return this._animType;
}

DvtMapAreaLayer.prototype.setAnimationDuration = function (animDur) {
  this._animDur = animDur;
}

DvtMapAreaLayer.prototype.getAnimationDuration = function () {
  return this._animDur;
}

DvtMapAreaLayer.prototype.getDropTarget = function () {
  return this._dropTarget;
}

DvtMapAreaLayer.prototype.getLabelType = function () {
  return this._labelType;
}

DvtMapAreaLayer.prototype.setAreaShapes = function (shapes) {
  this.AreaShapes = shapes;
}

DvtMapAreaLayer.prototype.setAreaNames = function (values) {
  this.AreaNames = values;
  for (var area in this.AreaNames) {
    this.setAreaRendered(area, true)
    this.setLabelRendered(area, true);
  }
}

DvtMapAreaLayer.prototype.getShortAreaName = function (area) {
  return this.AreaNames[area][DvtMapAreaLayer._SHORT_NAME]
}

DvtMapAreaLayer.prototype.getLongAreaName = function (area) {
  return this.AreaNames[area][DvtMapAreaLayer._LONG_NAME]
}

DvtMapAreaLayer.prototype.setAreaLabelInfo = function (values) {
  this._labelInfo = values;
}

DvtMapAreaLayer.prototype.getLabelInfoForArea = function (area) {
  if (!this._labelInfo)
    return null;
  return this._labelInfo[area];
}

DvtMapAreaLayer.prototype.setAreaChildren = function (children) {
  this._children = children;
}

DvtMapAreaLayer.prototype.getChildrenForArea = function (area) {
  if (this._children[area])
    return this._children[area].split(',');
  else
    return [];
}

DvtMapAreaLayer.prototype.getArea = function (id) {
  return this.Areas[id];
}

DvtMapAreaLayer.prototype.getAreaShape = function (id) {
  return this.AreaShapes[id];
}

DvtMapAreaLayer.prototype.getLabelDisplay = function () {
  return this._labelDisplay;
}

DvtMapAreaLayer.prototype.setDropSiteCSSStyle = function (style) {
  this._dropSiteCSSStyle = style;
}

DvtMapAreaLayer.prototype.setLayerCSSStyle = function (style) {
  this._layerCSSStyle = style;
}

DvtMapAreaLayer.prototype.getLayerCSSStyle = function () {
  return this._layerCSSStyle;
}

DvtMapAreaLayer.prototype.setAreaHoverStyle = function (style) {
  this._areaHoverStyle = style;
}

DvtMapAreaLayer.prototype.getAreaHoverStyle = function () {
  return this._areaHoverStyle;
}

DvtMapAreaLayer.prototype.setAreaSelectStyle = function (style) {
  this._areaSelectStyle = style;
}

DvtMapAreaLayer.prototype.getAreaSelectStyle = function () {
  return this._areaSelectStyle;
}

DvtMapAreaLayer.prototype.setAreaDiscloseStyle = function (style) {
  this._areaDiscloseStyle = style;
}

DvtMapAreaLayer.prototype.getAreaDiscloseStyle = function () {
  return this._areaDiscloseStyle;
}

DvtMapAreaLayer.prototype.setAreaRendered = function (area, bRender) {
  this._renderArea[area] = bRender;
}

DvtMapAreaLayer.prototype.setLabelRendered = function (area, bRender) {
  this._renderLabel[area] = bRender;
}

DvtMapAreaLayer.prototype.setIsolatedArea = function (isolatedArea) {
  this._isolatedArea = isolatedArea;
  // reset the layer dimensions in case of data layer update
  this._layerDim = null;
  for (var area in this.AreaShapes) {
    if (area != isolatedArea)
      this._renderArea[area] = false;
  }
}

/**
 * Returns the dimensions for this area layer.  Used for retrieving saved layer dimensions from built-in basemaps
 * and caching the layer dimensions
 * @return {DvtRectangle} The bounding box for this area layer
 */
DvtMapAreaLayer.prototype.getLayerDim = function () {
  if (!this._layerDim) {
    if (this._isolatedArea)
      this._layerDim = DvtPathUtils.getDimensions(DvtPathUtils.createPathArray(DvtBaseMapManager.getPathForArea(this._tmap.getMapName(), this.LayerName, this._isolatedArea)));
    else {
      if (this._tmap.getMapName() != 'world' && this._tmap.getMapName() != 'worldRegions')
        this._layerDim = DvtBaseMapManager.getBaseMapDim(this._tmap.getMapName(), this.LayerName);
      if (!this._layerDim) {
        // all layers for a basemap should have the same dimensions
        // need to combine area, data area and selected data area dimensions bc they are in separate containers
        // IE doesn't return the right dimensions unless we call getDim on the direct parent of areas
        this._layerDim = this.AreaContainer.getDimensions().getUnion(this._tmap.getDataAreaContainer().getChildAt(0).getDimensions());
        // if areas haven't been added yet, return null so we can check dimensions after they are added
        if (this._layerDim && this._layerDim.w === 0 && this._layerDim.h === 0)
          this._layerDim = null;
      }
    }
  }
  return this._layerDim;
}

DvtMapAreaLayer.prototype._createAreaAndLabel = function(area, bForceUpdateArea) {
  var areaShape = this.AreaShapes[area];
  if (areaShape) {
    if (bForceUpdateArea || !this.Areas[area])
      this.updateAreaShape(area);
    if (!this.Areas[area]) {
      var context = this._tmap.getCtx();
      var mapArea =  new DvtMapArea(context, areaShape, area, this._tmap.supportsVectorEffects());
      this.Areas[area] = mapArea;
      this.EventHandler.associate(areaShape, mapArea);
      var tooltip = (this.AreaNames && this.AreaNames[area]) ? this.AreaNames[area][DvtMapAreaLayer._LONG_NAME] : null;
      mapArea.setTooltip(tooltip);
    }
    
    if (this._renderLabel[area]) {
      var label = this._areaLabels[area];
      if (!label) {
        if (this._labelDisplay != 'off' && this.AreaNames) {
          var labelText = (this._labelType == 'short') ? this.AreaNames[area][DvtMapAreaLayer._SHORT_NAME] :
                                                         this.AreaNames[area][DvtMapAreaLayer._LONG_NAME];
          if (labelText) {
            if (this._labelInfo && this._labelInfo[area])
              label = new DvtMapLabel(this._tmap.getCtx(), labelText, this._labelInfo[area], this._labelDisplay, 
                                      this.LabelContainer, this._tmap.supportsVectorEffects());
            else {
              var areaDim = DvtDisplayableUtils.getDimensionsForced(this._tmap.getCtx(), areaShape);
              label = new DvtMapLabel(this._tmap.getCtx(), labelText, [[areaDim.x, areaDim.y, areaDim.w, areaDim.h]], 
                                      this._labelDisplay, this.LabelContainer, this._tmap.supportsVectorEffects());
            }
            this._areaLabels[area] = label;
            if (this._layerCSSStyle)
              label.setCSSStyle(this._layerCSSStyle)
          }
        }
      }
    } 
  }
}

/**
 * Adds and area and its label
 * @param {String} area the Area to be added.
 * @param {} fadeInObjs
 */
DvtMapAreaLayer.prototype._addAreaAndLabel = function(area, fadeInObjs) {
  if (this.AreaShapes[area]) {
    this.AreaContainer.addChild(this.Areas[area]);
    
    var label = this._areaLabels[area];
    if (label) {
      if (this._renderLabel[area])
        label.update(this.PzcMatrix);
      else
        label.reset();
      this._renderedLabels[area] = this._renderLabel[area];
    }
    
    if (fadeInObjs) {
      fadeInObjs.push(this.Areas[area]);
      if (label) {
        fadeInObjs.push(label);
        fadeInObjs.push(label.getLeaderLine());
      }
    }
  }
}

/**
 * Updates an area layer area's path commands based
 * @param {String} area The area id that needs to be updated
 */
DvtMapAreaLayer.prototype.updateAreaShape = function (area) {
  if (!this._paths || this._bUpdateShapesForRender) {
    this._bUpdateShapesForRender = false;
    var layerDim;
    if (this._tmap.getMapName() == 'world'  || this._tmap.getMapName() == 'worldRegions')
      layerDim = DvtBaseMapManager.getBaseMapDim(this._tmap.getMapName(), this.LayerName);
    else
      layerDim = this.getLayerDim();
    // don't simplify area paths if we don't know the dimensions ahead of time
    if (!layerDim) {
      this._paths = DvtBaseMapManager.getAreaPaths(this._tmap.getMapName(), this.LayerName);
    } else {
      this._paths = DvtBaseMapManager.simplifyAreaPaths(DvtBaseMapManager.getAreaPaths(this._tmap.getMapName(), this.LayerName), 
                                                  layerDim.w, layerDim.h, this._tmap.GetWidth(), this._tmap.GetHeight(),
                                                  this._tmap.getMaxZoomFactor());
    }
  }
  if (this.AreaShapes[area])
    this.AreaShapes[area].setCmds(this._paths[area]);
}

DvtMapAreaLayer.prototype.resetRenderedAreas = function () {
  // reset rendered areas on data layer update
  for (var area in this.AreaNames) {
    this.setAreaRendered(area, true)
    this.setLabelRendered(area, true);
  }
}

/**
 * @override
 */
DvtMapAreaLayer.prototype.updateDataLayer = function (dataLayer, pzcMatrix, topLayerName) {
  DvtMapAreaLayer.superclass.updateDataLayer.call(this, dataLayer, pzcMatrix, topLayerName);
  if (topLayerName == this.getLayerName()) {
    for (var area in this.AreaShapes) {
      this._createAreaAndLabel(area, true);
      if (this._renderArea[area])
        this._addAreaAndLabel(area);
    }
  }
}

DvtMapAreaLayer.prototype.render = function (pzcMatrix) {
  // create areashapes and then create the DvtMapArea object for all areas 
  this._bUpdateShapesForRender = true;
  for (var area in this.AreaShapes) {
    this._createAreaAndLabel(area, true);
    if (this._renderArea[area])
      this._addAreaAndLabel(area);
  }
  DvtMapAreaLayer.superclass.render.call(this, pzcMatrix);
}

/**
 * @override
 */
DvtMapAreaLayer.prototype.PreDataLayerUpdate = function () {
  // Create and render areas that were originally not created because the area was already created in the data layer
  for (var area in this._renderArea) {
    if (!this._renderArea[area]) {
      this._createAreaAndLabel(area, false);
      this._addAreaAndLabel(area);
    }
  }
}

/**
 * @override
 */
DvtMapAreaLayer.prototype.PostDataLayerUpdate = function () {
  // remove areas that were rendered in the data layer or created for the animation
  for (var area in this._renderArea) {
    if (!this._renderArea[area]) {
      this.AreaContainer.removeChild(this.Areas[area]);
      var label = this._areaLabels[area];
      if (label) {
        this._renderedLabels[area] = false;
        this.LabelContainer.removeChild(label);
        var leaderLine = label.getLeaderLine();
        if (leaderLine)
          this.LabelContainer.removeChild(leaderLine);
      }
    }
  }
}

DvtMapAreaLayer.prototype._renderSelectedAreasAndLabels = function(areas, fadeInObjs) {
  for (var i=0; i<areas.length; i++) {
    this._createAreaAndLabel(areas[i], false);
    // Do not render areas that were rendered in the data layer
    if (this._renderArea[areas[i]])
      this._addAreaAndLabel(areas[i], fadeInObjs);
  }
}

DvtMapAreaLayer.prototype.discloseAreas = function (areas, fadeInObjs) {
  this._renderSelectedAreasAndLabels(areas, fadeInObjs);
  for (var id in this.DataLayers)
    this.DataLayers[id].discloseAreas(areas, fadeInObjs, this.PzcMatrix);
  this._disclosed = this._disclosed.concat(areas);
}

/**
 * @param {Array} Array of objects that will be removed once undisclosed
 * @param {Array} Area ids of areas to undisclose
 */
DvtMapAreaLayer.prototype.undiscloseAreas = function(areas, fadeOutObjs) {
  for (var id in this.DataLayers)
    this.DataLayers[id].undiscloseAreas(areas, fadeOutObjs);
  var childAreaLayer = this._tmap.getDrillChildLayer(this.LayerName);
  for (var i=0; i<areas.length; i++) {
    var areaName = areas[i];
    if (this.Areas[areaName]) {
      var idx = DvtArrayUtils.getIndex(this._disclosed, areaName);
      if (idx !== -1) {
        this._disclosed.splice(idx, 1);
        fadeOutObjs.push(this.Areas[areaName]);
      }
    }
    // undisclose its child areas
    if (childAreaLayer)
      childAreaLayer.undiscloseAreas(this.getChildrenForArea(areaName), fadeOutObjs);
  }
}

/**
 * @override
 */
DvtMapAreaLayer.prototype.reset = function(fadeOutObjs, doNotResetAreas) {
  DvtMapAreaLayer.superclass.reset.call(this, fadeOutObjs, doNotResetAreas);
  if (this._tmap.getDrillMode() != 'none') {
    this.undiscloseAreas(this._disclosed, fadeOutObjs);
    this._disclosed = [];
  }
}

/**
 * Returns the node under the specified coordinates.
 * @param {number} x
 * @param {number} y
 * @return {DvtMapDataObject}
 */
DvtMapAreaLayer.prototype.__getObjectUnderPoint = function(x, y) {
  for (var id in this.Areas) {
    if (this.Areas[id].contains(x, y))
      return this.Areas[id];
  }
  // No object found, return null
  return null;
}

/**
 * Displays drop site feedback for the specified node.
 * @param {DvtMapArea} obj The object for which to show drop feedback, or null to remove drop feedback.
 * @return {DvtDisplayable} The drop site feedback, if any.
 */
DvtMapAreaLayer.prototype.__showDropSiteFeedback = function(obj) {
  // Remove any existing drop site feedback
  if(this._dropSiteFeedback) {
    this.AreaContainer.removeChild(this._dropSiteFeedback);
    this._dropSiteFeedback = null;
  }

  // Create feedback for the node
  if(obj) {
    this._dropSiteFeedback = obj.getDropSiteFeedback();
    if(this._dropSiteFeedback) {
      this._dropSiteFeedback.setFill(new DvtSolidFill(this._dropSiteCSSStyle.getStyle(DvtCSSStyle.BACKGROUND_COLOR)));
      var strokeWidth = this._dropSiteCSSStyle.getStyle(DvtCSSStyle.BORDER_WIDTH) ? 
                   this._dropSiteCSSStyle.getStyle(DvtCSSStyle.BORDER_WIDTH).substring(0, this._dropSiteCSSStyle.getStyle(DvtCSSStyle.BORDER_WIDTH).indexOf('px')) : 1;
      if (this._tmap.supportsVectorEffects())
        stroke.setFixedWidth(true);
      else
        strokeWidth /= this.PzcMatrix.getA();
      var stroke = new DvtSolidStroke(this._dropSiteCSSStyle.getStyle(DvtCSSStyle.BORDER_COLOR), 1, strokeWidth);

      this._dropSiteFeedback.setStroke(stroke);
      this.AreaContainer.addChild(this._dropSiteFeedback);
    }
  }
  
  return this._dropSiteFeedback;
}

DvtMapAreaLayer.prototype.HandleZoomEvent = function (event, pzcMatrix) {
  DvtMapAreaLayer.superclass.HandleZoomEvent.call(this, event, pzcMatrix);
  if (!this._tmap.supportsVectorEffects()) {
   for (var area in this.Areas)
     this.Areas[area].HandleZoomEvent(pzcMatrix);
  }
  
  for (var area in this._renderedLabels) {
    if (this._renderedLabels[area]) {
      var label = this._areaLabels[area];
      if (label)
        label.update(pzcMatrix);
    }
  }
}
/**
 * Thematic Map custom area layer
 * @param {DvtThematicMap} tmap The thematic map this map layer belongs to
 * @param {String} layerName The name of map area layer
 * @param {String} clientId The client id for this map layer
 * @param {String} labelDisplay Whether to display the labels for this map layer
 * @param {String} labelType The type of labels to display for this map layer (short or long)
 * @param {DvtEventManager} eventHandler The thematic map event manager
 * @constructor
 */
var DvtMapCustomAreaLayer = function (tmap, layerName, clientId, labelDisplay, labelType, eventHandler) {
  this.Init(tmap, layerName, clientId, labelDisplay, labelType, eventHandler);
}

DvtObj.createSubclass(DvtMapCustomAreaLayer, DvtMapAreaLayer, "DvtMapCustomAreaLayer");

/**
 * Helper method to initialize this DvtMapCustomAreaLayer object
 * @param {DvtThematicMap} tmap The thematic map this map layer belongs to
 * @param {String} layerName The name of map area layer
 * @param {String} clientId The client id for this map layer
 * @param {String} labelDisplay Whether to display the labels for this map layer
 * @param {String} labelType The type of labels to display for this map layer (short or long)
 * @param {DvtEventManager} eventHandler The thematic map event manager
 * @protected
 */
DvtMapCustomAreaLayer.prototype.Init = function (tmap, layerName, clientId, labelDisplay, labelType, eventHandler) {
  DvtMapCustomAreaLayer.superclass.Init.call(this, tmap, layerName, clientId, labelDisplay, labelType, eventHandler);
}

/**
 * @override
 */
DvtMapCustomAreaLayer.prototype.updateAreaShape = function (area) {
}


/**
 * @override
 */
DvtMapCustomAreaLayer.prototype.getLayerDim = function () {
  return new DvtRectangle(0,0, this._layerWidth, this._layerHeight);
}

DvtMapCustomAreaLayer.prototype._selectImageBasedOnResolution = function() {
  var widthRes = this._tmap.GetWidth();
  var heightRes = this._tmap.GetHeight();
  var images = this._areaLayerImages;
  // Iterate and use the first image with enough detail
  for(var i=0; i<images.length; i++) {
    var image = images[i];
    var source = image['source'];
    var width = image['width'];
    var height = image['height'];
    var isSvg = (source && source.search(".svg") > -1);
    
    // Use the image if it's SVG, a PNG whose size > resolution, or the last image provided.
    if(isSvg || (width >= widthRes && height >= heightRes) || i == images.length-1) {
      //Since points are given in the coordinate space of the original image size, we always set the image we choose
      //to that size.  The <image> tag will scale image as necessary.
      return source; 
    }
  }
}

DvtMapCustomAreaLayer.prototype.setAreaLayerImage = function(images) {
  var shape = null;
  var isRTL = DvtAgent.isRightToLeft(this._tmap.getCtx());
  // Use the images from the list provided
  if(images && images.length > 0) {
    var refWidth = images[0]['width'];
    var refHeight = images[0]['height'];
    this._layerWidth = refWidth;
    this._layerHeight = refHeight;
  
    // Filter the list to images matching the locale type. 
    var locImages = [];
    for(var i=0; i<images.length; i++) {
      if(isRTL && images[i]['dir'] == 'rtl') 
        locImages.push(images[i]);
      else if(!isRTL && images[i]['dir'] == 'ltr')
        locImages.push(images[i]);
    }
    this._areaLayerImages = locImages.length > 0 ? locImages : images; // Use all images if none match the bidi flag
    this._imageSrc = this._selectImageBasedOnResolution();   
    shape = new DvtImage(this._tmap.getCtx(), this._imageSrc, 0, 0, refWidth, refHeight); 

  }
  if (shape) {
    this.setAreaNames({'image': [null, null]});
    this.setAreaShapes({'image': shape});
  }
}

DvtMapCustomAreaLayer.prototype.HandleZoomEvent = function (event, pzcMatrix) {
  DvtMapCustomAreaLayer.superclass.HandleZoomEvent.call(this, event, pzcMatrix);
  if (this.Areas['image']) {
    var newImageSrc = this._selectImageBasedOnResolution();
    if (newImageSrc != this._imageSrc) {
      this._imageSrc = newImageSrc;
      this.Areas[areaName].setSrc(this._imageSrc);
    }
  }
}
var DvtMapDataLayer = function (tmap, parentLayer, clientId, eventHandler) {
  this.Init(tmap, parentLayer, clientId, eventHandler);
}

DvtObj.createSubclass(DvtMapDataLayer, DvtObj, "DvtMapDataLayer");

/**
 * @param {string} layerId The client ID of the layer
 */
DvtMapDataLayer.prototype.Init = function (tmap, parentLayer, clientId, eventHandler) {
  this._tmap = tmap;
  this._clientId = clientId;
  
  this._areaObjs = [];
  this._dataObjs = [];
  
  this._eventHandler = eventHandler;
  
  // Drag and drop support
  this._dragSource = new DvtDragSource(tmap.getCtx());
  this._eventHandler.setDragSource(this._dragSource);
  
  this._dataAreaLayer = new DvtContainer(this._tmap.getCtx());
  this._dataPointLayer = new DvtContainer(this._tmap.getCtx());
  this._dataLabelLayer = new DvtContainer(this._tmap.getCtx());
  // Add containers to head of parent container so parent layer objects are always drawn first i.e. drilled area borders
  this._tmap.getDataAreaContainer().addChildAt(this._dataAreaLayer, 0);
  this._tmap.getDataPointContainer().addChildAt(this._dataPointLayer, 0);
  this._tmap.getLabelContainer().addChildAt(this._dataLabelLayer, 0);
  
  this._parentLayer = parentLayer;
  
  this._disclosed = [];
  this._drilled = [];
}

DvtMapDataLayer.prototype.getDragSource = function () {
  return this._dragSource;
}

/**
 * Returns the DvtContainers for this data layer
 * @return {Array} Array of DvtContainers 
 */
DvtMapDataLayer.prototype.getContainers = function () {
  var containers = [this._dataAreaLayer, this._dataPointLayer, this._dataLabelLayer];
  return containers;
}

/**
 * Returns an array of scaled containers for data layer animation
 * @return {array} The array of scaled containers
 */
DvtMapDataLayer.prototype.getScaledContainers = function () {
  return [this._dataAreaLayer];
}

/**
 * Returns an array of non scaled containers for data layer animation
 * @return {array} The array of non scaled containers
 */
DvtMapDataLayer.prototype.getNonScaledContainers = function () {
  var containers = [this._dataLabelLayer];
  if (this._tmap.isMarkerZoomBehaviorFixed())
    containers.push(this._dataPointLayer);
  return containers;
}

/**
 * Returns the label container for this data layer
 * @return {DvtContainer} container for labels
 */
DvtMapDataLayer.prototype.getDataLabelContainer = function () {
  return this._dataLabelLayer;
}

DvtMapDataLayer.prototype.getMapLayer = function () {
  return this._parentLayer;
}

DvtMapDataLayer.prototype.getMap = function () {
  return this._tmap;
}

DvtMapDataLayer.prototype.getAllObjects = function () {
  return this._dataObjs.concat(this._areaObjs);
}

DvtMapDataLayer.prototype.getAreaObjects = function () {
  return this._areaObjs;
}

DvtMapDataLayer.prototype.getDataObjects = function () {
  return this._dataObjs;
}

DvtMapDataLayer.prototype.getNavigableAreaObjects = function () {
  var navigables = [];
  for (var i=0; i< this._areaObjs.length; i++) {
    if (!this._areaObjs[i].isDrilled())
      navigables.push(this._areaObjs[i]);
  }
  return navigables;
}

DvtMapDataLayer.prototype.getNavigableDisclosedAreaObjects = function () {
  var navigables = [];
  for (var i=0; i<this._areaObjs.length; i++) {
    for (var j=0; j<this._disclosed.length; j++) {
      if (this._areaObjs[i].getAreaId() == this._disclosed[j]) {
        if (!this._areaObjs[i].isDrilled())
          navigables.push(this._areaObjs[i]);
      }
    }
  }
  return navigables;
}
      
DvtMapDataLayer.prototype.addDataObject = function (obj) {
  this._dataObjs.push(obj);
  this._eventHandler.associate(obj.getDisplayable(), obj);
}

/**
 * Adds an area object to this data layer
 * @param {DvtMapDataArea} obj The map area to add
 */
DvtMapDataLayer.prototype.addAreaObject = function (obj) {
  this._areaObjs.push(obj);
  this._eventHandler.associate(obj.getDisplayable(), obj);
  obj.setAreaLayer(this._dataAreaLayer);
}

DvtMapDataLayer.prototype.getClientId = function () {
  return this._clientId;
}

DvtMapDataLayer.prototype.setAnimation = function (animType) {
  this._animType = animType;
}

DvtMapDataLayer.prototype.getAnimation = function () {
  return this._animType;
}

DvtMapDataLayer.prototype.setAnimationDuration = function (animDur) {
  this._animDur = animDur;
}

DvtMapDataLayer.prototype.getAnimationDuration = function () {
  return this._animDur;
}

/**
 * Sets the selection mode for this data layer
 * @param {String} mode The selection mode. Valid values are 's' and 'm'
 */
DvtMapDataLayer.prototype.setSelectionMode = function (mode) {
  this._selectionMode = mode;
  if (this._selectionMode) {
    this._selectionHandler = new DvtSelectionHandler(this._selectionMode);
    this._eventHandler.setSelectionHandler(this._clientId, this._selectionHandler);
  }
}

DvtMapDataLayer.prototype.isSelectable = function () {
  return this._selectionMode != null;
}

DvtMapDataLayer.prototype.setIsolatedAreaRowKey = function (isolated) {
  this._isolatedAreaRowKey = isolated;
}

/**
 * Since we don't set the area path commands until render time, we create an empty DvtDrillablePath when parsing the xml
 * so we can still set the area color and other info.  This path with no commands needs to be updated before adding to DOM.
 */
DvtMapDataLayer.prototype._updateAreaShape = function(areaObj) {
    var displayable = areaObj.getDisplayable();
    var pathToCopy = this._parentLayer.getAreaShape(areaObj.getAreaId());
    displayable.setCmds(pathToCopy.getCmds());
}

/**
 * Renders a specific DvtMapDataArea and updates the label
 * @param {number} areaIndex index of the area to be rendered
 * 
 * @private
 */
DvtMapDataLayer.prototype._renderAreaAndLabel = function(areaIndex) {
  var displayable = this._areaObjs[areaIndex].getDisplayable();
  this._updateAreaShape(this._areaObjs[areaIndex]);
  this._dataAreaLayer.addChild(displayable);
  var label = this._areaObjs[areaIndex].getLabel();
  if (label) {
    if (!label.hasBounds()) {
      var areaDim = displayable.getDimensions();
      label.addBounds(areaDim);
    }
    label.update(this._pzcMatrix);
  }
}

/**
 * Render the data layer objects
 * @param {DvtMatrix} pzcMatrix The matrix to use when rendering the data layer
 */
DvtMapDataLayer.prototype.render = function (pzcMatrix) {
  this._bFixPatterns = true;
  this._pzcMatrix = pzcMatrix;
  var areaLabelsToRemove = {};
  // first sort markers by size to prevent overlapping
  this._dataObjs.sort(function compare(a,b) {if (a.getSize() < b.getSize()) return 1; else if (a.getSize() > b.getSize()) return -1; else return 0;})
  for (var i=0; i<this._dataObjs.length; i++) {
    var dataObj = this._dataObjs[i];
    var displayable = dataObj.getDisplayable();
    var label = dataObj.getLabel();
    if (label) {
      // For markers that have rotation and labels, create another container and add the label to that to prevent
      // rotating the label. The outer group should have all te transforms except for the rotation and the marker should
      // only have the rotation transform.
      var rotation = displayable.getRotation();
      if (rotation) {
        var container = new DvtContainer(displayable.getCtx());
        this._dataPointLayer.addChild(container);
        container.addChild(displayable);
        container.addChild(label);
      } else {
        this._dataPointLayer.addChild(displayable);
        displayable.addChild(label);
      }
      dataObj.PositionLabel(pzcMatrix);
    } else {
      this._dataPointLayer.addChild(displayable);
    }
    // if area marker, do not display area label
    var regionId = dataObj.getAreaId();
    if (regionId)
     areaLabelsToRemove[regionId] = true;
  }
  for (var i=0; i<this._areaObjs.length; i++) {
    if (areaLabelsToRemove[this._areaObjs[i].getAreaId()])
      this._areaObjs[i].setLabel(null);
    this._renderAreaAndLabel(i);
  }
  
  
  if (this._initSelections)
    this._processInitialSelections();
}

/**
 * Discloses the children of the current drilled parent area.
 * @param {Array} areas The ids of the areas to disclose
 * @param {Array} fadeInObjs The objects that will be faded in for the drilling animation
 * @param {DvtMatrix} pzcMatrix The current canvas matrix
 */
DvtMapDataLayer.prototype.discloseAreas = function(areas, fadeInObjs, pzcMatrix) {
  this._pzcMatrix = pzcMatrix;
  var drilledAreas = [];
  for (var j=0; j<areas.length; j++) {
    for (var i=0; i<this._areaObjs.length; i++) {
      if (this._areaObjs[i].getAreaId() == areas[j]) {
        drilledAreas.push(this._areaObjs[i].getAreaId());
        this._renderAreaAndLabel(i);
        var displayable = this._areaObjs[i].getDisplayable();
        fadeInObjs.push(displayable);
        // update the disclosed area with the current zoom which is needed for IE to render the correct stroke widths
        displayable.handleZoomEvent(pzcMatrix);
        var label = this._areaObjs[i].getLabel();
        if (label) {
          fadeInObjs.push(label);
          var leaderLine = label.getLeaderLine();
          if (leaderLine)
            fadeInObjs.push(leaderLine);
        }
        break;
      }
    }
  }
  //If data layer contains markers or images, just add to data layer regardless of what area it is in if no id
  for (var i=0; i<this._dataObjs.length; i++) {
    for (var j=0; j<areas.length; j++) {
      var regionId = this._dataObjs[i].getAreaId();
      var displayable = this._dataObjs[i].getDisplayable();
      if (regionId != null) {
        if (regionId == areas[j]) {
          this._dataPointLayer.addChild(displayable);
          fadeInObjs.push(displayable);
        }
      } else {
        this._dataPointLayer.addChild(displayable);
        fadeInObjs.push(displayable);
      }
    }
  }
  this._disclosed = this._disclosed.concat(drilledAreas);
}

DvtMapDataLayer.prototype.undiscloseAreas = function(areas, fadeOutObjs) { 
  for (var j=0; j<areas.length; j++) {
    for (var i=0; i<this._areaObjs.length; i++) {
      if (this._areaObjs[i].getAreaId() == areas[j]) {
        if (this._areaObjs[i].isDrilled())
          this._areaObjs[i].setDrilled(false);
        if (this._areaObjs[i].isSelected())
          this._selectionHandler.removeFromSelection(this._areaObjs[i]);
        var idx = DvtArrayUtils.getIndex(this._disclosed, areas[j]);
        if (idx > -1) {
          this._disclosed.splice(idx, 1);
          fadeOutObjs.push(this._areaObjs[i].getDisplayable());
          var label = this._areaObjs[i].getLabel();
          if (label) {
            fadeOutObjs.push(label);
            fadeOutObjs.push(label.getLeaderLine());
          }
        }
        break;
      }
    }
  }
}

DvtMapDataLayer.prototype.drill = function(areaName, fadeOutObjs) { 
  for (var i=0; i<this._areaObjs.length; i++) {
    if (this._areaObjs[i].getAreaId() == areaName) {
      this._areaObjs[i].setDrilled(true);
      this._drilled.push(areaName);
      fadeOutObjs.push(this._areaObjs[i].getDisplayable());
      var label = this._areaObjs[i].getLabel();
      if (label) {
        fadeOutObjs.push(label);
        var leaderLine = label.getLeaderLine();
        if (leaderLine)
          fadeOutObjs.push(leaderLine);
      }
      break;
    }
  }
  for (var i=0; i<this._dataObjs.length; i++) {
    if (this._dataObjs[i].getAreaId() == areaName) {
      fadeOutObjs.push(this._dataObjs[i].getDisplayable());
      break;
    }
  }
}

DvtMapDataLayer.prototype.undrill = function(areaName, fadeInObjs) { 
  for (var i=0; i<this._areaObjs.length; i++) {
    if (this._areaObjs[i].getAreaId() == areaName) {
      var idx = DvtArrayUtils.getIndex(this._drilled, areaName);
      this._drilled.splice(idx, 1);
      this._areaObjs[i].setDrilled(false);
      var displayable = this._areaObjs[i].getDisplayable();
      this._dataAreaLayer.addChild(displayable);
      fadeInObjs.push(displayable);
      var label = this._areaObjs[i].getLabel();
      if (label) {
        label.update(this._pzcMatrix);
        fadeInObjs.push(label);
        fadeInObjs.push(label.getLeaderLine());
      }
      break;
    }
  }
  for (var i=0; i<this._dataObjs.length; i++) {
    if (this._dataObjs[i].getAreaId() == areaName) {
      var displayable = this._dataObjs[i].getDisplayable();
      this._dataPointLayer.addChild(displayable);
      fadeInObjs.push(displayable);
      break;
    }
  }
}

/**
 * Resets the data layer to its initial condition.
 * @param {Array} fadeOutObjs The list of objects that will be animated away
 * @param {Array} doNotResetAreas List of ids of areas that should not be reset
 */
DvtMapDataLayer.prototype.reset = function(fadeOutObjs, doNotResetAreas) {
  // Clear selected
  if (this._selectionHandler) {
    var selectedObjs = this._selectionHandler.getSelection();
    for (var i=0; i<selectedObjs.length; i++) {
      if (!doNotResetAreas || (doNotResetAreas && DvtArrayUtils.getIndex(doNotResetAreas, selectedObjs[i].getAreaId()) == -1))
        this._selectionHandler.removeFromSelection(selectedObjs[i]);
    }
  }
   
  // Clear drilled if drilling is on
  if (this._tmap.getDrillMode() != 'none') {
    for (var j=0; j<this._drilled.length; j++) {
      for (var i=0; i<this._areaObjs.length; i++) {
        if (this._areaObjs[i].getAreaId() == this._drilled[j]) {
          this._areaObjs[i].setDrilled(false);
          var displayable = this._areaObjs[i].getDisplayable();
          this._dataAreaLayer.addChild(displayable);
          fadeOutObjs.push(displayable);
          var label = this._areaObjs[i].getLabel();
          if (label) {
            label.update(this._pzcMatrix);
            fadeOutObjs.push(label);
            fadeOutObjs.push(label.getLeaderLine());
          }
          break;
        }
      }
      for (var i=0; i<this._dataObjs.length; i++) {
        if (this._dataObjs[i].getAreaId() == this._drilled[j]) {
          var displayable = this._dataObjs[i].getDisplayable();
          this._dataPointLayer.addChild(displayable);
          fadeOutObjs.push(displayable);
          break;
        }
      }
    }
  }
      
  this._drilled = [];
}

/**
 * Handles zoom events for the data layer objects
 * @param {DvtZoomEvent} event The zoom event sent by the pan zoom canvas
 * @param {DvtMatrix} pzcMatrix The pan zoom canvas matrix
 * @protected
 */
DvtMapDataLayer.prototype.HandleZoomEvent = function (event, pzcMatrix) {
  this._pzcMatrix = pzcMatrix;
  var zoom = pzcMatrix.getA();
  // If this is initial zoom to fit need to set transform on pattern gradients
  var type = event.getSubType();
  if (this._bFixPatterns && type == DvtZoomEvent.SUBTYPE_ZOOMED) {
    this._bFixPatterns = false;
    for(var j=0; j<this._areaObjs.length; j++) {
      var displayable = this._areaObjs[j].getDisplayable();
      var fill = displayable.getSavedPatternFill();
      if (fill) {
        var scaledFill = new DvtPatternFill();
        fill.mergeProps(scaledFill);
        scaledFill.setMatrix(new DvtMatrix(1/zoom, null, null, 1/zoom));
        displayable.setFill(scaledFill);
      }
    }
  }
  var areaObjs = this.getAreaObjects();
  for (var i=0; i<areaObjs.length; i++)
    areaObjs[i].HandleZoomEvent(pzcMatrix);
  
  if (this._tmap.isMarkerZoomBehaviorFixed()) {
    var dataObjs = this.getDataObjects();
    for (var i=0; i<dataObjs.length; i++)
      dataObjs[i].HandleZoomEvent(pzcMatrix);
  }
}

/**
 * Processes a pan event for this data layer and updates the locations of its data objects
 * @param {DvtMatrix} pzcMatrix The matrix to use for updating data object locations
 * @protected
 */
DvtMapDataLayer.prototype.HandlePanEvent = function (pzcMatrix) {
  this._pzcMatrix = pzcMatrix;
}


DvtMapDataLayer.prototype.setInitialSelections = function(selections) {
  this._initSelections = selections;
}

/**
 * Update the selection handler with the initial selections.
 */
DvtMapDataLayer.prototype._processInitialSelections = function() {
  if(this._selectionHandler) {
    this._selectionHandler.processInitialSelections(this._initSelections, this.getAllObjects());
    this._initSelections = null;
  }
}

/**
 * Returns the row keys for the current drag.
 * @param {DvtMapDataObject} obj The object where the drag was initiated.
 * @return {array} The row keys for the current drag.
 */
DvtMapDataLayer.prototype.__getDragTransferable = function(obj) {
  if (this._selectionHandler) {
    // Select the node if not already selected
    if(!obj.isSelected()) {
      this._selectionHandler.processClick(obj, false);
      this._eventHandler.fireSelectionEvent(obj);
    }
    
    // Gather the rowKeys for the selected objects
    var rowKeys = [];
    var selection = this._selectionHandler.getSelection();
    for(var i=0; i<selection.length; i++) {
      rowKeys.push(selection[i].getId());
    }
    
    return rowKeys;
  } else {
    return null;
  }
}

/**
 * Returns the displayables to use for drag feedback for the current drag.
 * @return {array} The displayables for the current drag.
 */
DvtMapDataLayer.prototype.__getDragFeedback = function() {
  // This is called after __getDragTransferable, so the selection has been updated already.
  // Gather the displayables for the selected objects
  var displayables = [];
  var selection = this._selectionHandler.getSelection();
  for(var i=0; i<selection.length; i++) {
    displayables.push(selection[i].getDisplayable());
  }
  
  return displayables;
}

/**
 * Given a list of area row keys, looks up and returns a list of their area ids
 * @param {Array} Row keys of areas to retrieve area ids for
 * @preturn {Array} Area ids
 */
DvtMapDataLayer.prototype.getSelectedAreas = function (selectedObjs) {
  var selectedAreas = []
  var areaObjs = this.getAreaObjects();
  for(var i=0; i<selectedObjs.length; i++) {
    for(var j=0; j<areaObjs.length; j++) {
      if (areaObjs[j].getId() == selectedObjs[i]) {
        selectedAreas.push(areaObjs[j].getAreaId());
        break;
      }
    }
  }
  return selectedAreas;
}
/**
 *  @param {DvtEventManager} manager The owning DvtEventManager
 *  @class DvtThematicMapKeyboardHandler
 *  @extends DvtKeyboardHandler
 *  @constructor
 */
var DvtThematicMapKeyboardHandler = function (tmap, manager) {
  this.Init(tmap, manager);
};

DvtObj.createSubclass(DvtThematicMapKeyboardHandler, DvtPanZoomCanvasKeyboardHandler, "DvtThematicMapKeyboardHandler");

/**
 * @override
 */
DvtThematicMapKeyboardHandler.prototype.Init = function (tmap, manager) {
  DvtThematicMapKeyboardHandler.superclass.Init(tmap, manager);
  this._tmap = tmap;
}

/**
 * @override
 */
DvtThematicMapKeyboardHandler.prototype.isSelectionEvent = function (event) {
  return this.isNavigationEvent(event) && !event.ctrlKey;
}

/**
 * @override
 */
DvtThematicMapKeyboardHandler.prototype.processKeyDown = function (event) {
  var keyCode = event.keyCode;

  if (keyCode == DvtKeyboardEvent.CLOSE_BRACKET) {
    var focusObj = this._eventManager.getFocus();
    var navigables = this._tmap.getNavigableObjects();
    if (focusObj instanceof DvtMapDataArea && navigables.length > 0)
      focusObj = DvtKeyboardHandler.getNextAdjacentNavigable(focusObj, event, navigables);
    this._eventManager.setFocus(focusObj);
    this._eventManager.SetClickInfo(focusObj);
    return focusObj;
  }
  else if (keyCode == DvtKeyboardEvent.OPEN_BRACKET) {
    var focusObj = this._eventManager.getFocus();
    var navigables = this._tmap.getNavigableAreas();
    if (!(focusObj instanceof DvtMapDataArea) && navigables.length > 0)
      focusObj = DvtKeyboardHandler.getNextAdjacentNavigable(focusObj, event, navigables);
    this._eventManager.setFocus(focusObj);
    this._eventManager.SetClickInfo(focusObj);
    return focusObj;
  }
  else {
    var focusObj = DvtThematicMapKeyboardHandler.superclass.processKeyDown.call(this, event);
    // update the clicked object for a navigation and selection event
    if (this.isNavigationEvent(event) && !event.ctrlKey)
      this._eventManager.SetClickInfo(focusObj);
    return focusObj;
  }
}

/**
 * @override
 */
DvtThematicMapKeyboardHandler.prototype.isMultiSelectEvent = function (event) {
  return event.keyCode == DvtKeyboardEvent.SPACE && event.ctrlKey;
}

/**
 * @override
 */
DvtThematicMapKeyboardHandler.prototype.isNavigationEvent = function (event) {
  var isNavigable = DvtThematicMapKeyboardHandler.superclass.isNavigationEvent.call(this, event);

  if (!isNavigable) {
    var keyCode = event.keyCode;
    if (keyCode == DvtKeyboardEvent.OPEN_BRACKET || keyCode == DvtKeyboardEvent.CLOSE_BRACKET)
      isNavigable = true;
  }

  return isNavigable;
}
// Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved.

/**
 * @constructor
 */
var DvtThematicMapEventManager = function(context, callback, callbackObj) {
  this.Init(context, callback, callbackObj);
};

DvtObj.createSubclass(DvtThematicMapEventManager, DvtEventManager, "DvtThematicMapEventManager");

DvtThematicMapEventManager.prototype.Init = function(context, callback, callbackObj) {
  DvtThematicMapEventManager.superclass.Init.call(this, context, callback, callbackObj);
  this._selectionHandlers = new Object();
  this._tmap = callbackObj;
  this._bDragged = false;
}

/**
 * @override
 */
DvtThematicMapEventManager.prototype.getSelectionHandler = function(logicalObj) {
  if (logicalObj && logicalObj.getDataLayer) {
    var clientId = logicalObj.getDataLayer().getClientId();
    return this._selectionHandlers[clientId];
  }
}

/**
 * @override
 */
DvtThematicMapEventManager.prototype.setSelectionHandler = function(dataLayerId, handler) {
  this._selectionHandlers[dataLayerId] = handler;
}

DvtThematicMapEventManager.prototype.setDrillMode = function (mode) {
  this._drillMode = mode;
}

DvtThematicMapEventManager.prototype.setPanZoomCanvas = function (pzc) {
  this._pzc = pzc;
}

DvtThematicMapEventManager.prototype.removeFromSelection = function (clientId, obj) {
  var selectionHandler = this._selectionHandlers[clientId];
  if (selectionHandler)
    selectionHandler.removeFromSelection(obj);
}

DvtThematicMapEventManager.prototype.clearSelection = function (clientId) {
  var selectionHandler = this._selectionHandlers[clientId];
  if (selectionHandler)
    selectionHandler.clearSelection();
}

DvtThematicMapEventManager.prototype.setInitialFocus = function (navigable) {
  //focus object will be set on child layers
  if (navigable) {
    DvtThematicMapEventManager.superclass.setFocus.call(this, navigable);
  }
}

/**
 * @override
 */
DvtThematicMapEventManager.prototype.OnMouseOver = function (event) {
  var obj = this.GetLogicalObject(event.target);
  if (obj && obj.getShowPopupBehaviors && obj.getDataLayer) {
    this._tmap.setEventClientId(obj.getDataLayer().getClientId());
  }
  DvtThematicMapEventManager.superclass.OnMouseOver.call(this, event);
}

/**
 * @override
 */
DvtThematicMapEventManager.prototype.OnMouseDown = function (event) {
  this._bDragged = false;
  DvtThematicMapEventManager.superclass.OnMouseDown.call(this, event);
}

/**
 * @override
 */
DvtThematicMapEventManager.prototype.OnMouseMove = function (event) {
  this._bDragged = true;
  DvtThematicMapEventManager.superclass.OnMouseMove.call(this, event);
}

/**
 * @override
 */
DvtThematicMapEventManager.prototype.OnClick = function (event) {
  if (this._bDragged)
    return;
    
  var obj = this.GetLogicalObject(event.target);
  this.SetClickInfo(obj);
  
  // Clear all selection handlers if something not selectable is clicked
  if (!(obj && obj.isSelectable && obj.isSelectable())) {
    for (var clientId in this._selectionHandlers) {
      var bSelectionChanged = this._selectionHandlers[clientId].processClick(null, event.ctrlKey);
      // If the selection has changed, fire an event
      if (bSelectionChanged) {
        var selectionEvent = new DvtSelectionEvent([]);
        selectionEvent.addParam('clientId', clientId);
        this._callback.call(this._callbackObj, selectionEvent);
      }
    }
  }
  
  DvtThematicMapEventManager.superclass.OnClick.call(this, event);
  this._handleClick(obj);
}

/**
 * Performs thematic map specific events on click called by the mouse and touch click handlers
 * @param {DvtDisplayable} obj The displayable that was clicked
 * @private
 */
DvtThematicMapEventManager.prototype._handleClick = function (obj) {
  if (obj instanceof DvtMapDataObject) {
    if (obj.hasAction()){
      var actionEvent = new DvtMapActionEvent(obj.getClientId(), obj.getId(), obj.getAction());
      actionEvent.addParam('clientId', obj.getDataLayer().getClientId());
      this.hideTooltip();
      this._callback.call(this._callbackObj, actionEvent);
    } else if (obj.getShowPopupBehaviors()) {
      this._tmap.setEventClientId(obj.getDataLayer().getClientId());
    }
  }
}

DvtThematicMapEventManager.prototype.SetClickInfo = function(obj) {
  var clientId = null;
  var mapLayer = null;
  var area = null;
  if (obj) {
    if (obj instanceof DvtMapDataObject) 
      area = obj.getDisplayable();
    else if (obj instanceof DvtMapArea)
      area = obj;
    if  (obj.getDataLayer) {
      var dataLayer = obj.getDataLayer();
      clientId = dataLayer.getClientId();
      mapLayer = dataLayer.getMapLayer().getLayerName();
    }
  }
  this._tmap.setClickInfo(clientId, mapLayer, area);
}

/**
 * @override
 */
DvtThematicMapEventManager.prototype.OnDblClick = function(event) {
  DvtThematicMapEventManager.superclass.OnDblClick.call(this, event);
  var obj = this.GetLogicalObject(event.target);
  if (this.getSelectionHandler(obj) && this._drillMode && this._drillMode != 'none') {
    // Create and fire the event
    var drillEvent = new DvtMapDrillEvent(DvtMapDrillEvent.DRILL_DOWN);
    this._callback.call(this._callbackObj, drillEvent);
  }
}

/**
 * Keyboard event handler. Handles keyboard navigation and triggering of context menus
 * @param {DvtKeyboardEvent} event
 * @return {boolean} true if this event manager has consumed the event
 */
DvtThematicMapEventManager.prototype.ProcessKeyboardEvent = function(event)
{
  var eventConsumed = true;
  var keyCode = event.keyCode;
  // Map Reset
  if ((keyCode == DvtKeyboardEvent.ZERO || keyCode == DvtKeyboardEvent.NUMPAD_ZERO) && event.ctrlKey && event.shiftKey) {
    this._tmap.resetMap();
    event.preventDefault();
  }
  // Legend
  else if (keyCode == DvtKeyboardEvent.BACK_SLASH) {
    var legendPanel = this._tmap.getLegendPanel();
    if (legendPanel) {
      if (legendPanel instanceof DvtCollapsiblePanel)
        legendPanel.setCollapsed(!legendPanel.isCollapsed());
      else if (legendPanel instanceof DvtPanelDrawer)
        legendPanel.setDisclosed(!legendPanel.isDisclosed());
    }
    event.preventDefault();
  }
  // Drilling
  else if (keyCode == DvtKeyboardEvent.ENTER) {
    if (event.shiftKey)
      this._tmap.drillUp();
    else 
      this._tmap.drillDown();
    event.preventDefault();
  }
  // Selection
  else if (keyCode == DvtKeyboardEvent.SPACE && event.ctrlKey) {
    var logicalObj = this.getFocus();
    this.SetClickInfo(logicalObj);
    this.ProcessSelectionEventHelper(logicalObj, true);
    event.preventDefault();
  }  
  // Zoom to fit
  else if ((keyCode == DvtKeyboardEvent.ZERO || keyCode == DvtKeyboardEvent.NUMPAD_ZERO) && event.ctrlKey) {
    var focusObj = this.getFocus();
    if (event.altKey)
      this._tmap.fitRegion(focusObj.getDisplayable());
    else
      this._tmap.fitSelectedRegions();
    event.preventDefault();
  }
  else {
    eventConsumed = DvtThematicMapEventManager.superclass.ProcessKeyboardEvent.call(this, event);
  }
  
  return eventConsumed;
}

/**
 * @override
 */
DvtThematicMapEventManager.prototype.OnComponentTouchClick = function (event) {
  var obj = this.GetLogicalObject(event.target);
  this.SetClickInfo(obj);
  
  // If no logical objects then pass on to all selection handlers to clear selection
  if (!obj || obj.isClearSelection) {
    for (var clientId in this._selectionHandlers) {
      var bSelectionChanged = this._selectionHandlers[clientId].processClick(null, event.ctrlKey);
      // If the selection has changed, fire an event
      if (bSelectionChanged) {
        var selectedObjs = this._selectionHandlers[clientId].getSelection();
        var selectedIds = [];
        for(var i=0; i<selectedObjs.length; i++)
          selectedIds.push(selectedObjs[i].getId());
        var selectionEvent = new DvtSelectionEvent(selectedIds);
        this._callback.call(this._callbackObj, selectionEvent);
      }
    }
  }
  
  DvtThematicMapEventManager.superclass.OnComponentTouchClick.call(this, event);
  this._handleClick(obj);
}

/**
 * @override
 */
DvtThematicMapEventManager.prototype.HandleTouchHoverOverInternal = function (event) {
  var obj = this.GetLogicalObject(event.target);
  if (obj && obj.getShowPopupBehaviors && obj.getDataLayer) {
    this._tmap.setEventClientId(obj.getDataLayer().getClientId());
  }
}

/**
 * @override
 */
DvtThematicMapEventManager.prototype.OnComponentTouchDblClick = function(event) {       
  var obj = this.GetLogicalObject(event.target);
  if(!obj)
    return;
  if (this.getSelectionHandler(obj) && this._drillMode && this._drillMode != 'none') {
    // First make sure a selection event is fired to support drilling on double click. Touch doesn't send click event
    // before a double click
    this.ProcessSelectionEventHelper(obj, event.ctrlKey);
    var drillEvent = new DvtMapDrillEvent(DvtMapDrillEvent.DRILL_DOWN);
    this._callback.call(this._callbackObj, drillEvent);
  }
}

// Copyright (c) 2011, 2014, Oracle and/or its affiliates. All rights reserved.
/**
 * @constructor
 */
var DvtThematicMapParser = function (tmap) {
  this.Init(tmap);
}

DvtObj.createSubclass(DvtThematicMapParser, DvtObj, "DvtThematicMapParser");

DvtThematicMapParser._ELEM_MAP_PROPERTIES = "mapProperties";
DvtThematicMapParser._ELEM_LAYERS = "layers";
DvtThematicMapParser._ELEM_LAYER = "layer";
DvtThematicMapParser._ELEM_POINTS = "points";
DvtThematicMapParser._ELEM_POINT = "point";
DvtThematicMapParser._ELEM_LEGEND = "legend";
DvtThematicMapParser._ELEM_RESOURCES = "resources";
DvtThematicMapParser._ELEM_MAP_HIERARCHY = "mapHierarchy";
DvtThematicMapParser._ELEM_MENUS = "menus";
DvtThematicMapParser.ELEM_COLOR_STYLES = "colorStyles";
DvtThematicMapParser.ELEM_GRADUATED_SYMBOL = "graduatedSymbol";
DvtThematicMapParser.ELEM_IMAGE = "image";
DvtThematicMapParser._ELEM_MARKER_DEF = "markerDef";
DvtThematicMapParser._ELEM_ROW = "row";
DvtThematicMapParser._ELEM_CUSTOM_LAYER = "customLayer";
DvtThematicMapParser._ELEM_AREA_LAYER = "areaLayer";
DvtThematicMapParser._ELEM_POINT_LAYER = "pointLayer";
DvtThematicMapParser._ELEM_SPB = "spb";
DvtThematicMapParser._ELEM_CUSTOM_REGION = "customRegion";
DvtThematicMapParser._ELEM_P = "p";
DvtThematicMapParser._ELEM_STYLES = "styles";
DvtThematicMapParser._ELEM_REGION_LAYER ="regionLayer";
DvtThematicMapParser._ELEM_MARKER_STYLE ="markerStyle";
DvtThematicMapParser._ELEM_TMAP_RESOURCES = "tmapResources";

DvtThematicMapParser._ATTR_ANIM_DATA_CHANGE = "animationDataChange";
DvtThematicMapParser._ATTR_ANIM_ON_LAYER_CHANGE = "animationOnLayerChange";
DvtThematicMapParser.ATTR_ID = "id";
DvtThematicMapParser._ATTR_CLIENT_ID = "clientId";
DvtThematicMapParser._ATTR_SELECTION_MODE = "selectionMode";
DvtThematicMapParser._ATTR_STYLE_ID = "styleId";
DvtThematicMapParser._ATTR_LAYER_NAME = "layerName";
DvtThematicMapParser._ATTR_LABEL = "label";
DvtThematicMapParser._ATTR_LABEL_DISPLAY = "labelDisplay";
DvtThematicMapParser._ATTR_LABEL_TYPE = "labelType";
DvtThematicMapParser._ATTR_LABEL_POSITION = "labelPosition";
DvtThematicMapParser._ATTR_ROW_KEY = "rowKey";
DvtThematicMapParser._ATTR_GROUP_ID = "groupID";
DvtThematicMapParser._ATTR_SHORT_NAME = "shortName";
DvtThematicMapParser._ATTR_LONG_NAME = "longName";
DvtThematicMapParser._ATTR_PATH = "d";
DvtThematicMapParser._ATTR_ALIGN_ID = "alignId";
DvtThematicMapParser._ATTR_SHOW_WITH = "showWith";
DvtThematicMapParser._ATTR_SUB_REGIONS ="subRegions";
DvtThematicMapParser._ATTR_INLINE_STYLE ="inlineStyle";
DvtThematicMapParser._ATTR_HOVER_STYLE ="hoverStyle";
DvtThematicMapParser._ATTR_SELECT_STYLE ="selectStyle";
DvtThematicMapParser._ATTR_DISCLOSED_STYLE ="disclosedStyle";
DvtThematicMapParser._ATTR_LABEL_STYLE ="labelStyle";
DvtThematicMapParser._ATTR_DROP_SITE_STYLE ="dropTargetStyle";
DvtThematicMapParser._ATTR_BASEMAP_NAME = "baseMapName";
DvtThematicMapParser._ATTR_ANIM_ON_DISP = "animationOnDisplay";
DvtThematicMapParser._ATTR_ANIM_ON_MAP_CHANGE = "animationOnMapChange";
DvtThematicMapParser._ATTR_ANIM_DUR = "animationDuration";
DvtThematicMapParser._ATTR_ANIM_ON_MAP_CHANGE = "animationOnMapChange";
DvtThematicMapParser._ATTR_ANIM_ON_DRILL = "animationOnDrill";
DvtThematicMapParser._ATTR_DRILL_ZOOM_TO_FIT = "drillZoomToFit";
DvtThematicMapParser._ATTR_DRILL_MODE = "drillMode";
DvtThematicMapParser._ATTR_INITIAL_ZOOMING = "initialZooming";
DvtThematicMapParser._ATTR_CTRLPANEL_BEHAVIOR = "controlPanelBehavior";
//DvtThematicMapParser._ATTR_ISBUILTINMAP = "isBuiltInMap";
DvtThematicMapParser._ATTR_TOOLTIP_DISPLAY = "displayTooltips";
DvtThematicMapParser._ATTR_FEATURES_OFF = "featuresOff";
DvtThematicMapParser._ATTR_LOCALE_L2R = "localeL2R";
DvtThematicMapParser._ATTR_CENTER_X = "centerX";
DvtThematicMapParser._ATTR_CENTER_Y = "centerY";
DvtThematicMapParser._ATTR_CUR_ZOOM = "curZoom";
DvtThematicMapParser._ATTR_IS_FLASH_POSITION = "isFlashPosition";
DvtThematicMapParser._ATTR_INLINE_STYLE = "inlineStyle";
DvtThematicMapParser._ATTR_ISOLATED_ROW_KEY = "isolatedRowKey";
DvtThematicMapParser._ATTR_SOURCE = "source";
DvtThematicMapParser._ATTR_ZOOMING = "zooming";
DvtThematicMapParser._ATTR_PANNING = "panning";
DvtThematicMapParser._ATTR_EXTENDS_LAYER = "extendsLayer";

DvtThematicMapParser._SEMICOLON = ";";

/**
 * Initializes this thematic map xml parser
 * @param {DvtThematicMap} tmap The thematic map this parser belongs to
 */
DvtThematicMapParser.prototype.Init = function (tmap) {
  this._tmap = tmap;
  this._customMarkerDefs = new Object();
  this._areaLayerStyle = null;
  this._areaHoverStyle = null;
  this._areaSelectStyle = null;
  this._areaDiscloseStyle = null;
  this._isMobile = DvtAgent.isTouchDevice();
}

/**
 * Parses an xml node containing thematic map layer and style information.
 * @param {DvtXmlNode} rootXmlNode The xml node to parse
 */
DvtThematicMapParser.prototype.loadXmlInitial = function (rootXmlNode) {
  var childNodes = rootXmlNode.getChildNodes();
  var node, nodeName;
  for (var i = 0;i < childNodes.length;i++) {
    node = childNodes[i];
    nodeName = node.getName();
    if (nodeName == DvtThematicMapParser._ELEM_MAP_PROPERTIES)
      this.ParseMapProperties(node);
    else if (nodeName == DvtThematicMapParser._ELEM_CUSTOM_LAYER)
      this.ParseCustomRegionLayer(node);
    else if (nodeName == DvtThematicMapParser._ELEM_LAYERS)
      this.ParseDataLayers(node);
    else if (nodeName == DvtThematicMapParser._ELEM_LEGEND)
      this.ParseLegend(node);
  }
}

/**
 * Parses map properties
 * @param {DvtXmlNode} xmlNode The xml node to parse
 */
DvtThematicMapParser.prototype.ParseMapProperties = function (xmlNode) {
  this._setMapProps(xmlNode);
  this._tmap.parseComponentAttrs(xmlNode);
  
  var childNodes = xmlNode.getChildNodes();
  var node, nodeName;
  for (var i = 0;i < childNodes.length;i++) {
    node = childNodes[i];
    nodeName = node.getName();
    if (nodeName == DvtThematicMapParser._ELEM_RESOURCES)
      this.ParseResources(node);
    else if (nodeName == DvtThematicMapParser._ELEM_MAP_HIERARCHY)
      this.ParseMapHierarchy(node);
    else if (nodeName == "panZoomCanvasProperties")
      this.ParsePanZoomResources(node);
    else if (nodeName == DvtThematicMapParser._ELEM_REGION_LAYER) {
      var attr = node.getAttr(DvtThematicMapParser._ATTR_INLINE_STYLE);
      if (attr)
        this._areaLayerStyle = new DvtCSSStyle(attr);
      attr = node.getAttr(DvtThematicMapParser._ATTR_HOVER_STYLE);
      if (attr)
        this._areaHoverStyle = new DvtCSSStyle(attr);
      attr = node.getAttr(DvtThematicMapParser._ATTR_SELECT_STYLE);
      if (attr)
        this._areaSelectStyle = new DvtCSSStyle(attr);
      attr = node.getAttr(DvtThematicMapParser._ATTR_DISCLOSED_STYLE);
      if (attr)
        this._areaDiscloseStyle = new DvtCSSStyle(attr);
    }
    else if (nodeName == DvtThematicMapParser._ELEM_MARKER_STYLE) {
      this._tmap.setMarkerStyle(new DvtCSSStyle(node.getAttr(DvtThematicMapParser._ATTR_INLINE_STYLE)))
    }
    else if (nodeName == 'basemap') {
      // check to see if this is the correct basemap metadata
      if (this._tmap.getMapName() == ('$'+node.getAttr(DvtThematicMapParser.ATTR_ID)))
        this.ParseCustomBasemap(node);
    }
  }
}

/**
 * Parses data layers for initial render or for data layer ppr.  On a data layer ppr the current pan zoom canvas 
 * matrix will be passed in to render the data layer at the current zoom level.
 * @param {DvtXmlNode} xmlNode The xml node to parse
 * @param {DvtMatrix} pzcMatrix The current map transform
 * @param {String} topLayerName The layer name of the current top layer
 */
DvtThematicMapParser.prototype.ParseDataLayers = function (xmlNode, pzcMatrix, topLayerName) {
  var layers = xmlNode.getElementsByTagName(DvtThematicMapParser._ELEM_LAYER);
  var legend = xmlNode.getElementsByTagName(DvtThematicMapParser._ELEM_LEGEND);
  // When only a data layer is updated the new legend xml is sent down in the same div.
  // Two legend elements will be returned bc the xml looks like: <legend><style><legend></legend></legend>
  // where the inner <legend> refers to the styles applied to the legend.
  // We need to check to see if this is a data layer update or initial render by checking to see if a pzcMatrix was 
  // passed in.
  if (pzcMatrix && legend && legend[0])
    this.ParseLegend(legend[0]);
    
  for (var i = 0;i < layers.length;i++) {
    var clientId = layers[i].getAttr(DvtThematicMapParser._ATTR_CLIENT_ID);
    var id = layers[i].getAttr(DvtThematicMapParser.ATTR_ID);
    var layer = this._tmap.getLayer(id);
    if (layer) {
      if (layer instanceof DvtMapAreaLayer)
        layer.resetRenderedAreas();
    } else {
      var parentLayerName = layers[i].getAttr(DvtThematicMapParser._ATTR_SHOW_WITH);
      if (parentLayerName) {
        layer = this._tmap.getLayer(parentLayerName);
      } else {
        layer = new DvtMapLayer(this._tmap, this._tmap.getEventHandler());
        this._tmap.addPointLayer(layer);
      }
    }
    var dataLayer = new DvtMapDataLayer(this._tmap, layer, clientId, this._tmap.getEventHandler());
  
    // Set data layer attributes
    //Set selection
    var selectionMode = layers[i].getAttr(DvtThematicMapParser._ATTR_SELECTION_MODE);
    if (selectionMode == 'single')
      dataLayer.setSelectionMode(DvtSelectionHandler.TYPE_SINGLE);
    else if (selectionMode == 'multiple')
      dataLayer.setSelectionMode(DvtSelectionHandler.TYPE_MULTIPLE);
      
    // Set Animation
    var animOnDataChange = layers[i].getAttr(DvtThematicMapParser._ATTR_ANIM_DATA_CHANGE);
    if (animOnDataChange) {
      var animDur = layers[i].getAttr(DvtThematicMapParser._ATTR_ANIM_DUR);
      if (animDur)
        animDur = parseFloat(animDur);
      if (!animDur || isNaN(animDur)) 
        animDur = 1.0;
      dataLayer.setAnimation(animOnDataChange);
      dataLayer.setAnimationDuration(animDur);
    }
    
    //Add initially isolated area
    var isolatedRowKey = null;
    if (layer instanceof DvtMapAreaLayer)
      isolatedRowKey = layers[i].getAttr(DvtThematicMapParser._ATTR_ISOLATED_ROW_KEY);
      
    // Add layer data objects
    var initSelections = [];
    var initDrilled = [];
    var styles = this._parseStyles(layers[i].getElementsByTagName(DvtThematicMapParser._ELEM_STYLES));
    var data = layers[i].getElementsByTagName(DvtThematicMapParser._ELEM_ROW);
    
    //Show popup behavior
    var spb = this._parseShowPopupBehavior(layers[i], styles);
    
    // Create dataobject using sytle id that matches
    for (var j = 0;j < data.length;j++) {
      var styleId = data[j].getAttr(DvtThematicMapParser._ATTR_STYLE_ID);
      var dataObj = this._parseDataObject(layer, dataLayer, id, data[j], styles[styleId], initSelections, initDrilled, isolatedRowKey);
      if (dataObj) {
        // Selection support
        var displayable = dataObj.getDisplayable();
        displayable.setSelectable(dataLayer.isSelectable() && !(dataObj instanceof DvtMapDataImage));
        
        //Show popup support
        if (spb.length > 0)
          dataObj.setShowPopupBehaviors(spb);
        if (dataObj instanceof DvtMapDataArea)
          dataLayer.addAreaObject(dataObj);
        else
          dataLayer.addDataObject(dataObj);
      }
    }
    
    // After processing all data objects we should have the area ID of the isolated area
    if (isolatedRowKey && this._isolatedArea) {
      dataLayer.setIsolatedAreaRowKey(isolatedRowKey);
      layer.setIsolatedArea(this._isolatedArea);
    }
    
    // Process initial data layer selections
    if (dataLayer.isSelectable() && initSelections.length > 0)
      dataLayer.setInitialSelections(initSelections);
    if (initDrilled.length > 0)
      this._tmap.addDrilledLayer(layer.getLayerName(), [dataLayer.getClientId(),initDrilled]);
    
    // If layer already exists, update
    if (pzcMatrix || layer.getDataLayer(dataLayer.getClientId()))
      layer.updateDataLayer(dataLayer, pzcMatrix, topLayerName);
    else
      layer.addDataLayer(dataLayer);
  }
}

DvtThematicMapParser.prototype.ParseLegend = function (xmlNode) {
  this._tmap.setLegendXml(xmlNode);
}

DvtThematicMapParser.prototype.ParseResources = function (xmlNode) {
  this._tmap.setResources(xmlNode);
}

/**
 * Parses and creates the map layers
 * @param {DvtXmlNode} xmlNode The xml node to parse
 * @protected
 */
DvtThematicMapParser.prototype.ParseMapHierarchy = function (xmlNode) {
  var layerNodes = xmlNode.getChildNodes();

  var baseMapName = this._tmap.getMapName();
  var layerName, labelDisplay, clientId, labelType, layer;

  for (var i = 0;i < layerNodes.length;i++) {
    var node = layerNodes[i];
    var nodeName = node.getName();

    if (nodeName != DvtThematicMapParser._ELEM_POINT_LAYER) {
      layerName = node.getAttr(DvtThematicMapParser._ATTR_LAYER_NAME);
      labelDisplay = node.getAttr(DvtThematicMapParser._ATTR_LABEL_DISPLAY);
      clientId = node.getAttr(DvtThematicMapParser._ATTR_CLIENT_ID);
      labelType = node.getAttr(DvtThematicMapParser._ATTR_LABEL_TYPE);

      // merge css set area layer styles with tag attribute set css area layer and area layer font styles
      var attr = node.getAttr('areaStyle');
      if (attr)
        this._areaLayerStyle.merge(new DvtCSSStyle(attr));  
      attr = node.getAttr(DvtThematicMapParser._ATTR_LABEL_STYLE);
      if (attr)
        this._areaLayerStyle.merge(new DvtCSSStyle(attr));

      if (this._isCustomBasemap) {
        layer = new DvtMapCustomAreaLayer(this._tmap, layerName, clientId, labelDisplay, labelType, this._tmap.getEventHandler());
      } else {
        layer = new DvtMapAreaLayer(this._tmap, layerName, clientId, labelDisplay, labelType, this._tmap.getEventHandler());
        var areaNames = DvtBaseMapManager.getAreaNames(baseMapName, layerName);
        layer.setAreaShapes(this._createPathShapes(areaNames));
        layer.setAreaNames(areaNames);
        layer.setAreaLabelInfo(DvtBaseMapManager.getAreaLabelInfo(baseMapName, layerName));
        layer.setAreaChildren(DvtBaseMapManager.getChildrenForLayerAreas(this._tmap.getMapName(), layerName));
        layer.setAreaHoverStyle(this._areaHoverStyle);
        layer.setAreaSelectStyle(this._areaSelectStyle);
        layer.setAreaDiscloseStyle(this._areaDiscloseStyle);
      }  
      layer.setLayerCSSStyle(this._areaLayerStyle);  
      layer.setDropSiteCSSStyle(this._areaDropSiteStyle);
        
      // Set Animation
      attr = node.getAttr(DvtThematicMapParser._ATTR_ANIM_ON_LAYER_CHANGE);
      if (attr) {
        var animDur = node.getAttr(DvtThematicMapParser._ATTR_ANIM_DUR);
        if (animDur)
          animDur = parseFloat(animDur);
        if (!animDur || isNaN(animDur)) 
          animDur = 1.0;
        layer.setAnimation(attr);
        layer.setAnimationDuration(animDur);
      }
      
      if (layer)
        this._tmap.addLayer(layer);
    }
  }
}

DvtThematicMapParser.prototype.ParseCustomBasemap = function (xmlNode) {
  var childNodes = xmlNode.getChildNodes();
  var node, nodeName;
  for (var i = 0;i < childNodes.length;i++) {
    node = childNodes[i];
    nodeName = node.getName();
    if (nodeName == DvtThematicMapParser._ELEM_LAYER)
      this._parseCustomLayer(node);
    else if (nodeName == DvtThematicMapParser._ELEM_POINTS)
      this._parseCustomPoints(node);
  }
}

DvtThematicMapParser.prototype._parseCustomLayer = function (xmlNode) {
  var childNodes = xmlNode.getChildNodes();
  var layerName = xmlNode.getAttr(DvtThematicMapParser.ATTR_ID);
  var node, nodeName;
  var images = [];
  for (var i = 0;i < childNodes.length;i++) {
    node = childNodes[i];
    nodeName = node.getName();
    // currently only images are supported
    if (nodeName == DvtThematicMapParser.ELEM_IMAGE) {
     var image = {};
     image['source'] = node.getAttr('source');
     image['width'] = node.getAttr('width');
     image['height'] = node.getAttr('height');
     var bidi = node.getAttr('bidi');
     var dir = node.getAttr('dir');
     // The bidi attribute is deprecated and dir="ltr/rtl" should be used instead.
     if (bidi == 'true' || dir == 'rtl')
       image['dir'] = 'rtl';
     else
       image['dir'] = 'ltr';
     images.push(image);
    }
  }
  var customLayer = this._tmap.getLayer(layerName);
  customLayer.setAreaLayerImage(images);
}

DvtThematicMapParser.prototype._parseCustomPoints = function (xmlNode) {
  var childNodes = xmlNode.getChildNodes();
  var node, nodeName;
  var points = {};
  var labels = {};
  for (var i = 0;i < childNodes.length;i++) {
    node = childNodes[i];
    nodeName = node.getName();
    if (nodeName == DvtThematicMapParser._ELEM_POINT) {
      points[node.getAttr('name')] = [node.getAttr('x'), node.getAttr('y')];
      labels[node.getAttr('name')] = [null, node.getAttr('longLabel')];
    }
  }
  // register points with base map manager
  // index will change once we allow more layers besides point
  DvtBaseMapManager.registerBaseMapLayer(this._tmap.getMapName(), 'cities', labels, points, null, null, 1);
}

DvtThematicMapParser.prototype.ParsePanZoomResources = function (xmlNode) {
  this._tmap.setPanZoomResources(xmlNode);
}

DvtThematicMapParser.prototype._createPathShapes = function(areaNames) {
  // create empty DvtPath objects as placeholders
  var shapes = {};
  var context = this._tmap.getCtx();
  for (var area in areaNames) {
    shapes[area] = new DvtPath(context);
    this._parseDataObjectFill(DvtThematicMapParser.ELEM_COLOR_STYLES, this._areaLayerStyle, shapes[area])
  }
  return shapes;
}

/**
 * Parses map attributes
 * @param {DvtXmlNode} xmlNode The xml node containing map attributes
 * @private
 */
DvtThematicMapParser.prototype._setMapProps = function (xmlNode) {
  var attr;

  //Basemap attributes
  attr = xmlNode.getAttr(DvtThematicMapParser._ATTR_SOURCE);
  if (attr)
    this._isCustomBasemap = true;
    
  attr = xmlNode.getAttr(DvtThematicMapParser._ATTR_BASEMAP_NAME);
  // prepend custom basemap name with a symbol so we don't overwrite built-in basemap data
  if (attr)
    this._tmap.setMapName(this._isCustomBasemap ? '$'+attr : attr);

  //Animation attributes
  attr = xmlNode.getAttr(DvtThematicMapParser._ATTR_ANIM_ON_DISP);
  if (attr)
    this._tmap.setAnimationOnDisplay(attr);
    
  attr = xmlNode.getAttr(DvtThematicMapParser._ATTR_ANIM_ON_MAP_CHANGE);
  if (attr)
    this._tmap.setAnimationOnMapChange(attr);
  
  attr = xmlNode.getAttr(DvtThematicMapParser._ATTR_ANIM_DUR);
  if (attr)
    this._tmap.setAnimationDuration(attr);
  
  //Tooltip behavior: auto, none, shortDescOnly
  attr = xmlNode.getAttr(DvtThematicMapParser._ATTR_TOOLTIP_DISPLAY);
  if (attr)
    this._tmap.setDisplayTooltips(attr);
    
  attr = xmlNode.getAttr(DvtThematicMapParser._ATTR_DROP_SITE_STYLE);
  if (attr)
    this._areaDropSiteStyle = new DvtCSSStyle(attr);

  //Control panel behavior: initExpanded, initCollapsed, hidden
  attr = xmlNode.getAttr(DvtThematicMapParser._ATTR_CTRLPANEL_BEHAVIOR);
  if (attr)
    this._tmap.setControlPanelBehavior(attr);

  attr = xmlNode.getAttr(DvtThematicMapParser._ATTR_FEATURES_OFF);
  if (attr)
    this._tmap.setFeaturesOff(attr);

  //For initial pan and zoom
  attr = xmlNode.getAttr(DvtThematicMapParser._ATTR_CENTER_X);
  if (attr)
    this._tmap.setInitialCenterX(attr);

  attr = xmlNode.getAttr(DvtThematicMapParser._ATTR_CENTER_Y);
  if (attr)
    this._tmap.setInitialCenterY(attr);

  attr = xmlNode.getAttr(DvtThematicMapParser._ATTR_CUR_ZOOM);
  if (attr)
    this._tmap.setInitialZoom(attr);
    
  //Drilling attributes
  attr = xmlNode.getAttr(DvtThematicMapParser._ATTR_ANIM_ON_DRILL);
  if (attr)
    this._tmap.setAnimationOnDrill(attr);

  attr = xmlNode.getAttr(DvtThematicMapParser._ATTR_DRILL_MODE);
  if (attr)
    this._tmap.setDrillMode(attr);

  attr = xmlNode.getAttr(DvtThematicMapParser._ATTR_DRILL_ZOOM_TO_FIT);
  if (attr)
    this._tmap.setDrillZoomToFit(attr);
  
  // Even if attributes aren't defined they
  attr = xmlNode.getAttr(DvtThematicMapParser._ATTR_INITIAL_ZOOMING);
  // initial zooming is set to false by default
  if (attr == 'auto')
    this._tmap.setInitialZooming(true);
  
  attr = xmlNode.getAttr(DvtThematicMapParser._ATTR_ZOOMING);
  // zooming is on by default
  if (attr == 'none')
    this._tmap.setZooming(false);
  
  attr = xmlNode.getAttr(DvtThematicMapParser._ATTR_PANNING);
  // panning is on by default
  if (attr == 'none')
    this._tmap.setPanning(false);
   
  attr = parseFloat(xmlNode.getAttr("maxZoom"));
  if (!isNaN(attr))
    this._tmap.setMaxZoomFactor(attr); 
    
  attr = xmlNode.getAttr("markerZoomBehavior");
  if (attr)
    this._tmap.setMarkerZoomBehavior(attr); 
}

DvtThematicMapParser.prototype._parseStyles = function (node) {
  var styles = new Object();
  if (node && node.length > 0) {
    var styleNodes = node[0].getChildNodes();
    for (var i = 0;i < styleNodes.length;i++) {
      var styleId = styleNodes[i].getAttr(DvtThematicMapParser.ATTR_ID);
      styles[styleId] = styleNodes[i];
    }
  }
  return styles;
}

DvtThematicMapParser.prototype._parseShowPopupBehavior = function (node, styles) {
  // Tmap allows alignId set to a marker, image, or area tag. Need to remove before creating the DvtShowPopupBehavior
  var spbNodes = node.getElementsByTagName(DvtThematicMapParser._ELEM_SPB);
  var spbs = new Array();
  for (var i = 0;i < spbNodes.length;i++) {
    var alignId = spbNodes[i].getAttr(DvtThematicMapParser._ATTR_ALIGN_ID);
    var popup = DvtShowPopupBehavior.newInstance(spbNodes[i]);
    for (var styleId in styles) {
      if (alignId == styleId) {
        popup = new DvtShowPopupBehavior(popup.getPopupId(), popup.getTriggerType(), null, popup.getAlign());
        break;
      }
    }
    spbs.push(popup);
  }
  return spbs;
}
 
 /**
  * Parses xml to create a map data object for a data layer
  * @param {DvtMapLayer} layer The map layer that this object belongs to
  * @param {DvtMapDataLayer} datalayer The data layer that this object belongs to
  * @param {String} layerName The name of the map layer that this data object belongs to
  * @param {DvtXmlNode} node The xml node containing details about this data object
  * @param {DvtXmlNode} style The xml node containing style details about this data object
  * @param {array} initSelections The array of ids for the currently selected objects
  * @param {array} initDrilled The array of ids for the currently drilled objects
  * @param {string} isolatedRowKey The row key of the isolated object
  * @return {DvtMapDataObject} The created map data object
  */
DvtThematicMapParser.prototype._parseDataObject = function (layer, dataLayer, layerName, node, style, initSelections, initDrilled, isolatedRowKey) {
  var context = this._tmap.getCtx();
  var id = node.getAttr(DvtThematicMapParser._ATTR_ROW_KEY);
  var clientId = node.getAttr(DvtThematicMapParser._ATTR_CLIENT_ID);
  var areaId = node.getAttr(DvtThematicMapParser.ATTR_ID);
  
  var dataObj;
  var styleType = style.getName();
  if (styleType == DvtThematicMapParser.ELEM_COLOR_STYLES) {//Data object is a DvtMapArea
    if (isolatedRowKey) {
      if (isolatedRowKey != id)
        return null;
      else 
        this._isolatedArea = areaId;
    }
    layer.setAreaRendered(areaId, false);
    dataObj = new DvtMapDataArea(context, dataLayer, id, clientId, areaId);
    this._parseMapArea(context, areaId, layer, node, dataObj);
  }
  else if (styleType == DvtThematicMapParser.ELEM_GRADUATED_SYMBOL) {//Data object is a DvtMapMarker
    dataObj = new DvtMapDataMarker(context, dataLayer, id, clientId, areaId);
    this._parseMapMarker(context, style, layerName, node, dataObj)
  }
  else if (styleType == DvtThematicMapParser.ELEM_IMAGE) {//Data object is a DvtMapImage
    dataObj = new DvtMapDataImage(context, dataLayer, id, clientId, areaId);
    this._parseMapImage(context, layerName, node, dataObj)
  }
  var displayable = dataObj.getDisplayable();
  if (!displayable) {
    return null;
  }
  var rotation = parseInt(node.getAttr('rotation'));
  if (rotation) {
    var radianRot = rotation*Math.PI/180;
    displayable.setRotation(radianRot);
    var center = dataObj.getCenter();
    // shape rotates around origin so need to find out current location after rotation and move back to the correct center
    displayable.setTranslate(center.x-(center.x*Math.cos(radianRot)-center.y*Math.sin(radianRot)), center.y-(center.x*Math.sin(radianRot)+center.y*Math.cos(radianRot)));
  }
  
  // disable labels in area layer if data layer exists and has labels
  if (areaId && layer instanceof DvtMapAreaLayer)
    layer.setLabelRendered(areaId, false);
  
  var hasAction = node.getAttr('hasAction') == 'true'; //TODO check actionListener
  dataObj.setHasAction(hasAction);
  if (hasAction)
    dataObj.setAction(node.getAttr('action'));
    
  var destination = node.getAttr('destination');
  if (destination) {
    var linkObj = [];
    linkObj["destination"] = destination;
    linkObj["targetFrame"] = "_blank";
    linkObj["focusable"] = true;
    displayable.setHyperlink(linkObj);
  }
  
  // Initially selected nodes
  var bSelected = node.getAttr('selected') == 'true';
  if (bSelected)
    initSelections.push(id);
    
  //Initially drilled nodes
  var bDrilled = node.getAttr('drilled') == 'true';
  if (bDrilled) {
    initDrilled.push(node.getAttr(DvtThematicMapParser.ATTR_ID));
    this._tmap.addDisclosedRowKey(id);
  }
  
  //Set label on data object
  var labelText = node.getAttr(DvtThematicMapParser._ATTR_LABEL);
  // assume label display is off unless label text is provided
  // for areas if no label is provided, we need to check if we should be using the area layer label
  var labelDisplay = 'off'; 
  if (labelText)
    labelDisplay = 'on';
  else if (styleType == DvtThematicMapParser.ELEM_COLOR_STYLES) 
    labelDisplay = layer.getLabelDisplay();
    
  // If object is a DvtMapDataArea see if label is provided, if not, use the DvtMapAreaLayer label type
  if (!labelText && areaId && labelDisplay != 'off')
    labelText = (layer.getLabelType() == 'long' ? layer.getLongAreaName(areaId) : layer.getShortAreaName(areaId));
    
  if (labelText) {
    var labelInfo;
    if(layer.getLabelInfoForArea) {
      labelInfo = layer.getLabelInfoForArea(areaId);
    }
    var label;
    if (labelInfo) {
      label = new DvtMapLabel(context, labelText, labelInfo, labelDisplay, dataLayer.getDataLabelContainer(), this._tmap.supportsVectorEffects());
    } else {
      if (styleType != DvtThematicMapParser.ELEM_COLOR_STYLES)  
        label = new DvtOutputText(context, labelText, 0, 0);
      else
        label = new DvtMapLabel(context, labelText, null, labelDisplay, dataLayer.getDataLabelContainer(), this._tmap.supportsVectorEffects());    
    }
    //BUG 14667560 we need to resolve label position in all cases
    var labelPosition = node.getAttr(DvtThematicMapParser._ATTR_LABEL_POSITION);
    if (labelPosition) {
      dataObj.setLabelPosition(labelPosition);
    }
    // add label style by merge styles sent from skin and tag
    var cssTextStyle = new DvtCSSStyle();
    if (styleType == DvtThematicMapParser.ELEM_COLOR_STYLES)
      cssTextStyle.merge(layer.getLayerCSSStyle());
    else if (styleType == DvtThematicMapParser.ELEM_GRADUATED_SYMBOL)
      cssTextStyle.merge(this._tmap.getMarkerStyle());
    var textStyle = node.getAttr(DvtThematicMapParser._ATTR_LABEL_STYLE);
    if (textStyle) {
      cssTextStyle.merge(new DvtCSSStyle(textStyle));
    }
    if (label instanceof DvtMapLabel) {// color label to contrast with data color
      if (!cssTextStyle.getStyle(DvtCSSStyle.COLOR))
        cssTextStyle.setStyle(DvtCSSStyle.COLOR, DvtColorUtils.getContrastingTextColor(dataObj.getDatatipColor()));
    }
    label.setCSSStyle(cssTextStyle);
  }

  dataObj.setLabel(label);
  
  // Set datatip
  var displayTooltips = this._tmap.getDisplayTooltips();
  if (displayTooltips != 'none') {
    var datatip = node.getAttr("shortDesc");
    if (displayTooltips == 'auto') {
      var preDatatip;
      // For data objects associated with supported areas or cities we prepend the area/city name before the datatip
      if (areaId) {
        if (layerName == 'cities' || this._isCustomBasemap)  // for AMX V1, custom basemaps only support points
          preDatatip = DvtBaseMapManager.getCityLabel(this._tmap.getMapName(), areaId);
        else
          preDatatip = DvtBaseMapManager.getLongAreaLabel(this._tmap.getMapName(),layerName,areaId)
      }
      if (preDatatip)
        datatip = (datatip ? preDatatip + ": " + datatip : preDatatip);
    }
    if (datatip)
      dataObj.setDatatip(datatip); 
  }

  return dataObj;
}

DvtThematicMapParser.prototype._parseCenter = function(layerName, node, isAreaMarker) {
  // We can get the coordiantes for a marker if they are:
  // 1) Passed in the xml
  // 2) A supported city
  // 3) A supported Area
  var mapName = this._tmap.getMapName();
  var areaId = node.getAttr(DvtThematicMapParser.ATTR_ID);
  if (areaId) {
    if (isAreaMarker)
      return DvtBaseMapManager.getAreaCenter(mapName, layerName, areaId);
    else
      return DvtBaseMapManager.getCityCoordinates(mapName, areaId);
  } else {
    var x = parseFloat(node.getAttr("x"));
    var y = parseFloat(node.getAttr("y"));
    return new DvtPoint(x, y);
  }
}

DvtThematicMapParser.prototype._parseMapImage = function (context, layerName, node, dataObj) {
  var source = node.getAttr("url");
  var image = null;  
  var isAreaMarker = layerName != 'cities';
  var center = this._parseCenter(layerName, node, isAreaMarker);
  
  if (!center) { // no city matching 
    return;
  } else {
    image = new DvtImage(context, source);
  }
  dataObj.setCenter(center);
  dataObj.setDisplayable(image);

  var width, height;
  //Get image dimensions via inlineStyle
  var inlineStyle = node.getAttr(DvtThematicMapParser._ATTR_INLINE_STYLE);
  if (inlineStyle) {
    var cssStyle = new DvtCSSStyle(inlineStyle);
    width = cssStyle.getStyle('width').substring(0, cssStyle.getStyle('width').indexOf('px'));
    if (width)
      image.setWidth(width);
    height = cssStyle.getStyle('height').substring(0, cssStyle.getStyle('height').indexOf('px'));
    if (height)
      image.setHeight(height);
    // set x/y only if both width and height are set, otherwise x/y will be set in the callback
    if (width != null && height != null) {
      image.setX(center.x-width/2);
      image.setY(center.y-height/2);
      dataObj.setSize(width*height);
    }
  }
  //If user does not specify image dimensions via inlineStyle then use the default image size.
  if (!width || !height) {
    DvtImageLoader.loadImage(context, source, DvtObj.createCallback(dataObj, dataObj.onImageLoaded));
  }
}

DvtThematicMapParser.prototype._parseMapArea = function (context, areaId, layer, node, dataObj) {  
  var areaShape = layer.getAreaShape(areaId);
  if (areaShape) {
    var cssStyle = new DvtCSSStyle(node.getAttr(DvtThematicMapParser._ATTR_INLINE_STYLE));
    // create an empty DvtPath for now and will set the cmd at render time
    var path = new DvtDrillablePath(context, this._tmap.supportsVectorEffects());
    var hoverStyle = layer.getAreaHoverStyle();
    var selectStyle = layer.getAreaSelectStyle();
    var discloseStyle = layer.getAreaDiscloseStyle();
    var hs = new DvtSolidStroke(hoverStyle.getStyle(DvtCSSStyle.BORDER_COLOR), 1, DvtDrillablePath.HOVER_STROKE_WIDTH);
    var sis = new DvtSolidStroke(selectStyle.getStyle(DvtCSSStyle.INNER_COLOR), 1, DvtDrillablePath.SELECTED_INNER_STROKE_WIDTH);
    var sos = new DvtSolidStroke(selectStyle.getStyle(DvtCSSStyle.OUTER_COLOR), 1, DvtDrillablePath.SELECTED_OUTER_STROKE_WIDTH);
    path.setHoverStroke(hs, null).setSelectedStroke(sis, sos);
    if (discloseStyle) {
      var dis = new DvtSolidStroke(discloseStyle.getStyle(DvtCSSStyle.INNER_COLOR), 1, DvtDrillablePath.DISCLOSED_INNER_STROKE_WIDTH);
      var dos = new DvtSolidStroke(discloseStyle.getStyle(DvtCSSStyle.OUTER_COLOR), 1, DvtDrillablePath.DISCLOSED_OUTER_STROKE_WIDTH);
      path.setDisclosedStroke(dis, dos);
    }
    dataObj.setDisplayable(path);
    this._parseDataObjectFill(DvtThematicMapParser.ELEM_COLOR_STYLES, cssStyle, path, dataObj);
  }
}

DvtThematicMapParser.prototype._parseMapMarker = function (context, style, layerName, node, dataObj) {
  var marker = null;
  var isAreaMarker = layerName != 'cities';
  var center = this._parseCenter(layerName, node, isAreaMarker);
  if (!center) // no city matching 
    return;
    
  var shapeType;
  var imgSrc = node.getAttr(DvtThematicMapParser._ATTR_SOURCE);
  // if marker image source is set, ignore the shape type value which is set for custom svg and built in markers
  if (imgSrc) {
    shapeType = [imgSrc, node.getAttr("sourceSelected"), node.getAttr("sourceHover"), node.getAttr("sourceHoverSelected")];
  } else {
    var shapeType = node.getAttr("shapeType");
    if (!shapeType)
      shapeType = DvtMapDataMarker.DEFAULT_MARKER_SHAPE;
    if (!DvtMarker.isBuiltInShape(shapeType)) {
      var markerDefs = style.getElementsByTagName(DvtThematicMapParser._ELEM_MARKER_DEF);
      for (var i=0; i<markerDefs.length; i++) {
        if (!this._customMarkerDefs[shapeType] && markerDefs[i].getAttr(DvtThematicMapParser.ATTR_ID) == shapeType)
          this._customMarkerDefs[shapeType] = DvtMarkerUtils.createMarkerDef(context, markerDefs[i]);
      }
    }
  }

  // Parse data object scales. Save original scale to maintain size despite zoom.
  var sx = node.getAttr("scaleX");
  if (isNaN(sx))
    sx = DvtMapDataMarker.DEFAULT_MARKER_SCALE;
  else
    sx = parseFloat(sx);
  
  var sy = node.getAttr("scaleY");
  if (isNaN(sy))
    sy = DvtMapDataMarker.DEFAULT_MARKER_SCALE;
  else
    sy = parseFloat(sy);
 
  var w = node.getAttr("width"); 
  var h = node.getAttr("height");
  
  if (!w || isNaN(w))
    w = DvtMapDataMarker.DEFAULT_MARKER_SIZE;
  else
    w = parseInt(w);
    
  if (!h || isNaN(h))
    h = DvtMapDataMarker.DEFAULT_MARKER_SIZE;
  else
    h = parseInt(h);

  var x, y;
   
  x = center.x - ((w*sx)/2);
  y = center.y - ((h*sy)/2);
  
  // id is used for custom marker definition lookup
  marker = new DvtMarker(context, shapeType, this._tmap.getSkinName(), x, y, w, h, null, sx, sy);
  dataObj.setCenter(center);
  dataObj.setDisplayable(marker);
  dataObj.setSize(w*sx*h*sy);
  
  var inlineStyle = node.getAttr(DvtThematicMapParser._ATTR_INLINE_STYLE);
  if (inlineStyle) {
    var cssStyle = new DvtCSSStyle(inlineStyle);
    this._parseDataObjectFill(DvtThematicMapParser.ELEM_GRADUATED_SYMBOL, cssStyle, marker, dataObj);
  }
  
  //  marker.addCategory(strShapeType);
//  if (data && data['hideAttrColor']) {
//    marker.addCategory(data['hideAttrColor'])
//    marker.addCategory(strShapeType + ',' + data['hideAttrColor']);
//  }
}

/**
 * Styles a DvtMapDataObject displayable
 * @param {string} styleType The data object type (image, marker, area)
 * @param {DvtCSSStyle} cssStyle The css style to use for object styling
 * @param {DvtShape} displayable The shape to style
 * @param {DvtMapDataObject} The map data object
 */
DvtThematicMapParser.prototype._parseDataObjectFill = function(styleType, cssStyle, displayable, dataObj) {
  if (!cssStyle)
    cssStyle = {};
  var pattern = cssStyle.getStyle('pattern');
  var patternColor = cssStyle.getStyle('pattern-color');
  var backgroundColor = cssStyle.getStyle('background-color');
  var gradient = (this._isMobile || this._tmap.getSkinName() == DvtCSSStyle.SKIN_ALTA) ? false : cssStyle.getStyle('gradient');
  
  if (backgroundColor && dataObj)
    dataObj.addCategory(backgroundColor);
  else if (patternColor && dataObj)
    dataObj.addCategory(patternColor);
  
  var opacity;
  if (cssStyle.getStyle('opacity')) {
    opacity = parseFloat(cssStyle.getStyle('opacity'));
  } else {
    if (styleType == DvtThematicMapParser.ELEM_GRADUATED_SYMBOL) 
      opacity = DvtMapDataMarker.DEFAULT_MARKER_ALPHA;
    else
      opacity = 1;
  }
  
  if (dataObj)  
    dataObj.setDatatipColor(backgroundColor ? backgroundColor : patternColor);
  
  // handle custom svg where color is set by user
  if (styleType == DvtThematicMapParser.ELEM_GRADUATED_SYMBOL && DvtMarker.isBuiltInShape(displayable.getType())) {
    var markerStyle = this._tmap.getMarkerStyle();
    var strokeStyle = cssStyle.getStyle('border-style') ? cssStyle.getStyle('border-style') : markerStyle.getStyle('border-style');
    if (strokeStyle != 'none') {
      var strokeColor = cssStyle.getStyle('border-color') ? cssStyle.getStyle('border-color') : markerStyle.getStyle('border-color');
      var strokeWidth = cssStyle.getStyle('border-width') ? cssStyle.getStyle('border-width') : markerStyle.getStyle('border-width');
      if (strokeWidth)
        strokeWidth = parseFloat(strokeWidth.substring(0, strokeWidth.indexOf('px')));
      var stroke = new DvtSolidStroke(strokeColor, DvtMapDataMarker.DEFAULT_MARKER_ALPHA, strokeWidth);
      if (!this._tmap.isMarkerZoomBehaviorFixed())
        stroke.setFixedWidth(true);
      displayable.setStroke(stroke);
    }
    
    if (gradient == 'true' && backgroundColor)
      displayable.setFill(new DvtMarkerGradient.createMarkerGradient(backgroundColor, displayable, opacity));
    else if (pattern)
      displayable.setFill(new DvtPatternFill(pattern, patternColor, backgroundColor));
    else if (backgroundColor)
      displayable.setSolidFill(backgroundColor, opacity);  
    else
      displayable.setSolidFill(markerStyle.getStyle('background-color'), opacity);
  } 
  else if (styleType == DvtThematicMapParser.ELEM_COLOR_STYLES) {  
    var borderColor = cssStyle.getStyle('border-color');
    if (borderColor && borderColor != 'transparent') {
      var stroke = new DvtSolidStroke(borderColor);
      if (this._tmap.supportsVectorEffects())
        stroke.setFixedWidth(true);
      displayable.setStroke(stroke);
    }
    
    if (pattern)
      displayable.savePatternFill(new DvtPatternFill(pattern, patternColor, backgroundColor));
    else if (backgroundColor && backgroundColor != 'transparent')
      displayable.setSolidFill(backgroundColor, opacity);
    else
      displayable.setFill(null);
      
  } 
}
// Copyright (c) 2011, 2014, Oracle and/or its affiliates. All rights reserved.
/**
 * Thematic Map JSON parser
 * @param {DvtThematicMap} tmap The thematic map to update
 * @constructor
 */
var DvtThematicMapJsonParser = function (tmap) {
  this.Init(tmap);
}

DvtObj.createSubclass(DvtThematicMapJsonParser, DvtObj, "DvtThematicMapJsonParser");

/**
 * Initializes this thematic map JSON parser
 * @param {DvtThematicMap} tmap The thematic map to update
 */
DvtThematicMapJsonParser.prototype.Init = function (tmap) {
  this._tmap = tmap;
  this._isCustomBasemap = false;
  this._areaLayerStyle = null;
  this._isMobile = DvtAgent.isTouchDevice();
  this._customAreaLayerImages = {};
}

/**
 * Parses a JSON object containing map attributes and data 
 * @param {Object} options The JSON object to parse
 */
DvtThematicMapJsonParser.prototype.parse = function (options) {
  options['skin'] = 'alta';
  this.ParseMapProperties(options);
  this.ParseStyles(options['styleDefaults']);
    // temporary code until JSON API approved for custom basemap
  if (this._isCustomBasemap) {
    var xmlParser = new DvtXmlParser(this._tmap.getCtx());
    var xmlNode = xmlParser.parse(options['sourceXml']);
    if (xmlNode)
        this.ParseCustomBasemap(xmlNode);
  }
  this.ParseAreaLayers(options['areaLayers']);
  this.ParseDataLayers(options['pointDataLayers'], null, false);
}

/**
 * Parses a JSON object containing map attributes 
 * @param {Object} options The JSON object to parse
 * @protected
 */
DvtThematicMapJsonParser.prototype.ParseMapProperties = function (options) {
  this._tmap.setAnimationDuration(options['animationDuration']/1000);
  this._tmap.setAnimationOnDisplay(options['animationOnDisplay'] == 'auto' ? 'alphaFade' : options['animationOnDisplay']);
  this._tmap.setAnimationOnMapChange(options['animationOnMapChange'] == 'auto' ? 'alphaFade' : options['animationOnMapChange']);
  
  this._isCustomBasemap = options['source'] != null;
  // prepend custom basemap name with a symbol so we don't overwrite built-in basemap data
  this._tmap.setMapName(this._isCustomBasemap ? '$'+options['basemap'] : options['basemap']);
  
  // No control panel for first json tmap release
  this._tmap.setControlPanelBehavior(options['controlPanelBehavior']);
  // No drilling for first json tmap release
  this._tmap.setDrillMode('none');
  this._tmap.setInitialZooming(options['initialZooming'] == 'auto');
  this._tmap.setMarkerZoomBehavior(options['markerZoomBehavior']); 
  this._tmap.setPanning(options['panning'] == 'auto');
  var tooltipDisplay = options['tooltipDisplay'];
  if (tooltipDisplay == 'shortDesc')
    tooltipDisplay = 'shortDescOnly';
  else if (tooltipDisplay == 'labelAndShortDesc')
    tooltipDisplay = 'auto';
  this._tmap.setDisplayTooltips(tooltipDisplay);
  this._tmap.setZooming(options['zooming'] == 'auto');
}

/**
 * Parses a JSON object containing map area layer attributes and data
 * @param {Object} areaLayers The JSON object to parse
 * @protected
 */
DvtThematicMapJsonParser.prototype.ParseAreaLayers = function (areaLayers) {
  var basemap = this._tmap.getMapName();
  for (var i = 0;i < areaLayers.length;i++) {
    var areaLayer = this._tmap.Defaults.calcAreaLayerOptions(areaLayers[i]);
    var layer = areaLayer['layer'];
    if (!layer)
      continue;

    var mapLayer;
    if (areaLayer['areaStyle'])
      this._areaLayerStyle.parseInlineStyle(areaLayer['areaStyle']);
    
    if (this._isCustomBasemap) {
      mapLayer = new DvtMapCustomAreaLayer(this._tmap, layer, null, areaLayer['labelDisplay'], areaLayer['labelType'], this._tmap.getEventHandler());
      mapLayer.setAreaLayerImage(this._customAreaLayerImages[layer]);
    } else {
      mapLayer = new DvtMapAreaLayer(this._tmap, layer, null, areaLayer['labelDisplay'], areaLayer['labelType'], this._tmap.getEventHandler());
      var areaNames = DvtBaseMapManager.getAreaNames(basemap, layer);
      mapLayer.setAreaShapes(this._createPathShapes(areaNames));
      mapLayer.setAreaNames(areaNames);
      mapLayer.setAreaLabelInfo(DvtBaseMapManager.getAreaLabelInfo(basemap, layer));
      mapLayer.setAreaChildren(DvtBaseMapManager.getChildrenForLayerAreas(this._tmap.getMapName(), layer));
    }
    mapLayer.setLayerCSSStyle(this._areaLayerStyle);
          
    mapLayer.setAnimation(areaLayer['animationOnLayerChange'] == 'auto' ? 'alphaFade' : areaLayer['animationOnLayerChange']);
    mapLayer.setAnimationDuration(this._tmap.getAnimationDuration());
    
    this._tmap.addLayer(mapLayer);
    // parse data layers
    if (areaLayer['areaDataLayer'])
      this.ParseDataLayers([areaLayer['areaDataLayer']], mapLayer, true);
    if (areaLayer['pointDataLayers'])
      this.ParseDataLayers(areaLayer['pointDataLayers'], mapLayer, false);
  }
}

/**
 * Parses JSON objects containing map data layer attributes and data
 * @param {Array} dataLayers An array of data layer JSON objects to parse
 * @param {DvtMapLayer} parentLayer The parent map layer this data layer belongs to
 * @param {boolean} isAreaDataLayer Whether a data layer is an area data layer
 * @protected
 */
DvtThematicMapJsonParser.prototype.ParseDataLayers = function (dataLayers, parentLayer, isAreaDataLayer) {
  if (!dataLayers)
    return;
  
  for (var i = 0;i < dataLayers.length;i++) {
    var dataLayerOptions = this._tmap.Defaults.calcDataLayerOptions(dataLayers[i]);
    if (parentLayer) {
      if (parentLayer instanceof DvtMapAreaLayer)
        parentLayer.resetRenderedAreas();
    } else {
      parentLayer = new DvtMapLayer(this._tmap, this._tmap.getEventHandler());
      this._tmap.addPointLayer(parentLayer);
    }
    var dataLayer = new DvtMapDataLayer(this._tmap, parentLayer, dataLayerOptions['id'], this._tmap.getEventHandler());
  
    var selectionMode = dataLayerOptions['selection'];
    if (selectionMode == 'single')
      dataLayer.setSelectionMode(DvtSelectionHandler.TYPE_SINGLE);
    else if (selectionMode == 'multiple')
      dataLayer.setSelectionMode(DvtSelectionHandler.TYPE_MULTIPLE);

    dataLayer.setAnimation(dataLayerOptions['animationOnDataChange'] == 'auto' ? 'alphaFade' : dataLayerOptions['animationOnDataChange']);
    dataLayer.setAnimationDuration(this._tmap.getAnimationDuration());
    
    //Add initially isolated area
    var isolatedRowKey = null;
    if (parentLayer instanceof DvtMapAreaLayer)
      isolatedRowKey = dataLayerOptions['isolatedItem'];
    
    var disclosedItems = dataLayerOptions['disclosedItems'];
    var initDisclosed = [];
    var isolatedAreaId;
    // Parse data objects
    var areas = dataLayerOptions['areas'];
    if (areas) {
      for (var j = 0;j < areas.length;j++) {
        var areaId = areas[j]['location'];
        
        if (isolatedRowKey) {
          if (isolatedRowKey != areas[j]['id'])
            continue;
          else
            isolatedAreaId = areaId;
        }
          
        if (disclosedItems && disclosedItems.indexOf(areas[j]['id']) != -1)
          initDisclosed.push(areaId);
          
        var dataObj = this._parseMapArea(parentLayer, dataLayer, areas[j]);
        if (dataObj) {
          // Selection support
          if (dataLayer.isSelectable()) {
            var displayable = dataObj.getDisplayable();
            displayable.setSelectable(true);
          }
          dataLayer.addAreaObject(dataObj);
        }
      }
    }
    
    var markers = dataLayerOptions['markers'];
    if (markers) {
      for (var j = 0;j < markers.length;j++) {
        var areaId = markers[j]['location'];
        
        if (isAreaDataLayer && isolatedRowKey) {
          if (isolatedRowKey != markers[j]['id'])
            continue;
          else
            isolatedAreaId = areaId;
        }
          
        var dataObj = this._parseMapMarker(parentLayer, dataLayer, markers[j], isAreaDataLayer);
        if (dataObj) {
          // Selection support
          if (dataLayer.isSelectable()) {
            var displayable = dataObj.getDisplayable();
            displayable.setSelectable(true);
          }
          dataLayer.addDataObject(dataObj);
        }
      }
    }
    
    // After processing all data objects we should have the area ID of the isolated area
    if (isolatedAreaId) {
      dataLayer.setIsolatedAreaRowKey(isolatedRowKey);
      parentLayer.setIsolatedArea(isolatedAreaId);
    }
    
    // Process initial data layer selections
    var initSelections = dataLayerOptions['selectedItems'];
    if (initSelections && initSelections.length > 0)
      dataLayer.setInitialSelections(initSelections);
      
    if (initDisclosed && initDisclosed.length > 0)
      this._tmap.addDrilledLayer(parentLayer.getLayerName(), [dataLayer.getClientId(), initDisclosed]);
      
    parentLayer.addDataLayer(dataLayer);
  }
}

//DvtThematicMapJsonParser.prototype.ParseResources = function (xmlNode) {
//  this._tmap.setButtonImages(xmlNode);
//}

/**
 * Parses a JSON object containing style defaults
 * @param {Object} styles The style default JSON object
 * @protected
 */
DvtThematicMapJsonParser.prototype.ParseStyles = function (styles) {
  this._areaLayerStyle = new DvtCSSStyle(styles['areaStyle']+styles['labelStyle']);
  this._tmap.setComponentStyle(new DvtCSSStyle('fill-type:solid;background-color:'+styles['backgroundColor']));
  this._tmap.setStyleDefaults(styles);
}

/**
 * Temporary method for parsing custom basemap xml for AMX and ADF until JET JSON API is approved.
 * @param {DvtXmlNode} xmlNode The xml node containing custom basemap metadata
 */
DvtThematicMapJsonParser.prototype.ParseCustomBasemap = function (xmlNode) {
  var childNodes = xmlNode.getChildNodes();
  var node, nodeName;
  for (var i = 0;i < childNodes.length;i++) {
    node = childNodes[i];
    nodeName = node.getName();
    if (nodeName == DvtThematicMapParser._ELEM_LAYER)
      this._parseCustomLayer(node);
    else if (nodeName == DvtThematicMapParser._ELEM_POINTS)
      this._parseCustomPoints(node);
  }
}

/**
 * Temporary method for parsing custom basemap xml for AMX and ADF until JET JSON API is approved.
 * @param {DvtXmlNode} xmlNode The xml node containing custom layer metadata
 * @private
 */
DvtThematicMapJsonParser.prototype._parseCustomLayer = function (xmlNode) {
  var childNodes = xmlNode.getChildNodes();
  var layerName = xmlNode.getAttr(DvtThematicMapParser.ATTR_ID);
  var node, nodeName;
  var images = [];
  for (var i = 0;i < childNodes.length;i++) {
    node = childNodes[i];
    nodeName = node.getName();
    // currently only images are supported
    if (nodeName == DvtThematicMapParser.ELEM_IMAGE) {
     var image = {};
     image['source'] = node.getAttr('source');
     image['width'] = node.getAttr('width');
     image['height'] = node.getAttr('height');
     var bidi = node.getAttr('bidi');
     var dir = node.getAttr('dir');
     // The bidi attribute is deprecated and dir="ltr/rtl" should be used instead.
     if (bidi == 'true' || dir == 'rtl')
       image['dir'] = 'rtl';
     else
       image['dir'] = 'ltr';
     images.push(image);
    }
  }
  this._customAreaLayerImages[layerName] = images;
}

/**
 * Temporary method for parsing custom basemap xml for AMX and ADF until JET JSON API is approved.
 * @param {DvtXmlNode} xmlNode The xml node containing custom points metadata
 * @private
 */
DvtThematicMapJsonParser.prototype._parseCustomPoints = function (xmlNode) {
  var childNodes = xmlNode.getChildNodes();
  var node, nodeName;
  var points = {};
  var labels = {};
  for (var i = 0;i < childNodes.length;i++) {
    node = childNodes[i];
    nodeName = node.getName();
    if (nodeName == DvtThematicMapParser._ELEM_POINT) {
      points[node.getAttr('name')] = [node.getAttr('x'), node.getAttr('y')];
      labels[node.getAttr('name')] = [null, node.getAttr('longLabel')];
    }
  }
  // register points with base map manager
  // index will change once we allow more layers besides point
  DvtBaseMapManager.registerBaseMapLayer(this._tmap.getMapName(), 'cities', labels, points, null, null, 1);
}

/**
 * Creates a map of area displayables for an area layer
 * @return {Object} Area id and path object map for an area layer
 * @private
 */
DvtThematicMapJsonParser.prototype._createPathShapes = function(areaNames) {
  // create empty DvtPath objects as placeholders
  var shapes = {};
  var context = this._tmap.getCtx();
  for (var area in areaNames) {
    shapes[area] = new DvtPath(context);
    this._styleDisplayable(this._areaLayerStyle, shapes[area]);
  }
  return shapes;
}

/**
 * Creates a DvtMapDataArea
 * @param {DvtMapLayer} layer The map layer this data object belongs to
 * @param {DvtMapDataLayer} dataLayer The data layer this data object belongs to
 * @param {Object} data The JSON object containing data object attributes
 * @return {DvtMapDataArea} The data object
 */
DvtThematicMapJsonParser.prototype._parseMapArea = function (layer, dataLayer, data) {
  var areaId = data['location'];
  var areaShape = layer.getAreaShape(areaId);
  // only render data area if we have the path info for it and if it has a data color
  if (areaShape && data['color']) {
    // create an empty DvtPath for now and will set the cmd at render time
    layer.setAreaRendered(areaId, false);  
    var context = this._tmap.getCtx();
    var path = new DvtDrillablePath(context, this._tmap.supportsVectorEffects());
    
    data = DvtJSONUtils.merge(data, this._tmap.getStyleDefaults()['dataAreaDefaults']);
    if (!data['labelStyle'])
      data['labelStyle'] = this._tmap.getStyleDefaults()['labelStyle'];
  
    var hs = new DvtSolidStroke(data['hoverColor'], 1, DvtDrillablePath.HOVER_STROKE_WIDTH);
    var sis = new DvtSolidStroke(data['selectedInnerColor'], 1, DvtDrillablePath.SELECTED_INNER_STROKE_WIDTH);
    var sos = new DvtSolidStroke(data['selectedOuterColor'], 1, DvtDrillablePath.SELECTED_OUTER_STROKE_WIDTH);
    path.setHoverStroke(hs, null).setSelectedStroke(sis, sos);
    var dis = new DvtSolidStroke(data['drilledInnerColor'], 1, DvtDrillablePath.DISCLOSED_INNER_STROKE_WIDTH);
    var dos = new DvtSolidStroke(data['drilledOuterColor'], 1, DvtDrillablePath.DISCLOSED_OUTER_STROKE_WIDTH);
    path.setDisclosedStroke(dis, dos);
  
    var dataObj = new DvtMapDataArea(context, dataLayer, data['id'], null, areaId);
    dataObj.setDisplayable(path);
    this._parseCommonData(layer, dataLayer, data, path, dataObj, true);
    return dataObj;
  }
  return null;
}

/**
 * Creates a DvtMapDataMarker
 * @param {DvtMapLayer} layer The map layer this data object belongs to
 * @param {DvtMapDataLayer} dataLayer The data layer this data object belongs to
 * @param {Object} data The JSON object containing data object attributes
 * @return {DvtMapDataMarker} The data object
 */
DvtThematicMapJsonParser.prototype._parseMapMarker = function (layer, dataLayer, data, isParentAreaDataLayer) {
  var center = this._getCenter(layer.getLayerName(), data, isParentAreaDataLayer);
  if (!center) // no matching city
    return null;
  
  var context = this._tmap.getCtx();
  var areaId = data['location'];
  dataObj = new DvtMapDataMarker(context, dataLayer, data['id'], null, areaId);
  dataObj.setCenter(center);
  
  data = DvtJSONUtils.merge(data, this._tmap.getStyleDefaults()['dataMarkerDefaults']);
  
  var shapeType;
  var imgSrc = data['source'];
  // if marker image source is set, ignore the shape type value which is set for custom svg and built in markers
  if (imgSrc) {
    shapeType = [imgSrc, data['sourceSelected'], data['sourceHover'], data['sourceHoverSelected']];
  } else {
    var shapeType = data['shape'];
    if (!shapeType)
      shapeType = DvtMapDataMarker.DEFAULT_MARKER_SHAPE;
     // TODO handle custom markers
  }

  // Parse data object scales. Save original scale to maintain size despite zoom.
  var sx = data['scaleX'];
  if (isNaN(sx))
    sx = DvtMapDataMarker.DEFAULT_MARKER_SCALE;
  
  var sy = data['scaleY'];
  if (isNaN(sy))
    sy = DvtMapDataMarker.DEFAULT_MARKER_SCALE;
 
  var w = data['width'];
  var h = data['height'];
  
  if (!w || isNaN(w))
    w = DvtMapDataMarker.DEFAULT_MARKER_SIZE;
    
  if (!h || isNaN(h))
    h = DvtMapDataMarker.DEFAULT_MARKER_SIZE;

  var x, y;
  x = center.x - ((w*sx)/2);
  y = center.y - ((h*sy)/2);
  
  // id is used for custom marker definition lookup
  marker = new DvtMarker(context, shapeType, 'alta', x, y, w, h, null, sx, sy);
  dataObj.setDisplayable(marker);
  dataObj.setSize(w*sx*h*sy);
  
  dataObj.setLabelPosition(data['labelPosition']);
  
  var rotation = data['rotation'];
  if (rotation) {
    var radianRot = rotation*Math.PI/180;
    marker.setRotation(radianRot);
    var center = dataObj.getCenter();
    // shape rotates around origin so need to find out current location after rotation and move back to the correct center
    marker.setTranslate(center.x-(center.x*Math.cos(radianRot)-center.y*Math.sin(radianRot)), center.y-(center.x*Math.sin(radianRot)+center.y*Math.cos(radianRot)));
  }
  
  this._parseCommonData(layer, dataLayer, data, marker, dataObj, isParentAreaDataLayer);
  return dataObj;
}

/**
 * Parses attributes common amonst all data objects
 * @param {DvtMapLayer} layer
 * @param {DvtMapDataLayer} dataLayer
 * @param {Object} data The json object for the data object
 * @param {DvtMapDataObject} dataObj
 * @private
 */
DvtThematicMapJsonParser.prototype._parseCommonData = function (layer, dataLayer, data, displayable, dataObj, isParentAreaDataLayer) {
  var areaId = data['location'];
  
  // disable labels in area layer if data layer exists and has label
  if (isParentAreaDataLayer && layer.getLabelDisplay() == 'auto')
    layer.setLabelRendered(areaId, false);
  
  if (data['action']) {
    dataObj.setHasAction(true);
    dataObj.setAction(data['action']);
  }
  
  var destination = data['destination'];
  if (destination) {
    var linkObj = [];
    linkObj["destination"] = destination;
    linkObj["targetFrame"] = "_blank";
    linkObj["focusable"] = true;
    displayable.setHyperlink(linkObj);
  }
  
  this._setDatatip(layer, dataLayer, data, dataObj, isParentAreaDataLayer);
  var cssStyle = new DvtCSSStyle();
  cssStyle.setStyle('background-color', data['color']);
  cssStyle.setStyle('pattern', data['pattern']);
  cssStyle.setStyle('border-color', data['borderColor']);
  cssStyle.setStyle('border-style', data['borderStyle']);
  if (data['borderWidth'])
    cssStyle.setStyle('border-width', data['borderWidth']);  
  cssStyle.setStyle('opacity', data['opacity']);
  this._styleDisplayable(cssStyle, displayable, dataObj);
  this._setLabel(layer, dataLayer, data, dataObj, isParentAreaDataLayer);
}

/**
 * Sets a label for a map data object
 * @param {DvtMapLayer} layer The map layer the data object belongs to
 * @param {DvtMapDataLayer} dataLayer The data layer the data object belongs to
 * @param {Object} data The JSON object containing label attributes
 * @param {DvtMapDataObject} dataObj The data object to set the label on
 * @param {boolean} isParentAreaDataLayer Whether the parent layer is an area data layer
 * @private
 */
DvtThematicMapJsonParser.prototype._setLabel = function(layer, dataLayer, data, dataObj, isParentAreaDataLayer) {
  var areaId = data['location'];
  var labelText = data['label'];
  // if data label is provided, assume label display is on and if is from an area data layer, use area layer's label display 
  var labelDisplay = labelText ? 'on' : 'off';
  if (isParentAreaDataLayer) 
    labelDisplay = layer.getLabelDisplay();

  // If object is a DvtMapDataArea see if label is provided, if not, use the DvtMapAreaLayer label type
  if (!labelText && (dataObj instanceof DvtMapDataArea) && labelDisplay != 'off')
    labelText = (layer.getLabelType() == 'long' ? layer.getLongAreaName(areaId) : layer.getShortAreaName(areaId));
    
  if (labelText) {
    var context = this._tmap.getCtx();
    var label;
    if (dataObj instanceof DvtMapDataMarker)
      label = new DvtOutputText(context, labelText, 0, 0);
    else
      label = new DvtMapLabel(context, labelText, layer.getLabelInfoForArea ? layer.getLabelInfoForArea(areaId) : null, 
                              labelDisplay, dataLayer.getDataLabelContainer(), this._tmap.supportsVectorEffects());

    var labelStyle = new DvtCSSStyle(data['labelStyle']);
    if (label instanceof DvtMapLabel) {// color label to contrast with data color
        if (!labelStyle.getStyle(DvtCSSStyle.COLOR))
          labelStyle.setStyle(DvtCSSStyle.COLOR, DvtColorUtils.getContrastingTextColor(dataObj.getDatatipColor()));
    }
    label.setCSSStyle(labelStyle);
  }

  dataObj.setLabel(label);
}

/**
 * Sets a datatip for a map data object
 * @param {DvtMapLayer} layer The map layer the data object belongs to
 * @param {DvtMapDataLayer} dataLayer The data layer the data object belongs to
 * @param {Object} data The JSON object containing datatip attributes
 * @param {DvtMapDataObject} dataObj The data object to set the label on
 * @param {boolean} isParentAreaDataLayer Whether the parent layer is an area data layer
 * @private
 */
DvtThematicMapJsonParser.prototype._setDatatip = function(layer, dataLayer, data, dataObj, isParentAreaDataLayer) {
  var displayTooltips = this._tmap.getDisplayTooltips();
  if (displayTooltips != 'none') {
    var datatip = data["shortDesc"];
    if (displayTooltips == 'auto') {
      var preDatatip;
      var areaId = data['location'];
      // For data objects associated with supported areas or cities we prepend the area/city name before the datatip
      if (areaId) {
        if (!isParentAreaDataLayer || this._isCustomBasemap)  // for AMX V1, custom basemaps only support points
          preDatatip = DvtBaseMapManager.getCityLabel(this._tmap.getMapName(), areaId);
        else
          preDatatip = DvtBaseMapManager.getLongAreaLabel(this._tmap.getMapName(),layer.getLayerName(),areaId)
      }
      if (preDatatip)
        datatip = (datatip ? preDatatip + ": " + datatip : preDatatip);
    }
    if (datatip)
      dataObj.setDatatip(datatip); 
  }
}

/**
 * Styles a map data object's displayable
 * @param {DvtCSSStyle} cssStyle The css style object to style the displayable with
 * @param {DvtDisplayable} displayable The displayable to style
 * @param {DvtMapDataObject} dataObj The displayable's data object
 * @private
 */
DvtThematicMapJsonParser.prototype._styleDisplayable = function(cssStyle, displayable, dataObj) {
  // TODO take json isntead of DvtCSSStyle once we switch ADF over and area layer style doesn't need to be a DvtCSSStyle
  if (!cssStyle)
    cssStyle = {};
  var pattern = cssStyle.getStyle('pattern');
  var backgroundColor = cssStyle.getStyle('background-color');
  var gradient = false; // only adf supports graident
  
  
  if (dataObj)  
    dataObj.setDatatipColor(backgroundColor);
    
  // handle custom svg where color is set by user
  if (displayable instanceof DvtMarker && DvtMarker.isBuiltInShape(displayable.getType())) {
    if (cssStyle.getStyle('border-style') != 'none') {
      var stroke = new DvtSolidStroke(cssStyle.getStyle('border-color'), DvtMapDataMarker.DEFAULT_MARKER_ALPHA, cssStyle.getStyle('border-width'));
      if (!this._tmap.isMarkerZoomBehaviorFixed())
        stroke.setFixedWidth(true);
      displayable.setStroke(stroke);
    }
                  
    var opacity = cssStyle.getStyle('opacity');                
    if (gradient == 'true' && backgroundColor)
      displayable.setFill(new DvtMarkerGradient.createMarkerGradient(backgroundColor, displayable, opacity));
    else if (pattern)
      displayable.setFill(new DvtPatternFill(pattern, backgroundColor, '#FFFFFF'));
    else if (backgroundColor)
      displayable.setSolidFill(backgroundColor, opacity);  
    else
      displayable.setSolidFill(cssStyle.getStyle('background-color'), opacity);
  } 
  else if (displayable instanceof DvtPath) {  
    var borderColor = cssStyle.getStyle('border-color');
    if (borderColor && borderColor != 'transparent') {
      var stroke = new DvtSolidStroke(borderColor);
      if (this._tmap.supportsVectorEffects())
        stroke.setFixedWidth(true);
      displayable.setStroke(stroke);
    }
    
    if (pattern)
      displayable.savePatternFill(new DvtPatternFill(pattern, backgroundColor, '#FFFFFF'));
    else if (backgroundColor != 'transparent')
      displayable.setSolidFill(backgroundColor, opacity);
    else //TODO set on area layer instead
      displayable.setFill(null);
  } 
}

/**
 * Retrieves the x/y coordinates for this data object if they exist
 * @param {String} layerName The map area layer name to look up coordinate data from
 * @param {Object} data The JSON object containing data object info
 * @param {boolean} isAreaMarker Whether the data object is an area marker
 * @private
 */
DvtThematicMapJsonParser.prototype._getCenter = function(layerName, data, isAreaMarker) {
  // We can get the coordiantes for a marker if they are:
  // 1) Passed in the xml
  // 2) A supported city
  // 3) A supported Area
  var mapName = this._tmap.getMapName();
  var areaId = data['location'];
  if (areaId) {
    if (isAreaMarker)
      return DvtBaseMapManager.getAreaCenter(mapName, layerName, areaId);
    else
      return DvtBaseMapManager.getCityCoordinates(mapName, areaId);
  } else {
    return DvtThematicMapProjections.project(data['x'], data['y'], this._tmap.getMapName());
  }
}
var DvtThematicMapProjections = {
};

DvtObj.createSubclass(DvtThematicMapProjections, DvtObj, "DvtThematicMapProjections");

DvtThematicMapProjections._VIEWPORT_BOUNDS = new DvtRectangle(0, 0, 800, 500);
DvtThematicMapProjections._RADIUS = 6378206.4;

DvtThematicMapProjections._NEW_ZEALAND_RECT = new DvtRectangle(500, 200, 200, 200);
DvtThematicMapProjections._NEW_ZEALAND_BOUNDS = new DvtRectangle(163,  - 49, 17, 17);
DvtThematicMapProjections._AFRICA_BOUNDS = new DvtRectangle( - 17.379205428479874,  - 37.201510854305546, 68.66391442808313, 77.50071544582713);
DvtThematicMapProjections._ASIA_BOUNDS = new DvtRectangle( - 0.8436866097568272,  - 0.7626456732012923, 1.8336308036296942, 1.5748427214611724);
DvtThematicMapProjections._AUSTRALIA_BOUNDS = new DvtRectangle(113.29667079927977,  - 52.89550592498755, 65.25257389065216, 42.123114617504626);
DvtThematicMapProjections._EUROPE_BOUNDS = new DvtRectangle( - 0.47944476148667076,  - 0.0014669405958800579, 0.7364925893845453, 0.6293972741802124);
DvtThematicMapProjections._N_AMERICA_BOUNDS = new DvtRectangle( - 0.6154469465354344,  - 0.24589767758847714, 1.2448236795108683, 1.2631535127174947);
DvtThematicMapProjections._S_AMERICA_BOUNDS = new DvtRectangle( - 80.60817722658722,  - 60.796273249672765, 46.608687602908056, 66.96595767361796);
DvtThematicMapProjections._APAC_BOUNDS = new DvtRectangle(68.20516856593524,  - 52.89892708045518, 111.65739821771903, 116.55460214469134);
DvtThematicMapProjections._EMEA_BOUNDS = new DvtRectangle( - 24.543831069368586,  - 37.202500659225905, 204.54283106936856, 164.9634493690208);
DvtThematicMapProjections._L_AMERICA_BOUNDS = new DvtRectangle( - 117.12451221229134,  - 54.95921623126266, 82.33223251442891, 87.67786623127876);
DvtThematicMapProjections._USA_CANADA_BOUNDS = new DvtRectangle( - 0.6154656300926513, 0.0507209798775865, 1.0153104799231851, 0.966537441082997);
DvtThematicMapProjections._WORLD_BOUNDS = new DvtRectangle( - 171.9,  - 62.6, 349.8, 150.8);
DvtThematicMapProjections._ALASKA1_RECT = new DvtRectangle(172, 51, 8, 3);
DvtThematicMapProjections._ALASKA2_RECT = new DvtRectangle( - 180, 51, 51, 21);
DvtThematicMapProjections._HAWAII_RECT = new DvtRectangle( - 178.5, 18.9, 35, 11);
DvtThematicMapProjections._USA_RECT = new DvtRectangle( - 124.8, 24.4, 58, 25.5);
DvtThematicMapProjections._ALASKA_BOUNDS = new DvtRectangle( - 187.5517578125, 59.82610321044922, 57.562225341796875, 43.83738708496094);
DvtThematicMapProjections._HAWAII_BOUNDS = new DvtRectangle( - 160.23606872558594, 18.91549301147461, 5.4374847412109375, 3.3189010620117188);
DvtThematicMapProjections._USA_BOUNDS = new DvtRectangle( - 2386803.25,  - 1183550.5, 4514111, 2908402);
DvtThematicMapProjections._HAWAII_WINDOW = new DvtRectangle(165.0, 400.0, 100.0, 100.0);
DvtThematicMapProjections._ALASKA_WINDOW = new DvtRectangle(-75.0, 350.0, 240.0, 150.0);

DvtThematicMapProjections._ROBINSON_COORDINATES = [[1, 0], [0.9986, 0.0314], [0.9954, 0.0629], [0.9900, 0.0943], [0.9822, 0.1258], [0.9730, 0.1572], [0.9600, 0.1887], [0.9427, 0.2201], [0.9216, 0.2515], [0.8962, 0.2826], [0.8679, 0.3132], [0.8350, 0.3433], [0.7986, 0.3726], [0.7597, 0.4008], [0.6732, 0.4532], [0.6213, 0.4765], [0.5722, 0.4951], [0.5322, 0.5072]];

/**
 * Gets the projection for built-in basemaps to be used for JET/AMX 
 * @param {number} x Longitude
 * @param {number} y Latitude
 * @param {String} basemap The basemap name
 * @returns {DvtPoint} The projected point in the basemap coordinate system for built-in basemaps or the original point
 */
DvtThematicMapProjections.project = function (x, y, basemap) {
  var point;
  switch (basemap) {
    case 'africa':
      point = DvtThematicMapProjections._getAffineProjection(DvtThematicMapProjections._AFRICA_BOUNDS, 
                                                             DvtThematicMapProjections._getMercatorProjection(x, y));
      break;
    case 'asia':
      point = DvtThematicMapProjections._getAffineProjection(DvtThematicMapProjections._ASIA_BOUNDS, 
                                                             DvtThematicMapProjections._getAlbersEqualAreaConicProjection(40, 95, 20, 60, x, y),
                                                             DvtThematicMapProjections.toRadians(5));
      break;
    case 'australia':
      point = DvtThematicMapProjections._getAustraliaProjection(x, y);
      break;
    case 'europe':
      point = DvtThematicMapProjections._getAffineProjection(DvtThematicMapProjections._EUROPE_BOUNDS, 
                                                             DvtThematicMapProjections._getAlbersEqualAreaConicProjection(35, 25, 40, 65, x, y),
                                                             DvtThematicMapProjections.toRadians(10));
      break;
    case 'northAmerica':
      point = DvtThematicMapProjections._getAffineProjection(DvtThematicMapProjections._N_AMERICA_BOUNDS, 
                                                             DvtThematicMapProjections._getAlbersEqualAreaConicProjection(23,  - 96, 20, 60, x, y));
      break;
    case 'southAmerica':
      point = DvtThematicMapProjections._getAffineProjection(DvtThematicMapProjections._S_AMERICA_BOUNDS, 
                                                             new DvtPoint(x, y),
                                                             DvtThematicMapProjections.toRadians(5));
      break;
    case 'apac':
      point = DvtThematicMapProjections._getAffineProjection(DvtThematicMapProjections._APAC_BOUNDS, 
                                                             DvtThematicMapProjections._getMercatorProjection(x, y));
      break;
    case 'emea':
      point = DvtThematicMapProjections._getAffineProjection(DvtThematicMapProjections._EMEA_BOUNDS, 
                                                             DvtThematicMapProjections._getMercatorProjection(x, y));
      break;
    case 'latinAmerica':
        point = DvtThematicMapProjections._getAffineProjection(DvtThematicMapProjections._L_AMERICA_BOUNDS, 
                                                               new DvtPoint(x, y));
      break;
    case 'usaAndCanada':
      point = DvtThematicMapProjections._getAffineProjection(DvtThematicMapProjections._USA_CANADA_BOUNDS, 
                                                             DvtThematicMapProjections._getAlbersEqualAreaConicProjection(23,  - 96, 20, 60, x, y));
      break;
    case 'worldRegions':
      point = DvtThematicMapProjections._getWorldProjection(x, y);
      break;
    case 'usa':
      point = DvtThematicMapProjections._getUSAProjection(x, y);
      break;
    case 'world':
      point = DvtThematicMapProjections._getWorldProjection(x, y);
      break;
    default :
      break;
  }
  if (point)
    return new DvtPoint(point.x * 10, point.y * 10);// multiply by 10 because basemaps are 10x bigger
  else 
    return new DvtPoint(x, y);
}

/**
 * Returns the projected long/lat point in the usa basemap coordinate system
 * @param {number} x Longitude
 * @param {number} y Latitude
 * @returns {DvtPoint} The projected point in the basemap coordinate system for built-in basemaps or the original point
 * @private
 */
DvtThematicMapProjections._getUSAProjection = function (x, y) {
  var viewPortTransform
  if (DvtThematicMapProjections._ALASKA1_RECT.containsPoint(x, y) || DvtThematicMapProjections._ALASKA2_RECT.containsPoint(x, y)) {
    viewPortTransform = DvtThematicMapProjections._getViewPortTransformation(DvtThematicMapProjections._ALASKA_BOUNDS, DvtThematicMapProjections._ALASKA_WINDOW);
    return DvtThematicMapProjections._applyAffineTransform(viewPortTransform, DvtThematicMapProjections._getMercatorProjection(x, y));
  }
  else if (DvtThematicMapProjections._HAWAII_RECT.containsPoint(x, y)) {
    viewPortTransform = DvtThematicMapProjections._getViewPortTransformation(DvtThematicMapProjections._HAWAII_BOUNDS, DvtThematicMapProjections._HAWAII_WINDOW);
    return DvtThematicMapProjections._applyAffineTransform(viewPortTransform, new DvtPoint(x, y));
  }
  else if (DvtThematicMapProjections._USA_RECT.containsPoint(x, y)) {
    viewPortTransform = DvtThematicMapProjections._getViewPortTransformation(DvtThematicMapProjections._USA_BOUNDS, DvtThematicMapProjections._VIEWPORT_BOUNDS);
    return DvtThematicMapProjections._applyAffineTransform(viewPortTransform, DvtThematicMapProjections._getOrthographicProjection(new DvtPoint( - 95, 36), x, y));
  }
  return new DvtPoint(x, y);
}

/**
 * Returns the projected long/lat point in the world basemap coordinate system
 * @param {number} x Longitude
 * @param {number} y Latitude
 * @returns {DvtPoint} The projected point in the basemap coordinate system for built-in basemaps or the original point
 * @private
 */
DvtThematicMapProjections._getWorldProjection = function (x, y) {
  var viewPortTransform = DvtThematicMapProjections._getViewPortTransformation(DvtThematicMapProjections._WORLD_BOUNDS, DvtThematicMapProjections._VIEWPORT_BOUNDS);
  return DvtThematicMapProjections._applyAffineTransform(viewPortTransform, DvtThematicMapProjections._getRobinsonProjection(x, y));
}

/**
 * Returns the projected long/lat point in the australia basemap coordinate system
 * @param {number} x Longitude
 * @param {number} y Latitude
 * @returns {DvtPoint} The projected point in the basemap coordinate system for built-in basemaps or the original point
 * @private
 */
DvtThematicMapProjections._getAustraliaProjection = function (x, y) {
  var viewPortTransform;
  if (DvtThematicMapProjections._NEW_ZEALAND_BOUNDS.containsPoint(x, y))
    viewPortTransform = DvtThematicMapProjections._getViewPortTransformation(DvtThematicMapProjections._NEW_ZEALAND_BOUNDS, DvtThematicMapProjections._NEW_ZEALAND_RECT);
  else 
    viewPortTransform = DvtThematicMapProjections._getViewPortTransformation(DvtThematicMapProjections._AUSTRALIA_BOUNDS, DvtThematicMapProjections._VIEWPORT_BOUNDS);

  return DvtThematicMapProjections._applyAffineTransform(viewPortTransform, DvtThematicMapProjections._getMercatorProjection(x, y));
}

/**
 * Applies an affine transform to a point
 * @param {DvtRectangle} mapBounds The map bounds
 * @param {DvtPoint} point The point to apply the transform to
 * @param {number} rotRadians The rotation to apply to the transform matrix in radians
 * @private
 */
DvtThematicMapProjections._getAffineProjection = function (mapBounds, point, rotRadians) {
  var viewPortTransform = DvtThematicMapProjections._getViewPortTransformation(mapBounds, DvtThematicMapProjections._VIEWPORT_BOUNDS);
  if (rotRadians) {
    var rotMatrix = new DvtMatrix();
    rotMatrix.rotate(rotRadians);
    viewPortTransform = DvtThematicMapProjections._concatAffineTransforms(viewPortTransform, rotMatrix);
  }
  return viewPortTransform.transformPoint(point);
}

/**
 * Returns the projected long/lat point using the albers equal area conic projection
 * @param {number} latOfOrigin latitude for the origin, in degrees
 * @param {number} lonOfOrigin longitude for the origin, in degrees
 * @param {number} sP1 standard parallel 1, in degrees
 * @param {number} sP2 standard parallel 2, in degrees
 * @param {number} x Longitude
 * @param {number} y Latitude
 * @returns {DvtPoint} The projected point in the basemap coordinate system for built-in basemaps or the original point
 * @private
 */
DvtThematicMapProjections._getAlbersEqualAreaConicProjection = function (latOfOrigin, lonOfOrigin, sP1, sP2, x, y) {
  var lambda0 = DvtThematicMapProjections.toRadians(lonOfOrigin);
  var phi0 = DvtThematicMapProjections.toRadians(latOfOrigin);
  sP1 = DvtThematicMapProjections.toRadians(sP1);
  sP2 = DvtThematicMapProjections.toRadians(sP2);

  var n = 0.5 * (Math.sin(sP1) + Math.sin(sP2));
  var c = Math.pow((Math.cos(sP1)), 2) + (2 * n * Math.sin(sP1));

  var rho0 = c - (2 * n * Math.sin(phi0));
  rho0 = Math.sqrt(rho0) / n;

  var lambda = DvtThematicMapProjections.toRadians(x);
  var phi = DvtThematicMapProjections.toRadians(y);

  var theta = n * (lambda - lambda0);

  var rho = c - (2 * n * Math.sin(phi));
  rho = Math.sqrt(rho) / n;

  var pX = rho * Math.sin(theta);
  var pY = rho0 - (rho * Math.cos(theta));

  return new DvtPoint(pX, pY);
}

/**
 * Returns the projected long/lat point using the mercator projection assuming center is at 0,0
 * @param {number} x Longitude
 * @param {number} y Latitude
 * @returns {DvtPoint} The projected point in the basemap coordinate system for built-in basemaps or the original point
 * @private
 */
DvtThematicMapProjections._getMercatorProjection = function (x, y) {
  var pY = Math.log(Math.tan(0.25 * Math.PI + 0.5 * DvtThematicMapProjections.toRadians(y)));
  return new DvtPoint(x, DvtThematicMapProjections.toDegrees(pY));
}

/**
 * Returns the projected long/lat point using the orthographic projection
 * @param {number} x Longitude
 * @param {number} y Latitude
 * @returns {DvtPoint} The projected point in the basemap coordinate system for built-in basemaps or the original point
 * @private
 */
DvtThematicMapProjections._getOrthographicProjection = function (center, x, y) {
  var radX = DvtThematicMapProjections.toRadians(x);
  var radY = DvtThematicMapProjections.toRadians(y);
  var centerX = DvtThematicMapProjections.toRadians(center.x);
  var centerY = DvtThematicMapProjections.toRadians(center.y);
  var px = Math.cos(radY) * Math.sin(radX - centerX);
  var py = Math.cos(centerY) * Math.sin(radY) - Math.sin(centerY) * Math.cos(radY) * Math.cos(radX - centerX);
  return new DvtPoint(px * DvtThematicMapProjections._RADIUS, py * DvtThematicMapProjections._RADIUS);
}

/**
 * Returns the projected long/lat point using the robinson projection assuming center is at 0,0
 * @param {number} x Longitude
 * @param {number} y Latitude
 * @returns {DvtPoint} The projected point in the basemap coordinate system for built-in basemaps or the original point
 * @private
 */
DvtThematicMapProjections._getRobinsonProjection = function (x, y) {
  var ycriteria = Math.floor(Math.abs(y) / 5);
  if (ycriteria >= DvtThematicMapProjections._ROBINSON_COORDINATES.length - 1)
    ycriteria = DvtThematicMapProjections._ROBINSON_COORDINATES.length - 2;

  var yInterval = (Math.abs(y) - ycriteria * 5) / 5;

  var xLength = DvtThematicMapProjections._ROBINSON_COORDINATES[ycriteria + 1][0] - DvtThematicMapProjections._ROBINSON_COORDINATES[ycriteria][0];
  var yLength = DvtThematicMapProjections._ROBINSON_COORDINATES[ycriteria + 1][1] - DvtThematicMapProjections._ROBINSON_COORDINATES[ycriteria][1];

  var newX = x * (DvtThematicMapProjections._ROBINSON_COORDINATES[ycriteria][0] + yInterval * xLength);
  var newY = (DvtThematicMapProjections._ROBINSON_COORDINATES[ycriteria][1] + yInterval * yLength);

  if (y < 0)
    newY =  - 1 * newY;

  return new DvtPoint(newX, newY * 180);
}

/**
 * Applies an affine transformation to a DvtPoint
 * @param {DvtMatrix} matrix The affine transformation matrix
 * @param {DvtPoint} point The point to apply the transform to
 * @return {DvtPoint} The transformed point
 * @private
 */
DvtThematicMapProjections._applyAffineTransform = function (matrix, point) {
  return new DvtPoint(point.x * matrix.getA() + matrix.getTx(), point.y * matrix.getD() + matrix.getTy());
}

/**
 * Returns the projected long/lat point using the robinson projection assuming center is at 0,0
 * @param {number} x Longitude
 * @param {number} y Latitude
 * @returns {DvtPoint} The projected point in the basemap coordinate system for built-in basemaps or the original point
 * @private
 */
DvtThematicMapProjections._concatAffineTransforms = function (transform1, transform2) {
  var t1A = transform1.getA();
  var a = transform2.getA() * t1A;
  var b = transform2.getB() * t1A;
  var tx = transform1.getTx() + transform2.getTx() * t1A;

  var t1D = transform1.getD();
  var c = transform2.getC() * t1D;
  var d = transform2.getD() * t1D;
  var ty = transform1.getTy() + transform2.getTy() * t1D;

  return new DvtMatrix(a, b, c, d, tx, ty);
}

/**
 * Gets the viewport transformation matrix 
 * @param {DvtRectangle} mapBound The map bounds
 * @param {DvtRectangle} deviceView The viewport bounds
 * @returns {DvtMatrix} The viewport transform matrix
 * @private
 */
DvtThematicMapProjections._getViewPortTransformation = function (mapBound, deviceView) {
  var i = deviceView.x;
  var j = deviceView.y;

  var d = mapBound.w;
  var d1 = mapBound.h;
  var d2 = 0;
  var d3 = deviceView.w / d;
  var d4 = deviceView.h / d1;
  d2 = (d3 <= d4) ? d3 : d4;
  var d5 = i - mapBound.x * d2;
  var d6 = j + mapBound.y * d2;
  d5 += (deviceView.w - d * d2) / 2;
  d6 += deviceView.h - (deviceView.h - d1 * d2) / 2;

  return new DvtMatrix(d2, 0, 0,  - d2, d5, d6);
}

/**
 * Converts a number to radians
 * @param {number} x The number to convert to radians
 * @return {number} The number converted to radians
 */
DvtThematicMapProjections.toRadians = function (x) {
  return x * (Math.PI / 180);
}

/**
 * Converts a number to degrees
 * @param {number} x The number to convert to degrees
 * @return {number} The number converted to degrees
 */
DvtThematicMapProjections.toDegrees = function (x) {
  return x * (180 / Math.PI);
}

/**
 * Gets the inverse projection for built-in basemaps to be used for drag and drop
 * @param {number} x The x coordinate in the basemap coordinate system
 * @param {number} y The y coordinate in the basemap coordinate system
 * @param {String} basemap The basemap name
 * @returns {DvtPoint} The inversely projected point in longitude/latitude for built-in basemaps or the original point
 */
DvtThematicMapProjections.inverseProject = function (x, y, basemap) {
  var point;
  // divide by 10 because basemaps are 10x larger than original projected maps
  x/=10;
  y/=10;
  switch (basemap) {
    case 'africa':
      point = DvtThematicMapProjections._getInverseAffineProjection(DvtThematicMapProjections._AFRICA_BOUNDS, 
                                                                    new DvtPoint(x, y));
      point = DvtThematicMapProjections._getInverseMercatorProjection(point.x, point.y);
      break;
    case 'asia':
      point = DvtThematicMapProjections._getInverseAffineProjection(DvtThematicMapProjections._ASIA_BOUNDS, 
                                                                    new DvtPoint(x, y),
                                                                    DvtThematicMapProjections.toRadians(5));
      point = DvtThematicMapProjections._getInverseAlbersEqualAreaConicProjection(40, 95, 20, 60, point.x, point.y);
      break;
    case 'australia':
      point = DvtThematicMapProjections._getInverseAustraliaProjection(x, y);
      break;
    case 'europe':
      point = DvtThematicMapProjections._getInverseAffineProjection(DvtThematicMapProjections._EUROPE_BOUNDS, 
                                                                    new DvtPoint(x, y),
                                                                    DvtThematicMapProjections.toRadians(10));
      point = DvtThematicMapProjections._getInverseAlbersEqualAreaConicProjection(35, 25, 40, 65, point.x, point.y);
      break;
    case 'northAmerica':
      point = DvtThematicMapProjections._getInverseAffineProjection(DvtThematicMapProjections._N_AMERICA_BOUNDS, 
                                                                    new DvtPoint(x, y));
      point = DvtThematicMapProjections._getInverseAlbersEqualAreaConicProjection(23,  - 96, 20, 60, point.x, point.y);
      break;
    case 'southAmerica':
      point = DvtThematicMapProjections._getInverseAffineProjection(DvtThematicMapProjections._S_AMERICA_BOUNDS, 
                                                                    new DvtPoint(x, y),
                                                                    DvtThematicMapProjections.toRadians(5));
      break;
    case 'apac':
      point = DvtThematicMapProjections._getInverseAffineProjection(DvtThematicMapProjections._APAC_BOUNDS, 
                                                                    new DvtPoint(x, y));
      point = DvtThematicMapProjections._getInverseMercatorProjection(point.x, point.y);
      break;
    case 'emea':
      point = DvtThematicMapProjections._getInverseAffineProjection(DvtThematicMapProjections._EMEA_BOUNDS, 
                                                                    new DvtPoint(x, y));
      point = DvtThematicMapProjections._getInverseMercatorProjection(point.x, point.y);
      break;
    case 'latinAmerica':
      point = DvtThematicMapProjections._getInverseAffineProjection(DvtThematicMapProjections._L_AMERICA_BOUNDS, 
                                                                    new DvtPoint(x, y));
      break;
    case 'usaAndCanada':
      point = DvtThematicMapProjections._getInverseAffineProjection(DvtThematicMapProjections._USA_CANADA_BOUNDS, 
                                                                    new DvtPoint(x, y));
      point = DvtThematicMapProjections._getInverseAlbersEqualAreaConicProjection(23,  - 96, 20, 60, point.x, point.y);
      break;
    case 'worldRegions':
      point = DvtThematicMapProjections._getInverseWorldProjection(x, y);
      break;
    case 'usa':
      point = DvtThematicMapProjections._getInverseUSAProjection(x, y);
      break;
    case 'world':
      point = DvtThematicMapProjections._getInverseWorldProjection(x, y);
      break;
    default :
      break;
  }
  if (point)
    return point;
  else 
    return new DvtPoint(x, y);
}

/**
 * Returns the inversely projected long/lat point in the usa basemap coordinate system
 * @param {number} x The x coordinate in the basemap coordinate system
 * @param {number} y The y coordinate in the basemap coordinate system
 * @returns {DvtPoint} The projected point in longitude/latitude using the basemap projection
 * @private
 */
DvtThematicMapProjections._getInverseUSAProjection = function (x, y) {
  var viewPortTransform
  if (DvtThematicMapProjections._ALASKA_WINDOW.containsPoint(x, y)) {
    viewPortTransform = DvtThematicMapProjections._getViewPortTransformation(DvtThematicMapProjections._ALASKA_BOUNDS, DvtThematicMapProjections._ALASKA_WINDOW);
    viewPortTransform.invert();
    var point = viewPortTransform.transformPoint(new DvtPoint(x, y));
    return DvtThematicMapProjections._getInverseMercatorProjection(point.x, point.y);
  }
  else if (DvtThematicMapProjections._HAWAII_WINDOW.containsPoint(x, y)) {
    viewPortTransform = DvtThematicMapProjections._getViewPortTransformation(DvtThematicMapProjections._HAWAII_BOUNDS, DvtThematicMapProjections._HAWAII_WINDOW);
    viewPortTransform.invert();
    return viewPortTransform.transformPoint(new DvtPoint(x, y));
  }
  else if (DvtThematicMapProjections._VIEWPORT_BOUNDS.containsPoint(x, y)) {
    viewPortTransform = DvtThematicMapProjections._getViewPortTransformation(DvtThematicMapProjections._USA_BOUNDS, DvtThematicMapProjections._VIEWPORT_BOUNDS);
    viewPortTransform.invert();
    var point = viewPortTransform.transformPoint(new DvtPoint(x, y));
    return DvtThematicMapProjections._getInverseOrthographicProjection(new DvtPoint( - 95, 36), point.x, point.y);
  }
  return new DvtPoint(x, y);
}

/**
 * Returns the inversely projected long/lat point in the world basemap coordinate system
 * @param {number} x The x coordinate in the basemap coordinate system
 * @param {number} y The y coordinate in the basemap coordinate system
 * @returns {DvtPoint} The projected point in longitude/latitude using the basemap projection
 * @private
 */
DvtThematicMapProjections._getInverseWorldProjection = function (x, y) {
  var viewPortTransform = DvtThematicMapProjections._getViewPortTransformation(DvtThematicMapProjections._WORLD_BOUNDS, DvtThematicMapProjections._VIEWPORT_BOUNDS);
  viewPortTransform.invert();
  var point = viewPortTransform.transformPoint(new DvtPoint(x, y));
  return DvtThematicMapProjections._getInverseRobinsonProjection(point.x, point.y);
}

/**
 * Returns the inversely projected long/lat point in the australia basemap coordinate system
 * @param {number} x The x coordinate in the basemap coordinate system
 * @param {number} y The y coordinate in the basemap coordinate system
 * @returns {DvtPoint} The projected point in longitude/latitude using the basemap projection
 * @private
 */
DvtThematicMapProjections._getInverseAustraliaProjection = function (x, y) {
  var viewPortTransform;
  if (DvtThematicMapProjections._NEW_ZEALAND_RECT.containsPoint(x, y))
    viewPortTransform = DvtThematicMapProjections._getViewPortTransformation(DvtThematicMapProjections._NEW_ZEALAND_BOUNDS, DvtThematicMapProjections._NEW_ZEALAND_RECT);
  else
    viewPortTransform = DvtThematicMapProjections._getViewPortTransformation(DvtThematicMapProjections._AUSTRALIA_BOUNDS, DvtThematicMapProjections._VIEWPORT_BOUNDS);

  viewPortTransform.invert();
  var point = viewPortTransform.transformPoint(new DvtPoint(x, y));
  return DvtThematicMapProjections._getInverseMercatorProjection(point.x, point.y);
}

/**
 * Applies an inverse affine transform to a point
 * @param {DvtRectangle} mapBounds The map bounds
 * @param {DvtPoint} point The point to apply the transform to
 * @param {number} rotRadians The rotation to apply to the transform matrix in radians
 * @private
 */
DvtThematicMapProjections._getInverseAffineProjection = function (mapBounds, point, rotRadians) {
  var viewPortTransform = DvtThematicMapProjections._getViewPortTransformation(mapBounds, DvtThematicMapProjections._VIEWPORT_BOUNDS);
  if (rotRadians) {
    var rotMatrix = new DvtMatrix();
    rotMatrix.rotate(rotRadians);
    viewPortTransform = DvtThematicMapProjections._concatAffineTransforms(viewPortTransform, rotMatrix);
  }
  viewPortTransform.invert();
  return viewPortTransform.transformPoint(point);
}

/**
 * Returns the inversely projected long/lat point using the albers equal area conic projection
 * @param {number} x The x coordinate in the basemap coordinate system
 * @param {number} y The y coordinate in the basemap coordinate system
 * @returns {DvtPoint} The projected point in longitude/latitude using the basemap projection
 * @private
 */
DvtThematicMapProjections._getInverseAlbersEqualAreaConicProjection = function (latOfOrigin, lonOfOrigin, sP1, sP2, x, y) {
  var lambda0 = DvtThematicMapProjections.toRadians(lonOfOrigin);
  var phi0 = DvtThematicMapProjections.toRadians(latOfOrigin);
  sP1 = DvtThematicMapProjections.toRadians(sP1);
  sP2 = DvtThematicMapProjections.toRadians(sP2);

  var n = 0.5 * (Math.sin(sP1) + Math.sin(sP2));
  var c = Math.pow((Math.cos(sP1)), 2) + (2 * n * Math.sin(sP1));

  var p0 = c - (2 * n * Math.sin(phi0));
  p0 = Math.sqrt(p0) / n;

  var p = Math.sqrt(x * x + (p0 - y) * (p0 - y));
  var pheta = Math.atan(x / (p0 - y));

  var py = Math.asin((c - p * p * n * n) / (2 * n));
  var px = lambda0 + pheta / n;

  return new DvtPoint(DvtThematicMapProjections.toDegrees(px), DvtThematicMapProjections.toDegrees(py));
}

/**
 * Returns the inversely projected long/lat point using the mercator projection, assuming center at 0,0
 * @param {number} x The x coordinate in the basemap coordinate system
 * @param {number} y The y coordinate in the basemap coordinate system
 * @returns {DvtPoint} The projected point in longitude/latitude using the basemap projection
 * @private
 */
DvtThematicMapProjections._getInverseMercatorProjection = function (x, y) {
  var py = 2 * Math.atan(Math.exp(DvtThematicMapProjections.toRadians(y))) - 0.5 * Math.PI;
  return new DvtPoint(x, DvtThematicMapProjections.toDegrees(py));	
}

/**
 * Returns the inversely projected long/lat point using the orthographic projection, assuming center at 0,0
 * @param {number} x The x coordinate in the basemap coordinate system
 * @param {number} y The y coordinate in the basemap coordinate system
 * @returns {DvtPoint} The projected point in longitude/latitude using the basemap projection
 * @private
 */
DvtThematicMapProjections._getInverseOrthographicProjection = function (center, x, y) {
  var radX = x/DvtThematicMapProjections._RADIUS;
  var radY = y/DvtThematicMapProjections._RADIUS;
  var centerX = DvtThematicMapProjections.toRadians(center.x);
  var centerY = DvtThematicMapProjections.toRadians(center.y);
  
  var p = Math.sqrt((radX * radX) + (radY * radY));
  var c = Math.asin (p);
  
  var py = Math.asin(Math.cos(c) * Math.sin(centerY) + (radY * Math.sin(c) * Math.cos(centerY) / p));
  var px = centerX + Math.atan(radX * Math.sin(c) / (p * Math.cos(centerY) * Math.cos(c) - radY * Math.sin(centerY) * Math.sin(c)));
  
  return new DvtPoint(DvtThematicMapProjections.toDegrees(px), DvtThematicMapProjections.toDegrees(py));
}

/**
 * Returns the inversely projected long/lat point using the robinson projection, assuming center at 0,0
 * @param {number} x The x coordinate in the basemap coordinate system
 * @param {number} y The y coordinate in the basemap coordinate system
 * @returns {DvtPoint} The projected point in longitude/latitude using the basemap projection
 * @private
 */
DvtThematicMapProjections._getInverseRobinsonProjection = function (x, y) {
  var criteria = Math.floor(Math.abs(y) / 5.0);
  if (criteria >= DvtThematicMapProjections._ROBINSON_COORDINATES.length - 1)
    criteria = DvtThematicMapProjections._ROBINSON_COORDINATES.length - 2;

  var xLength = DvtThematicMapProjections._ROBINSON_COORDINATES[criteria + 1][0] - DvtThematicMapProjections._ROBINSON_COORDINATES[criteria][0];
  var yLength = DvtThematicMapProjections._ROBINSON_COORDINATES[criteria + 1][1] - DvtThematicMapProjections._ROBINSON_COORDINATES[criteria][1];

  var yInterval = (Math.abs(y / 180.0) - DvtThematicMapProjections._ROBINSON_COORDINATES[criteria][1]) / yLength;
  var originalY = (yInterval * 5.0) + criteria * 5.0;
  var originalX = x / (DvtThematicMapProjections._ROBINSON_COORDINATES[criteria][0] + yInterval * xLength);

  if (y < 0.0)
    originalY =  - 1 * originalY;

  return new DvtPoint(originalX, originalY);
}
/**
 * @constructor
 * ZoomInButton for use with Diagram.
 */
var DvtMapControlButton = function (context, button, mapCallback, panZoomCanvas, btype, resources, eventManager) {
  this.Init(context, button, mapCallback, panZoomCanvas, btype, resources, eventManager);
};

/*
 * make DvtMapControlButton a subclass of DvtBasePanZoomControl
 */
DvtObj.createSubclass(DvtMapControlButton, DvtBasePanZoomControl, "DvtMapControlButton");

DvtMapControlButton.BUTTON_TYPE_DRILLUP = 0;
DvtMapControlButton.BUTTON_TYPE_DRILLDOWN  = 1;
DvtMapControlButton.BUTTON_TYPE_RESET = 2;

/**
 * Helper method called by the constructor to initialize this object.
 * @param {DvtContext} context An object maintaining application specific context, as well as well as providing
 *                             access to platform specific data and objects, such as the factory
 * @param {DvtButton} button A button used by the control
 * @param {function} mapCallback A callback function that should be called on click event
 * @param {DvtPanZoomCanvas} canvas The PanZoomCanvas this control will be associated with
 * @param {DvtXmlNode} resources The map of translated resource strings
 * @param {DvtEventManager} eventManager An event manager to handle events for the control
 */
DvtMapControlButton.prototype.Init = function (context, button, mapCallback, panZoomCanvas, btype, resources, eventManager) {
  DvtMapControlButton.superclass.Init.call(this, context, panZoomCanvas, resources);

  this._btype = btype;
  this._button = button;
  this._eventManager = eventManager;
  this._button.setCallback(this.HandleOnClick, this);
  this._button.setCursor(DvtSelectionEffectUtils.getSelectingCursor());  
  var proxy = new DvtPanZoomControlPanelEventHandlerProxy(this, null, null, 
                                                    null, null, null,
                                                    this._getTooltipText());
  this._eventManager.associate(this._button, proxy);

  this.addChild(this._button);
  
  this._mapCallback = mapCallback;
  this._isEnabled = true;
}

/**
 * Sets button state
 * @param {boolean} enabled True to enable the button
 */
DvtMapControlButton.prototype.setEnabled = function (enabled)
{
  this.setAlpha(enabled ? 1.0 : 0.4);
  this._button.setCursor(enabled ? DvtSelectionEffectUtils.getSelectingCursor() : null);
  this._isEnabled = enabled;
  this._button.setEnabled(enabled);
  this._button.initState();
}

DvtMapControlButton.prototype.HandleOnClick = function (event)
{
  DvtEventManager.consumeEvent(event);
  if (this._isEnabled && this._mapCallback){
    this._mapCallback();
  }
}

/**
 * @returns tooltip text for current buton type.
 */
DvtMapControlButton.prototype._getTooltipText = function(){

    if(this._btype == DvtMapControlButton.BUTTON_TYPE_DRILLUP){
        return this.getResources().getControlPanelDrillUpTooltip();
    }else  if(this._btype == DvtMapControlButton.BUTTON_TYPE_DRILLDOWN){
        return this.getResources().getControlPanelDrillDownTooltip();
    }else  if(this._btype == DvtMapControlButton.BUTTON_TYPE_RESET){
        return this.getResources().getControlPanelResetTooltip();
    }else{
        return null;
    }
}

/**
 * @constructor
 * DvtPanZoomControlPanel for use with PanZoomCanvas.
 * This panel contains tools for zooming and panning.
 * By default, the panel is initially collapsed.
 */
var DvtThematicMapControlPanel = function (context, drillMode, buttonImages, callbacks, canvas, resources, controls, view) {
  this.Init(context, drillMode, buttonImages, callbacks, canvas, resources, controls, view);
};

/*
 * make DvtPanZoomControlPanel a subclass of DvtContainer
 */
DvtObj.createSubclass(DvtThematicMapControlPanel, DvtPanZoomControlPanel, "DvtThematicMapControlPanel");

DvtThematicMapControlPanel.prototype.Init = function (context, drillMode, buttonImages, callbacks, canvas, resources, controls, view) {
  DvtThematicMapControlPanel.superclass.Init.call(this, context, canvas, buttonImages, resources, controls, view);
  this.setResources(new DvtThematicMapControlPanelResources(resources));
  this._drillMode = drillMode;
  this._buttonImages = buttonImages;
  this._drillUpCallback = callbacks[0];
  this._drillDownCallback = callbacks[1];
  this._resetCallback = callbacks[2];
  this._resetButton = null;
  this._drillUpButton = null;
  this._drillDownButton = null;
  this._drillDownButtonEnabled = false;
  this._drillUpButtonEnabled = false;
  this._styleMap = view.getControlPanelStyleMap();
};

DvtThematicMapControlPanel.prototype.setEnabledDrillDownButton = function (enable) {
  this._drillDownButtonEnabled = enable;
  if (this._drillDownButton)
    this._drillDownButton.setEnabled(enable);
}

DvtThematicMapControlPanel.prototype.setEnabledDrillUpButton = function (enable) {
  this._drillUpButtonEnabled = enable;
  if (this._drillUpButton)
    this._drillUpButton.setEnabled(enable);
}
DvtThematicMapControlPanel.prototype.setResources = function(resources){
    DvtThematicMapControlPanel.superclass.setResources.call(this, resources);
    if(this._drillDownButton){
        this._drillDownButton.setResources(resources);
    }
    if(this._drillUpButton){
        this._drillUpButton.setResources(resources);
    }
    if(this._resetButton){
        this._resetButton.setResources(resources);
    }
}

/**
  *  Populate the horizontal part of the control panel
  *  @param {DvtContainer} contentSprite Container for holding additional buttons
  */
DvtThematicMapControlPanel.prototype.PopulateHorzContentBar = function (contentSprite) {
  if (this._drillMode && this._drillMode != 'none') {
    var buttonOffset = DvtStyleUtils.getStyle(this._styleMap,DvtPanZoomControlPanel.CP_BUTTON_WIDTH,0);
    this._resetButton = DvtButtonLAFUtils.createResetButton(this.getCtx(), this._resetCallback, this._panZoomCanvas, 
                                                            DvtMapControlButton.BUTTON_TYPE_RESET, this.getResources(), 
                                                            this._buttonImages, this._eventManager, this._styleMap);
    contentSprite.addChild(this._resetButton);
    this._drillDownButton = DvtButtonLAFUtils.createDrillDownButton(this.getCtx(), this._drillDownCallback, 
                                                                    this._panZoomCanvas, 
                                                                    DvtMapControlButton.BUTTON_TYPE_DRILLDOWN, 
                                                                    this.getResources(), this._buttonImages, 
                                                                    this._eventManager, this._styleMap);
    this._drillDownButton.setTranslateX(buttonOffset);
    this._drillDownButton.setEnabled(this._drillDownButtonEnabled);
    contentSprite.addChild(this._drillDownButton);
    this._drillUpButton = DvtButtonLAFUtils.createDrillUpButton(this.getCtx(), this._drillUpCallback, 
                                                                this._panZoomCanvas, 
                                                                DvtMapControlButton.BUTTON_TYPE_DRILLUP, 
                                                                this.getResources(), this._buttonImages, 
                                                                this._eventManager, this._styleMap);

    this._drillUpButton.setTranslateX(buttonOffset*2);
    this._drillUpButton.setEnabled(this._drillUpButtonEnabled);
    contentSprite.addChild(this._drillUpButton);

  }
};
/**
 * @constructor
 * Class used to maintain translated resources used by the ThematicMapControlPanel.
 */
var DvtThematicMapControlPanelResources = function (parent) {
  this.Init(parent);
};


/*
 * make DvtThematicMapControlPanelResources a subclass of DvtPanZoomControlPanelResources
 */
DvtObj.createSubclass(DvtThematicMapControlPanelResources, DvtPanZoomControlPanelResources, "DvtThematicMapControlPanelResources");


DvtThematicMapControlPanelResources.prototype.Init = function (parent) {
   DvtThematicMapControlPanelResources.superclass.Init.call(this, parent);
 
  if(!parent){
      this._controlPanelDrillUpTooltip = "Show Control Panel (/)";
      this._controlPanelDrillDownTooltip = "Hide (/)";
      this._controlPanelResetTooltip = "Zoom and Center (Ctrl+Alt+0)";      
  } else {
      this._controlPanelDrillUpTooltip = parent.getAttr("pdu");
      this._controlPanelDrillDownTooltip = parent.getAttr("pdd");
      this._controlPanelResetTooltip = parent.getAttr("res");    
  }
}

/**
 * Get the ControlPanelDrillUpTooltip to use.
 * 
 * @return controlPanelDrillUpToolTip being used
 */
DvtThematicMapControlPanelResources.prototype.getControlPanelDrillUpTooltip = function () {
  return this._controlPanelDrillUpTooltip;
}
    
/**
 * Set the PanControlDrillUpTooltip to use.
 * 
 * @param panControlDrillUpToolTip to use
 */
DvtThematicMapControlPanelResources.prototype.setPanControlDrillUpTooltip = function (s) {
  this._controlPanelDrillUpTooltip = s;
}

/**
 * Get the ControlPanelDrillDownTooltip to use.
 * 
 * @return controlPanelDrillDownToolTip being used
 */
DvtThematicMapControlPanelResources.prototype.getControlPanelDrillDownTooltip = function () {
  return this._controlPanelDrillDownTooltip;
}
    
/**
 * Set the PanControlDrillDownTooltip to use.
 * 
 * @param panControlDrillDownToolTip to use
 */
DvtThematicMapControlPanelResources.prototype.setPanControlDrillDownTooltip = function (s) {
  this._controlPanelDrillDownTooltip = s;
}

/**
 * Get the ControlPanelResetTooltip to use.
 * 
 * @return controlPanelResetToolTip being used
 */
DvtThematicMapControlPanelResources.prototype.getControlPanelResetTooltip = function () {
  return this._controlPanelResetTooltip;
}
    
/**
 * Set the PanControlResetTooltip to use.
 * 
 * @param panControlResetToolTip to use
 */
DvtThematicMapControlPanelResources.prototype.setPanControlResetTooltip = function (s) {
  this._controlPanelResetTooltip = s;
}
});